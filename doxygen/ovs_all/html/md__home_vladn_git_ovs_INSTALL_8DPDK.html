<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ovs all: Using Open vSwitch with DPDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ovs all
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_vladn_git_ovs_INSTALL_8DPDK.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using Open vSwitch with DPDK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Open vSwitch can use Intel(R) DPDK lib to operate entirely in userspace. This file explains how to install and use Open vSwitch in such a mode.</p>
<p>The DPDK support of Open vSwitch is considered experimental. It has not been thoroughly tested.</p>
<p>This version of Open vSwitch should be built manually with <code>configure</code> and <code>make</code>.</p>
<p>OVS needs a system with 1GB hugepages support.</p>
<h2>Building and Installing: </h2>
<p>Required: DPDK 2.0 Optional (if building with vhost-cuse): <code>fuse</code>, <code>fuse-devel</code> (<code>libfuse-dev</code> on Debian/Ubuntu)</p>
<ol type="1">
<li>Configure build &amp; install DPDK:<ol type="a">
<li><p class="startli">Set <code>$DPDK_DIR</code></p>
<p class="startli">``` export DPDK_DIR=/usr/src/dpdk-2.0 cd $DPDK_DIR ```</p>
</li>
<li><p class="startli">Update <code>config/common_linuxapp</code> so that DPDK generate single lib file. (modification also required for IVSHMEM build)</p>
<p class="startli"><code>CONFIG_RTE_BUILD_COMBINE_LIBS=y</code></p>
<p class="startli">Update <code>config/common_linuxapp</code> so that DPDK is built with vhost libraries.</p>
<p class="startli"><code>CONFIG_RTE_LIBRTE_VHOST=y</code></p>
<p class="startli">Then run <code>make install</code> to build and install the library. For default install without IVSHMEM:</p>
<p class="startli"><code>make install T=x86_64-native-linuxapp-gcc</code></p>
<p class="startli">To include IVSHMEM (shared memory):</p>
<p class="startli"><code>make install T=x86_64-ivshmem-linuxapp-gcc</code></p>
<p class="startli">For further details refer to <a href="http://dpdk.org/">http://dpdk.org/</a></p>
</li>
</ol>
</li>
<li><p class="startli">Configure &amp; build the Linux kernel:</p>
<p class="startli">Refer to intel-dpdk-getting-started-guide.pdf for understanding DPDK kernel requirement.</p>
</li>
<li><p class="startli">Configure &amp; build OVS:</p><ul>
<li><p class="startli">Non IVSHMEM:</p>
<p class="startli"><code>export DPDK_BUILD=$DPDK_DIR/x86_64-native-linuxapp-gcc/</code></p>
</li>
<li><p class="startli">IVSHMEM:</p>
<p class="startli"><code>export DPDK_BUILD=$DPDK_DIR/x86_64-ivshmem-linuxapp-gcc/</code></p>
</li>
</ul>
<p class="startli">``` cd /openvswitch ./boot.sh ./configure &ndash;with-dpdk=$DPDK_BUILD [CFLAGS="-g -O2 -Wno-cast-align"] make ```</p>
<p class="startli">Note: 'clang' users may specify the '-Wno-cast-align' flag to suppress DPDK cast-align warnings.</p>
</li>
</ol>
<p>To have better performance one can enable aggressive compiler optimizations and use the special instructions(popcnt, crc32) that may not be available on all machines. Instead of typing <code>make</code>, type:</p>
<p>`make CFLAGS='-O3 -march=native'`</p>
<p>Refer to <a class="el" href="INSTALL_8userspace_8md.html">INSTALL.userspace.md</a> for general requirements of building userspace OVS.</p>
<h2>Using the DPDK with ovs-vswitchd: </h2>
<ol type="1">
<li><p class="startli">Setup system boot Add the following options to the kernel bootline:</p>
<p class="startli"><code>default_hugepagesz=1GB hugepagesz=1G hugepages=1</code></p>
</li>
<li><p class="startli">Setup DPDK devices:</p>
<p class="startli">DPDK devices can be setup using either the VFIO (for DPDK 1.7+) or UIO modules. UIO requires inserting an out of tree driver igb_uio.ko that is available in DPDK. Setup for both methods are described below.</p><ul>
<li>UIO:<ol type="a">
<li>insert uio.ko: <code>modprobe uio</code></li>
<li>insert igb_uio.ko: <code>insmod $DPDK_BUILD/kmod/igb_uio.ko</code></li>
<li>Bind network device to igb_uio: <code>$DPDK_DIR/tools/dpdk_nic_bind.py --bind=igb_uio eth1</code></li>
</ol>
</li>
<li><p class="startli">VFIO:</p>
<p class="startli">VFIO needs to be supported in the kernel and the BIOS. More information can be found in the <a href="http://www.dpdk.org/doc/guides/linux_gsg/build_dpdk.html#binding-and-unbinding-network-ports-to-from-the-igb-uioor-vfio-modules">DPDK Linux GSG</a>.</p><ol type="a">
<li>Insert vfio-pci.ko: <code>modprobe vfio-pci</code></li>
<li>Set correct permissions on vfio device: <code>sudo /usr/bin/chmod a+x /dev/vfio</code> and: <code>sudo /usr/bin/chmod 0666 /dev/vfio/*</code></li>
<li>Bind network device to vfio-pci: <code>$DPDK_DIR/tools/dpdk_nic_bind.py --bind=vfio-pci eth1</code></li>
</ol>
</li>
</ul>
</li>
<li><p class="startli">Mount the hugetable filsystem</p>
<p class="startli"><code>mount -t hugetlbfs -o pagesize=1G none /dev/hugepages</code></p>
<p class="startli">Ref to <a href="http://www.dpdk.org/doc/quick-start">http://www.dpdk.org/doc/quick-start</a> for verifying DPDK setup.</p>
</li>
<li>Follow the instructions in <a class="el" href="INSTALL_8md.html">INSTALL.md</a> to install only the userspace daemons and utilities (via 'make install').<ol type="a">
<li><p class="startli">First time only db creation (or clearing):</p>
<p class="startli">``` mkdir -p /usr/local/etc/openvswitch mkdir -p /usr/local/var/run/openvswitch rm /usr/local/etc/openvswitch/conf.db ovsdb-tool create /usr/local/etc/openvswitch/conf.db \ /usr/local/share/openvswitch/vswitch.ovsschema ```</p>
</li>
<li><p class="startli">Start ovsdb-server</p>
<p class="startli">``` ovsdb-server &ndash;remote=punix:/usr/local/var/run/openvswitch/db.sock \ &ndash;remote=db:Open_vSwitch,Open_vSwitch,manager_options \ &ndash;private-key=db:Open_vSwitch,SSL,private_key \ &ndash;certificate=Open_vSwitch,SSL,certificate \ &ndash;bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert &ndash;pidfile &ndash;detach ```</p><ol type="i">
<li><p class="startli">First time after db creation, initialize:</p>
<p class="startli">``` ovs-vsctl &ndash;no-wait init ```</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p class="startli">Start vswitchd:</p>
<p class="startli">DPDK configuration arguments can be passed to vswitchd via <code>--dpdk</code> argument. This needs to be first argument passed to vswitchd process. dpdk arg -c is ignored by ovs-dpdk, but it is a required parameter for dpdk initialization.</p>
<p class="startli">``` export DB_SOCK=/usr/local/var/run/openvswitch/db.sock ovs-vswitchd &ndash;dpdk -c 0x1 -n 4 &ndash; unix:$DB_SOCK &ndash;pidfile &ndash;detach ```</p>
<p class="startli">If allocated more than one GB hugepage (as for IVSHMEM), set amount and use NUMA node 0 memory:</p>
<p class="startli">``` ovs-vswitchd &ndash;dpdk -c 0x1 -n 4 &ndash;socket-mem 1024,0 \ &ndash; unix:$DB_SOCK &ndash;pidfile &ndash;detach ```</p>
</li>
<li><p class="startli">Add bridge &amp; ports</p>
<p class="startli">To use ovs-vswitchd with DPDK, create a bridge with datapath_type "netdev" in the configuration database. For example:</p>
<p class="startli"><code>ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev</code></p>
<p class="startli">Now you can add dpdk devices. OVS expect DPDK device name start with dpdk and end with portid. vswitchd should print (in the log file) the number of dpdk devices found.</p>
<p class="startli">``` ovs-vsctl add-port br0 dpdk0 &ndash; set Interface dpdk0 type=dpdk ovs-vsctl add-port br0 dpdk1 &ndash; set Interface dpdk1 type=dpdk ```</p>
<p class="startli">Once first DPDK port is added to vswitchd, it creates a Polling thread and polls dpdk device in continuous loop. Therefore CPU utilization for that thread is always 100%.</p>
<p class="startli">Note: creating bonds of DPDK interfaces is slightly different to creating bonds of system interfaces. For DPDK, the interface type must be explicitly set, for example:</p>
<p class="startli">``` ovs-vsctl add-bond br0 dpdkbond dpdk0 dpdk1 &ndash; set Interface dpdk0 type=dpdk &ndash; set Interface dpdk1 type=dpdk ```</p>
</li>
<li><p class="startli">Add test flows</p>
<p class="startli">Test flow script across NICs (assuming ovs in /usr/src/ovs): Execute script:</p>
<p class="startli">``` #! /bin/sh </p><h1>Move to command directory</h1>
<p class="startli">cd /usr/src/ovs/utilities/</p>
</li>
</ol>
<h1>Clear current flows</h1>
<p>./ovs-ofctl del-flows br0</p>
<h1>Add flows between port 1 (dpdk0) to port 2 (dpdk1)</h1>
<p>./ovs-ofctl add-flow br0 in_port=1,action=output:2 ./ovs-ofctl add-flow br0 in_port=2,action=output:1 ```</p>
<ol type="1">
<li><p class="startli">Performance tuning</p>
<p class="startli">With pmd multi-threading support, OVS creates one pmd thread for each numa node as default. The pmd thread handles the I/O of all DPDK interfaces on the same numa node. The following two commands can be used to configure the multi-threading behavior.</p>
<p class="startli"><code>ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=&lt;hex string&gt;</code></p>
<p class="startli">The command above asks for a CPU mask for setting the affinity of pmd threads. A set bit in the mask means a pmd thread is created and pinned to the corresponding CPU core. For more information, please refer to <code>man ovs-vswitchd.conf.db</code></p>
<p class="startli"><code>ovs-vsctl set Open_vSwitch . other_config:n-dpdk-rxqs=&lt;integer&gt;</code></p>
<p class="startli">The command above sets the number of rx queues of each DPDK interface. The rx queues are assigned to pmd threads on the same numa node in round-robin fashion. For more information, please refer to <code>man ovs-vswitchd.conf.db</code></p>
<p class="startli">Ideally for maximum throughput, the pmd thread should not be scheduled out which temporarily halts its execution. The following affinitization methods can help.</p>
<p class="startli">Lets pick core 4,6,8,10 for pmd threads to run on. Also assume a dual 8 core sandy bridge system with hyperthreading enabled where CPU1 has cores 0,...,7 and 16,...,23 &amp; CPU2 cores 8,...,15 &amp; 24,...,31. (A different cpu configuration could have different core mask requirements).</p>
<p class="startli">To kernel bootline add core isolation list for cores and associated hype cores (e.g. isolcpus=4,20,6,22,8,24,10,26,). Reboot system for isolation to take effect, restart everything.</p>
<p class="startli">Configure pmd threads on core 4,6,8,10 using 'pmd-cpu-mask':</p>
<p class="startli"><code>ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=00000550</code></p>
<p class="startli">You should be able to check that pmd threads are pinned to the correct cores via:</p>
<p class="startli">``<code> top -p</code>pidof ovs-vswitchd<code>-H -d1 </code>``</p>
<p class="startli">Note, the pmd threads on a numa node are only created if there is at least one DPDK interface from the numa node that has been added to OVS.</p>
<p class="startli">To understand where most of the time is spent and whether the caches are effective, these commands can be used:</p>
<p class="startli">``` ovs-appctl dpif-netdev/pmd-stats-clear #To reset statistics ovs-appctl dpif-netdev/pmd-stats-show ```</p>
</li>
</ol>
<h2>DPDK Rings : </h2>
<p>Following the steps above to create a bridge, you can now add dpdk rings as a port to the vswitch. OVS will expect the DPDK ring device name to start with dpdkr and end with a portid.</p>
<p><code>ovs-vsctl add-port br0 dpdkr0 -- set Interface dpdkr0 type=dpdkr</code></p>
<p>DPDK rings client test application</p>
<p>Included in the test directory is a sample DPDK application for testing the rings. This is from the base dpdk directory and modified to work with the ring naming used within ovs.</p>
<p>location tests/ovs_client</p>
<p>To run the client :</p>
<p>``` cd /usr/src/ovs/tests/ ovsclient -c 1 -n 4 &ndash;proc-type=secondary &ndash; -n "port id you gave dpdkr" ```</p>
<p>In the case of the dpdkr example above the "port id you gave dpdkr" is 0.</p>
<p>It is essential to have &ndash;proc-type=secondary</p>
<p>The application simply receives an mbuf on the receive queue of the ethernet ring and then places that same mbuf on the transmit ring of the ethernet ring. It is a trivial loopback application.</p>
<h2>DPDK rings in VM (IVSHMEM shared memory communications) </h2>
<p>In addition to executing the client in the host, you can execute it within a guest VM. To do so you will need a patched qemu. You can download the patch and getting started guide at :</p>
<p><a href="https://01.org/packet-processing/downloads">https://01.org/packet-processing/downloads</a></p>
<p>A general rule of thumb for better performance is that the client application should not be assigned the same dpdk core mask "-c" as the vswitchd.</p>
<h2>DPDK vhost: </h2>
<p>DPDK 2.0 supports two types of vhost:</p>
<ol type="1">
<li>vhost-user</li>
<li>vhost-cuse</li>
</ol>
<p>Whatever type of vhost is enabled in the DPDK build specified, is the type that will be enabled in OVS. By default, vhost-user is enabled in DPDK. Therefore, unless vhost-cuse has been enabled in DPDK, vhost-user ports will be enabled in OVS. Please note that support for vhost-cuse is intended to be deprecated in OVS in a future release.</p>
<h2>DPDK vhost-user: </h2>
<p>The following sections describe the use of vhost-user 'dpdkvhostuser' ports with OVS.</p>
<h2>DPDK vhost-user Prerequisites: </h2>
<ol type="1">
<li>DPDK 2.0 with vhost support enabled as documented in the "Building and
   Installing section"</li>
<li><p class="startli">QEMU version v2.1.0+</p>
<p class="startli">QEMU v2.1.0 will suffice, but it is recommended to use v2.2.0 if providing your VM with memory greater than 1GB due to potential issues with memory mapping larger areas.</p>
</li>
</ol>
<h2>Adding DPDK vhost-user ports to the Switch: </h2>
<p>Following the steps above to create a bridge, you can now add DPDK vhost-user as a port to the vswitch. Unlike DPDK ring ports, DPDK vhost-user ports can have arbitrary names.</p>
<ul>
<li><p class="startli">For vhost-user, the name of the port type is <code>dpdkvhostuser</code></p>
<p class="startli">``` ovs-vsctl add-port br0 vhost-user-1 &ndash; set Interface vhost-user-1 type=dpdkvhostuser ```</p>
<p class="startli">This action creates a socket located at <code>/usr/local/var/run/openvswitch/vhost-user-1</code>, which you must provide to your VM on the QEMU command line. More instructions on this can be found in the next section "DPDK vhost-user VM configuration" Note: If you wish for the vhost-user sockets to be created in a directory other than <code>/usr/local/var/run/openvswitch</code>, you may specify another location on the ovs-vswitchd command line like so:</p>
<p class="startli"><code>./vswitchd/ovs-vswitchd --dpdk -vhost_sock_dir /my-dir -c 0x1 ...</code></p>
</li>
</ul>
<h2>DPDK vhost-user VM configuration: </h2>
<p>Follow the steps below to attach vhost-user <a class="el" href="structport.html">port(s)</a> to a VM.</p>
<ol type="1">
<li><p class="startli">Configure sockets. Pass the following parameters to QEMU to attach a vhost-user device:</p>
<p class="startli">``` -chardev socket,id=char1,path=/usr/local/var/run/openvswitch/vhost-user-1 -netdev type=vhost-user,id=mynet1,chardev=char1,vhostforce -device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1 ```</p>
<p class="startli">...where vhost-user-1 is the name of the vhost-user port added to the switch. Repeat the above parameters for multiple devices, changing the chardev path and id as necessary. Note that a separate and different chardev path needs to be specified for each vhost-user device. For example you have a second vhost-user port named 'vhost-user-2', you append your QEMU command line with an additional set of parameters:</p>
<p class="startli">``` -chardev socket,id=char2,path=/usr/local/var/run/openvswitch/vhost-user-2 -netdev type=vhost-user,id=mynet2,chardev=char2,vhostforce -device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2 ```</p>
</li>
<li><p class="startli">Configure huge pages. QEMU must allocate the VM's memory on hugetlbfs. vhost-user ports access a virtio-net device's virtual rings and packet buffers mapping the VM's physical memory on hugetlbfs. To enable vhost-user ports to map the VM's memory into their process address space, pass the following paramters to QEMU:</p>
<p class="startli">``` -object memory-backend-file,id=mem,size=4096M,mem-path=/dev/hugepages, share=on -numa node,memdev=mem -mem-prealloc ```</p>
</li>
</ol>
<h2>DPDK vhost-cuse: </h2>
<p>The following sections describe the use of vhost-cuse 'dpdkvhostcuse' ports with OVS.</p>
<h2>DPDK vhost-cuse Prerequisites: </h2>
<ol type="1">
<li><p class="startli">DPDK 2.0 with vhost support enabled as documented in the "Building and
   Installing section" As an additional step, you must enable vhost-cuse in DPDK by setting the following additional flag in <code>config/common_linuxapp</code>:</p>
<p class="startli"><code>CONFIG_RTE_LIBRTE_VHOST_USER=n</code></p>
<p class="startli">Following this, rebuild DPDK as per the instructions in the "Building and
   Installing" section. Finally, rebuild OVS as per step 3 in the "Building
   and Installing" section - OVS will detect that DPDK has vhost-cuse libraries compiled and in turn will enable support for it in the switch and disable vhost-user support.</p>
</li>
<li><p class="startli">Insert the Cuse module:</p>
<p class="startli"><code>modprobe cuse</code></p>
</li>
<li><p class="startli">Build and insert the <code>eventfd_link</code> module:</p>
<p class="startli">``` cd $DPDK_DIR/lib/librte_vhost/eventfd_link/ make insmod $DPDK_DIR/lib/librte_vhost/eventfd_link.ko ```</p>
</li>
<li><p class="startli">QEMU version v2.1.0+</p>
<p class="startli">vhost-cuse will work with QEMU v2.1.0 and above, however it is recommended to use v2.2.0 if providing your VM with memory greater than 1GB due to potential issues with memory mapping larger areas. Note: QEMU v1.6.2 will also work, with slightly different command line parameters, which are specified later in this document.</p>
</li>
</ol>
<h2>Adding DPDK vhost-cuse ports to the Switch: </h2>
<p>Following the steps above to create a bridge, you can now add DPDK vhost-cuse as a port to the vswitch. Unlike DPDK ring ports, DPDK vhost-cuse ports can have arbitrary names.</p>
<ul>
<li><p class="startli">For vhost-cuse, the name of the port type is <code>dpdkvhostcuse</code></p>
<p class="startli">``` ovs-vsctl add-port br0 vhost-cuse-1 &ndash; set Interface vhost-cuse-1 type=dpdkvhostcuse ```</p>
<p class="startli">When attaching vhost-cuse ports to QEMU, the name provided during the add-port operation must match the ifname parameter on the QEMU command line. More instructions on this can be found in the next section.</p>
</li>
</ul>
<h2>DPDK vhost-cuse VM configuration: </h2>
<p>vhost-cuse ports use a Linux* character device to communicate with QEMU. By default it is set to <code>/dev/vhost-net</code>. It is possible to reuse this standard device for DPDK vhost, which makes setup a little simpler but it is better practice to specify an alternative character device in order to avoid any conflicts if kernel vhost is to be used in parallel.</p>
<ol type="1">
<li><p class="startli">This step is only needed if using an alternative character device.</p>
<p class="startli">The new character device filename must be specified on the vswitchd commandline: </p><pre class="fragment"> `./vswitchd/ovs-vswitchd --dpdk --cuse_dev_name my-vhost-net -c 0x1 ...`
</pre><p class="startli">Note that the <code>--cuse_dev_name</code> argument and associated string must be the first arguments after <code>--dpdk</code> and come before the EAL arguments. In the example above, the character device to be used will be <code>/dev/my-vhost-net</code>.</p>
</li>
<li>This step is only needed if reusing the standard character device. It will conflict with the kernel vhost character device so the user must first remove it. <pre class="fragment">`rm -rf /dev/vhost-net`
</pre></li>
</ol>
<p>3a. Configure virtio-net adaptors: The following parameters must be passed to the QEMU binary:</p>
<p>``` -netdev tap,id=&lt;id&gt;,script=no,downscript=no,ifname=&lt;name&gt;,vhost=on -device virtio-net-pci,netdev=net1,mac=&lt;mac&gt; ```</p>
<p>Repeat the above parameters for multiple devices.</p>
<p>The DPDK vhost library will negiotiate its own features, so they need not be passed in as command line params. Note that as offloads are disabled this is the equivalent of setting:</p>
<p><code>csum=off,gso=off,guest_tso4=off,guest_tso6=off,guest_ecn=off</code></p>
<p>3b. If using an alternative character device. It must be also explicitly passed to QEMU using the <code>vhostfd</code> argument:</p>
<p>``` -netdev tap,id=&lt;id&gt;,script=no,downscript=no,ifname=&lt;name&gt;,vhost=on, vhostfd=&lt;open_fd&gt; -device virtio-net-pci,netdev=net1,mac=&lt;mac&gt; ```</p>
<p>The open file descriptor must be passed to QEMU running as a child process. This could be done with a simple python script.</p>
<p>``` #!/usr/bin/python fd = os.open("/dev/usvhost", os.O_RDWR) subprocess.call("qemu-system-x86_64 .... -netdev tap,id=vhostnet0,\
                        vhost=on,vhostfd=" + fd +"...", shell=True)</p>
<p>Alternatively the <code><a class="el" href="qemu-wrap_8py.html">qemu-wrap.py</a></code> script can be used to automate the requirements specified above and can be used in conjunction with libvirt if desired. See the "DPDK vhost VM configuration with QEMU wrapper" section below.</p>
<ol type="1">
<li><p class="startli">Configure huge pages: QEMU must allocate the VM's memory on hugetlbfs. Vhost ports access a virtio-net device's virtual rings and packet buffers mapping the VM's physical memory on hugetlbfs. To enable vhost-ports to map the VM's memory into their process address space, pass the following parameters to QEMU:</p>
<p class="startli"><code>-object memory-backend-file,id=mem,size=4096M,mem-path=/dev/hugepages, share=on -numa node,memdev=mem -mem-prealloc</code></p>
<p class="startli">Note: For use with an earlier QEMU version such as v1.6.2, use the following to configure hugepages instead:</p>
<p class="startli"><code>-mem-path /dev/hugepages -mem-prealloc</code></p>
</li>
</ol>
<h2>DPDK vhost-cuse VM configuration with QEMU wrapper: </h2>
<p>The QEMU wrapper script automatically detects and calls QEMU with the necessary parameters. It performs the following actions:</p>
<ul>
<li>Automatically detects the location of the hugetlbfs and inserts this into the command line parameters.</li>
<li>Automatically open file descriptors for each virtio-net device and inserts this into the command line parameters.</li>
<li>Calls QEMU passing both the command line parameters passed to the script itself and those it has auto-detected.</li>
</ul>
<p>Before use, you <b>must</b> edit the configuration parameters section of the script to point to the correct emulator location and set additional settings. Of these settings, <code>emul_path</code> and <code>us_vhost_path</code> <b>must</b> be set. All other settings are optional.</p>
<p>To use directly from the command line simply pass the wrapper some of the QEMU parameters: it will configure the rest. For example:</p>
<p>``` <a class="el" href="qemu-wrap_8py.html">qemu-wrap.py</a> -cpu host -boot c -hda &lt;disk image&gt;=""&gt; -m 4096 -smp 4 &ndash;enable-kvm -nographic -vnc none -net none -netdev tap,id=net1, script=no,downscript=no,ifname=if1,vhost=on -device virtio-net-pci, netdev=net1,mac=00:00:00:00:00:01 ```</p>
<h2>DPDK vhost-cuse VM configuration with libvirt: </h2>
<p>If you are using libvirt, you must enable libvirt to access the character device by adding it to controllers cgroup for libvirtd using the following steps. </p><pre class="fragment"> 1. In `/etc/libvirt/qemu.conf` add/edit the following lines:

    ```
    1) clear_emulator_capabilities = 0
    2) user = "root"
    3) group = "root"
    4) cgroup_device_acl = [
           "/dev/null", "/dev/full", "/dev/zero",
           "/dev/random", "/dev/urandom",
           "/dev/ptmx", "/dev/kvm", "/dev/kqemu",
           "/dev/rtc", "/dev/hpet", "/dev/net/tun",
           "/dev/&lt;my-vhost-device&gt;",
           "/dev/hugepages"]
    ```

    &lt;my-vhost-device&gt; refers to "vhost-net" if using the `/dev/vhost-net`
    device. If you have specificed a different name on the ovs-vswitchd
    commandline using the "--cuse_dev_name" parameter, please specify that
    filename instead.

 2. Disable SELinux or set to permissive mode

 3. Restart the libvirtd process
    For example, on Fedora:

      `systemctl restart libvirtd.service`
</pre><p>After successfully editing the configuration, you may launch your vhost-enabled VM. The XML describing the VM can be configured like so within the &lt;qemu:commandline&gt; section: </p><pre class="fragment"> 1. Set up shared hugepages:

 ```
 &lt;qemu:arg value='-object'/&gt;
 &lt;qemu:arg value='memory-backend-file,id=mem,size=4096M,mem-path=/dev/hugepages,share=on'/&gt;
 &lt;qemu:arg value='-numa'/&gt;
 &lt;qemu:arg value='node,memdev=mem'/&gt;
 &lt;qemu:arg value='-mem-prealloc'/&gt;
 ```

 2. Set up your tap devices:

 ```
 &lt;qemu:arg value='-netdev'/&gt;
 &lt;qemu:arg value='type=tap,id=net1,script=no,downscript=no,ifname=vhost0,vhost=on'/&gt;
 &lt;qemu:arg value='-device'/&gt;
 &lt;qemu:arg value='virtio-net-pci,netdev=net1,mac=00:00:00:00:00:01'/&gt;
 ```

 Repeat for as many devices as are desired, modifying the id, ifname
 and mac as necessary.

 Again, if you are using an alternative character device (other than
 `/dev/vhost-net`), please specify the file descriptor like so:

 `&lt;qemu:arg value='type=tap,id=net3,script=no,downscript=no,ifname=vhost0,vhost=on,vhostfd=&lt;open_fd&gt;'/&gt;`

 Where &lt;open_fd&gt; refers to the open file descriptor of the character device.
 Instructions of how to retrieve the file descriptor can be found in the
 "DPDK vhost VM configuration" section.
 Alternatively, the process is automated with the qemu-wrap.py script,
 detailed in the next section.
</pre><p>Now you may launch your VM using virt-manager, or like so: </p><pre class="fragment">`virsh create my_vhost_vm.xml`
</pre><h2>DPDK vhost-cuse VM configuration with libvirt and QEMU wrapper: </h2>
<p>To use the qemu-wrapper script in conjuntion with libvirt, follow the steps in the previous section before proceeding with the following steps:</p>
<ol type="1">
<li>Place <code><a class="el" href="qemu-wrap_8py.html">qemu-wrap.py</a></code> in libvirtd's binary search PATH ($PATH) Ideally in the same directory that the QEMU binary is located.</li>
<li>Ensure that the script has the same owner/group and file permissions as the QEMU binary.</li>
<li>Update the VM xml file using "virsh edit VM.xml"<ol type="a">
<li><p class="startli">Set the VM to use the launch script. Set the emulator path contained in the <code>&lt;emulator&gt;&lt;emulator/&gt;</code> tags. For example, replace:</p>
<p class="startli"><code>&lt;emulator&gt;/usr/bin/qemu-kvm&lt;emulator/&gt;</code></p>
<p class="startli">with:</p>
<p class="startli"><code>&lt;emulator&gt;/usr/bin/qemu-wrap.py&lt;emulator/&gt;</code></p>
</li>
</ol>
</li>
<li>Edit the Configuration Parameters section of the script to point to the correct emulator location and set any additional options. If you are using a alternative character device name, please set "us_vhost_path" to the location of that device. The script will automatically detect and insert the correct "vhostfd" value in the QEMU command line arguments.</li>
<li>Use virt-manager to launch the VM</li>
</ol>
<h2>Running ovs-vswitchd with DPDK backend inside a VM </h2>
<p>Please note that additional configuration is required if you want to run ovs-vswitchd with DPDK backend inside a QEMU virtual machine. Ovs-vswitchd creates separate DPDK TX queues for each CPU core available. This operation fails inside QEMU virtual machine because, by default, VirtIO NIC provided to the guest is configured to support only single TX queue and single RX queue. To change this behavior, you need to turn on 'mq' (multiqueue) property of all virtio-net-pci devices emulated by QEMU and used by DPDK. You may do it manually (by changing QEMU command line) or, if you use Libvirt, by adding the following string:</p>
<p>`&lt;driver name="vhost" queues="N"&gt;`</p>
<p>to &lt;interface&gt; sections of all network devices used by DPDK. Parameter 'N' determines how many queues can be used by the guest.</p>
<h2>Restrictions: </h2>
<ul>
<li>Work with 1500 MTU, needs few changes in DPDK lib to fix this issue.</li>
<li>Currently DPDK port does not make use any offload functionality.</li>
<li>DPDK-vHost support works with 1G huge pages.</li>
</ul>
<p>ivshmem:</p><ul>
<li>If you run Open vSwitch with smaller page sizes (e.g. 2MB), you may be unable to share any rings or mempools with a virtual machine. This is because the current implementation of ivshmem works by sharing a single 1GB huge page from the host operating system to any guest operating system through the Qemu ivshmem device. When using smaller page sizes, multiple pages may be required to hold the ring descriptors and buffer pools. The Qemu ivshmem device does not allow you to share multiple file descriptors to the guest operating system. However, if you want to share dpdkr rings with other processes on the host, you can do this with smaller page sizes.</li>
</ul>
<p>Platform and Network Interface:</p><ul>
<li>Currently it is not possible to use an Intel XL710 Network Interface as a DPDK port type on a platform with more than 64 logical cores. This is related to how DPDK reports the number of TX queues that may be used by a DPDK application with an XL710. The maximum number of TX queues supported by a DPDK application for an XL710 is 64. If a user attempts to add an XL710 interface as a DPDK port type to a system as described above the port addition will fail as OVS will attempt to initialize a TX queue greater than 64. This issue is expected to be resolved in a future DPDK release. As a workaround a user can disable hyper-threading to reduce the overall core count of the system to be less than or equal to 64 when using an XL710 interface with DPDK.</li>
</ul>
<h2>Bug Reporting: </h2>
<p>Please report problems to <a href="#" onclick="location.href='mai'+'lto:'+'bug'+'s@'+'ope'+'nv'+'swi'+'tc'+'h.o'+'rg'; return false;">bugs@<span style="display: none;">.nosp@m.</span>open<span style="display: none;">.nosp@m.</span>vswit<span style="display: none;">.nosp@m.</span>ch.o<span style="display: none;">.nosp@m.</span>rg</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Sep 9 2015 19:08:08 for ovs all by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
