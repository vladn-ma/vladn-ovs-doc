<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ovs all: How to Port Open vSwitch to New Software or Hardware</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ovs all
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_vladn_git_ovs_PORTING.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to Port Open vSwitch to New Software or Hardware </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Open vSwitch (OVS) is intended to be easily ported to new software and hardware platforms. This document describes the types of changes that are most likely to be necessary in porting OVS to Unix-like platforms. (Porting OVS to other kinds of platforms is likely to be more difficult.)</p>
<h2>Vocabulary </h2>
<p>For historical reasons, different words are used for essentially the same concept in different areas of the Open vSwitch source tree. Here is a concordance, indexed by the area of the source tree: </p><pre class="fragment">    datapath/       vport           ---
    vswitchd/       iface           port
    ofproto/        port            bundle
    ofproto/bond.c  slave           bond
    lib/lacp.c      slave           lacp
    lib/netdev.c    netdev          ---
    database        Interface       Port
</pre><h2>Open vSwitch Architectural Overview </h2>
<p>The following diagram shows the very high-level architecture of Open vSwitch from a porter's perspective. </p><pre class="fragment">               +-------------------+
               |    ovs-vswitchd   |&lt;--&gt;ovsdb-server
               +-------------------+
               |      ofproto      |&lt;--&gt;OpenFlow controllers
               +--------+-+--------+
               | netdev | | ofproto|
               +--------+ |provider|
               | netdev | +--------+
               |provider|
               +--------+
</pre><p>Some of the components are generic. Modulo bugs or inadequacies, these components should not need to be modified as part of a port:</p>
<ul>
<li>"ovs-vswitchd" is the main Open vSwitch userspace program, in vswitchd/. It reads the desired Open vSwitch configuration from the ovsdb-server program over an IPC channel and passes this configuration down to the "ofproto" library. It also passes certain status and statistical information from ofproto back into the database.</li>
<li>"ofproto" is the Open vSwitch library, in ofproto/, that implements an OpenFlow switch. It talks to OpenFlow controllers over the network and to switch hardware or software through an "ofproto provider", explained further below.</li>
<li>"netdev" is the Open vSwitch library, in <a class="el" href="netdev_8c.html">lib/netdev.c</a>, that abstracts interacting with network devices, that is, Ethernet interfaces. The netdev library is a thin layer over "netdev
    provider" code, explained further below.</li>
</ul>
<p>The other components may need attention during a port. You will almost certainly have to implement a "netdev provider". Depending on the type of port you are doing and the desired performance, you may also have to implement an "ofproto provider" or a lower-level component called a "dpif" provider.</p>
<p>The following sections talk about these components in more detail.</p>
<h2>Writing a netdev Provider </h2>
<p>A "netdev provider" implements an operating system and hardware specific interface to "network devices", e.g. eth0 on Linux. Open vSwitch must be able to open each port on a switch as a netdev, so you will need to implement a "netdev provider" that works with your switch hardware and software.</p>
<p>struct <a class="el" href="structnetdev__class.html">netdev_class</a>, in <a class="el" href="netdev-provider_8h.html">lib/netdev-provider.h</a>, defines the interfaces required to implement a netdev. That structure contains many function pointers, each of which has a comment that is meant to describe its behavior in detail. If the requirements are unclear, please report this as a bug.</p>
<p>The netdev interface can be divided into a few rough categories:</p>
<ul>
<li>Functions required to properly implement OpenFlow features. For example, OpenFlow requires the ability to report the Ethernet hardware address of a port. These functions must be implemented for minimally correct operation.</li>
<li>Functions required to implement optional Open vSwitch features. For example, the Open vSwitch support for in-band control requires netdev support for inspecting the TCP/IP stack's ARP table. These functions must be implemented if the corresponding OVS features are to work, but may be omitted initially.</li>
<li>Functions needed in some implementations but not in others. For example, most kinds of ports (see below) do not need functionality to receive packets from a network device.</li>
</ul>
<p>The existing netdev implementations may serve as useful examples during a port:</p>
<ul>
<li><a class="el" href="netdev-linux_8c.html">lib/netdev-linux.c</a> implements netdev functionality for Linux network devices, using Linux kernel calls. It may be a good place to start for full-featured netdev implementations.</li>
<li><a class="el" href="netdev-vport_8c.html">lib/netdev-vport.c</a> provides support for "virtual ports" implemented by the Open vSwitch datapath module for the Linux kernel. This may serve as a model for minimal netdev implementations.</li>
<li><a class="el" href="netdev-dummy_8c.html">lib/netdev-dummy.c</a> is a fake netdev implementation useful only for testing.</li>
</ul>
<h2>Porting Strategies </h2>
<p>After a netdev provider has been implemented for a system's network devices, you may choose among three basic porting strategies.</p>
<p>The lowest-effort strategy is to use the "userspace switch" implementation built into Open vSwitch. This ought to work, without writing any more code, as long as the netdev provider that you implemented supports receiving packets. It yields poor performance, however, because every packet passes through the ovs-vswitchd process. See <a class="el" href="INSTALL_8userspace_8md.html">INSTALL.userspace.md</a> for instructions on how to configure a userspace switch.</p>
<p>If the userspace switch is not the right choice for your port, then you will have to write more code. You may implement either an "ofproto provider" or a "dpif provider". Which you should choose depends on a few different factors:</p>
<ul>
<li>Only an ofproto provider can take full advantage of hardware with built-in support for wildcards (e.g. an ACL table or a TCAM).</li>
<li>A dpif provider can take advantage of the Open vSwitch built-in implementations of bonding, LACP, 802.1ag, 802.1Q VLANs, and other features. An ofproto provider has to provide its own implementations, if the hardware can support them at all.</li>
<li>A dpif provider is usually easier to implement, but most appropriate for software switching. It "explodes" wildcard rules into exact-match entries (with an optional wildcard mask). This allows fast hash lookups in software, but makes inefficient use of TCAMs in hardware that support wildcarding.</li>
</ul>
<p>The following sections describe how to implement each kind of port.</p>
<h2>ofproto Providers </h2>
<p>An "ofproto provider" is what ofproto uses to directly monitor and control an OpenFlow-capable switch. struct <a class="el" href="structofproto__class.html">ofproto_class</a>, in <a class="el" href="ofproto-provider_8h.html">ofproto/ofproto-provider.h</a>, defines the interfaces to implement an ofproto provider for new hardware or software. That structure contains many function pointers, each of which has a comment that is meant to describe its behavior in detail. If the requirements are unclear, please report this as a bug.</p>
<p>The ofproto provider interface is preliminary. Please let us know if it seems unsuitable for your purpose. We will try to improve it.</p>
<h2>Writing a dpif Provider </h2>
<p>Open vSwitch has a built-in ofproto provider named "ofproto-dpif", which is built on top of a library for manipulating datapaths, called "dpif". A "datapath" is a simple flow table, one that is only required to support exact-match flows, that is, flows without wildcards. When a packet arrives on a network device, the datapath looks for it in this table. If there is a match, then it performs the associated actions. If there is no match, the datapath passes the packet up to ofproto-dpif, which maintains the full OpenFlow flow table. If the packet matches in this flow table, then ofproto-dpif executes its actions and inserts a new entry into the dpif flow table. (Otherwise, ofproto-dpif passes the packet up to ofproto to send the packet to the OpenFlow controller, if one is configured.)</p>
<p>When calculating the dpif flow, ofproto-dpif generates an exact-match flow that describes the missed packet. It makes an effort to figure out what fields can be wildcarded based on the switch's configuration and OpenFlow flow table. The dpif is free to ignore the suggested wildcards and only support the exact-match entry. However, if the dpif supports wildcarding, then it can use the masks to match multiple flows with fewer entries and potentially significantly reduce the number of flow misses handled by ofproto-dpif.</p>
<p>The "dpif" library in turn delegates much of its functionality to a "dpif provider". The following diagram shows how dpif providers fit into the Open vSwitch architecture: </p><pre class="fragment">            _
           |   +-------------------+
           |   |    ovs-vswitchd   |&lt;--&gt;ovsdb-server
           |   +-------------------+
           |   |      ofproto      |&lt;--&gt;OpenFlow controllers
           |   +--------+-+--------+  _
           |   | netdev | |ofproto-|   |
 userspace |   +--------+ |  dpif  |   |
           |   | netdev | +--------+   |
           |   |provider| |  dpif  |   |
           |   +---||---+ +--------+   |
           |       ||     |  dpif  |   | implementation of
           |       ||     |provider|   | ofproto provider
           |_      ||     +---||---+   |
                   ||         ||       |
            _  +---||-----+---||---+   |
           |   |          |datapath|   |
    kernel |   |          +--------+  _|
           |   |                   |
           |_  +--------||---------+
                        ||
                     physical
                       NIC
</pre><p>struct <a class="el" href="structdpif__class.html">dpif_class</a>, in <a class="el" href="dpif-provider_8h.html">lib/dpif-provider.h</a>, defines the interfaces required to implement a dpif provider for new hardware or software. That structure contains many function pointers, each of which has a comment that is meant to describe its behavior in detail. If the requirements are unclear, please report this as a bug.</p>
<p>There are two existing dpif implementations that may serve as useful examples during a port:</p>
<ul>
<li><a class="el" href="dpif-netlink_8c.html">lib/dpif-netlink.c</a> is a Linux-specific dpif implementation that talks to an Open vSwitch-specific kernel module (whose sources are in the "datapath" directory). The kernel module performs all of the switching work, passing packets that do not match any flow table entry up to userspace. This dpif implementation is essentially a wrapper around calls into the kernel module.</li>
<li><a class="el" href="dpif-netdev_8c.html">lib/dpif-netdev.c</a> is a generic dpif implementation that performs all switching internally. This is how the Open vSwitch userspace switch is implemented.</li>
</ul>
<h2>Miscellaneous Notes </h2>
<p>Open vSwitch source code uses uint16_t, uint32_t, and uint64_t as fixed-width types in host byte order, and ovs_be16, ovs_be32, and ovs_be64 as fixed-width types in network byte order. Each of the latter is equivalent to the one of the former, but the difference in name makes the intended use obvious.</p>
<p>The default "fail-mode" for Open vSwitch bridges is "standalone", meaning that, when the OpenFlow controllers cannot be contacted, Open vSwitch acts as a regular MAC-learning switch. This works well in virtualization environments where there is normally just one uplink (either a single physical interface or a bond). In a more general environment, it can create loops. So, if you are porting to a general-purpose switch platform, you should consider changing the default "fail-mode" to "secure", which does not behave this way. See documentation for the "fail-mode" column in the Bridge table in ovs-vswitchd.conf.db(5) for more information.</p>
<p><a class="el" href="entropy_8c.html">lib/entropy.c</a> assumes that it can obtain high-quality random number seeds at startup by reading from /dev/urandom. You will need to modify it if this is not true on your platform.</p>
<p><a class="el" href="system-stats_8c.html">vswitchd/system-stats.c</a> only knows how to obtain some statistics on Linux. Optionally you may implement them for your platform as well.</p>
<h2>Why OVS Does Not Support Hybrid Providers </h2>
<p>The "Porting Strategies" section above describes the "ofproto
provider" and "dpif provider" porting strategies. Only an ofproto provider can take advantage of hardware TCAM support, and only a dpif provider can take advantage of the OVS built-in implementations of various features. It is therefore tempting to suggest a hybrid approach that shares the advantages of both strategies.</p>
<p>However, Open vSwitch does not support a hybrid approach. Doing so may be possible, with a significant amount of extra development work, but it does not yet seem worthwhile, for the reasons explained below.</p>
<p>First, user surprise is likely when a switch supports a feature only with a high performance penalty. For example, one user questioned why adding a particular OpenFlow action to a flow caused a 1,058x slowdown on a hardware OpenFlow implementation [1]. The action required the flow to be implemented in software.</p>
<p>Given that implementing a flow in software on the slow management CPU of a hardware switch causes a major slowdown, software-implemented flows would only make sense for very low-volume traffic. But many of the features built into the OVS software switch implementation would need to apply to every flow to be useful. There is no value, for example, in applying bonding or 802.1Q VLAN support only to low-volume traffic.</p>
<p>Besides supporting features of OpenFlow actions, a hybrid approach could also support forms of matching not supported by particular switching hardware, by sending all packets that might match a rule to software. But again this can cause an unacceptable slowdown by forcing bulk traffic through software in the hardware switch's slow management CPU. Consider, for example, a hardware switch that can match on the IPv6 Ethernet type but not on fields in IPv6 headers. An OpenFlow table that matched on the IPv6 Ethernet type would perform well, but adding a rule that matched only UDPv6 would force every IPv6 packet to software, slowing down not just UDPv6 but all IPv6 processing.</p>
<p>[1] Aaron Rosen, "Modify packet fields extremely slow", openflow-discuss mailing list, June 26, 2011, archived at <a href="https://mailman.stanford.edu/pipermail/openflow-discuss/2011-June/002386.html">https://mailman.stanford.edu/pipermail/openflow-discuss/2011-June/002386.html</a>.</p>
<h2>Questions </h2>
<p>Please direct porting questions to <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'@o'+'pen'+'vs'+'wit'+'ch'+'.or'+'g'; return false;">dev@o<span style="display: none;">.nosp@m.</span>penv<span style="display: none;">.nosp@m.</span>switc<span style="display: none;">.nosp@m.</span>h.or<span style="display: none;">.nosp@m.</span>g</a>. We will try to use questions to improve this porting guide. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Sep 9 2015 19:08:08 for ovs all by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
