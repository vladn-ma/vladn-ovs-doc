{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment ovs datapath }ovs datapath}
{\comment Generated byDoxgyen. }
{\creatim \yr2015\mo8\dy17\hr11\min15\sec8}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Open vSwitch datapath developer documentation{\tc \v Open vSwitch datapath developer documentation}\par \pard\plain 
{\bkmkstart AAAAAAADHE}
{\bkmkend AAAAAAADHE}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Open vSwitch kernel module allows flexible userspace control over flow-level packet processing on selected network devices. It can be used to implement a plain Ethernet switch, network device bonding, VLAN processing, network access control, flow-based network control, and so on.\par
The kernel module implements multiple "datapaths" (analogous to bridges), each of which can have multiple "vports" (analogous to ports within a bridge). Each datapath also has associated with it a "flow
table" that userspace populates with "flows" that map from keys based on packet headers and metadata to sets of actions. The most common action forwards the packet to another vport; other actions are also implemented.\par
When a packet arrives on a vport, the kernel module processes it by extracting its flow key and looking it up in the flow table. If there is a matching flow, it executes the associated actions. If there is no match, it queues the packet to userspace for processing (as part of its processing, userspace will likely set up a flow to handle further packets of the same type entirely in-kernel).\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Flow key compatibility \par}
Network protocols evolve over time. New protocols become important and existing protocols lose their prominence. For the Open vSwitch kernel module to remain relevant, it must be possible for newer versions to parse additional protocols as part of the flow key. It might even be desirable, someday, to drop support for parsing protocols that have become obsolete. Therefore, the Netlink interface to Open vSwitch is designed to allow carefully written userspace applications to work with any version of the flow key, past or future.\par
To support this forward and backward compatibility, whenever the kernel module passes a packet to userspace, it also passes along the flow key that it parsed from the packet. Userspace then extracts its own notion of a flow key from the packet and compares it against the kernel-provided version:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If userspace's notion of the flow key for the packet matches the kernel's, then nothing special is necessary.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the kernel's flow key includes more fields than the userspace version of the flow key, for example if the kernel decoded IPv6 headers but userspace stopped at the Ethernet type (because it does not understand IPv6), then again nothing special is necessary. Userspace can still set up a flow in the usual way, as long as it uses the kernel-provided flow key to do it.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the userspace flow key includes more fields than the kernel's, for example if userspace decoded an IPv6 header but the kernel stopped at the Ethernet type, then userspace can forward the packet manually, without setting up a flow in the kernel. This case is bad for performance because every packet that the kernel considers part of the flow must go to userspace, but the forwarding behavior is correct. (If userspace can determine that the values of the extra fields would not affect forwarding behavior, then it could set up a flow anyway.)\par}
How flow keys evolve over time is important to making this work, so the following sections go into detail.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Flow key format \par}
A flow key is passed over a Netlink socket as a sequence of Netlink attributes. Some attributes represent packet metadata, defined as any information about a packet that cannot be extracted from the packet itself, e.g. the vport on which the packet was received. Most attributes, however, are extracted from headers within the packet, e.g. source and destination addresses from Ethernet, IP, or TCP headers.\par
The <{\b linux/openvswitch.h}> header file defines the exact format of the flow key attributes. For informal explanatory purposes here, we write them as comma-separated strings, with parentheses indicating arguments and nesting. For example, the following could represent a flow key corresponding to a TCP packet that arrived on vport 1: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid in_port(1), eth(src=e0:91:f5:21:d0:b2, dst=00:02:e3:0f:80:a4),\par
eth_type(0x0800), ipv4(src=172.16.0.20, dst=172.18.0.52, proto=17, tos=0,\par
frag=no), tcp(src=49163, dst=80)\par
}
\par
Often we ellipsize arguments not important to the discussion, e.g.: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid in_port(1), eth(...), eth_type(0x0800), ipv4(...), tcp(...)\par
}
\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Wildcarded flow key format \par}
A wildcarded flow is described with two sequences of Netlink attributes passed over the Netlink socket. A flow key, exactly as described above, and an optional corresponding flow mask.\par
A wildcarded flow can represent a group of exact match flows. Each '1' bit in the mask specifies an exact match with the corresponding bit in the flow key. A '0' bit specifies a don't care bit, which will match either a '1' or '0' bit of an incoming packet. Using a wildcarded flow can improve the flow set up rate by reducing the number of new flows that need to be processed by the user space program.\par
Support for the mask Netlink attribute is optional for both the kernel and user space program. The kernel can ignore the mask attribute, installing an exact match flow, or reduce the number of don't care bits in the kernel to less than what was specified by the user space program. In this case, variations in bits that the kernel does not implement will simply result in additional flow setups. The kernel module will also work with user space programs that neither support nor supply flow mask attributes.\par
Since the kernel may ignore or modify wildcard bits, it can be difficult for the userspace program to know exactly what matches are installed. There are two possible approaches: reactively install flows as they miss the kernel flow table (and therefore not attempt to determine wildcard changes at all) or use the kernel's response messages to determine the installed wildcards.\par
When interacting with userspace, the kernel should maintain the match portion of the key exactly as originally installed. This will provides a handle to identify the flow for all future operations. However, when reporting the mask of an installed flow, the mask should include any restrictions imposed by the kernel.\par
The behavior when using overlapping wildcarded flows is undefined. It is the responsibility of the user space program to ensure that any incoming packet can match at most one flow, wildcarded or not. The current implementation performs best-effort detection of overlapping wildcarded flows and may reject some but not all of them. However, this behavior may change in future versions.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Unique flow identifiers \par}
An alternative to using the original match portion of a key as the handle for flow identification is a unique flow identifier, or "UFID". UFIDs are optional for both the kernel and user space program.\par
User space programs that support UFID are expected to provide it during flow setup in addition to the flow, then refer to the flow using the UFID for all future operations. The kernel is not required to index flows by the original flow key if a UFID is specified.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Basic rule for evolving flow keys \par}
Some care is needed to really maintain forward and backward compatibility for applications that follow the rules listed under "Flow key compatibility" above.\par
The basic rule is obvious: {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
 New network protocol support must only supplement existing flow key attributes. It must not change the meaning of already defined {\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}flow key attributes. \par}
This rule does have less-obvious consequences so it is worth working through a few examples. Suppose, for example, that the kernel module did not already implement VLAN parsing. Instead, it just interpreted the 802.1Q TPID (0x8100) as the Ethertype then stopped parsing the packet. The flow key for any packet with an 802.1Q header would look essentially like this, ignoring metadata: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid eth(...), eth_type(0x8100)\par
}
\par
Naively, to add VLAN support, it makes sense to add a new "vlan" flow key attribute to contain the VLAN tag, then continue to decode the encapsulated headers beyond the VLAN tag using the existing field definitions. With this change, a TCP packet in VLAN 10 would have a flow key much like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid eth(...), vlan(vid=10, pcp=0), eth_type(0x0800), ip(proto=6, ...), tcp(...)\par
}
\par
But this change would negatively affect a userspace application that has not been updated to understand the new "vlan" flow key attribute. The application could, following the flow compatibility rules above, ignore the "vlan" attribute that it does not understand and therefore assume that the flow contained IP packets. This is a bad assumption (the flow only contains IP packets if one parses and skips over the 802.1Q header) and it could cause the application's behavior to change across kernel versions even though it follows the compatibility rules.\par
The solution is to use a set of nested attributes. This is, for example, why 802.1Q support uses nested attributes. A TCP packet in VLAN 10 is actually expressed as: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid eth(...), eth_type(0x8100), vlan(vid=10, pcp=0), encap(eth_type(0x0800),\par
ip(proto=6, ...), tcp(...)))\par
}
\par
Notice how the "eth_type", "ip", and "tcp" flow key attributes are nested inside the "encap" attribute. Thus, an application that does not understand the "vlan" key will not see either of those attributes and therefore will not misinterpret them. (Also, the outer eth_type is still 0x8100, not changed to 0x0800.)\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Handling malformed packets \par}
Don't drop packets in the kernel for malformed protocol headers, bad checksums, etc. This would prevent userspace from implementing a simple Ethernet switch that forwards every packet.\par
Instead, in such a case, include an attribute with "empty" content. It doesn't matter if the empty content could be valid protocol values, as long as those values are rarely seen in practice, because userspace can always forward all packets with those values to userspace and handle them individually.\par
For example, consider a packet that contains an IP header that indicates protocol 6 for TCP, but which is truncated just after the IP header, so that the TCP header is missing. The flow key for this packet would include a tcp attribute with all-zero src and dst, like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid eth(...), eth_type(0x0800), ip(proto=6, ...), tcp(src=0, dst=0)\par
}
\par
As another example, consider a packet with an Ethernet type of 0x8100, indicating that a VLAN TCI should follow, but which is truncated just after the Ethernet type. The flow key for this packet would include an all-zero-bits vlan and an empty encap attribute, like this: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid eth(...), eth_type(0x8100), vlan(0), encap()\par
}
\par
Unlike a TCP packet with source and destination ports 0, an all-zero-bits VLAN TCI is not that rare, so the CFI bit (aka VLAN_TAG_PRESENT inside the kernel) is ordinarily set in a vlan attribute expressly to allow this situation to be distinguished. Thus, the flow key in this second example unambiguously indicates a missing or malformed VLAN TCI.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Other rules \par}
The other rules for flow keys are much less subtle:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Duplicate attributes are not allowed at a given nesting level.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ordering of attributes is not significant.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When the kernel sends a given flow key to userspace, it always composes it the same way. This allows userspace to hash and compare entire flow keys that it may not be able to fully interpret.\par}
{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl \v 3}Coding rules \par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Compatibility \par}
Please implement the headers and codes for compatibility with older kernel in linux/compat/ directory. All public functions should be exported using EXPORT_SYMBOL macro. Public function replacing the same-named kernel function should be prefixed with 'rpl_'. Otherwise, the function should be prefixed with 'ovs_'. For special case when it is not possible to follow this rule (e.g., the pskb_expand_head() function), the function name must be added to linux/compat/build-aux/export-check-whitelist, otherwise, the compilation check 'check-export-symbol' will fail. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b action_fifo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b arp_eth_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b datapath} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b deferred_action} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACST \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dp_stats_percpu} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dp_upcall_info} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b flow_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b flow_table} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b geneve_port} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gre_cisco_protocol} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b internal_dev} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b lisp_port} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b lisphdr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b mask_array} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b mask_cache_entry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b netdev_vport} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_action_hash} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_action_push_mpls} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_action_push_tnl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_action_push_vlan} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_dp_megaflow_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_dp_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_flow_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_arp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_ethernet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_icmp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_icmpv6} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_ipv4} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_ipv4_tunnel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_ipv6} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_mpls} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_nd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_sctp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_tcp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_key_udp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_len_tbl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_net} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_skb_cb} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_tunnel_info} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_vport_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ovs_vxlan_opts} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pcpu_sw_netstats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b reciprocal_value} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b rpl_genl_family} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_actions} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_id} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_key} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_key_range} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_mask} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sw_flow_match} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b table_instance} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tnl_ptk_info} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b u64_stats_sync} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport_err_stats} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport_net} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport_ops} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport_parms} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vport_portids} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vxlan_metadata} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vxlan_port} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vxlan_sock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vxlanhdr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vxlanhdr_gbp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /home/vladn/git/ovs/datapath/{\b actions.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b compat.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b datapath.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b datapath.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b dp_notify.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow_netlink.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow_netlink.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow_table.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b flow_table.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vlan.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-geneve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-gre.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-internal_dev.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-internal_dev.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-lisp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-netdev.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-netdev.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-stt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-vxlan.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport-vxlan.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/{\b vport.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b actions.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b datapath.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b dev-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b dp_notify.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b exthdrs_core.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b flex_array.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b flow.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b flow_dissector.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b flow_netlink.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b flow_table.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b genetlink-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b geneve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b gre.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b gso.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b ip_tunnels_core.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b kcompat.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b net_namespace.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b netdevice.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b openvswitch.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b reciprocal_div.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b skbuff-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b stt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b udp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b udp_tunnel.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-geneve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-geneve.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-gre.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-gre.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-internal_dev.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-lisp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-lisp.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-netdev.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-stt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-stt.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-vxlan.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport-vxlan.mod.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vport.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/{\b vxlan.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b dev-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b exthdrs_core.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b flex_array.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b flow_dissector.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b genetlink-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b geneve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b gre.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b gso.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b gso.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b ip_tunnels_core.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b net_namespace.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b netdevice.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b reciprocal_div.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b skbuff-openvswitch.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b stt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b udp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b udp_tunnel.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b utils.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/{\b vxlan.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b bug.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b compiler-gcc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b compiler.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b cpumask.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b err.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b etherdevice.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b flex_array.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b icmp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b icmpv6.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b if.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b if_arp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b if_ether.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b if_vlan.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b in.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b ip.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b ipv6.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b jiffies.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b kconfig.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b kernel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b mpls.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b net.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b netdev_features.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b netdevice.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b netlink.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b percpu.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b poison.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b random.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b rculist.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b rcupdate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b reciprocal_div.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b rtnetlink.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b sctp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b skbuff.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b stddef.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b tcp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b types.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b u64_stats_sync.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b udp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b workqueue.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b checksum.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b dst.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b flow_keys.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b genetlink.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b geneve.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b gre.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b inet_frag.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b ip.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b ip_tunnels.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b ipv6.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b mpls.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b net_namespace.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b netlink.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b sock.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b stt.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b udp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b udp_tunnel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/{\b vxlan.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/vladn/git/ovs/datapath/linux/compat/include/net/sctp/{\b checksum.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
action_fifo Struct Reference\par \pard\plain 
{\tc\tcl2 \v action_fifo}
{\xe \v action_fifo}
{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
Collaboration diagram for action_fifo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structaction__fifo__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b head}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tail}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b deferred_action} {\b fifo} [{\b DEFERRED_ACTION_FIFO_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v fifo\:action_fifo}
{\xe \v action_fifo\:fifo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b deferred_action} action_fifo::fifo}}
\par
{\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v head\:action_fifo}
{\xe \v action_fifo\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int action_fifo::head}}
\par
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tail\:action_fifo}
{\xe \v action_fifo\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int action_fifo::tail}}
\par
{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b actions.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arp_eth_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v arp_eth_header}
{\xe \v arp_eth_header}
{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
\par
{
{\f2 #include <flow.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b ar_hrd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b ar_pro}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_hln}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_pln}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b ar_op}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_sha} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_sip} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_tha} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b ar_tip} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ar_hln\:arp_eth_header}
{\xe \v arp_eth_header\:ar_hln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_hln}}
\par
{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_hrd\:arp_eth_header}
{\xe \v arp_eth_header\:ar_hrd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 arp_eth_header::ar_hrd}}
\par
{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_op\:arp_eth_header}
{\xe \v arp_eth_header\:ar_op}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 arp_eth_header::ar_op}}
\par
{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_pln\:arp_eth_header}
{\xe \v arp_eth_header\:ar_pln}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_pln}}
\par
{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_pro\:arp_eth_header}
{\xe \v arp_eth_header\:ar_pro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 arp_eth_header::ar_pro}}
\par
{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_sha\:arp_eth_header}
{\xe \v arp_eth_header\:ar_sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_sha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_sip\:arp_eth_header}
{\xe \v arp_eth_header\:ar_sip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_sip[4]}}
\par
{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_tha\:arp_eth_header}
{\xe \v arp_eth_header\:ar_tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_tha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ar_tip\:arp_eth_header}
{\xe \v arp_eth_header\:ar_tip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char arp_eth_header::ar_tip[4]}}
\par
{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datapath Struct Reference\par \pard\plain 
{\tc\tcl2 \v datapath}
{\xe \v datapath}
{\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
\par
{
{\f2 #include <datapath.h>}}\par
Collaboration diagram for datapath:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdatapath__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b list_node}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b flow_table} {\b table}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct hlist_head * {\b ports}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dp_stats_percpu} {\b __percpu} * {\b stats_percpu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b user_features}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct datapath - datapath for flow-based packet switching : RCU callback head for deferred destruction. : Element in global 'dps' list. : flow table. : Hash table for ports. OVSP_LOCAL port always exists. Protected by ovs_mutex and RCU. : Per-CPU datapath statistics. : Reference to net namespace.\par
Context: See the comment on locking at the top of datapath.c for additional locking information. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v list_node\:datapath}
{\xe \v datapath\:list_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head datapath::list_node}}
\par
{\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ports\:datapath}
{\xe \v datapath\:ports}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_head* datapath::ports}}
\par
{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:datapath}
{\xe \v datapath\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head datapath::rcu}}
\par
{\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stats_percpu\:datapath}
{\xe \v datapath\:stats_percpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dp_stats_percpu} {\b __percpu}* datapath::stats_percpu}}
\par
{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v table\:datapath}
{\xe \v datapath\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b flow_table} datapath::table}}
\par
{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v user_features\:datapath}
{\xe \v datapath\:user_features}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 datapath::user_features}}
\par
{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b datapath.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
deferred_action Struct Reference\par \pard\plain 
{\tc\tcl2 \v deferred_action}
{\xe \v deferred_action}
{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
Collaboration diagram for deferred_action:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdeferred__action__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sk_buff * {\b skb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct nlattr * {\b actions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key} {\b pkt_key}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v actions\:deferred_action}
{\xe \v deferred_action\:actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nlattr * deferred_action::actions}}
\par
{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pkt_key\:deferred_action}
{\xe \v deferred_action\:pkt_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key} deferred_action::pkt_key}}
\par
{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb\:deferred_action}
{\xe \v deferred_action\:skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sk_buff * deferred_action::skb}}
\par
{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b actions.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dp_stats_percpu Struct Reference\par \pard\plain 
{\tc\tcl2 \v dp_stats_percpu}
{\xe \v dp_stats_percpu}
{\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
\par
{
{\f2 #include <datapath.h>}}\par
Collaboration diagram for dp_stats_percpu:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdp__stats__percpu__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b n_hit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b n_missed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b n_lost}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b n_mask_hit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b u64_stats_sync} {\b syncp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b dp_stats_percpu} - per-cpu packet processing statistics for a given datapath. : Number of received packets for which a matching flow was found in the flow table. : Number of received packets that had no matching flow in the flow table. The sum of  and  is the number of packets that have been received by the datapath. : Number of received packets that had no matching flow in the flow table that could not be sent to userspace (normally due to an overflow in one of the datapath's queues). : Number of masks looked up for flow match.  / ( + ) will be the average masks looked up per packet. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v n_hit\:dp_stats_percpu}
{\xe \v dp_stats_percpu\:n_hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 dp_stats_percpu::n_hit}}
\par
{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_lost\:dp_stats_percpu}
{\xe \v dp_stats_percpu\:n_lost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 dp_stats_percpu::n_lost}}
\par
{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_mask_hit\:dp_stats_percpu}
{\xe \v dp_stats_percpu\:n_mask_hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 dp_stats_percpu::n_mask_hit}}
\par
{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_missed\:dp_stats_percpu}
{\xe \v dp_stats_percpu\:n_missed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 dp_stats_percpu::n_missed}}
\par
{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v syncp\:dp_stats_percpu}
{\xe \v dp_stats_percpu\:syncp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b u64_stats_sync} dp_stats_percpu::syncp}}
\par
{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b datapath.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dp_upcall_info Struct Reference\par \pard\plain 
{\tc\tcl2 \v dp_upcall_info}
{\xe \v dp_upcall_info}
{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
\par
{
{\f2 #include <datapath.h>}}\par
Collaboration diagram for dp_upcall_info:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdp__upcall__info__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct {\b ovs_tunnel_info} * {\b egress_tun_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct nlattr * {\b userdata}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct nlattr * {\b actions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b actions_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b portid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b cmd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct dp_upcall - metadata to include with a packet to send to userspace : One of OVS_PACKET_CMD_*. : If nonnull, its variable-length value is passed to userspace as OVS_PACKET_ATTR_USERDATA. : Netlink portid to which packet should be sent. If  is 0 then no packet is sent and the packet is accounted in the datapath's  counter. : If nonnull, becomes OVS_PACKET_ATTR_EGRESS_TUN_KEY. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v actions\:dp_upcall_info}
{\xe \v dp_upcall_info\:actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nlattr* dp_upcall_info::actions}}
\par
{\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v actions_len\:dp_upcall_info}
{\xe \v dp_upcall_info\:actions_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dp_upcall_info::actions_len}}
\par
{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cmd\:dp_upcall_info}
{\xe \v dp_upcall_info\:cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 dp_upcall_info::cmd}}
\par
{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v egress_tun_info\:dp_upcall_info}
{\xe \v dp_upcall_info\:egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_tunnel_info}* dp_upcall_info::egress_tun_info}}
\par
{\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v portid\:dp_upcall_info}
{\xe \v dp_upcall_info\:portid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 dp_upcall_info::portid}}
\par
{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v userdata\:dp_upcall_info}
{\xe \v dp_upcall_info\:userdata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nlattr* dp_upcall_info::userdata}}
\par
{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b datapath.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
flow_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v flow_stats}
{\xe \v flow_stats}
{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
\par
{
{\f2 #include <flow.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b packet_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b byte_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b used}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
spinlock_t {\b lock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tcp_flags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v byte_count\:flow_stats}
{\xe \v flow_stats\:byte_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 flow_stats::byte_count}}
\par
{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lock\:flow_stats}
{\xe \v flow_stats\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
spinlock_t flow_stats::lock}}
\par
{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v packet_count\:flow_stats}
{\xe \v flow_stats\:packet_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 flow_stats::packet_count}}
\par
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tcp_flags\:flow_stats}
{\xe \v flow_stats\:tcp_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 flow_stats::tcp_flags}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v used\:flow_stats}
{\xe \v flow_stats\:used}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long flow_stats::used}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
flow_table Struct Reference\par \pard\plain 
{\tc\tcl2 \v flow_table}
{\xe \v flow_table}
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
\par
{
{\f2 #include <flow_table.h>}}\par
Collaboration diagram for flow_table:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structflow__table__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b table_instance} {\b __rcu} * {\b ti}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b table_instance} {\b __rcu} * {\b ufid_ti}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b mask_cache_entry} {\b __percpu} * {\b mask_cache}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b mask_array} {\b __rcu} * {\b mask_array}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b last_rehash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b ufid_count}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v count\:flow_table}
{\xe \v flow_table\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int flow_table::count}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v last_rehash\:flow_table}
{\xe \v flow_table\:last_rehash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long flow_table::last_rehash}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mask_array\:flow_table}
{\xe \v flow_table\:mask_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b mask_array} {\b __rcu}* flow_table::mask_array}}
\par
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mask_cache\:flow_table}
{\xe \v flow_table\:mask_cache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b mask_cache_entry} {\b __percpu}* flow_table::mask_cache}}
\par
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ti\:flow_table}
{\xe \v flow_table\:ti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b table_instance} {\b __rcu}* flow_table::ti}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ufid_count\:flow_table}
{\xe \v flow_table\:ufid_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int flow_table::ufid_count}}
\par
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ufid_ti\:flow_table}
{\xe \v flow_table\:ufid_ti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b table_instance} {\b __rcu}* flow_table::ufid_ti}}
\par
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
geneve_port Struct Reference\par \pard\plain 
{\tc\tcl2 \v geneve_port}
{\xe \v geneve_port}
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct geneve_sock * {\b gs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [IFNAMSIZ]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v gs\:geneve_port}
{\xe \v geneve_port\:gs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct geneve_sock * geneve_port::gs}}
\par
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:geneve_port}
{\xe \v geneve_port\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char geneve_port::name}}
\par
{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/{\b vport-geneve.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gre_cisco_protocol Struct Reference\par \pard\plain 
{\tc\tcl2 \v gre_cisco_protocol}
{\xe \v gre_cisco_protocol}
{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
\par
{
{\f2 #include <gre.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b handler} )(struct sk_buff *skb, const struct {\b tnl_ptk_info} *tpi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b err_handler} )(struct sk_buff *skb, u32 info, const struct {\b tnl_ptk_info} *tpi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b priority}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v err_handler\:gre_cisco_protocol}
{\xe \v gre_cisco_protocol\:err_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* gre_cisco_protocol::err_handler) (struct sk_buff *skb, u32 info, const struct {\b tnl_ptk_info} *tpi)}}
\par
{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handler\:gre_cisco_protocol}
{\xe \v gre_cisco_protocol\:handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* gre_cisco_protocol::handler) (struct sk_buff *skb, const struct {\b tnl_ptk_info} *tpi)}}
\par
{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v priority\:gre_cisco_protocol}
{\xe \v gre_cisco_protocol\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 gre_cisco_protocol::priority}}
\par
{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b gre.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
internal_dev Struct Reference\par \pard\plain 
{\tc\tcl2 \v internal_dev}
{\xe \v internal_dev}
{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
Collaboration diagram for internal_dev:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structinternal__dev__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b vport}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v vport\:internal_dev}
{\xe \v internal_dev\:vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport} * internal_dev::vport}}
\par
{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/{\b vport-internal_dev.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lisp_port Struct Reference\par \pard\plain 
{\tc\tcl2 \v lisp_port}
{\xe \v lisp_port}
{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b dst_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b list}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct socket * {\b lisp_rcv_socket}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [IFNAMSIZ]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dst_port\:lisp_port}
{\xe \v lisp_port\:dst_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 lisp_port::dst_port}}
\par
{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lisp_rcv_socket\:lisp_port}
{\xe \v lisp_port\:lisp_rcv_socket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct socket * lisp_port::lisp_rcv_socket}}
\par
{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v list\:lisp_port}
{\xe \v lisp_port\:list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head lisp_port::list}}
\par
{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:lisp_port}
{\xe \v lisp_port\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char lisp_port::name}}
\par
{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/{\b vport-lisp.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lisphdr Struct Reference\par \pard\plain 
{\tc\tcl2 \v lisphdr}
{\xe \v lisphdr}
{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b nonce_present}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b locator_status_bits_present}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b solicit_echo_nonce}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b map_version_present}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b instance_id_present}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b reserved_flags}:3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __u8 {\b nonce} [3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __u8 {\b map_version} [3]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b u1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be32 {\b locator_status_bits}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __u8 {\b instance_id} [3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __u8 {\b locator_status_bits}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b word2}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b u2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __u8 {\b nonce} [3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __u8 {\b map_version} [3]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b u1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be32 {\b locator_status_bits}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __u8 {\b instance_id} [3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __u8 {\b locator_status_bits}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b word2}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b u2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct lisphdr - LISP header : Flag indicating the presence of a 24 bit nonce value. : Flag indicating the presence of Locator Status Bits (LSB). : Flag indicating the use of the echo noncing mechanism. : Flag indicating the use of mapping versioning. : Flag indicating the presence of a 24 bit Instance ID. : 3 bits reserved for future flags. : 24 bit nonce value. : 24 bit mapping version. : Locator Status Bits: 32 bits when instance_id_present is not set, 8 bits when it is. : 24 bit Instance ID \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v instance_id\:lisphdr}
{\xe \v lisphdr\:instance_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::instance_id[3]}}
\par
{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v instance_id_present\:lisphdr}
{\xe \v lisphdr\:instance_id_present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::instance_id_present}}
\par
{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v locator_status_bits\:lisphdr}
{\xe \v lisphdr\:locator_status_bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 lisphdr::locator_status_bits}}
\par
{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v locator_status_bits\:lisphdr}
{\xe \v lisphdr\:locator_status_bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::locator_status_bits}}
\par
{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v locator_status_bits_present\:lisphdr}
{\xe \v lisphdr\:locator_status_bits_present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::locator_status_bits_present}}
\par
{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_version\:lisphdr}
{\xe \v lisphdr\:map_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::map_version[3]}}
\par
{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_version_present\:lisphdr}
{\xe \v lisphdr\:map_version_present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::map_version_present}}
\par
{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nonce\:lisphdr}
{\xe \v lisphdr\:nonce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::nonce[3]}}
\par
{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nonce_present\:lisphdr}
{\xe \v lisphdr\:nonce_present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::nonce_present}}
\par
{\bkmkstart AAAAAAACUV}
{\bkmkend AAAAAAACUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reserved_flags\:lisphdr}
{\xe \v lisphdr\:reserved_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::reserved_flags}}
\par
{\bkmkstart AAAAAAACUW}
{\bkmkend AAAAAAACUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v solicit_echo_nonce\:lisphdr}
{\xe \v lisphdr\:solicit_echo_nonce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 lisphdr::solicit_echo_nonce}}
\par
{\bkmkstart AAAAAAACUX}
{\bkmkend AAAAAAACUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v u1\:lisphdr}
{\xe \v lisphdr\:u1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \}   lisphdr::u1}}
\par
{\bkmkstart AAAAAAACUY}
{\bkmkend AAAAAAACUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v u1\:lisphdr}
{\xe \v lisphdr\:u1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \}   lisphdr::u1}}
\par
{\bkmkstart AAAAAAACUZ}
{\bkmkend AAAAAAACUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v u2\:lisphdr}
{\xe \v lisphdr\:u2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \}   lisphdr::u2}}
\par
{\bkmkstart AAAAAAACVA}
{\bkmkend AAAAAAACVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v u2\:lisphdr}
{\xe \v lisphdr\:u2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \}   lisphdr::u2}}
\par
{\bkmkstart AAAAAAACVB}
{\bkmkend AAAAAAACVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v word2\:lisphdr}
{\xe \v lisphdr\:word2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   lisphdr::word2}}
\par
{\bkmkstart AAAAAAACVC}
{\bkmkend AAAAAAACVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v word2\:lisphdr}
{\xe \v lisphdr\:word2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   lisphdr::word2}}
\par
{\bkmkstart AAAAAAACVD}
{\bkmkend AAAAAAACVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/{\b vport-lisp.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mask_array Struct Reference\par \pard\plain 
{\tc\tcl2 \v mask_array}
{\xe \v mask_array}
{\bkmkstart AAAAAAACVE}
{\bkmkend AAAAAAACVE}
\par
{
{\f2 #include <flow_table.h>}}\par
Collaboration diagram for mask_array:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structmask__array__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b max}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_mask} {\b __rcu} * {\b masks} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v count\:mask_array}
{\xe \v mask_array\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int mask_array::count}}
\par
{\bkmkstart AAAAAAACVF}
{\bkmkend AAAAAAACVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v masks\:mask_array}
{\xe \v mask_array\:masks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_mask} {\b __rcu}* mask_array::masks[]}}
\par
{\bkmkstart AAAAAAACVG}
{\bkmkend AAAAAAACVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v max\:mask_array}
{\xe \v mask_array\:max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int mask_array::max}}
\par
{\bkmkstart AAAAAAACVH}
{\bkmkend AAAAAAACVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:mask_array}
{\xe \v mask_array\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head mask_array::rcu}}
\par
{\bkmkstart AAAAAAACVI}
{\bkmkend AAAAAAACVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mask_cache_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v mask_cache_entry}
{\xe \v mask_cache_entry}
{\bkmkstart AAAAAAACVJ}
{\bkmkend AAAAAAACVJ}
\par
{
{\f2 #include <flow_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b skb_hash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b mask_index}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mask_index\:mask_cache_entry}
{\xe \v mask_cache_entry\:mask_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 mask_cache_entry::mask_index}}
\par
{\bkmkstart AAAAAAACVK}
{\bkmkend AAAAAAACVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_hash\:mask_cache_entry}
{\xe \v mask_cache_entry\:skb_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 mask_cache_entry::skb_hash}}
\par
{\bkmkstart AAAAAAACVL}
{\bkmkend AAAAAAACVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
netdev_vport Struct Reference\par \pard\plain 
{\tc\tcl2 \v netdev_vport}
{\xe \v netdev_vport}
{\bkmkstart AAAAAAACVM}
{\bkmkend AAAAAAACVM}
\par
{
{\f2 #include <vport-netdev.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct net_device * {\b dev}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dev\:netdev_vport}
{\xe \v netdev_vport\:dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct net_device* netdev_vport::dev}}
\par
{\bkmkstart AAAAAAACVN}
{\bkmkend AAAAAAACVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:netdev_vport}
{\xe \v netdev_vport\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head netdev_vport::rcu}}
\par
{\bkmkstart AAAAAAACVO}
{\bkmkend AAAAAAACVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport-netdev.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_action_hash Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_action_hash}
{\xe \v ovs_action_hash}
{\bkmkstart AAAAAAACVP}
{\bkmkend AAAAAAACVP}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b hash_alg}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b hash_basis}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v hash_alg\:ovs_action_hash}
{\xe \v ovs_action_hash\:hash_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_hash::hash_alg}}
\par
{\bkmkstart AAAAAAACVQ}
{\bkmkend AAAAAAACVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hash_basis\:ovs_action_hash}
{\xe \v ovs_action_hash\:hash_basis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_hash::hash_basis}}
\par
{\bkmkstart AAAAAAACVR}
{\bkmkend AAAAAAACVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_action_push_mpls Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_action_push_mpls}
{\xe \v ovs_action_push_mpls}
{\bkmkstart AAAAAAACVS}
{\bkmkend AAAAAAACVS}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b mpls_lse}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b mpls_ethertype}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b ovs_action_push_mpls} - OVS_ACTION_ATTR_PUSH_MPLS action argument. : MPLS label stack entry to push. : Ethertype to set in the encapsulating ethernet frame.\par
The only values  should ever be given are ETH_P_MPLS_UC and ETH_P_MPLS_MC, indicating MPLS unicast or multicast. Other are rejected. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mpls_ethertype\:ovs_action_push_mpls}
{\xe \v ovs_action_push_mpls\:mpls_ethertype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_action_push_mpls::mpls_ethertype}}
\par
{\bkmkstart AAAAAAACVT}
{\bkmkend AAAAAAACVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mpls_lse\:ovs_action_push_mpls}
{\xe \v ovs_action_push_mpls\:mpls_lse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_action_push_mpls::mpls_lse}}
\par
{\bkmkstart AAAAAAACVU}
{\bkmkend AAAAAAACVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_action_push_tnl Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl}
{\bkmkstart AAAAAAACVV}
{\bkmkend AAAAAAACVV}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b tnl_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b out_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b header_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b tnl_type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b header} [{\b TNL_PUSH_HEADER_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v header\:ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl\:header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ovs_action_push_tnl::header[{\b TNL_PUSH_HEADER_SIZE}]}}
\par
{\bkmkstart AAAAAAACVW}
{\bkmkend AAAAAAACVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v header_len\:ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl\:header_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_push_tnl::header_len}}
\par
{\bkmkstart AAAAAAACVX}
{\bkmkend AAAAAAACVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v out_port\:ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl\:out_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_push_tnl::out_port}}
\par
{\bkmkstart AAAAAAACVY}
{\bkmkend AAAAAAACVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tnl_port\:ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl\:tnl_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_push_tnl::tnl_port}}
\par
{\bkmkstart AAAAAAACVZ}
{\bkmkend AAAAAAACVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tnl_type\:ovs_action_push_tnl}
{\xe \v ovs_action_push_tnl\:tnl_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ovs_action_push_tnl::tnl_type}}
\par
{\bkmkstart AAAAAAACWA}
{\bkmkend AAAAAAACWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_action_push_vlan Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_action_push_vlan}
{\xe \v ovs_action_push_vlan}
{\bkmkstart AAAAAAACWB}
{\bkmkend AAAAAAACWB}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b vlan_tpid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b vlan_tci}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b ovs_action_push_vlan} - OVS_ACTION_ATTR_PUSH_VLAN action argument. : Tag protocol identifier (TPID) to push. : Tag control identifier (TCI) to push. The CFI bit must be set (but it will not be set in the 802.1Q header that is pushed).\par
The  value is typically ETH_P_8021Q. The only acceptable TPID values are those that the kernel module also parses as 802.1Q headers, to prevent OVS_ACTION_ATTR_PUSH_VLAN followed by OVS_ACTION_ATTR_POP_VLAN from having surprising results. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v vlan_tci\:ovs_action_push_vlan}
{\xe \v ovs_action_push_vlan\:vlan_tci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_action_push_vlan::vlan_tci}}
\par
{\bkmkstart AAAAAAACWC}
{\bkmkend AAAAAAACWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vlan_tpid\:ovs_action_push_vlan}
{\xe \v ovs_action_push_vlan\:vlan_tpid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_action_push_vlan::vlan_tpid}}
\par
{\bkmkstart AAAAAAACWD}
{\bkmkend AAAAAAACWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_dp_megaflow_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats}
{\bkmkstart AAAAAAACWE}
{\bkmkend AAAAAAACWE}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_mask_hit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u32 {\b n_masks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u32 {\b pad0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b pad1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b pad2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v n_mask_hit\:ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats\:n_mask_hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_megaflow_stats::n_mask_hit}}
\par
{\bkmkstart AAAAAAACWF}
{\bkmkend AAAAAAACWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_masks\:ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats\:n_masks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u32 ovs_dp_megaflow_stats::n_masks}}
\par
{\bkmkstart AAAAAAACWG}
{\bkmkend AAAAAAACWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pad0\:ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats\:pad0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u32 ovs_dp_megaflow_stats::pad0}}
\par
{\bkmkstart AAAAAAACWH}
{\bkmkend AAAAAAACWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pad1\:ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats\:pad1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_megaflow_stats::pad1}}
\par
{\bkmkstart AAAAAAACWI}
{\bkmkend AAAAAAACWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pad2\:ovs_dp_megaflow_stats}
{\xe \v ovs_dp_megaflow_stats\:pad2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_megaflow_stats::pad2}}
\par
{\bkmkstart AAAAAAACWJ}
{\bkmkend AAAAAAACWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_dp_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_dp_stats}
{\xe \v ovs_dp_stats}
{\bkmkstart AAAAAAACWK}
{\bkmkend AAAAAAACWK}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_hit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_missed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_lost}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_flows}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v n_flows\:ovs_dp_stats}
{\xe \v ovs_dp_stats\:n_flows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_stats::n_flows}}
\par
{\bkmkstart AAAAAAACWL}
{\bkmkend AAAAAAACWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_hit\:ovs_dp_stats}
{\xe \v ovs_dp_stats\:n_hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_stats::n_hit}}
\par
{\bkmkstart AAAAAAACWM}
{\bkmkend AAAAAAACWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_lost\:ovs_dp_stats}
{\xe \v ovs_dp_stats\:n_lost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_stats::n_lost}}
\par
{\bkmkstart AAAAAAACWN}
{\bkmkend AAAAAAACWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_missed\:ovs_dp_stats}
{\xe \v ovs_dp_stats\:n_missed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_dp_stats::n_missed}}
\par
{\bkmkstart AAAAAAACWO}
{\bkmkend AAAAAAACWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_flow_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_flow_stats}
{\xe \v ovs_flow_stats}
{\bkmkstart AAAAAAACWP}
{\bkmkend AAAAAAACWP}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b n_bytes}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v n_bytes\:ovs_flow_stats}
{\xe \v ovs_flow_stats\:n_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_flow_stats::n_bytes}}
\par
{\bkmkstart AAAAAAACWQ}
{\bkmkend AAAAAAACWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_packets\:ovs_flow_stats}
{\xe \v ovs_flow_stats\:n_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_flow_stats::n_packets}}
\par
{\bkmkstart AAAAAAACWR}
{\bkmkend AAAAAAACWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_header}
{\xe \v ovs_header}
{\bkmkstart AAAAAAACWS}
{\bkmkend AAAAAAACWS}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dp_ifindex}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b ovs_header} - header for OVS Generic Netlink messages. : ifindex of local port for datapath (0 to make a request not specific to a datapath).\par
Attributes following the header are specific to a particular OVS Generic Netlink family, but all of the OVS families use this header. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dp_ifindex\:ovs_header}
{\xe \v ovs_header\:dp_ifindex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_header::dp_ifindex}}
\par
{\bkmkstart AAAAAAACWT}
{\bkmkend AAAAAAACWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_arp Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_arp}
{\xe \v ovs_key_arp}
{\bkmkstart AAAAAAACWU}
{\bkmkend AAAAAAACWU}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b arp_sip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b arp_tip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b arp_op}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b arp_sha} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b arp_tha} [ETH_ALEN]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v arp_op\:ovs_key_arp}
{\xe \v ovs_key_arp\:arp_op}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_arp::arp_op}}
\par
{\bkmkstart AAAAAAACWV}
{\bkmkend AAAAAAACWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp_sha\:ovs_key_arp}
{\xe \v ovs_key_arp\:arp_sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_arp::arp_sha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACWW}
{\bkmkend AAAAAAACWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp_sip\:ovs_key_arp}
{\xe \v ovs_key_arp\:arp_sip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_arp::arp_sip}}
\par
{\bkmkstart AAAAAAACWX}
{\bkmkend AAAAAAACWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp_tha\:ovs_key_arp}
{\xe \v ovs_key_arp\:arp_tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_arp::arp_tha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACWY}
{\bkmkend AAAAAAACWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp_tip\:ovs_key_arp}
{\xe \v ovs_key_arp\:arp_tip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_arp::arp_tip}}
\par
{\bkmkstart AAAAAAACWZ}
{\bkmkend AAAAAAACWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_ethernet Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_ethernet}
{\xe \v ovs_key_ethernet}
{\bkmkstart AAAAAAACXA}
{\bkmkend AAAAAAACXA}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b eth_src} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b eth_dst} [ETH_ALEN]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v eth_dst\:ovs_key_ethernet}
{\xe \v ovs_key_ethernet\:eth_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ethernet::eth_dst[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACXB}
{\bkmkend AAAAAAACXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v eth_src\:ovs_key_ethernet}
{\xe \v ovs_key_ethernet\:eth_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ethernet::eth_src[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACXC}
{\bkmkend AAAAAAACXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_icmp Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_icmp}
{\xe \v ovs_key_icmp}
{\bkmkstart AAAAAAACXD}
{\bkmkend AAAAAAACXD}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b icmp_type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b icmp_code}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v icmp_code\:ovs_key_icmp}
{\xe \v ovs_key_icmp\:icmp_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_icmp::icmp_code}}
\par
{\bkmkstart AAAAAAACXE}
{\bkmkend AAAAAAACXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v icmp_type\:ovs_key_icmp}
{\xe \v ovs_key_icmp\:icmp_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_icmp::icmp_type}}
\par
{\bkmkstart AAAAAAACXF}
{\bkmkend AAAAAAACXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_icmpv6 Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_icmpv6}
{\xe \v ovs_key_icmpv6}
{\bkmkstart AAAAAAACXG}
{\bkmkend AAAAAAACXG}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b icmpv6_type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b icmpv6_code}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v icmpv6_code\:ovs_key_icmpv6}
{\xe \v ovs_key_icmpv6\:icmpv6_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_icmpv6::icmpv6_code}}
\par
{\bkmkstart AAAAAAACXH}
{\bkmkend AAAAAAACXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v icmpv6_type\:ovs_key_icmpv6}
{\xe \v ovs_key_icmpv6\:icmpv6_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_icmpv6::icmpv6_type}}
\par
{\bkmkstart AAAAAAACXI}
{\bkmkend AAAAAAACXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_ipv4 Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_ipv4}
{\xe \v ovs_key_ipv4}
{\bkmkstart AAAAAAACXJ}
{\bkmkend AAAAAAACXJ}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv4_proto}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv4_tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv4_ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv4_frag}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ipv4_dst\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv4::ipv4_dst}}
\par
{\bkmkstart AAAAAAACXK}
{\bkmkend AAAAAAACXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_frag\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_frag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv4::ipv4_frag}}
\par
{\bkmkstart AAAAAAACXL}
{\bkmkend AAAAAAACXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_proto\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv4::ipv4_proto}}
\par
{\bkmkstart AAAAAAACXM}
{\bkmkend AAAAAAACXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_src\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv4::ipv4_src}}
\par
{\bkmkstart AAAAAAACXN}
{\bkmkend AAAAAAACXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_tos\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv4::ipv4_tos}}
\par
{\bkmkstart AAAAAAACXO}
{\bkmkend AAAAAAACXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_ttl\:ovs_key_ipv4}
{\xe \v ovs_key_ipv4\:ipv4_ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv4::ipv4_ttl}}
\par
{\bkmkstart AAAAAAACXP}
{\bkmkend AAAAAAACXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_ipv4_tunnel Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel}
{\bkmkstart AAAAAAACXQ}
{\bkmkend AAAAAAACXQ}
\par
{
{\f2 #include <flow.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be64 {\b tun_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tun_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b ipv4_tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b ipv4_ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tp_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tp_dst}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ipv4_dst\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:ipv4_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv4_tunnel::ipv4_dst}}
\par
{\bkmkstart AAAAAAACXR}
{\bkmkend AAAAAAACXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_src\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:ipv4_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv4_tunnel::ipv4_src}}
\par
{\bkmkstart AAAAAAACXS}
{\bkmkend AAAAAAACXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_tos\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:ipv4_tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ovs_key_ipv4_tunnel::ipv4_tos}}
\par
{\bkmkstart AAAAAAACXT}
{\bkmkend AAAAAAACXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_ttl\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:ipv4_ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ovs_key_ipv4_tunnel::ipv4_ttl}}
\par
{\bkmkstart AAAAAAACXU}
{\bkmkend AAAAAAACXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp_dst\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:tp_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_ipv4_tunnel::tp_dst}}
\par
{\bkmkstart AAAAAAACXV}
{\bkmkend AAAAAAACXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp_src\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:tp_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_ipv4_tunnel::tp_src}}
\par
{\bkmkstart AAAAAAACXW}
{\bkmkend AAAAAAACXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_flags\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:tun_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_ipv4_tunnel::tun_flags}}
\par
{\bkmkstart AAAAAAACXX}
{\bkmkend AAAAAAACXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_id\:ovs_key_ipv4_tunnel}
{\xe \v ovs_key_ipv4_tunnel\:tun_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be64 ovs_key_ipv4_tunnel::tun_id}}
\par
{\bkmkstart AAAAAAACXY}
{\bkmkend AAAAAAACXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_ipv6 Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_ipv6}
{\xe \v ovs_key_ipv6}
{\bkmkstart AAAAAAACXZ}
{\bkmkend AAAAAAACXZ}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv6_src} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv6_dst} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv6_label}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv6_proto}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv6_tclass}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv6_hlimit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b ipv6_frag}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ipv6_dst\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv6::ipv6_dst[4]}}
\par
{\bkmkstart AAAAAAACYA}
{\bkmkend AAAAAAACYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_frag\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_frag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv6::ipv6_frag}}
\par
{\bkmkstart AAAAAAACYB}
{\bkmkend AAAAAAACYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_hlimit\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_hlimit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv6::ipv6_hlimit}}
\par
{\bkmkstart AAAAAAACYC}
{\bkmkend AAAAAAACYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_label\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv6::ipv6_label}}
\par
{\bkmkstart AAAAAAACYD}
{\bkmkend AAAAAAACYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_proto\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv6::ipv6_proto}}
\par
{\bkmkstart AAAAAAACYE}
{\bkmkend AAAAAAACYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_src\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_ipv6::ipv6_src[4]}}
\par
{\bkmkstart AAAAAAACYF}
{\bkmkend AAAAAAACYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6_tclass\:ovs_key_ipv6}
{\xe \v ovs_key_ipv6\:ipv6_tclass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_ipv6::ipv6_tclass}}
\par
{\bkmkstart AAAAAAACYG}
{\bkmkend AAAAAAACYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_mpls Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_mpls}
{\xe \v ovs_key_mpls}
{\bkmkstart AAAAAAACYH}
{\bkmkend AAAAAAACYH}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b mpls_lse}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mpls_lse\:ovs_key_mpls}
{\xe \v ovs_key_mpls\:mpls_lse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_mpls::mpls_lse}}
\par
{\bkmkstart AAAAAAACYI}
{\bkmkend AAAAAAACYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_nd Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_nd}
{\xe \v ovs_key_nd}
{\bkmkstart AAAAAAACYJ}
{\bkmkend AAAAAAACYJ}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b nd_target} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b nd_sll} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b nd_tll} [ETH_ALEN]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v nd_sll\:ovs_key_nd}
{\xe \v ovs_key_nd\:nd_sll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_nd::nd_sll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACYK}
{\bkmkend AAAAAAACYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nd_target\:ovs_key_nd}
{\xe \v ovs_key_nd\:nd_target}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ovs_key_nd::nd_target[4]}}
\par
{\bkmkstart AAAAAAACYL}
{\bkmkend AAAAAAACYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nd_tll\:ovs_key_nd}
{\xe \v ovs_key_nd\:nd_tll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 ovs_key_nd::nd_tll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAACYM}
{\bkmkend AAAAAAACYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_sctp Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_sctp}
{\xe \v ovs_key_sctp}
{\bkmkstart AAAAAAACYN}
{\bkmkend AAAAAAACYN}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b sctp_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b sctp_dst}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v sctp_dst\:ovs_key_sctp}
{\xe \v ovs_key_sctp\:sctp_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_sctp::sctp_dst}}
\par
{\bkmkstart AAAAAAACYO}
{\bkmkend AAAAAAACYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sctp_src\:ovs_key_sctp}
{\xe \v ovs_key_sctp\:sctp_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_sctp::sctp_src}}
\par
{\bkmkstart AAAAAAACYP}
{\bkmkend AAAAAAACYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_tcp Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_tcp}
{\xe \v ovs_key_tcp}
{\bkmkstart AAAAAAACYQ}
{\bkmkend AAAAAAACYQ}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tcp_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tcp_dst}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v tcp_dst\:ovs_key_tcp}
{\xe \v ovs_key_tcp\:tcp_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_tcp::tcp_dst}}
\par
{\bkmkstart AAAAAAACYR}
{\bkmkend AAAAAAACYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tcp_src\:ovs_key_tcp}
{\xe \v ovs_key_tcp\:tcp_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_tcp::tcp_src}}
\par
{\bkmkstart AAAAAAACYS}
{\bkmkend AAAAAAACYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_key_udp Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_key_udp}
{\xe \v ovs_key_udp}
{\bkmkstart AAAAAAACYT}
{\bkmkend AAAAAAACYT}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b udp_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b udp_dst}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v udp_dst\:ovs_key_udp}
{\xe \v ovs_key_udp\:udp_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_udp::udp_dst}}
\par
{\bkmkstart AAAAAAACYU}
{\bkmkend AAAAAAACYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v udp_src\:ovs_key_udp}
{\xe \v ovs_key_udp\:udp_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 ovs_key_udp::udp_src}}
\par
{\bkmkstart AAAAAAACYV}
{\bkmkend AAAAAAACYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_len_tbl Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_len_tbl}
{\xe \v ovs_len_tbl}
{\bkmkstart AAAAAAACYW}
{\bkmkend AAAAAAACYW}
Collaboration diagram for ovs_len_tbl:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structovs__len__tbl__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct {\b ovs_len_tbl} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v len\:ovs_len_tbl}
{\xe \v ovs_len_tbl\:len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_len_tbl::len}}
\par
{\bkmkstart AAAAAAACYX}
{\bkmkend AAAAAAACYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v next\:ovs_len_tbl}
{\xe \v ovs_len_tbl\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_len_tbl} * ovs_len_tbl::next}}
\par
{\bkmkstart AAAAAAACYY}
{\bkmkend AAAAAAACYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow_netlink.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_net Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_net}
{\xe \v ovs_net}
{\bkmkstart AAAAAAACYZ}
{\bkmkend AAAAAAACYZ}
\par
{
{\f2 #include <datapath.h>}}\par
Collaboration diagram for ovs_net:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structovs__net__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b dps}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct work_struct {\b dp_notify_work}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_net} {\b vport_net}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b ovs_net} - Per net-namespace data for ovs. : List of datapaths to enable dumping them all out. Protected by genl_mutex. : Per network namespace data for vport. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dp_notify_work\:ovs_net}
{\xe \v ovs_net\:dp_notify_work}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct work_struct ovs_net::dp_notify_work}}
\par
{\bkmkstart AAAAAAACZA}
{\bkmkend AAAAAAACZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dps\:ovs_net}
{\xe \v ovs_net\:dps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head ovs_net::dps}}
\par
{\bkmkstart AAAAAAACZB}
{\bkmkend AAAAAAACZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vport_net\:ovs_net}
{\xe \v ovs_net\:vport_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport_net} ovs_net::vport_net}}
\par
{\bkmkstart AAAAAAACZC}
{\bkmkend AAAAAAACZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b datapath.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_skb_cb Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_skb_cb}
{\xe \v ovs_skb_cb}
{\bkmkstart AAAAAAACZD}
{\bkmkend AAAAAAACZD}
\par
{
{\f2 #include <datapath.h>}}\par
Collaboration diagram for ovs_skb_cb:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structovs__skb__cb__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_tunnel_info} * {\b egress_tun_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b input_vport}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b ovs_skb_cb} - OVS data in skb CB : Tunnel information about this packet on egress path. NULL if the packet is not being tunneled. : The original vport packet came in on. This value is cached when a packet is received by OVS. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v egress_tun_info\:ovs_skb_cb}
{\xe \v ovs_skb_cb\:egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ovs_tunnel_info}* ovs_skb_cb::egress_tun_info}}
\par
{\bkmkstart AAAAAAACZE}
{\bkmkend AAAAAAACZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v input_vport\:ovs_skb_cb}
{\xe \v ovs_skb_cb\:input_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_skb_cb::input_vport}}
\par
{\bkmkstart AAAAAAACZF}
{\bkmkend AAAAAAACZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b datapath.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_tunnel_info Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_tunnel_info}
{\xe \v ovs_tunnel_info}
{\bkmkstart AAAAAAACZG}
{\bkmkend AAAAAAACZG}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for ovs_tunnel_info:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structovs__tunnel__info__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4_tunnel} {\b tunnel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const void * {\b options}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b options_len}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v options\:ovs_tunnel_info}
{\xe \v ovs_tunnel_info\:options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const void* ovs_tunnel_info::options}}
\par
{\bkmkstart AAAAAAACZH}
{\bkmkend AAAAAAACZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v options_len\:ovs_tunnel_info}
{\xe \v ovs_tunnel_info\:options_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ovs_tunnel_info::options_len}}
\par
{\bkmkstart AAAAAAACZI}
{\bkmkend AAAAAAACZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tunnel\:ovs_tunnel_info}
{\xe \v ovs_tunnel_info\:tunnel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ovs_key_ipv4_tunnel} ovs_tunnel_info::tunnel}}
\par
{\bkmkstart AAAAAAACZJ}
{\bkmkend AAAAAAACZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_vport_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_vport_stats}
{\xe \v ovs_vport_stats}
{\bkmkstart AAAAAAACZK}
{\bkmkend AAAAAAACZK}
\par
{
{\f2 #include <openvswitch.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b rx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b tx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b rx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b tx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b rx_errors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b tx_errors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b rx_dropped}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u64 {\b tx_dropped}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v rx_bytes\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:rx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::rx_bytes}}
\par
{\bkmkstart AAAAAAACZL}
{\bkmkend AAAAAAACZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_dropped\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:rx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::rx_dropped}}
\par
{\bkmkstart AAAAAAACZM}
{\bkmkend AAAAAAACZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_errors\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:rx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::rx_errors}}
\par
{\bkmkstart AAAAAAACZN}
{\bkmkend AAAAAAACZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_packets\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:rx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::rx_packets}}
\par
{\bkmkstart AAAAAAACZO}
{\bkmkend AAAAAAACZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_bytes\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:tx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::tx_bytes}}
\par
{\bkmkstart AAAAAAACZP}
{\bkmkend AAAAAAACZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_dropped\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:tx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::tx_dropped}}
\par
{\bkmkstart AAAAAAACZQ}
{\bkmkend AAAAAAACZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_errors\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:tx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::tx_errors}}
\par
{\bkmkstart AAAAAAACZR}
{\bkmkend AAAAAAACZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_packets\:ovs_vport_stats}
{\xe \v ovs_vport_stats\:tx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u64 ovs_vport_stats::tx_packets}}
\par
{\bkmkstart AAAAAAACZS}
{\bkmkend AAAAAAACZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b openvswitch.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ovs_vxlan_opts Struct Reference\par \pard\plain 
{\tc\tcl2 \v ovs_vxlan_opts}
{\xe \v ovs_vxlan_opts}
{\bkmkstart AAAAAAACZT}
{\bkmkend AAAAAAACZT}
\par
{
{\f2 #include <vport-vxlan.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u32 {\b gbp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v gbp\:ovs_vxlan_opts}
{\xe \v ovs_vxlan_opts\:gbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u32 ovs_vxlan_opts::gbp}}
\par
{\bkmkstart AAAAAAACZU}
{\bkmkend AAAAAAACZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport-vxlan.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pcpu_sw_netstats Struct Reference\par \pard\plain 
{\tc\tcl2 \v pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats}
{\bkmkstart AAAAAAACZV}
{\bkmkend AAAAAAACZV}
\par
{
{\f2 #include <netdevice.h>}}\par
Collaboration diagram for pcpu_sw_netstats:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structpcpu__sw__netstats__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b rx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b rx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b tx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b tx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b u64_stats_sync} {\b syncp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v rx_bytes\:pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats\:rx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 pcpu_sw_netstats::rx_bytes}}
\par
{\bkmkstart AAAAAAACZW}
{\bkmkend AAAAAAACZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_packets\:pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats\:rx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 pcpu_sw_netstats::rx_packets}}
\par
{\bkmkstart AAAAAAACZX}
{\bkmkend AAAAAAACZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v syncp\:pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats\:syncp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b u64_stats_sync} pcpu_sw_netstats::syncp}}
\par
{\bkmkstart AAAAAAACZY}
{\bkmkend AAAAAAACZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_bytes\:pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats\:tx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 pcpu_sw_netstats::tx_bytes}}
\par
{\bkmkstart AAAAAAACZZ}
{\bkmkend AAAAAAACZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_packets\:pcpu_sw_netstats}
{\xe \v pcpu_sw_netstats\:tx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 pcpu_sw_netstats::tx_packets}}
\par
{\bkmkstart AAAAAAADAA}
{\bkmkend AAAAAAADAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b netdevice.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
reciprocal_value Struct Reference\par \pard\plain 
{\tc\tcl2 \v reciprocal_value}
{\xe \v reciprocal_value}
{\bkmkstart AAAAAAADAB}
{\bkmkend AAAAAAADAB}
\par
{
{\f2 #include <reciprocal_div.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b m}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b sh1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b sh2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v m\:reciprocal_value}
{\xe \v reciprocal_value\:m}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 reciprocal_value::m}}
\par
{\bkmkstart AAAAAAADAC}
{\bkmkend AAAAAAADAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sh1\:reciprocal_value}
{\xe \v reciprocal_value\:sh1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 reciprocal_value::sh1}}
\par
{\bkmkstart AAAAAAADAD}
{\bkmkend AAAAAAADAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sh2\:reciprocal_value}
{\xe \v reciprocal_value\:sh2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 reciprocal_value::sh2}}
\par
{\bkmkstart AAAAAAADAE}
{\bkmkend AAAAAAADAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b reciprocal_div.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rpl_genl_family Struct Reference\par \pard\plain 
{\tc\tcl2 \v rpl_genl_family}
{\xe \v rpl_genl_family}
{\bkmkstart AAAAAAADAF}
{\bkmkend AAAAAAADAF}
\par
{
{\f2 #include <genetlink.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b genl_family} {\b compat_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b hdrsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [GENL_NAMSIZ]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b maxattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b netnsok}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b parallel_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b pre_doit} )(const struct genl_ops *{\b ops}, struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b post_doit} )(const struct genl_ops *{\b ops}, struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct nlattr ** {\b attrbuf}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct genl_ops * {\b ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct genl_multicast_group * {\b mcgrps}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b n_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b n_mcgrps}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mcgrp_offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b family_list}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct module * {\b module}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v attrbuf\:rpl_genl_family}
{\xe \v rpl_genl_family\:attrbuf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct nlattr** rpl_genl_family::attrbuf}}
\par
{\bkmkstart AAAAAAADAG}
{\bkmkend AAAAAAADAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v compat_family\:rpl_genl_family}
{\xe \v rpl_genl_family\:compat_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family} rpl_genl_family::compat_family}}
\par
{\bkmkstart AAAAAAADAH}
{\bkmkend AAAAAAADAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v family_list\:rpl_genl_family}
{\xe \v rpl_genl_family\:family_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head rpl_genl_family::family_list}}
\par
{\bkmkstart AAAAAAADAI}
{\bkmkend AAAAAAADAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hdrsize\:rpl_genl_family}
{\xe \v rpl_genl_family\:hdrsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::hdrsize}}
\par
{\bkmkstart AAAAAAADAJ}
{\bkmkend AAAAAAADAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v id\:rpl_genl_family}
{\xe \v rpl_genl_family\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::id}}
\par
{\bkmkstart AAAAAAADAK}
{\bkmkend AAAAAAADAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v maxattr\:rpl_genl_family}
{\xe \v rpl_genl_family\:maxattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::maxattr}}
\par
{\bkmkstart AAAAAAADAL}
{\bkmkend AAAAAAADAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mcgrp_offset\:rpl_genl_family}
{\xe \v rpl_genl_family\:mcgrp_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::mcgrp_offset}}
\par
{\bkmkstart AAAAAAADAM}
{\bkmkend AAAAAAADAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mcgrps\:rpl_genl_family}
{\xe \v rpl_genl_family\:mcgrps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct genl_multicast_group* rpl_genl_family::mcgrps}}
\par
{\bkmkstart AAAAAAADAN}
{\bkmkend AAAAAAADAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module\:rpl_genl_family}
{\xe \v rpl_genl_family\:module}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct module* rpl_genl_family::module}}
\par
{\bkmkstart AAAAAAADAO}
{\bkmkend AAAAAAADAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_mcgrps\:rpl_genl_family}
{\xe \v rpl_genl_family\:n_mcgrps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::n_mcgrps}}
\par
{\bkmkstart AAAAAAADAP}
{\bkmkend AAAAAAADAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_ops\:rpl_genl_family}
{\xe \v rpl_genl_family\:n_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::n_ops}}
\par
{\bkmkstart AAAAAAADAQ}
{\bkmkend AAAAAAADAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:rpl_genl_family}
{\xe \v rpl_genl_family\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char rpl_genl_family::name[GENL_NAMSIZ]}}
\par
{\bkmkstart AAAAAAADAR}
{\bkmkend AAAAAAADAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v netnsok\:rpl_genl_family}
{\xe \v rpl_genl_family\:netnsok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} rpl_genl_family::netnsok}}
\par
{\bkmkstart AAAAAAADAS}
{\bkmkend AAAAAAADAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ops\:rpl_genl_family}
{\xe \v rpl_genl_family\:ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct genl_ops* rpl_genl_family::ops}}
\par
{\bkmkstart AAAAAAADAT}
{\bkmkend AAAAAAADAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parallel_ops\:rpl_genl_family}
{\xe \v rpl_genl_family\:parallel_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} rpl_genl_family::parallel_ops}}
\par
{\bkmkstart AAAAAAADAU}
{\bkmkend AAAAAAADAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v post_doit\:rpl_genl_family}
{\xe \v rpl_genl_family\:post_doit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* rpl_genl_family::post_doit) (const struct genl_ops *{\b ops}, struct sk_buff *skb, struct genl_info *info)}}
\par
{\bkmkstart AAAAAAADAV}
{\bkmkend AAAAAAADAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pre_doit\:rpl_genl_family}
{\xe \v rpl_genl_family\:pre_doit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* rpl_genl_family::pre_doit) (const struct genl_ops *{\b ops}, struct sk_buff *skb, struct genl_info *info)}}
\par
{\bkmkstart AAAAAAADAW}
{\bkmkend AAAAAAADAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v version\:rpl_genl_family}
{\xe \v rpl_genl_family\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int rpl_genl_family::version}}
\par
{\bkmkstart AAAAAAADAX}
{\bkmkend AAAAAAADAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b genetlink.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow}
{\xe \v sw_flow}
{\bkmkstart AAAAAAADAY}
{\bkmkend AAAAAAADAY}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for sw_flow:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structsw__flow__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct hlist_node {\b node} [2]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b hash}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b flow_table}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct hlist_node {\b node} [2]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b hash}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b ufid_table}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b stats_last_writer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key} {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_id} {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_mask} * {\b mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_actions} {\b __rcu} * {\b sf_acts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b flow_stats} {\b __rcu} * {\b stats} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v flow_table\:sw_flow}
{\xe \v sw_flow\:flow_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow::flow_table}}
\par
{\bkmkstart AAAAAAADAZ}
{\bkmkend AAAAAAADAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hash\:sw_flow}
{\xe \v sw_flow\:hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow::hash}}
\par
{\bkmkstart AAAAAAADBA}
{\bkmkend AAAAAAADBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v id\:sw_flow}
{\xe \v sw_flow\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_id} sw_flow::id}}
\par
{\bkmkstart AAAAAAADBB}
{\bkmkend AAAAAAADBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key\:sw_flow}
{\xe \v sw_flow\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key} sw_flow::key}}
\par
{\bkmkstart AAAAAAADBC}
{\bkmkend AAAAAAADBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mask\:sw_flow}
{\xe \v sw_flow\:mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_mask}* sw_flow::mask}}
\par
{\bkmkstart AAAAAAADBD}
{\bkmkend AAAAAAADBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v node\:sw_flow}
{\xe \v sw_flow\:node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_node sw_flow::node[2]}}
\par
{\bkmkstart AAAAAAADBE}
{\bkmkend AAAAAAADBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:sw_flow}
{\xe \v sw_flow\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head sw_flow::rcu}}
\par
{\bkmkstart AAAAAAADBF}
{\bkmkend AAAAAAADBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sf_acts\:sw_flow}
{\xe \v sw_flow\:sf_acts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_actions} {\b __rcu}* sw_flow::sf_acts}}
\par
{\bkmkstart AAAAAAADBG}
{\bkmkend AAAAAAADBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stats\:sw_flow}
{\xe \v sw_flow\:stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b flow_stats} {\b __rcu}* sw_flow::stats[]}}
\par
{\bkmkstart AAAAAAADBH}
{\bkmkend AAAAAAADBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stats_last_writer\:sw_flow}
{\xe \v sw_flow\:stats_last_writer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sw_flow::stats_last_writer}}
\par
{\bkmkstart AAAAAAADBI}
{\bkmkend AAAAAAADBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ufid_table\:sw_flow}
{\xe \v sw_flow\:ufid_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow::ufid_table}}
\par
{\bkmkstart AAAAAAADBJ}
{\bkmkend AAAAAAADBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_actions Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_actions}
{\xe \v sw_flow_actions}
{\bkmkstart AAAAAAADBK}
{\bkmkend AAAAAAADBK}
\par
{
{\f2 #include <flow.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b actions_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct nlattr {\b actions} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v actions\:sw_flow_actions}
{\xe \v sw_flow_actions\:actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct nlattr sw_flow_actions::actions[]}}
\par
{\bkmkstart AAAAAAADBL}
{\bkmkend AAAAAAADBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v actions_len\:sw_flow_actions}
{\xe \v sw_flow_actions\:actions_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_actions::actions_len}}
\par
{\bkmkstart AAAAAAADBM}
{\bkmkend AAAAAAADBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:sw_flow_actions}
{\xe \v sw_flow_actions\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head sw_flow_actions::rcu}}
\par
{\bkmkstart AAAAAAADBN}
{\bkmkend AAAAAAADBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_id Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_id}
{\xe \v sw_flow_id}
{\bkmkstart AAAAAAADBO}
{\bkmkend AAAAAAADBO}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for sw_flow_id:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structsw__flow__id__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ufid_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b ufid} [{\b MAX_UFID_LENGTH}/4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct {\b sw_flow_key} * {\b unmasked_key}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \} }}
\par
{\bkmkstart AAAAAAADBP}
{\bkmkend AAAAAAADBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ufid\:sw_flow_id}
{\xe \v sw_flow_id\:ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_id::ufid[{\b MAX_UFID_LENGTH}/4]}}
\par
{\bkmkstart AAAAAAADBQ}
{\bkmkend AAAAAAADBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ufid_len\:sw_flow_id}
{\xe \v sw_flow_id\:ufid_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_id::ufid_len}}
\par
{\bkmkstart AAAAAAADBR}
{\bkmkend AAAAAAADBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unmasked_key\:sw_flow_id}
{\xe \v sw_flow_id\:unmasked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key}* sw_flow_id::unmasked_key}}
\par
{\bkmkstart AAAAAAADBS}
{\bkmkend AAAAAAADBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_key Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_key}
{\xe \v sw_flow_key}
{\bkmkstart AAAAAAADBT}
{\bkmkend AAAAAAADBT}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for sw_flow_key:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structsw__flow__key__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b tun_opts} [255]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b tun_opts_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4_tunnel} {\b tun_key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b priority}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b skb_mark}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u16 {\b in_port}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b phy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_flow_hash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b recirc_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u8 {\b src} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u8 {\b dst} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b tci}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b type}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b eth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __be32 {\b top_lse}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b mpls}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b proto}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b frag}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ip}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b flags}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b tp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ __be32 {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ __be32 {\b dst}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b sha} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b tha} [ETH_ALEN]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b arp}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b dst}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __be32 {\b label}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b target}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b sll} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b tll} [ETH_ALEN]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b nd}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ipv6}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \} }}
\par
{\bkmkstart AAAAAAADBU}
{\bkmkend AAAAAAADBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \} }}
\par
{\bkmkstart AAAAAAADBV}
{\bkmkend AAAAAAADBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addr\:sw_flow_key}
{\xe \v sw_flow_key\:addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::addr}}
\par
{\bkmkstart AAAAAAADBW}
{\bkmkend AAAAAAADBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addr\:sw_flow_key}
{\xe \v sw_flow_key\:addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::addr}}
\par
{\bkmkstart AAAAAAADBX}
{\bkmkend AAAAAAADBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp\:sw_flow_key}
{\xe \v sw_flow_key\:arp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::arp}}
\par
{\bkmkstart AAAAAAADBY}
{\bkmkend AAAAAAADBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dst\:sw_flow_key}
{\xe \v sw_flow_key\:dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::dst[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADBZ}
{\bkmkend AAAAAAADBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dst\:sw_flow_key}
{\xe \v sw_flow_key\:dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 sw_flow_key::dst}}
\par
{\bkmkstart AAAAAAADCA}
{\bkmkend AAAAAAADCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dst\:sw_flow_key}
{\xe \v sw_flow_key\:dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 sw_flow_key::dst}}
\par
{\bkmkstart AAAAAAADCB}
{\bkmkend AAAAAAADCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dst\:sw_flow_key}
{\xe \v sw_flow_key\:dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr sw_flow_key::dst}}
\par
{\bkmkstart AAAAAAADCC}
{\bkmkend AAAAAAADCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v eth\:sw_flow_key}
{\xe \v sw_flow_key\:eth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::eth}}
\par
{\bkmkstart AAAAAAADCD}
{\bkmkend AAAAAAADCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flags\:sw_flow_key}
{\xe \v sw_flow_key\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 sw_flow_key::flags}}
\par
{\bkmkstart AAAAAAADCE}
{\bkmkend AAAAAAADCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v frag\:sw_flow_key}
{\xe \v sw_flow_key\:frag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::frag}}
\par
{\bkmkstart AAAAAAADCF}
{\bkmkend AAAAAAADCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v in_port\:sw_flow_key}
{\xe \v sw_flow_key\:in_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u16 sw_flow_key::in_port}}
\par
{\bkmkstart AAAAAAADCG}
{\bkmkend AAAAAAADCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ip\:sw_flow_key}
{\xe \v sw_flow_key\:ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::ip}}
\par
{\bkmkstart AAAAAAADCH}
{\bkmkend AAAAAAADCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4\:sw_flow_key}
{\xe \v sw_flow_key\:ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::ipv4}}
\par
{\bkmkstart AAAAAAADCI}
{\bkmkend AAAAAAADCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6\:sw_flow_key}
{\xe \v sw_flow_key\:ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::ipv6}}
\par
{\bkmkstart AAAAAAADCJ}
{\bkmkend AAAAAAADCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v label\:sw_flow_key}
{\xe \v sw_flow_key\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 sw_flow_key::label}}
\par
{\bkmkstart AAAAAAADCK}
{\bkmkend AAAAAAADCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mpls\:sw_flow_key}
{\xe \v sw_flow_key\:mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::mpls}}
\par
{\bkmkstart AAAAAAADCL}
{\bkmkend AAAAAAADCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nd\:sw_flow_key}
{\xe \v sw_flow_key\:nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::nd}}
\par
{\bkmkstart AAAAAAADCM}
{\bkmkend AAAAAAADCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_flow_hash\:sw_flow_key}
{\xe \v sw_flow_key\:ovs_flow_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_key::ovs_flow_hash}}
\par
{\bkmkstart AAAAAAADCN}
{\bkmkend AAAAAAADCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phy\:sw_flow_key}
{\xe \v sw_flow_key\:phy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}  sw_flow_key::phy}}
\par
{\bkmkstart AAAAAAADCO}
{\bkmkend AAAAAAADCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v priority\:sw_flow_key}
{\xe \v sw_flow_key\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_key::priority}}
\par
{\bkmkstart AAAAAAADCP}
{\bkmkend AAAAAAADCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v proto\:sw_flow_key}
{\xe \v sw_flow_key\:proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::proto}}
\par
{\bkmkstart AAAAAAADCQ}
{\bkmkend AAAAAAADCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v recirc_id\:sw_flow_key}
{\xe \v sw_flow_key\:recirc_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_key::recirc_id}}
\par
{\bkmkstart AAAAAAADCR}
{\bkmkend AAAAAAADCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sha\:sw_flow_key}
{\xe \v sw_flow_key\:sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::sha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADCS}
{\bkmkend AAAAAAADCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_mark\:sw_flow_key}
{\xe \v sw_flow_key\:skb_mark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 sw_flow_key::skb_mark}}
\par
{\bkmkstart AAAAAAADCT}
{\bkmkend AAAAAAADCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sll\:sw_flow_key}
{\xe \v sw_flow_key\:sll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::sll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADCU}
{\bkmkend AAAAAAADCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v src\:sw_flow_key}
{\xe \v sw_flow_key\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::src[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADCV}
{\bkmkend AAAAAAADCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v src\:sw_flow_key}
{\xe \v sw_flow_key\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 sw_flow_key::src}}
\par
{\bkmkstart AAAAAAADCW}
{\bkmkend AAAAAAADCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v src\:sw_flow_key}
{\xe \v sw_flow_key\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 sw_flow_key::src}}
\par
{\bkmkstart AAAAAAADCX}
{\bkmkend AAAAAAADCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v src\:sw_flow_key}
{\xe \v sw_flow_key\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr sw_flow_key::src}}
\par
{\bkmkstart AAAAAAADCY}
{\bkmkend AAAAAAADCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v target\:sw_flow_key}
{\xe \v sw_flow_key\:target}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr sw_flow_key::target}}
\par
{\bkmkstart AAAAAAADCZ}
{\bkmkend AAAAAAADCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tci\:sw_flow_key}
{\xe \v sw_flow_key\:tci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 sw_flow_key::tci}}
\par
{\bkmkstart AAAAAAADDA}
{\bkmkend AAAAAAADDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tha\:sw_flow_key}
{\xe \v sw_flow_key\:tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::tha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADDB}
{\bkmkend AAAAAAADDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tll\:sw_flow_key}
{\xe \v sw_flow_key\:tll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::tll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAADDC}
{\bkmkend AAAAAAADDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top_lse\:sw_flow_key}
{\xe \v sw_flow_key\:top_lse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 sw_flow_key::top_lse}}
\par
{\bkmkstart AAAAAAADDD}
{\bkmkend AAAAAAADDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tos\:sw_flow_key}
{\xe \v sw_flow_key\:tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::tos}}
\par
{\bkmkstart AAAAAAADDE}
{\bkmkend AAAAAAADDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp\:sw_flow_key}
{\xe \v sw_flow_key\:tp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   sw_flow_key::tp}}
\par
{\bkmkstart AAAAAAADDF}
{\bkmkend AAAAAAADDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ttl\:sw_flow_key}
{\xe \v sw_flow_key\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::ttl}}
\par
{\bkmkstart AAAAAAADDG}
{\bkmkend AAAAAAADDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_key\:sw_flow_key}
{\xe \v sw_flow_key\:tun_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ovs_key_ipv4_tunnel} sw_flow_key::tun_key}}
\par
{\bkmkstart AAAAAAADDH}
{\bkmkend AAAAAAADDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_opts\:sw_flow_key}
{\xe \v sw_flow_key\:tun_opts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::tun_opts[255]}}
\par
{\bkmkstart AAAAAAADDI}
{\bkmkend AAAAAAADDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_opts_len\:sw_flow_key}
{\xe \v sw_flow_key\:tun_opts_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sw_flow_key::tun_opts_len}}
\par
{\bkmkstart AAAAAAADDJ}
{\bkmkend AAAAAAADDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:sw_flow_key}
{\xe \v sw_flow_key\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 sw_flow_key::type}}
\par
{\bkmkstart AAAAAAADDK}
{\bkmkend AAAAAAADDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_key_range Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_key_range}
{\xe \v sw_flow_key_range}
{\bkmkstart AAAAAAADDL}
{\bkmkend AAAAAAADDL}
\par
{
{\f2 #include <flow.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short int {\b start}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short int {\b end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v end\:sw_flow_key_range}
{\xe \v sw_flow_key_range\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short int sw_flow_key_range::end}}
\par
{\bkmkstart AAAAAAADDM}
{\bkmkend AAAAAAADDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:sw_flow_key_range}
{\xe \v sw_flow_key_range\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short int sw_flow_key_range::start}}
\par
{\bkmkstart AAAAAAADDN}
{\bkmkend AAAAAAADDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_mask Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_mask}
{\xe \v sw_flow_mask}
{\bkmkstart AAAAAAADDO}
{\bkmkend AAAAAAADDO}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for sw_flow_mask:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structsw__flow__mask__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ref_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key_range} {\b range}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key} {\b key}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v key\:sw_flow_mask}
{\xe \v sw_flow_mask\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key} sw_flow_mask::key}}
\par
{\bkmkstart AAAAAAADDP}
{\bkmkend AAAAAAADDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v range\:sw_flow_mask}
{\xe \v sw_flow_mask\:range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key_range} sw_flow_mask::range}}
\par
{\bkmkstart AAAAAAADDQ}
{\bkmkend AAAAAAADDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:sw_flow_mask}
{\xe \v sw_flow_mask\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head sw_flow_mask::rcu}}
\par
{\bkmkstart AAAAAAADDR}
{\bkmkend AAAAAAADDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ref_count\:sw_flow_mask}
{\xe \v sw_flow_mask\:ref_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sw_flow_mask::ref_count}}
\par
{\bkmkstart AAAAAAADDS}
{\bkmkend AAAAAAADDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sw_flow_match Struct Reference\par \pard\plain 
{\tc\tcl2 \v sw_flow_match}
{\xe \v sw_flow_match}
{\bkmkstart AAAAAAADDT}
{\bkmkend AAAAAAADDT}
\par
{
{\f2 #include <flow.h>}}\par
Collaboration diagram for sw_flow_match:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structsw__flow__match__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key} * {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key_range} {\b range}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_mask} * {\b mask}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v key\:sw_flow_match}
{\xe \v sw_flow_match\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key}* sw_flow_match::key}}
\par
{\bkmkstart AAAAAAADDU}
{\bkmkend AAAAAAADDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mask\:sw_flow_match}
{\xe \v sw_flow_match\:mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_mask}* sw_flow_match::mask}}
\par
{\bkmkstart AAAAAAADDV}
{\bkmkend AAAAAAADDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v range\:sw_flow_match}
{\xe \v sw_flow_match\:range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key_range} sw_flow_match::range}}
\par
{\bkmkstart AAAAAAADDW}
{\bkmkend AAAAAAADDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
table_instance Struct Reference\par \pard\plain 
{\tc\tcl2 \v table_instance}
{\xe \v table_instance}
{\bkmkstart AAAAAAADDX}
{\bkmkend AAAAAAADDX}
\par
{
{\f2 #include <flow_table.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct flex_array * {\b buckets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b n_buckets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b node_ver}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b hash_seed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b keep_flows}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v buckets\:table_instance}
{\xe \v table_instance\:buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct flex_array* table_instance::buckets}}
\par
{\bkmkstart AAAAAAADDY}
{\bkmkend AAAAAAADDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hash_seed\:table_instance}
{\xe \v table_instance\:hash_seed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 table_instance::hash_seed}}
\par
{\bkmkstart AAAAAAADDZ}
{\bkmkend AAAAAAADDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v keep_flows\:table_instance}
{\xe \v table_instance\:keep_flows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} table_instance::keep_flows}}
\par
{\bkmkstart AAAAAAADEA}
{\bkmkend AAAAAAADEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_buckets\:table_instance}
{\xe \v table_instance\:n_buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int table_instance::n_buckets}}
\par
{\bkmkstart AAAAAAADEB}
{\bkmkend AAAAAAADEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v node_ver\:table_instance}
{\xe \v table_instance\:node_ver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int table_instance::node_ver}}
\par
{\bkmkstart AAAAAAADEC}
{\bkmkend AAAAAAADEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:table_instance}
{\xe \v table_instance\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head table_instance::rcu}}
\par
{\bkmkstart AAAAAAADED}
{\bkmkend AAAAAAADED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b flow_table.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tnl_ptk_info Struct Reference\par \pard\plain 
{\tc\tcl2 \v tnl_ptk_info}
{\xe \v tnl_ptk_info}
{\bkmkstart AAAAAAADEE}
{\bkmkend AAAAAAADEE}
\par
{
{\f2 #include <ip_tunnels.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b proto}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b seq}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v flags\:tnl_ptk_info}
{\xe \v tnl_ptk_info\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tnl_ptk_info::flags}}
\par
{\bkmkstart AAAAAAADEF}
{\bkmkend AAAAAAADEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key\:tnl_ptk_info}
{\xe \v tnl_ptk_info\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 tnl_ptk_info::key}}
\par
{\bkmkstart AAAAAAADEG}
{\bkmkend AAAAAAADEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v proto\:tnl_ptk_info}
{\xe \v tnl_ptk_info\:proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tnl_ptk_info::proto}}
\par
{\bkmkstart AAAAAAADEH}
{\bkmkend AAAAAAADEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v seq\:tnl_ptk_info}
{\xe \v tnl_ptk_info\:seq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 tnl_ptk_info::seq}}
\par
{\bkmkstart AAAAAAADEI}
{\bkmkend AAAAAAADEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b ip_tunnels.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
u64_stats_sync Struct Reference\par \pard\plain 
{\tc\tcl2 \v u64_stats_sync}
{\xe \v u64_stats_sync}
{\bkmkstart AAAAAAADEJ}
{\bkmkend AAAAAAADEJ}
\par
{
{\f2 #include <u64_stats_sync.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/{\b u64_stats_sync.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport}
{\xe \v vport}
{\bkmkstart AAAAAAADEK}
{\bkmkend AAAAAAADEK}
\par
{
{\f2 #include <vport.h>}}\par
Collaboration diagram for vport:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvport__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b datapath} * {\b dp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_portids} {\b __rcu} * {\b upcall_portids}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u16 {\b port_no}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct hlist_node {\b hash_node}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct hlist_node {\b dp_hash_node}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const struct {\b vport_ops} * {\b ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pcpu_sw_netstats} {\b __percpu} * {\b percpu_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_err_stats} {\b err_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b detach_list}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct vport - one port within a datapath : RCU callback head for deferred destruction. : Datapath to which this port belongs. : RCU protected 'struct {\b vport_portids}'. : Index into 's  array. : Element in  hash table in vport.c. : Element in ->ports hash table in datapath.c. : Class structure. : Points to per-CPU statistics used and maintained by vport : Points to error statistics used and maintained by vport : list used for detaching vport in net-exit call. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v detach_list\:vport}
{\xe \v vport\:detach_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head vport::detach_list}}
\par
{\bkmkstart AAAAAAADEL}
{\bkmkend AAAAAAADEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dp\:vport}
{\xe \v vport\:dp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b datapath}* vport::dp}}
\par
{\bkmkstart AAAAAAADEM}
{\bkmkend AAAAAAADEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dp_hash_node\:vport}
{\xe \v vport\:dp_hash_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_node vport::dp_hash_node}}
\par
{\bkmkstart AAAAAAADEN}
{\bkmkend AAAAAAADEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v err_stats\:vport}
{\xe \v vport\:err_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport_err_stats} vport::err_stats}}
\par
{\bkmkstart AAAAAAADEO}
{\bkmkend AAAAAAADEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hash_node\:vport}
{\xe \v vport\:hash_node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_node vport::hash_node}}
\par
{\bkmkstart AAAAAAADEP}
{\bkmkend AAAAAAADEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ops\:vport}
{\xe \v vport\:ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b vport_ops}* vport::ops}}
\par
{\bkmkstart AAAAAAADEQ}
{\bkmkend AAAAAAADEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v percpu_stats\:vport}
{\xe \v vport\:percpu_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b pcpu_sw_netstats} {\b __percpu}* vport::percpu_stats}}
\par
{\bkmkstart AAAAAAADER}
{\bkmkend AAAAAAADER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v port_no\:vport}
{\xe \v vport\:port_no}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u16 vport::port_no}}
\par
{\bkmkstart AAAAAAADES}
{\bkmkend AAAAAAADES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:vport}
{\xe \v vport\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head vport::rcu}}
\par
{\bkmkstart AAAAAAADET}
{\bkmkend AAAAAAADET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upcall_portids\:vport}
{\xe \v vport\:upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport_portids} {\b __rcu}* vport::upcall_portids}}
\par
{\bkmkstart AAAAAAADEU}
{\bkmkend AAAAAAADEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport_err_stats Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport_err_stats}
{\xe \v vport_err_stats}
{\bkmkstart AAAAAAADEV}
{\bkmkend AAAAAAADEV}
\par
{
{\f2 #include <vport.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
atomic_long_t {\b rx_dropped}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
atomic_long_t {\b rx_errors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
atomic_long_t {\b tx_dropped}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
atomic_long_t {\b tx_errors}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v rx_dropped\:vport_err_stats}
{\xe \v vport_err_stats\:rx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
atomic_long_t vport_err_stats::rx_dropped}}
\par
{\bkmkstart AAAAAAADEW}
{\bkmkend AAAAAAADEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_errors\:vport_err_stats}
{\xe \v vport_err_stats\:rx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
atomic_long_t vport_err_stats::rx_errors}}
\par
{\bkmkstart AAAAAAADEX}
{\bkmkend AAAAAAADEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_dropped\:vport_err_stats}
{\xe \v vport_err_stats\:tx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
atomic_long_t vport_err_stats::tx_dropped}}
\par
{\bkmkstart AAAAAAADEY}
{\bkmkend AAAAAAADEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_errors\:vport_err_stats}
{\xe \v vport_err_stats\:tx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
atomic_long_t vport_err_stats::tx_errors}}
\par
{\bkmkstart AAAAAAADEZ}
{\bkmkend AAAAAAADEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport_net Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport_net}
{\xe \v vport_net}
{\bkmkstart AAAAAAADFA}
{\bkmkend AAAAAAADFA}
\par
{
{\f2 #include <vport.h>}}\par
Collaboration diagram for vport_net:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvport__net__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} {\b __rcu} * {\b gre_vport}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} {\b __rcu} * {\b gre64_vport}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v gre64_vport\:vport_net}
{\xe \v vport_net\:gre64_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport} {\b __rcu}* vport_net::gre64_vport}}
\par
{\bkmkstart AAAAAAADFB}
{\bkmkend AAAAAAADFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v gre_vport\:vport_net}
{\xe \v vport_net\:gre_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport} {\b __rcu}* vport_net::gre_vport}}
\par
{\bkmkstart AAAAAAADFC}
{\bkmkend AAAAAAADFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport_ops Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport_ops}
{\xe \v vport_ops}
{\bkmkstart AAAAAAADFD}
{\bkmkend AAAAAAADFD}
\par
{
{\f2 #include <vport.h>}}\par
Collaboration diagram for vport_ops:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvport__ops__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_vport_type} {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} *(* {\b create} )(const struct {\b vport_parms} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b destroy} )(struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b set_options} )(struct {\b vport} *, struct nlattr *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b get_options} )(const struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char *(* {\b get_name} )(const struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b send} )(struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b get_egress_tun_info} )(struct {\b vport} *, struct sk_buff *, struct {\b ovs_tunnel_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct module * {\b owner}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct list_head {\b list}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b vport_ops} - definition of a type of virtual port\par
: OVS_VPORT_TYPE_* value for this type of virtual port. : Create a new vport configured as specified. On success returns a new vport allocated with {\b ovs_vport_alloc()}, otherwise an ERR_PTR() value. : Destroys a vport. Must call vport_free() on the vport but not before an RCU grace period has elapsed. : Modify the configuration of an existing vport. May be NULL if modification is not supported. : Appends vport-specific attributes for the configuration of an existing vport to a &struct sk_buff. May be NULL for a vport that does not have any configuration. : Get the device's name. : Send a packet on the device. Returns the length of the packet sent, zero for dropped packets or negative for error. : Get the egress tunnel 5-tuple and other info for a packet. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v create\:vport_ops}
{\xe \v vport_ops\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}*(* vport_ops::create) (const struct {\b vport_parms} *)}}
\par
{\bkmkstart AAAAAAADFE}
{\bkmkend AAAAAAADFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v destroy\:vport_ops}
{\xe \v vport_ops\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* vport_ops::destroy) (struct {\b vport} *)}}
\par
{\bkmkstart AAAAAAADFF}
{\bkmkend AAAAAAADFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_egress_tun_info\:vport_ops}
{\xe \v vport_ops\:get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* vport_ops::get_egress_tun_info) (struct {\b vport} *, struct sk_buff *, struct {\b ovs_tunnel_info} *)}}
\par
{\bkmkstart AAAAAAADFG}
{\bkmkend AAAAAAADFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_name\:vport_ops}
{\xe \v vport_ops\:get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char*(* vport_ops::get_name) (const struct {\b vport} *)}}
\par
{\bkmkstart AAAAAAADFH}
{\bkmkend AAAAAAADFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_options\:vport_ops}
{\xe \v vport_ops\:get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* vport_ops::get_options) (const struct {\b vport} *, struct sk_buff *)}}
\par
{\bkmkstart AAAAAAADFI}
{\bkmkend AAAAAAADFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v list\:vport_ops}
{\xe \v vport_ops\:list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct list_head vport_ops::list}}
\par
{\bkmkstart AAAAAAADFJ}
{\bkmkend AAAAAAADFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v owner\:vport_ops}
{\xe \v vport_ops\:owner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct module* vport_ops::owner}}
\par
{\bkmkstart AAAAAAADFK}
{\bkmkend AAAAAAADFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v send\:vport_ops}
{\xe \v vport_ops\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* vport_ops::send) (struct {\b vport} *, struct sk_buff *)}}
\par
{\bkmkstart AAAAAAADFL}
{\bkmkend AAAAAAADFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set_options\:vport_ops}
{\xe \v vport_ops\:set_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* vport_ops::set_options) (struct {\b vport} *, struct nlattr *)}}
\par
{\bkmkstart AAAAAAADFM}
{\bkmkend AAAAAAADFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:vport_ops}
{\xe \v vport_ops\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_vport_type} vport_ops::type}}
\par
{\bkmkstart AAAAAAADFN}
{\bkmkend AAAAAAADFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport_parms Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport_parms}
{\xe \v vport_parms}
{\bkmkstart AAAAAAADFO}
{\bkmkend AAAAAAADFO}
\par
{
{\f2 #include <vport.h>}}\par
Collaboration diagram for vport_parms:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvport__parms__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_vport_type} {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct nlattr * {\b options}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b datapath} * {\b dp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u16 {\b port_no}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct nlattr * {\b upcall_portids}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dp\:vport_parms}
{\xe \v vport_parms\:dp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b datapath}* vport_parms::dp}}
\par
{\bkmkstart AAAAAAADFP}
{\bkmkend AAAAAAADFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:vport_parms}
{\xe \v vport_parms\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* vport_parms::name}}
\par
{\bkmkstart AAAAAAADFQ}
{\bkmkend AAAAAAADFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v options\:vport_parms}
{\xe \v vport_parms\:options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct nlattr* vport_parms::options}}
\par
{\bkmkstart AAAAAAADFR}
{\bkmkend AAAAAAADFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v port_no\:vport_parms}
{\xe \v vport_parms\:port_no}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u16 vport_parms::port_no}}
\par
{\bkmkstart AAAAAAADFS}
{\bkmkend AAAAAAADFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:vport_parms}
{\xe \v vport_parms\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_vport_type} vport_parms::type}}
\par
{\bkmkstart AAAAAAADFT}
{\bkmkend AAAAAAADFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upcall_portids\:vport_parms}
{\xe \v vport_parms\:upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct nlattr* vport_parms::upcall_portids}}
\par
{\bkmkstart AAAAAAADFU}
{\bkmkend AAAAAAADFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vport_portids Struct Reference\par \pard\plain 
{\tc\tcl2 \v vport_portids}
{\xe \v vport_portids}
{\bkmkstart AAAAAAADFV}
{\bkmkend AAAAAAADFV}
\par
{
{\f2 #include <vport.h>}}\par
Collaboration diagram for vport_portids:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvport__portids__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reciprocal_value} {\b rn_ids}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b n_ids}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ids} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct {\b vport_portids} - array of netlink portids of a vport. must be protected by rcu. : The reciprocal value of . : RCU callback head for deferred destruction. : Size of  array. : Array storing the Netlink socket pids to be used for packets received on this port that miss the flow table. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ids\:vport_portids}
{\xe \v vport_portids\:ids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 vport_portids::ids[]}}
\par
{\bkmkstart AAAAAAADFW}
{\bkmkend AAAAAAADFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v n_ids\:vport_portids}
{\xe \v vport_portids\:n_ids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 vport_portids::n_ids}}
\par
{\bkmkstart AAAAAAADFX}
{\bkmkend AAAAAAADFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:vport_portids}
{\xe \v vport_portids\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head vport_portids::rcu}}
\par
{\bkmkstart AAAAAAADFY}
{\bkmkend AAAAAAADFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rn_ids\:vport_portids}
{\xe \v vport_portids\:rn_ids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b reciprocal_value} vport_portids::rn_ids}}
\par
{\bkmkstart AAAAAAADFZ}
{\bkmkend AAAAAAADFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/{\b vport.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vxlan_metadata Struct Reference\par \pard\plain 
{\tc\tcl2 \v vxlan_metadata}
{\xe \v vxlan_metadata}
{\bkmkstart AAAAAAADGA}
{\bkmkend AAAAAAADGA}
\par
{
{\f2 #include <vxlan.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b vni}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b gbp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v gbp\:vxlan_metadata}
{\xe \v vxlan_metadata\:gbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 vxlan_metadata::gbp}}
\par
{\bkmkstart AAAAAAADGB}
{\bkmkend AAAAAAADGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vni\:vxlan_metadata}
{\xe \v vxlan_metadata\:vni}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 vxlan_metadata::vni}}
\par
{\bkmkstart AAAAAAADGC}
{\bkmkend AAAAAAADGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b vxlan.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vxlan_port Struct Reference\par \pard\plain 
{\tc\tcl2 \v vxlan_port}
{\xe \v vxlan_port}
{\bkmkstart AAAAAAADGD}
{\bkmkend AAAAAAADGD}
Collaboration diagram for vxlan_port:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structvxlan__port__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_sock} * {\b vs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [IFNAMSIZ]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b exts}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v exts\:vxlan_port}
{\xe \v vxlan_port\:exts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 vxlan_port::exts}}
\par
{\bkmkstart AAAAAAADGE}
{\bkmkend AAAAAAADGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:vxlan_port}
{\xe \v vxlan_port\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char vxlan_port::name}}
\par
{\bkmkstart AAAAAAADGF}
{\bkmkend AAAAAAADGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vs\:vxlan_port}
{\xe \v vxlan_port\:vs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vxlan_sock} * vxlan_port::vs}}
\par
{\bkmkstart AAAAAAADGG}
{\bkmkend AAAAAAADGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/{\b vport-vxlan.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vxlan_sock Struct Reference\par \pard\plain 
{\tc\tcl2 \v vxlan_sock}
{\xe \v vxlan_sock}
{\bkmkstart AAAAAAADGH}
{\bkmkend AAAAAAADGH}
\par
{
{\f2 #include <vxlan.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct hlist_node {\b hlist}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b vxlan_rcv_t} * {\b rcv}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct work_struct {\b del_work}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct socket * {\b sock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct rcu_head {\b rcu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b flags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:vxlan_sock}
{\xe \v vxlan_sock\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* vxlan_sock::data}}
\par
{\bkmkstart AAAAAAADGI}
{\bkmkend AAAAAAADGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v del_work\:vxlan_sock}
{\xe \v vxlan_sock\:del_work}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct work_struct vxlan_sock::del_work}}
\par
{\bkmkstart AAAAAAADGJ}
{\bkmkend AAAAAAADGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flags\:vxlan_sock}
{\xe \v vxlan_sock\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 vxlan_sock::flags}}
\par
{\bkmkstart AAAAAAADGK}
{\bkmkend AAAAAAADGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hlist\:vxlan_sock}
{\xe \v vxlan_sock\:hlist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_node vxlan_sock::hlist}}
\par
{\bkmkstart AAAAAAADGL}
{\bkmkend AAAAAAADGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu\:vxlan_sock}
{\xe \v vxlan_sock\:rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rcu_head vxlan_sock::rcu}}
\par
{\bkmkstart AAAAAAADGM}
{\bkmkend AAAAAAADGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcv\:vxlan_sock}
{\xe \v vxlan_sock\:rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b vxlan_rcv_t}* vxlan_sock::rcv}}
\par
{\bkmkstart AAAAAAADGN}
{\bkmkend AAAAAAADGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sock\:vxlan_sock}
{\xe \v vxlan_sock\:sock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct socket* vxlan_sock::sock}}
\par
{\bkmkstart AAAAAAADGO}
{\bkmkend AAAAAAADGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b vxlan.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vxlanhdr Struct Reference\par \pard\plain 
{\tc\tcl2 \v vxlanhdr}
{\xe \v vxlanhdr}
{\bkmkstart AAAAAAADGP}
{\bkmkend AAAAAAADGP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b vx_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b vx_vni}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v vx_flags\:vxlanhdr}
{\xe \v vxlanhdr\:vx_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 vxlanhdr::vx_flags}}
\par
{\bkmkstart AAAAAAADGQ}
{\bkmkend AAAAAAADGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vx_vni\:vxlanhdr}
{\xe \v vxlanhdr\:vx_vni}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 vxlanhdr::vx_vni}}
\par
{\bkmkstart AAAAAAADGR}
{\bkmkend AAAAAAADGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/{\b vxlan.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vxlanhdr_gbp Struct Reference\par \pard\plain 
{\tc\tcl2 \v vxlanhdr_gbp}
{\xe \v vxlanhdr_gbp}
{\bkmkstart AAAAAAADGS}
{\bkmkend AAAAAAADGS}
\par
{
{\f2 #include <vxlan.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__u8 {\b vx_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b policy_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b vx_vni}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v policy_id\:vxlanhdr_gbp}
{\xe \v vxlanhdr_gbp\:policy_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 vxlanhdr_gbp::policy_id}}
\par
{\bkmkstart AAAAAAADGT}
{\bkmkend AAAAAAADGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vx_flags\:vxlanhdr_gbp}
{\xe \v vxlanhdr_gbp\:vx_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__u8 vxlanhdr_gbp::vx_flags}}
\par
{\bkmkstart AAAAAAADGU}
{\bkmkend AAAAAAADGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vx_vni\:vxlanhdr_gbp}
{\xe \v vxlanhdr_gbp\:vx_vni}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 vxlanhdr_gbp::vx_vni}}
\par
{\bkmkstart AAAAAAADGV}
{\bkmkend AAAAAAADGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/{\b vxlan.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/actions.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/actions.c}
{\xe \v /home/vladn/git/ovs/datapath/actions.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/in6.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/checksum.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/sctp/checksum.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for actions.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "actions_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b deferred_action}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b action_fifo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEFERRED_ACTION_FIFO_SIZE}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXEC_ACTIONS_LEVEL_LIMIT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MASKED}(OLD,  KEY,  MASK)\~ ((KEY) | ((OLD) & ~(MASK)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SET_MASKED}(OLD,  KEY,  MASK)\~ ((OLD) = {\b MASKED}(OLD, KEY, MASK))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b get_mask}(a,  {\b type})\~ ((const {\b type})nla_data(a) + 1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b do_execute_actions} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DEFINE_PER_CPU} (int, exec_actions_level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b action_fifo_init} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b action_fifo_is_empty} (const struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b action_fifo_get} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b action_fifo_put} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b add_deferred_actions} (struct sk_buff *skb, const struct {\b sw_flow_key} *key, const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b invalidate_flow_key} (struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_flow_key_valid} (const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b push_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct {\b ovs_action_push_mpls} *{\b mpls})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b pop_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const __be16 ethertype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const __be32 *mpls_lse, const __be32 *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b pop_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b push_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct {\b ovs_action_push_vlan} *vlan)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ether_addr_copy_masked} (u8 *dst_, const u8 *src_, const u8 *mask_)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_eth_addr} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ethernet} *key, const struct {\b ovs_key_ethernet} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ip_addr} (struct sk_buff *skb, struct iphdr *nh, __be32 *{\b addr}, __be32 new_addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b update_ipv6_checksum} (struct sk_buff *skb, u8 l4_proto, __be32 {\b addr}[4], const __be32 new_addr[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_ipv6_addr} (const __be32 old[4], const __be32 {\b addr}[4], const __be32 mask[4], __be32 masked[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ipv6_addr} (struct sk_buff *skb, u8 l4_proto, __be32 {\b addr}[4], const __be32 new_addr[4], {\b bool} recalculate_csum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ipv6_fl} (struct ipv6hdr *nh, u32 fl, u32 mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ip_ttl} (struct sk_buff *skb, struct iphdr *nh, u8 new_ttl, u8 mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_ipv4} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ipv4} *key, const struct {\b ovs_key_ipv4} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_ipv6_mask_nonzero} (const __be32 {\b addr}[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_ipv6} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ipv6} *key, const struct {\b ovs_key_ipv6} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_tp_port} (struct sk_buff *skb, __be16 *port, __be16 new_port, {\b __sum16} *check)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_udp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_udp} *key, const struct {\b ovs_key_udp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_tcp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_tcp} *key, const struct {\b ovs_key_tcp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_sctp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_sctp} *key, const struct {\b ovs_key_sctp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b do_output} (struct {\b datapath} *dp, struct sk_buff *skb, int out_port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b output_userspace} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, const struct nlattr *actions, int actions_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sample} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, const struct nlattr *actions, int actions_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b execute_hash} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_set_action} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct nlattr *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_masked_set_action} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct nlattr *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_recirc} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *a, int rem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_deferred_actions} (struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_execute_actions} (struct {\b datapath} *dp, struct sk_buff *skb, const struct {\b sw_flow_actions} *acts, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b action_fifos_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b action_fifos_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b action_fifo} {\b __percpu} * {\b action_fifos}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEFERRED_ACTION_FIFO_SIZE\:actions.c}
{\xe \v actions.c\:DEFERRED_ACTION_FIFO_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEFERRED_ACTION_FIFO_SIZE\~ 10}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXEC_ACTIONS_LEVEL_LIMIT\:actions.c}
{\xe \v actions.c\:EXEC_ACTIONS_LEVEL_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXEC_ACTIONS_LEVEL_LIMIT}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4   /* limit used to detect packet\par
                      * looping by the network stack\par
                      */\par
}
}
{\xe \v get_mask\:actions.c}
{\xe \v actions.c\:get_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define get_mask( a,  {\b type})\~ ((const {\b type})nla_data(a) + 1)}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MASKED\:actions.c}
{\xe \v actions.c\:MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MASKED( OLD,  KEY,  MASK)\~ ((KEY) | ((OLD) & ~(MASK)))}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:actions.c}
{\xe \v actions.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SET_MASKED\:actions.c}
{\xe \v actions.c\:SET_MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SET_MASKED( OLD,  KEY,  MASK)\~ ((OLD) = {\b MASKED}(OLD, KEY, MASK))}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v action_fifo_get\:actions.c}
{\xe \v actions.c\:action_fifo_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* action_fifo_get (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83     if (action_fifo_is_empty(fifo))\par
   84         return NULL;\par
   85 \par
   86     return &fifo->fifo[fifo->tail++];\par
   87 \}\par
}
}
{\xe \v action_fifo_init\:actions.c}
{\xe \v actions.c\:action_fifo_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void action_fifo_init (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     fifo->head = 0;\par
   73     fifo->tail = 0;\par
   74 \}\par
}
}
{\xe \v action_fifo_is_empty\:actions.c}
{\xe \v actions.c\:action_fifo_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} action_fifo_is_empty (const struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    77 \{\par
   78     return (fifo->head == fifo->tail);\par
   79 \}\par
}
}
{\xe \v action_fifo_put\:actions.c}
{\xe \v actions.c\:action_fifo_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* action_fifo_put (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90 \{\par
   91     if (fifo->head >= DEFERRED_ACTION_FIFO_SIZE - 1)\par
   92         return NULL;\par
   93 \par
   94     return &fifo->fifo[fifo->head++];\par
   95 \}\par
}
}
{\xe \v action_fifos_exit\:actions.c}
{\xe \v actions.c\:action_fifos_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void action_fifos_exit (void )}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1016 \{\par
 1017     free_percpu(action_fifos);\par
 1018 \}\par
}
}
{\xe \v action_fifos_init\:actions.c}
{\xe \v actions.c\:action_fifos_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int action_fifos_init (void )}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1007 \{\par
 1008     action_fifos = alloc_percpu(struct action_fifo);\par
 1009     if (!action_fifos)\par
 1010         return -ENOMEM;\par
 1011 \par
 1012     return 0;\par
 1013 \}\par
}
}
{\xe \v add_deferred_actions\:actions.c}
{\xe \v actions.c\:add_deferred_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* add_deferred_actions (struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102     struct action_fifo *fifo;\par
  103     struct deferred_action *da;\par
  104 \par
  105     fifo = this_cpu_ptr(action_fifos);\par
  106     da = action_fifo_put(fifo);\par
  107     if (da) \{\par
  108         da->skb = skb;\par
  109         da->actions = attr;\par
  110         da->pkt_key = *key;\par
  111     \}\par
  112 \par
  113     return da;\par
  114 \}\par
}
}
{\xe \v DEFINE_PER_CPU\:actions.c}
{\xe \v actions.c\:DEFINE_PER_CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static DEFINE_PER_CPU (int , exec_actions_level ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v do_execute_actions\:actions.c}
{\xe \v actions.c\:do_execute_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int do_execute_actions (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   856 \{\par
  857     /* Every output action needs a separate clone of 'skb', but the common\par
  858      * case is just a single output action, so that doing a clone and\par
  859      * then freeing the original skbuff is wasteful.  So the following code\par
  860      * is slightly obscure just to avoid that.\par
  861      */\par
  862     int prev_port = -1;\par
  863     const struct nlattr *a;\par
  864     int rem;\par
  865 \par
  866     for (a = attr, rem = len; rem > 0;\par
  867          a = nla_next(a, &rem)) \{\par
  868         int err = 0;\par
  869 \par
  870         if (unlikely(prev_port != -1)) \{\par
  871             struct sk_buff *out_skb = skb_clone(skb, GFP_ATOMIC);\par
  872 \par
  873             if (out_skb)\par
  874                 do_output(dp, out_skb, prev_port);\par
  875 \par
  876             prev_port = -1;\par
  877         \}\par
  878 \par
  879         switch (nla_type(a)) \{\par
  880         case OVS_ACTION_ATTR_OUTPUT:\par
  881             prev_port = nla_get_u32(a);\par
  882             break;\par
  883 \par
  884         case OVS_ACTION_ATTR_USERSPACE:\par
  885             output_userspace(dp, skb, key, a, attr, len);\par
  886             break;\par
  887 \par
  888         case OVS_ACTION_ATTR_HASH:\par
  889             execute_hash(skb, key, a);\par
  890             break;\par
  891 \par
  892         case OVS_ACTION_ATTR_PUSH_MPLS:\par
  893             err = push_mpls(skb, key, nla_data(a));\par
  894             break;\par
  895 \par
  896         case OVS_ACTION_ATTR_POP_MPLS:\par
  897             err = pop_mpls(skb, key, nla_get_be16(a));\par
  898             break;\par
  899 \par
  900         case OVS_ACTION_ATTR_PUSH_VLAN:\par
  901             err = push_vlan(skb, key, nla_data(a));\par
  902             break;\par
  903 \par
  904         case OVS_ACTION_ATTR_POP_VLAN:\par
  905             err = pop_vlan(skb, key);\par
  906             break;\par
  907 \par
  908         case OVS_ACTION_ATTR_RECIRC:\par
  909             err = execute_recirc(dp, skb, key, a, rem);\par
  910             if (nla_is_last(a, rem)) \{\par
  911                 /* If this is the last action, the skb has\par
  912                  * been consumed or freed.\par
  913                  * Return immediately.\par
  914                  */\par
  915                 return err;\par
  916             \}\par
  917             break;\par
  918 \par
  919         case OVS_ACTION_ATTR_SET:\par
  920             err = execute_set_action(skb, key, nla_data(a));\par
  921             break;\par
  922 \par
  923         case OVS_ACTION_ATTR_SET_MASKED:\par
  924         case OVS_ACTION_ATTR_SET_TO_MASKED:\par
  925             err = execute_masked_set_action(skb, key, nla_data(a));\par
  926             break;\par
  927 \par
  928         case OVS_ACTION_ATTR_SAMPLE:\par
  929             err = sample(dp, skb, key, a, attr, len);\par
  930             break;\par
  931         \}\par
  932 \par
  933         if (unlikely(err)) \{\par
  934             kfree_skb(skb);\par
  935             return err;\par
  936         \}\par
  937     \}\par
  938 \par
  939     if (prev_port != -1)\par
  940         do_output(dp, skb, prev_port);\par
  941     else\par
  942         consume_skb(skb);\par
  943 \par
  944     return 0;\par
  945 \}\par
}
}
{\xe \v do_output\:actions.c}
{\xe \v actions.c\:do_output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void do_output (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, int  {\i out_port}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   604 \{\par
  605     struct vport *vport = ovs_vport_rcu(dp, out_port);\par
  606 \par
  607     if (likely(vport))\par
  608         ovs_vport_send(vport, skb);\par
  609     else\par
  610         kfree_skb(skb);\par
  611 \}\par
}
}
{\xe \v ether_addr_copy_masked\:actions.c}
{\xe \v actions.c\:ether_addr_copy_masked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ether_addr_copy_masked (u8 *  {\i dst_}, const u8 *  {\i src_}, const u8 *  {\i mask_}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   245 \{\par
  246     u16 *dst = (u16 *)dst_;\par
  247     const u16 *src = (const u16 *)src_;\par
  248     const u16 *mask = (const u16 *)mask_;\par
  249 \par
  250     SET_MASKED(dst[0], src[0], mask[0]);\par
  251     SET_MASKED(dst[1], src[1], mask[1]);\par
  252     SET_MASKED(dst[2], src[2], mask[2]);\par
  253 \}\par
}
}
{\xe \v execute_hash\:actions.c}
{\xe \v actions.c\:execute_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void execute_hash (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   720 \{\par
  721     struct ovs_action_hash *hash_act = nla_data(attr);\par
  722     u32 hash = 0;\par
  723 \par
  724     /* OVS_HASH_ALG_L4 is the only possible hash algorithm.  */\par
  725     hash = skb_get_hash(skb);\par
  726     hash = jhash_1word(hash, hash_act->hash_basis);\par
  727     if (!hash)\par
  728         hash = 0x1;\par
  729 \par
  730     key->ovs_flow_hash = hash;\par
  731 \}\par
}
}
{\xe \v execute_masked_set_action\:actions.c}
{\xe \v actions.c\:execute_masked_set_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_masked_set_action (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct nlattr *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   752 \{\par
  753     int err = 0;\par
  754 \par
  755     switch (nla_type(a)) \{\par
  756     case OVS_KEY_ATTR_PRIORITY:\par
  757         SET_MASKED(skb->priority, nla_get_u32(a), *get_mask(a, u32 *));\par
  758         flow_key->phy.priority = skb->priority;\par
  759         break;\par
  760 \par
  761     case OVS_KEY_ATTR_SKB_MARK:\par
  762         SET_MASKED(skb->mark, nla_get_u32(a), *get_mask(a, u32 *));\par
  763         flow_key->phy.skb_mark = skb->mark;\par
  764         break;\par
  765 \par
  766     case OVS_KEY_ATTR_TUNNEL_INFO:\par
  767         /* Masked data not supported for tunnel. */\par
  768         err = -EINVAL;\par
  769         break;\par
  770 \par
  771     case OVS_KEY_ATTR_ETHERNET:\par
  772         err = set_eth_addr(skb, flow_key, nla_data(a),\par
  773                    get_mask(a, struct ovs_key_ethernet *));\par
  774         break;\par
  775 \par
  776     case OVS_KEY_ATTR_IPV4:\par
  777         err = set_ipv4(skb, flow_key, nla_data(a),\par
  778                    get_mask(a, struct ovs_key_ipv4 *));\par
  779         break;\par
  780 \par
  781     case OVS_KEY_ATTR_IPV6:\par
  782         err = set_ipv6(skb, flow_key, nla_data(a),\par
  783                    get_mask(a, struct ovs_key_ipv6 *));\par
  784         break;\par
  785 \par
  786     case OVS_KEY_ATTR_TCP:\par
  787         err = set_tcp(skb, flow_key, nla_data(a),\par
  788                   get_mask(a, struct ovs_key_tcp *));\par
  789         break;\par
  790 \par
  791     case OVS_KEY_ATTR_UDP:\par
  792         err = set_udp(skb, flow_key, nla_data(a),\par
  793                   get_mask(a, struct ovs_key_udp *));\par
  794         break;\par
  795 \par
  796     case OVS_KEY_ATTR_SCTP:\par
  797         err = set_sctp(skb, flow_key, nla_data(a),\par
  798                    get_mask(a, struct ovs_key_sctp *));\par
  799         break;\par
  800 \par
  801     case OVS_KEY_ATTR_MPLS:\par
  802         err = set_mpls(skb, flow_key, nla_data(a), get_mask(a,\par
  803                                     __be32 *));\par
  804         break;\par
  805     \}\par
  806 \par
  807     return err;\par
  808 \}\par
}
}
{\xe \v execute_recirc\:actions.c}
{\xe \v actions.c\:execute_recirc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_recirc (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i a}, int  {\i rem}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   813 \{\par
  814     struct deferred_action *da;\par
  815 \par
  816     if (!is_flow_key_valid(key)) \{\par
  817         int err;\par
  818 \par
  819         err = ovs_flow_key_update(skb, key);\par
  820         if (err)\par
  821             return err;\par
  822     \}\par
  823     BUG_ON(!is_flow_key_valid(key));\par
  824 \par
  825     if (!nla_is_last(a, rem)) \{\par
  826         /* Recirc action is the not the last action\par
  827          * of the action list, need to clone the skb.\par
  828          */\par
  829         skb = skb_clone(skb, GFP_ATOMIC);\par
  830 \par
  831         /* Skip the recirc action when out of memory, but\par
  832          * continue on with the rest of the action list.\par
  833          */\par
  834         if (!skb)\par
  835             return 0;\par
  836     \}\par
  837 \par
  838     da = add_deferred_actions(skb, key, NULL);\par
  839     if (da) \{\par
  840         da->pkt_key.recirc_id = nla_get_u32(a);\par
  841     \} else \{\par
  842         kfree_skb(skb);\par
  843 \par
  844         if (net_ratelimit())\par
  845             pr_warn("%s: deferred action limit reached, drop recirc action\\n",\par
  846                 ovs_dp_name(dp));\par
  847     \}\par
  848 \par
  849     return 0;\par
  850 \}\par
}
}
{\xe \v execute_set_action\:actions.c}
{\xe \v actions.c\:execute_set_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_set_action (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct nlattr *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   736 \{\par
  737     /* Only tunnel set execution is supported without a mask. */\par
  738     if (nla_type(a) == OVS_KEY_ATTR_TUNNEL_INFO) \{\par
  739         OVS_CB(skb)->egress_tun_info = nla_data(a);\par
  740         return 0;\par
  741     \}\par
  742 \par
  743     return -EINVAL;\par
  744 \}\par
}
}
{\xe \v invalidate_flow_key\:actions.c}
{\xe \v actions.c\:invalidate_flow_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void invalidate_flow_key (struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117 \{\par
  118     key->eth.type = htons(0);\par
  119 \}\par
}
}
{\xe \v is_flow_key_valid\:actions.c}
{\xe \v actions.c\:is_flow_key_valid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_flow_key_valid (const struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   122 \{\par
  123     return !!key->eth.type;\par
  124 \}\par
}
}
{\xe \v is_ipv6_mask_nonzero\:actions.c}
{\xe \v actions.c\:is_ipv6_mask_nonzero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_ipv6_mask_nonzero (const __be32  {\i addr}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   418 \{\par
  419     return !!(addr[0] | addr[1] | addr[2] | addr[3]);\par
  420 \}\par
}
}
{\xe \v mask_ipv6_addr\:actions.c}
{\xe \v actions.c\:mask_ipv6_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_ipv6_addr (const __be32  {\i old}[4], const __be32  {\i addr}[4], const __be32  {\i mask}[4], __be32  {\i masked}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   335 \{\par
  336     masked[0] = MASKED(old[0], addr[0], mask[0]);\par
  337     masked[1] = MASKED(old[1], addr[1], mask[1]);\par
  338     masked[2] = MASKED(old[2], addr[2], mask[2]);\par
  339     masked[3] = MASKED(old[3], addr[3], mask[3]);\par
  340 \}\par
}
}
{\xe \v output_userspace\:actions.c}
{\xe \v actions.c\:output_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int output_userspace (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, const struct nlattr *  {\i actions}, int  {\i actions_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   616 \{\par
  617     struct ovs_tunnel_info info;\par
  618     struct dp_upcall_info upcall;\par
  619     const struct nlattr *a;\par
  620     int rem;\par
  621 \par
  622     memset(&upcall, 0, sizeof(upcall));\par
  623     upcall.cmd = OVS_PACKET_CMD_ACTION;\par
  624 \par
  625     for (a = nla_data(attr), rem = nla_len(attr); rem > 0;\par
  626          a = nla_next(a, &rem)) \{\par
  627         switch (nla_type(a)) \{\par
  628         case OVS_USERSPACE_ATTR_USERDATA:\par
  629             upcall.userdata = a;\par
  630             break;\par
  631 \par
  632         case OVS_USERSPACE_ATTR_PID:\par
  633             upcall.portid = nla_get_u32(a);\par
  634             break;\par
  635 \par
  636         case OVS_USERSPACE_ATTR_EGRESS_TUN_PORT: \{\par
  637             /* Get out tunnel info. */\par
  638             struct vport *vport;\par
  639 \par
  640             vport = ovs_vport_rcu(dp, nla_get_u32(a));\par
  641             if (vport) \{\par
  642                 int err;\par
  643 \par
  644                 err = ovs_vport_get_egress_tun_info(vport, skb,\par
  645                                     &info);\par
  646                 if (!err)\par
  647                     upcall.egress_tun_info = &info;\par
  648             \}\par
  649             break;\par
  650         \}\par
  651 \par
  652         case OVS_USERSPACE_ATTR_ACTIONS: \{\par
  653             /* Include actions. */\par
  654             upcall.actions = actions;\par
  655             upcall.actions_len = actions_len;\par
  656             break;\par
  657         \}\par
  658 \par
  659         \} /* End of switch. */\par
  660     \}\par
  661 \par
  662     return ovs_dp_upcall(dp, skb, key, &upcall);\par
  663 \}\par
}
}
{\xe \v ovs_execute_actions\:actions.c}
{\xe \v actions.c\:ovs_execute_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_execute_actions (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_actions} *  {\i acts}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   977 \{\par
  978     int level = this_cpu_read(exec_actions_level);\par
  979     int err;\par
  980 \par
  981     if (unlikely(level >= EXEC_ACTIONS_LEVEL_LIMIT)) \{\par
  982         if (net_ratelimit())\par
  983             pr_warn("%s: packet loop detected, dropping.\\n",\par
  984                 ovs_dp_name(dp));\par
  985 \par
  986         kfree_skb(skb);\par
  987         return -ELOOP;\par
  988     \}\par
  989 \par
  990     this_cpu_inc(exec_actions_level);\par
  991     err = do_execute_actions(dp, skb, key,\par
  992                  acts->actions, acts->actions_len);\par
  993 \par
  994     if (!level)\par
  995         process_deferred_actions(dp);\par
  996 \par
  997     this_cpu_dec(exec_actions_level);\par
  998 \par
  999     /* This return status currently does not reflect the errors\par
 1000      * encounted during deferred actions execution. Probably needs to\par
 1001      * be fixed in the future.\par
 1002      */\par
 1003     return err;\par
 1004 \}\par
}
}
{\xe \v pop_mpls\:actions.c}
{\xe \v actions.c\:pop_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int pop_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const __be16  {\i ethertype}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   163 \{\par
  164     struct ethhdr *hdr;\par
  165     int err;\par
  166 \par
  167     err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\par
  168     if (unlikely(err))\par
  169         return err;\par
  170 \par
  171     skb_postpull_rcsum(skb, skb_mpls_header(skb), MPLS_HLEN);\par
  172 \par
  173     memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),\par
  174         skb->mac_len);\par
  175 \par
  176     __skb_pull(skb, MPLS_HLEN);\par
  177     skb_reset_mac_header(skb);\par
  178 \par
  179     /* skb_mpls_header() is used to locate the ethertype\par
  180      * field correctly in the presence of VLAN tags.\par
  181      */\par
  182     hdr = (struct ethhdr *)(skb_mpls_header(skb) - ETH_HLEN);\par
  183     hdr->h_proto = ethertype;\par
  184     if (eth_p_mpls(skb->protocol))\par
  185         skb->protocol = ethertype;\par
  186 \par
  187     invalidate_flow_key(key);\par
  188     return 0;\par
  189 \}\par
}
}
{\xe \v pop_vlan\:actions.c}
{\xe \v actions.c\:pop_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int pop_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221 \{\par
  222     int err;\par
  223 \par
  224     err = skb_vlan_pop(skb);\par
  225     if (skb_vlan_tag_present(skb))\par
  226         invalidate_flow_key(key);\par
  227     else\par
  228         key->eth.tci = 0;\par
  229     return err;\par
  230 \}\par
}
}
{\xe \v process_deferred_actions\:actions.c}
{\xe \v actions.c\:process_deferred_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void process_deferred_actions (struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   948 \{\par
  949     struct action_fifo *fifo = this_cpu_ptr(action_fifos);\par
  950 \par
  951     /* Do not touch the FIFO in case there is no deferred actions. */\par
  952     if (action_fifo_is_empty(fifo))\par
  953         return;\par
  954 \par
  955     /* Finishing executing all deferred actions. */\par
  956     do \{\par
  957         struct deferred_action *da = action_fifo_get(fifo);\par
  958         struct sk_buff *skb = da->skb;\par
  959         struct sw_flow_key *key = &da->pkt_key;\par
  960         const struct nlattr *actions = da->actions;\par
  961 \par
  962         if (actions)\par
  963             do_execute_actions(dp, skb, key, actions,\par
  964                        nla_len(actions));\par
  965         else\par
  966             ovs_dp_process_packet(skb, key);\par
  967     \} while (!action_fifo_is_empty(fifo));\par
  968 \par
  969     /* Reset FIFO for the next packet.  */\par
  970     action_fifo_init(fifo);\par
  971 \}\par
}
}
{\xe \v push_mpls\:actions.c}
{\xe \v actions.c\:push_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int push_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct {\b ovs_action_push_mpls} *  {\i mpls}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   128 \{\par
  129     __be32 *new_mpls_lse;\par
  130     struct ethhdr *hdr;\par
  131 \par
  132     /* Networking stack do not allow simultaneous Tunnel and MPLS GSO. */\par
  133     if (skb_encapsulation(skb))\par
  134         return -ENOTSUPP;\par
  135 \par
  136     if (skb_cow_head(skb, MPLS_HLEN) < 0)\par
  137         return -ENOMEM;\par
  138 \par
  139     skb_push(skb, MPLS_HLEN);\par
  140     memmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),\par
  141         skb->mac_len);\par
  142     skb_reset_mac_header(skb);\par
  143 \par
  144     new_mpls_lse = (__be32 *)skb_mpls_header(skb);\par
  145     *new_mpls_lse = mpls->mpls_lse;\par
  146 \par
  147     if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  148         skb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,\par
  149                                  MPLS_HLEN, 0));\par
  150 \par
  151     hdr = eth_hdr(skb);\par
  152     hdr->h_proto = mpls->mpls_ethertype;\par
  153     if (!ovs_skb_get_inner_protocol(skb))\par
  154         ovs_skb_set_inner_protocol(skb, skb->protocol);\par
  155     skb->protocol = mpls->mpls_ethertype;\par
  156 \par
  157     invalidate_flow_key(key);\par
  158     return 0;\par
  159 \}\par
}
}
{\xe \v push_vlan\:actions.c}
{\xe \v actions.c\:push_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int push_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct {\b ovs_action_push_vlan} *  {\i vlan}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234 \{\par
  235     if (skb_vlan_tag_present(skb))\par
  236         invalidate_flow_key(key);\par
  237     else\par
  238         key->eth.tci = vlan->vlan_tci;\par
  239     return skb_vlan_push(skb, vlan->vlan_tpid,\par
  240                  ntohs(vlan->vlan_tci) & ~VLAN_TAG_PRESENT);\par
  241 \}\par
}
}
{\xe \v sample\:actions.c}
{\xe \v actions.c\:sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int sample (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, const struct nlattr *  {\i actions}, int  {\i actions_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   668 \{\par
  669     const struct nlattr *acts_list = NULL;\par
  670     const struct nlattr *a;\par
  671     int rem;\par
  672 \par
  673     for (a = nla_data(attr), rem = nla_len(attr); rem > 0;\par
  674          a = nla_next(a, &rem)) \{\par
  675         switch (nla_type(a)) \{\par
  676         case OVS_SAMPLE_ATTR_PROBABILITY:\par
  677             if (prandom_u32() >= nla_get_u32(a))\par
  678                 return 0;\par
  679             break;\par
  680 \par
  681         case OVS_SAMPLE_ATTR_ACTIONS:\par
  682             acts_list = a;\par
  683             break;\par
  684         \}\par
  685     \}\par
  686 \par
  687     rem = nla_len(acts_list);\par
  688     a = nla_data(acts_list);\par
  689 \par
  690     /* Actions list is empty, do nothing */\par
  691     if (unlikely(!rem))\par
  692         return 0;\par
  693 \par
  694     /* The only known usage of sample action is having a single user-space\par
  695      * action. Treat this usage as a special case.\par
  696      * The output_userspace() should clone the skb to be sent to the\par
  697      * user space. This skb will be consumed by its caller.\par
  698      */\par
  699     if (likely(nla_type(a) == OVS_ACTION_ATTR_USERSPACE &&\par
  700            nla_is_last(a, rem)))\par
  701         return output_userspace(dp, skb, key, a, actions, actions_len);\par
  702 \par
  703     skb = skb_clone(skb, GFP_ATOMIC);\par
  704     if (!skb)\par
  705         /* Skip the sample action when out of memory. */\par
  706         return 0;\par
  707 \par
  708     if (!add_deferred_actions(skb, key, a)) \{\par
  709         if (net_ratelimit())\par
  710             pr_warn("%s: deferred actions limit reached, dropping sample action\\n",\par
  711                 ovs_dp_name(dp));\par
  712 \par
  713         kfree_skb(skb);\par
  714     \}\par
  715     return 0;\par
  716 \}\par
}
}
{\xe \v set_eth_addr\:actions.c}
{\xe \v actions.c\:set_eth_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_eth_addr (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ethernet} *  {\i key}, const struct {\b ovs_key_ethernet} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     int err;\par
  260 \par
  261     err = skb_ensure_writable(skb, ETH_HLEN);\par
  262     if (unlikely(err))\par
  263         return err;\par
  264 \par
  265     skb_postpull_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\par
  266 \par
  267     ether_addr_copy_masked(eth_hdr(skb)->h_source, key->eth_src,\par
  268                    mask->eth_src);\par
  269     ether_addr_copy_masked(eth_hdr(skb)->h_dest, key->eth_dst,\par
  270                    mask->eth_dst);\par
  271 \par
  272     ovs_skb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\par
  273 \par
  274     ether_addr_copy(flow_key->eth.src, eth_hdr(skb)->h_source);\par
  275     ether_addr_copy(flow_key->eth.dst, eth_hdr(skb)->h_dest);\par
  276     return 0;\par
  277 \}\par
}
}
{\xe \v set_ip_addr\:actions.c}
{\xe \v actions.c\:set_ip_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ip_addr (struct sk_buff *  {\i skb}, struct iphdr *  {\i nh}, __be32 *  {\i addr}, __be32  {\i new_addr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   281 \{\par
  282     int transport_len = skb->len - skb_transport_offset(skb);\par
  283 \par
  284     if (nh->protocol == IPPROTO_TCP) \{\par
  285         if (likely(transport_len >= sizeof(struct tcphdr)))\par
  286             inet_proto_csum_replace4(&tcp_hdr(skb)->check, skb,\par
  287                          *addr, new_addr, 1);\par
  288     \} else if (nh->protocol == IPPROTO_UDP) \{\par
  289         if (likely(transport_len >= sizeof(struct udphdr))) \{\par
  290             struct udphdr *uh = udp_hdr(skb);\par
  291 \par
  292             if (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) \{\par
  293                 inet_proto_csum_replace4(&uh->check, skb,\par
  294                              *addr, new_addr, 1);\par
  295                 if (!uh->check)\par
  296                     uh->check = CSUM_MANGLED_0;\par
  297             \}\par
  298         \}\par
  299     \}\par
  300 \par
  301     csum_replace4(&nh->check, *addr, new_addr);\par
  302     skb_clear_hash(skb);\par
  303     *addr = new_addr;\par
  304 \}\par
}
}
{\xe \v set_ip_ttl\:actions.c}
{\xe \v actions.c\:set_ip_ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ip_ttl (struct sk_buff *  {\i skb}, struct iphdr *  {\i nh}, u8  {\i new_ttl}, u8  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   363 \{\par
  364     new_ttl = MASKED(nh->ttl, new_ttl, mask);\par
  365 \par
  366     csum_replace2(&nh->check, htons(nh->ttl << 8), htons(new_ttl << 8));\par
  367     nh->ttl = new_ttl;\par
  368 \}\par
}
}
{\xe \v set_ipv4\:actions.c}
{\xe \v actions.c\:set_ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_ipv4 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ipv4} *  {\i key}, const struct {\b ovs_key_ipv4} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   373 \{\par
  374     struct iphdr *nh;\par
  375     __be32 new_addr;\par
  376     int err;\par
  377 \par
  378     err = skb_ensure_writable(skb, skb_network_offset(skb) +\par
  379                   sizeof(struct iphdr));\par
  380     if (unlikely(err))\par
  381         return err;\par
  382 \par
  383     nh = ip_hdr(skb);\par
  384 \par
  385     /* Setting an IP addresses is typically only a side effect of\par
  386      * matching on them in the current userspace implementation, so it\par
  387      * makes sense to check if the value actually changed.\par
  388      */\par
  389     if (mask->ipv4_src) \{\par
  390         new_addr = MASKED(nh->saddr, key->ipv4_src, mask->ipv4_src);\par
  391 \par
  392         if (unlikely(new_addr != nh->saddr)) \{\par
  393             set_ip_addr(skb, nh, &nh->saddr, new_addr);\par
  394             flow_key->ipv4.addr.src = new_addr;\par
  395         \}\par
  396     \}\par
  397     if (mask->ipv4_dst) \{\par
  398         new_addr = MASKED(nh->daddr, key->ipv4_dst, mask->ipv4_dst);\par
  399 \par
  400         if (unlikely(new_addr != nh->daddr)) \{\par
  401             set_ip_addr(skb, nh, &nh->daddr, new_addr);\par
  402             flow_key->ipv4.addr.dst = new_addr;\par
  403         \}\par
  404     \}\par
  405     if (mask->ipv4_tos) \{\par
  406         ipv4_change_dsfield(nh, ~mask->ipv4_tos, key->ipv4_tos);\par
  407         flow_key->ip.tos = nh->tos;\par
  408     \}\par
  409     if (mask->ipv4_ttl) \{\par
  410         set_ip_ttl(skb, nh, key->ipv4_ttl, mask->ipv4_ttl);\par
  411         flow_key->ip.ttl = nh->ttl;\par
  412     \}\par
  413 \par
  414     return 0;\par
  415 \}\par
}
}
{\xe \v set_ipv6\:actions.c}
{\xe \v actions.c\:set_ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_ipv6 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ipv6} *  {\i key}, const struct {\b ovs_key_ipv6} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   425 \{\par
  426     struct ipv6hdr *nh;\par
  427     int err;\par
  428 \par
  429     err = skb_ensure_writable(skb, skb_network_offset(skb) +\par
  430                   sizeof(struct ipv6hdr));\par
  431     if (unlikely(err))\par
  432         return err;\par
  433 \par
  434     nh = ipv6_hdr(skb);\par
  435 \par
  436     /* Setting an IP addresses is typically only a side effect of\par
  437      * matching on them in the current userspace implementation, so it\par
  438      * makes sense to check if the value actually changed.\par
  439      */\par
  440     if (is_ipv6_mask_nonzero(mask->ipv6_src)) \{\par
  441         __be32 *saddr = (__be32 *)&nh->saddr;\par
  442         __be32 masked[4];\par
  443 \par
  444         mask_ipv6_addr(saddr, key->ipv6_src, mask->ipv6_src, masked);\par
  445 \par
  446         if (unlikely(memcmp(saddr, masked, sizeof(masked)))) \{\par
  447             set_ipv6_addr(skb, key->ipv6_proto, saddr, masked,\par
  448                       true);\par
  449             memcpy(&flow_key->ipv6.addr.src, masked,\par
  450                    sizeof(flow_key->ipv6.addr.src));\par
  451         \}\par
  452     \}\par
  453     if (is_ipv6_mask_nonzero(mask->ipv6_dst)) \{\par
  454         unsigned int offset = 0;\par
  455         int flags = IP6_FH_F_SKIP_RH;\par
  456         bool recalc_csum = true;\par
  457         __be32 *daddr = (__be32 *)&nh->daddr;\par
  458         __be32 masked[4];\par
  459 \par
  460         mask_ipv6_addr(daddr, key->ipv6_dst, mask->ipv6_dst, masked);\par
  461 \par
  462         if (unlikely(memcmp(daddr, masked, sizeof(masked)))) \{\par
  463             if (ipv6_ext_hdr(nh->nexthdr))\par
  464                 recalc_csum = (ipv6_find_hdr(skb, &offset,\par
  465                                  NEXTHDR_ROUTING,\par
  466                                  NULL, &flags)\par
  467                            != NEXTHDR_ROUTING);\par
  468 \par
  469             set_ipv6_addr(skb, key->ipv6_proto, daddr, masked,\par
  470                       recalc_csum);\par
  471             memcpy(&flow_key->ipv6.addr.dst, masked,\par
  472                    sizeof(flow_key->ipv6.addr.dst));\par
  473         \}\par
  474     \}\par
  475     if (mask->ipv6_tclass) \{\par
  476         ipv6_change_dsfield(nh, ~mask->ipv6_tclass, key->ipv6_tclass);\par
  477         flow_key->ip.tos = ipv6_get_dsfield(nh);\par
  478     \}\par
  479     if (mask->ipv6_label) \{\par
  480         set_ipv6_fl(nh, ntohl(key->ipv6_label),\par
  481                 ntohl(mask->ipv6_label));\par
  482         flow_key->ipv6.label =\par
  483             *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\par
  484     \}\par
  485     if (mask->ipv6_hlimit) \{\par
  486         SET_MASKED(nh->hop_limit, key->ipv6_hlimit, mask->ipv6_hlimit);\par
  487         flow_key->ip.ttl = nh->hop_limit;\par
  488     \}\par
  489     return 0;\par
  490 \}\par
}
}
{\xe \v set_ipv6_addr\:actions.c}
{\xe \v actions.c\:set_ipv6_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ipv6_addr (struct sk_buff *  {\i skb}, u8  {\i l4_proto}, __be32  {\i addr}[4], const __be32  {\i new_addr}[4], {\b bool}  {\i recalculate_csum}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   345 \{\par
  346     if (likely(recalculate_csum))\par
  347         update_ipv6_checksum(skb, l4_proto, addr, new_addr);\par
  348 \par
  349     skb_clear_hash(skb);\par
  350     memcpy(addr, new_addr, sizeof(__be32[4]));\par
  351 \}\par
}
}
{\xe \v set_ipv6_fl\:actions.c}
{\xe \v actions.c\:set_ipv6_fl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ipv6_fl (struct ipv6hdr *  {\i nh}, u32  {\i fl}, u32  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   354 \{\par
  355     /* Bits 21-24 are always unmasked, so this retains their values. */\par
  356     SET_MASKED(nh->flow_lbl[0], (u8)(fl >> 16), (u8)(mask >> 16));\par
  357     SET_MASKED(nh->flow_lbl[1], (u8)(fl >> 8), (u8)(mask >> 8));\par
  358     SET_MASKED(nh->flow_lbl[2], (u8)fl, (u8)mask);\par
  359 \}\par
}
}
{\xe \v set_mpls\:actions.c}
{\xe \v actions.c\:set_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const __be32 *  {\i mpls_lse}, const __be32 *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   197 \{\par
  198     __be32 *stack;\par
  199     __be32 lse;\par
  200     int err;\par
  201 \par
  202     err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\par
  203     if (unlikely(err))\par
  204         return err;\par
  205 \par
  206     stack = (__be32 *)skb_mpls_header(skb);\par
  207     lse = MASKED(*stack, *mpls_lse, *mask);\par
  208     if (skb->ip_summed == CHECKSUM_COMPLETE) \{\par
  209         __be32 diff[] = \{ ~(*stack), lse \};\par
  210 \par
  211         skb->csum = ~csum_partial((char *)diff, sizeof(diff),\par
  212                       ~skb->csum);\par
  213     \}\par
  214 \par
  215     *stack = lse;\par
  216     flow_key->mpls.top_lse = lse;\par
  217     return 0;\par
  218 \}\par
}
}
{\xe \v set_sctp\:actions.c}
{\xe \v actions.c\:set_sctp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_sctp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_sctp} *  {\i key}, const struct {\b ovs_key_sctp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   574 \{\par
  575     unsigned int sctphoff = skb_transport_offset(skb);\par
  576     struct sctphdr *sh;\par
  577     __le32 old_correct_csum, new_csum, old_csum;\par
  578     int err;\par
  579 \par
  580     err = skb_ensure_writable(skb, sctphoff + sizeof(struct sctphdr));\par
  581     if (unlikely(err))\par
  582         return err;\par
  583 \par
  584     sh = sctp_hdr(skb);\par
  585     old_csum = sh->checksum;\par
  586     old_correct_csum = sctp_compute_cksum(skb, sctphoff);\par
  587 \par
  588     sh->source = MASKED(sh->source, key->sctp_src, mask->sctp_src);\par
  589     sh->dest = MASKED(sh->dest, key->sctp_dst, mask->sctp_dst);\par
  590 \par
  591     new_csum = sctp_compute_cksum(skb, sctphoff);\par
  592 \par
  593     /* Carry any checksum errors through. */\par
  594     sh->checksum = old_csum ^ old_correct_csum ^ new_csum;\par
  595 \par
  596     skb_clear_hash(skb);\par
  597     flow_key->tp.src = sh->source;\par
  598     flow_key->tp.dst = sh->dest;\par
  599 \par
  600     return 0;\par
  601 \}\par
}
}
{\xe \v set_tcp\:actions.c}
{\xe \v actions.c\:set_tcp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_tcp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_tcp} *  {\i key}, const struct {\b ovs_key_tcp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   545 \{\par
  546     struct tcphdr *th;\par
  547     __be16 src, dst;\par
  548     int err;\par
  549 \par
  550     err = skb_ensure_writable(skb, skb_transport_offset(skb) +\par
  551                   sizeof(struct tcphdr));\par
  552     if (unlikely(err))\par
  553         return err;\par
  554 \par
  555     th = tcp_hdr(skb);\par
  556     src = MASKED(th->source, key->tcp_src, mask->tcp_src);\par
  557     if (likely(src != th->source)) \{\par
  558         set_tp_port(skb, &th->source, src, &th->check);\par
  559         flow_key->tp.src = src;\par
  560     \}\par
  561     dst = MASKED(th->dest, key->tcp_dst, mask->tcp_dst);\par
  562     if (likely(dst != th->dest)) \{\par
  563         set_tp_port(skb, &th->dest, dst, &th->check);\par
  564         flow_key->tp.dst = dst;\par
  565     \}\par
  566     skb_clear_hash(skb);\par
  567 \par
  568     return 0;\par
  569 \}\par
}
}
{\xe \v set_tp_port\:actions.c}
{\xe \v actions.c\:set_tp_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_tp_port (struct sk_buff *  {\i skb}, __be16 *  {\i port}, __be16  {\i new_port}, {\b __sum16} *  {\i check}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   495 \{\par
  496     inet_proto_csum_replace2(check, skb, *port, new_port, 0);\par
  497     *port = new_port;\par
  498 \}\par
}
}
{\xe \v set_udp\:actions.c}
{\xe \v actions.c\:set_udp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_udp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_udp} *  {\i key}, const struct {\b ovs_key_udp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   503 \{\par
  504     struct udphdr *uh;\par
  505     __be16 src, dst;\par
  506     int err;\par
  507 \par
  508     err = skb_ensure_writable(skb, skb_transport_offset(skb) +\par
  509                   sizeof(struct udphdr));\par
  510     if (unlikely(err))\par
  511         return err;\par
  512 \par
  513     uh = udp_hdr(skb);\par
  514     /* Either of the masks is non-zero, so do not bother checking them. */\par
  515     src = MASKED(uh->source, key->udp_src, mask->udp_src);\par
  516     dst = MASKED(uh->dest, key->udp_dst, mask->udp_dst);\par
  517 \par
  518     if (uh->check && skb->ip_summed != CHECKSUM_PARTIAL) \{\par
  519         if (likely(src != uh->source)) \{\par
  520             set_tp_port(skb, &uh->source, src, &uh->check);\par
  521             flow_key->tp.src = src;\par
  522         \}\par
  523         if (likely(dst != uh->dest)) \{\par
  524             set_tp_port(skb, &uh->dest, dst, &uh->check);\par
  525             flow_key->tp.dst = dst;\par
  526         \}\par
  527 \par
  528         if (unlikely(!uh->check))\par
  529             uh->check = CSUM_MANGLED_0;\par
  530     \} else \{\par
  531         uh->source = src;\par
  532         uh->dest = dst;\par
  533         flow_key->tp.src = src;\par
  534         flow_key->tp.dst = dst;\par
  535     \}\par
  536 \par
  537     skb_clear_hash(skb);\par
  538 \par
  539     return 0;\par
  540 \}\par
}
}
{\xe \v update_ipv6_checksum\:actions.c}
{\xe \v actions.c\:update_ipv6_checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void update_ipv6_checksum (struct sk_buff *  {\i skb}, u8  {\i l4_proto}, __be32  {\i addr}[4], const __be32  {\i new_addr}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309     int transport_len = skb->len - skb_transport_offset(skb);\par
  310 \par
  311     if (l4_proto == NEXTHDR_TCP) \{\par
  312         if (likely(transport_len >= sizeof(struct tcphdr)))\par
  313             inet_proto_csum_replace16(&tcp_hdr(skb)->check, skb,\par
  314                           addr, new_addr, 1);\par
  315     \} else if (l4_proto == NEXTHDR_UDP) \{\par
  316         if (likely(transport_len >= sizeof(struct udphdr))) \{\par
  317             struct udphdr *uh = udp_hdr(skb);\par
  318 \par
  319             if (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) \{\par
  320                 inet_proto_csum_replace16(&uh->check, skb,\par
  321                               addr, new_addr, 1);\par
  322                 if (!uh->check)\par
  323                     uh->check = CSUM_MANGLED_0;\par
  324             \}\par
  325         \}\par
  326     \} else if (l4_proto == NEXTHDR_ICMP) \{\par
  327         if (likely(transport_len >= sizeof(struct icmp6hdr)))\par
  328             inet_proto_csum_replace16(&icmp6_hdr(skb)->icmp6_cksum,\par
  329                           skb, addr, new_addr, 1);\par
  330     \}\par
  331 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v action_fifos\:actions.c}
{\xe \v actions.c\:action_fifos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b action_fifo} {\b __percpu}* action_fifos{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/actions.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/actions.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/actions.c}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/in6.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/checksum.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/sctp/checksum.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for actions.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2actions_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b deferred_action}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b action_fifo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEFERRED_ACTION_FIFO_SIZE}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXEC_ACTIONS_LEVEL_LIMIT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MASKED}(OLD,  KEY,  MASK)\~ ((KEY) | ((OLD) & ~(MASK)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SET_MASKED}(OLD,  KEY,  MASK)\~ ((OLD) = {\b MASKED}(OLD, KEY, MASK))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b get_mask}(a,  {\b type})\~ ((const {\b type})nla_data(a) + 1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b do_execute_actions} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DEFINE_PER_CPU} (int, exec_actions_level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b action_fifo_init} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b action_fifo_is_empty} (const struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b action_fifo_get} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b action_fifo_put} (struct {\b action_fifo} *fifo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b deferred_action} * {\b add_deferred_actions} (struct sk_buff *skb, const struct {\b sw_flow_key} *key, const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b invalidate_flow_key} (struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_flow_key_valid} (const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b push_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct {\b ovs_action_push_mpls} *{\b mpls})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b pop_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const __be16 ethertype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_mpls} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const __be32 *mpls_lse, const __be32 *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b pop_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b push_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct {\b ovs_action_push_vlan} *vlan)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ether_addr_copy_masked} (u8 *dst_, const u8 *src_, const u8 *mask_)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_eth_addr} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ethernet} *key, const struct {\b ovs_key_ethernet} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ip_addr} (struct sk_buff *skb, struct iphdr *nh, __be32 *{\b addr}, __be32 new_addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b update_ipv6_checksum} (struct sk_buff *skb, u8 l4_proto, __be32 {\b addr}[4], const __be32 new_addr[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_ipv6_addr} (const __be32 old[4], const __be32 {\b addr}[4], const __be32 mask[4], __be32 masked[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ipv6_addr} (struct sk_buff *skb, u8 l4_proto, __be32 {\b addr}[4], const __be32 new_addr[4], {\b bool} recalculate_csum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ipv6_fl} (struct ipv6hdr *nh, u32 fl, u32 mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_ip_ttl} (struct sk_buff *skb, struct iphdr *nh, u8 new_ttl, u8 mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_ipv4} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ipv4} *key, const struct {\b ovs_key_ipv4} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_ipv6_mask_nonzero} (const __be32 {\b addr}[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_ipv6} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_ipv6} *key, const struct {\b ovs_key_ipv6} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_tp_port} (struct sk_buff *skb, __be16 *port, __be16 new_port, {\b __sum16} *check)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_udp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_udp} *key, const struct {\b ovs_key_udp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_tcp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_tcp} *key, const struct {\b ovs_key_tcp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_sctp} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct {\b ovs_key_sctp} *key, const struct {\b ovs_key_sctp} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b do_output} (struct {\b datapath} *dp, struct sk_buff *skb, int out_port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b output_userspace} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, const struct nlattr *actions, int actions_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sample} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr, const struct nlattr *actions, int actions_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b execute_hash} (struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_set_action} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct nlattr *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_masked_set_action} (struct sk_buff *skb, struct {\b sw_flow_key} *flow_key, const struct nlattr *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b execute_recirc} (struct {\b datapath} *dp, struct sk_buff *skb, struct {\b sw_flow_key} *key, const struct nlattr *a, int rem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_deferred_actions} (struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_execute_actions} (struct {\b datapath} *dp, struct sk_buff *skb, const struct {\b sw_flow_actions} *acts, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b action_fifos_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b action_fifos_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b action_fifo} {\b __percpu} * {\b action_fifos}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEFERRED_ACTION_FIFO_SIZE\:linux/actions.c}
{\xe \v linux/actions.c\:DEFERRED_ACTION_FIFO_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEFERRED_ACTION_FIFO_SIZE\~ 10}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXEC_ACTIONS_LEVEL_LIMIT\:linux/actions.c}
{\xe \v linux/actions.c\:EXEC_ACTIONS_LEVEL_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXEC_ACTIONS_LEVEL_LIMIT}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4   /* limit used to detect packet\par
                      * looping by the network stack\par
                      */\par
}
}
{\xe \v get_mask\:linux/actions.c}
{\xe \v linux/actions.c\:get_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define get_mask( a,  {\b type})\~ ((const {\b type})nla_data(a) + 1)}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MASKED\:linux/actions.c}
{\xe \v linux/actions.c\:MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MASKED( OLD,  KEY,  MASK)\~ ((KEY) | ((OLD) & ~(MASK)))}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:linux/actions.c}
{\xe \v linux/actions.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SET_MASKED\:linux/actions.c}
{\xe \v linux/actions.c\:SET_MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SET_MASKED( OLD,  KEY,  MASK)\~ ((OLD) = {\b MASKED}(OLD, KEY, MASK))}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v action_fifo_get\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifo_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* action_fifo_get (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83     if (action_fifo_is_empty(fifo))\par
   84         return NULL;\par
   85 \par
   86     return &fifo->fifo[fifo->tail++];\par
   87 \}\par
}
}
{\xe \v action_fifo_init\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifo_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void action_fifo_init (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     fifo->head = 0;\par
   73     fifo->tail = 0;\par
   74 \}\par
}
}
{\xe \v action_fifo_is_empty\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifo_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} action_fifo_is_empty (const struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    77 \{\par
   78     return (fifo->head == fifo->tail);\par
   79 \}\par
}
}
{\xe \v action_fifo_put\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifo_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* action_fifo_put (struct {\b action_fifo} *  {\i fifo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90 \{\par
   91     if (fifo->head >= DEFERRED_ACTION_FIFO_SIZE - 1)\par
   92         return NULL;\par
   93 \par
   94     return &fifo->fifo[fifo->head++];\par
   95 \}\par
}
}
{\xe \v action_fifos_exit\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifos_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void action_fifos_exit (void )}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1016 \{\par
 1017     free_percpu(action_fifos);\par
 1018 \}\par
}
}
{\xe \v action_fifos_init\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifos_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int action_fifos_init (void )}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1007 \{\par
 1008     action_fifos = alloc_percpu(struct action_fifo);\par
 1009     if (!action_fifos)\par
 1010         return -ENOMEM;\par
 1011 \par
 1012     return 0;\par
 1013 \}\par
}
}
{\xe \v add_deferred_actions\:linux/actions.c}
{\xe \v linux/actions.c\:add_deferred_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b deferred_action}* add_deferred_actions (struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102     struct action_fifo *fifo;\par
  103     struct deferred_action *da;\par
  104 \par
  105     fifo = this_cpu_ptr(action_fifos);\par
  106     da = action_fifo_put(fifo);\par
  107     if (da) \{\par
  108         da->skb = skb;\par
  109         da->actions = attr;\par
  110         da->pkt_key = *key;\par
  111     \}\par
  112 \par
  113     return da;\par
  114 \}\par
}
}
{\xe \v DEFINE_PER_CPU\:linux/actions.c}
{\xe \v linux/actions.c\:DEFINE_PER_CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static DEFINE_PER_CPU (int , exec_actions_level ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v do_execute_actions\:linux/actions.c}
{\xe \v linux/actions.c\:do_execute_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int do_execute_actions (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   856 \{\par
  857     /* Every output action needs a separate clone of 'skb', but the common\par
  858      * case is just a single output action, so that doing a clone and\par
  859      * then freeing the original skbuff is wasteful.  So the following code\par
  860      * is slightly obscure just to avoid that.\par
  861      */\par
  862     int prev_port = -1;\par
  863     const struct nlattr *a;\par
  864     int rem;\par
  865 \par
  866     for (a = attr, rem = len; rem > 0;\par
  867          a = nla_next(a, &rem)) \{\par
  868         int err = 0;\par
  869 \par
  870         if (unlikely(prev_port != -1)) \{\par
  871             struct sk_buff *out_skb = skb_clone(skb, GFP_ATOMIC);\par
  872 \par
  873             if (out_skb)\par
  874                 do_output(dp, out_skb, prev_port);\par
  875 \par
  876             prev_port = -1;\par
  877         \}\par
  878 \par
  879         switch (nla_type(a)) \{\par
  880         case OVS_ACTION_ATTR_OUTPUT:\par
  881             prev_port = nla_get_u32(a);\par
  882             break;\par
  883 \par
  884         case OVS_ACTION_ATTR_USERSPACE:\par
  885             output_userspace(dp, skb, key, a, attr, len);\par
  886             break;\par
  887 \par
  888         case OVS_ACTION_ATTR_HASH:\par
  889             execute_hash(skb, key, a);\par
  890             break;\par
  891 \par
  892         case OVS_ACTION_ATTR_PUSH_MPLS:\par
  893             err = push_mpls(skb, key, nla_data(a));\par
  894             break;\par
  895 \par
  896         case OVS_ACTION_ATTR_POP_MPLS:\par
  897             err = pop_mpls(skb, key, nla_get_be16(a));\par
  898             break;\par
  899 \par
  900         case OVS_ACTION_ATTR_PUSH_VLAN:\par
  901             err = push_vlan(skb, key, nla_data(a));\par
  902             break;\par
  903 \par
  904         case OVS_ACTION_ATTR_POP_VLAN:\par
  905             err = pop_vlan(skb, key);\par
  906             break;\par
  907 \par
  908         case OVS_ACTION_ATTR_RECIRC:\par
  909             err = execute_recirc(dp, skb, key, a, rem);\par
  910             if (nla_is_last(a, rem)) \{\par
  911                 /* If this is the last action, the skb has\par
  912                  * been consumed or freed.\par
  913                  * Return immediately.\par
  914                  */\par
  915                 return err;\par
  916             \}\par
  917             break;\par
  918 \par
  919         case OVS_ACTION_ATTR_SET:\par
  920             err = execute_set_action(skb, key, nla_data(a));\par
  921             break;\par
  922 \par
  923         case OVS_ACTION_ATTR_SET_MASKED:\par
  924         case OVS_ACTION_ATTR_SET_TO_MASKED:\par
  925             err = execute_masked_set_action(skb, key, nla_data(a));\par
  926             break;\par
  927 \par
  928         case OVS_ACTION_ATTR_SAMPLE:\par
  929             err = sample(dp, skb, key, a, attr, len);\par
  930             break;\par
  931         \}\par
  932 \par
  933         if (unlikely(err)) \{\par
  934             kfree_skb(skb);\par
  935             return err;\par
  936         \}\par
  937     \}\par
  938 \par
  939     if (prev_port != -1)\par
  940         do_output(dp, skb, prev_port);\par
  941     else\par
  942         consume_skb(skb);\par
  943 \par
  944     return 0;\par
  945 \}\par
}
}
{\xe \v do_output\:linux/actions.c}
{\xe \v linux/actions.c\:do_output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void do_output (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, int  {\i out_port}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   604 \{\par
  605     struct vport *vport = ovs_vport_rcu(dp, out_port);\par
  606 \par
  607     if (likely(vport))\par
  608         ovs_vport_send(vport, skb);\par
  609     else\par
  610         kfree_skb(skb);\par
  611 \}\par
}
}
{\xe \v ether_addr_copy_masked\:linux/actions.c}
{\xe \v linux/actions.c\:ether_addr_copy_masked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ether_addr_copy_masked (u8 *  {\i dst_}, const u8 *  {\i src_}, const u8 *  {\i mask_}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   245 \{\par
  246     u16 *dst = (u16 *)dst_;\par
  247     const u16 *src = (const u16 *)src_;\par
  248     const u16 *mask = (const u16 *)mask_;\par
  249 \par
  250     SET_MASKED(dst[0], src[0], mask[0]);\par
  251     SET_MASKED(dst[1], src[1], mask[1]);\par
  252     SET_MASKED(dst[2], src[2], mask[2]);\par
  253 \}\par
}
}
{\xe \v execute_hash\:linux/actions.c}
{\xe \v linux/actions.c\:execute_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void execute_hash (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   720 \{\par
  721     struct ovs_action_hash *hash_act = nla_data(attr);\par
  722     u32 hash = 0;\par
  723 \par
  724     /* OVS_HASH_ALG_L4 is the only possible hash algorithm.  */\par
  725     hash = skb_get_hash(skb);\par
  726     hash = jhash_1word(hash, hash_act->hash_basis);\par
  727     if (!hash)\par
  728         hash = 0x1;\par
  729 \par
  730     key->ovs_flow_hash = hash;\par
  731 \}\par
}
}
{\xe \v execute_masked_set_action\:linux/actions.c}
{\xe \v linux/actions.c\:execute_masked_set_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_masked_set_action (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct nlattr *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   752 \{\par
  753     int err = 0;\par
  754 \par
  755     switch (nla_type(a)) \{\par
  756     case OVS_KEY_ATTR_PRIORITY:\par
  757         SET_MASKED(skb->priority, nla_get_u32(a), *get_mask(a, u32 *));\par
  758         flow_key->phy.priority = skb->priority;\par
  759         break;\par
  760 \par
  761     case OVS_KEY_ATTR_SKB_MARK:\par
  762         SET_MASKED(skb->mark, nla_get_u32(a), *get_mask(a, u32 *));\par
  763         flow_key->phy.skb_mark = skb->mark;\par
  764         break;\par
  765 \par
  766     case OVS_KEY_ATTR_TUNNEL_INFO:\par
  767         /* Masked data not supported for tunnel. */\par
  768         err = -EINVAL;\par
  769         break;\par
  770 \par
  771     case OVS_KEY_ATTR_ETHERNET:\par
  772         err = set_eth_addr(skb, flow_key, nla_data(a),\par
  773                    get_mask(a, struct ovs_key_ethernet *));\par
  774         break;\par
  775 \par
  776     case OVS_KEY_ATTR_IPV4:\par
  777         err = set_ipv4(skb, flow_key, nla_data(a),\par
  778                    get_mask(a, struct ovs_key_ipv4 *));\par
  779         break;\par
  780 \par
  781     case OVS_KEY_ATTR_IPV6:\par
  782         err = set_ipv6(skb, flow_key, nla_data(a),\par
  783                    get_mask(a, struct ovs_key_ipv6 *));\par
  784         break;\par
  785 \par
  786     case OVS_KEY_ATTR_TCP:\par
  787         err = set_tcp(skb, flow_key, nla_data(a),\par
  788                   get_mask(a, struct ovs_key_tcp *));\par
  789         break;\par
  790 \par
  791     case OVS_KEY_ATTR_UDP:\par
  792         err = set_udp(skb, flow_key, nla_data(a),\par
  793                   get_mask(a, struct ovs_key_udp *));\par
  794         break;\par
  795 \par
  796     case OVS_KEY_ATTR_SCTP:\par
  797         err = set_sctp(skb, flow_key, nla_data(a),\par
  798                    get_mask(a, struct ovs_key_sctp *));\par
  799         break;\par
  800 \par
  801     case OVS_KEY_ATTR_MPLS:\par
  802         err = set_mpls(skb, flow_key, nla_data(a), get_mask(a,\par
  803                                     __be32 *));\par
  804         break;\par
  805     \}\par
  806 \par
  807     return err;\par
  808 \}\par
}
}
{\xe \v execute_recirc\:linux/actions.c}
{\xe \v linux/actions.c\:execute_recirc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_recirc (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i a}, int  {\i rem}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   813 \{\par
  814     struct deferred_action *da;\par
  815 \par
  816     if (!is_flow_key_valid(key)) \{\par
  817         int err;\par
  818 \par
  819         err = ovs_flow_key_update(skb, key);\par
  820         if (err)\par
  821             return err;\par
  822     \}\par
  823     BUG_ON(!is_flow_key_valid(key));\par
  824 \par
  825     if (!nla_is_last(a, rem)) \{\par
  826         /* Recirc action is the not the last action\par
  827          * of the action list, need to clone the skb.\par
  828          */\par
  829         skb = skb_clone(skb, GFP_ATOMIC);\par
  830 \par
  831         /* Skip the recirc action when out of memory, but\par
  832          * continue on with the rest of the action list.\par
  833          */\par
  834         if (!skb)\par
  835             return 0;\par
  836     \}\par
  837 \par
  838     da = add_deferred_actions(skb, key, NULL);\par
  839     if (da) \{\par
  840         da->pkt_key.recirc_id = nla_get_u32(a);\par
  841     \} else \{\par
  842         kfree_skb(skb);\par
  843 \par
  844         if (net_ratelimit())\par
  845             pr_warn("%s: deferred action limit reached, drop recirc action\\n",\par
  846                 ovs_dp_name(dp));\par
  847     \}\par
  848 \par
  849     return 0;\par
  850 \}\par
}
}
{\xe \v execute_set_action\:linux/actions.c}
{\xe \v linux/actions.c\:execute_set_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int execute_set_action (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct nlattr *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   736 \{\par
  737     /* Only tunnel set execution is supported without a mask. */\par
  738     if (nla_type(a) == OVS_KEY_ATTR_TUNNEL_INFO) \{\par
  739         OVS_CB(skb)->egress_tun_info = nla_data(a);\par
  740         return 0;\par
  741     \}\par
  742 \par
  743     return -EINVAL;\par
  744 \}\par
}
}
{\xe \v invalidate_flow_key\:linux/actions.c}
{\xe \v linux/actions.c\:invalidate_flow_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void invalidate_flow_key (struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117 \{\par
  118     key->eth.type = htons(0);\par
  119 \}\par
}
}
{\xe \v is_flow_key_valid\:linux/actions.c}
{\xe \v linux/actions.c\:is_flow_key_valid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_flow_key_valid (const struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   122 \{\par
  123     return !!key->eth.type;\par
  124 \}\par
}
}
{\xe \v is_ipv6_mask_nonzero\:linux/actions.c}
{\xe \v linux/actions.c\:is_ipv6_mask_nonzero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_ipv6_mask_nonzero (const __be32  {\i addr}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   418 \{\par
  419     return !!(addr[0] | addr[1] | addr[2] | addr[3]);\par
  420 \}\par
}
}
{\xe \v mask_ipv6_addr\:linux/actions.c}
{\xe \v linux/actions.c\:mask_ipv6_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_ipv6_addr (const __be32  {\i old}[4], const __be32  {\i addr}[4], const __be32  {\i mask}[4], __be32  {\i masked}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   335 \{\par
  336     masked[0] = MASKED(old[0], addr[0], mask[0]);\par
  337     masked[1] = MASKED(old[1], addr[1], mask[1]);\par
  338     masked[2] = MASKED(old[2], addr[2], mask[2]);\par
  339     masked[3] = MASKED(old[3], addr[3], mask[3]);\par
  340 \}\par
}
}
{\xe \v output_userspace\:linux/actions.c}
{\xe \v linux/actions.c\:output_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int output_userspace (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, const struct nlattr *  {\i actions}, int  {\i actions_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   616 \{\par
  617     struct ovs_tunnel_info info;\par
  618     struct dp_upcall_info upcall;\par
  619     const struct nlattr *a;\par
  620     int rem;\par
  621 \par
  622     memset(&upcall, 0, sizeof(upcall));\par
  623     upcall.cmd = OVS_PACKET_CMD_ACTION;\par
  624 \par
  625     for (a = nla_data(attr), rem = nla_len(attr); rem > 0;\par
  626          a = nla_next(a, &rem)) \{\par
  627         switch (nla_type(a)) \{\par
  628         case OVS_USERSPACE_ATTR_USERDATA:\par
  629             upcall.userdata = a;\par
  630             break;\par
  631 \par
  632         case OVS_USERSPACE_ATTR_PID:\par
  633             upcall.portid = nla_get_u32(a);\par
  634             break;\par
  635 \par
  636         case OVS_USERSPACE_ATTR_EGRESS_TUN_PORT: \{\par
  637             /* Get out tunnel info. */\par
  638             struct vport *vport;\par
  639 \par
  640             vport = ovs_vport_rcu(dp, nla_get_u32(a));\par
  641             if (vport) \{\par
  642                 int err;\par
  643 \par
  644                 err = ovs_vport_get_egress_tun_info(vport, skb,\par
  645                                     &info);\par
  646                 if (!err)\par
  647                     upcall.egress_tun_info = &info;\par
  648             \}\par
  649             break;\par
  650         \}\par
  651 \par
  652         case OVS_USERSPACE_ATTR_ACTIONS: \{\par
  653             /* Include actions. */\par
  654             upcall.actions = actions;\par
  655             upcall.actions_len = actions_len;\par
  656             break;\par
  657         \}\par
  658 \par
  659         \} /* End of switch. */\par
  660     \}\par
  661 \par
  662     return ovs_dp_upcall(dp, skb, key, &upcall);\par
  663 \}\par
}
}
{\xe \v ovs_execute_actions\:linux/actions.c}
{\xe \v linux/actions.c\:ovs_execute_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_execute_actions (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_actions} *  {\i acts}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   977 \{\par
  978     int level = this_cpu_read(exec_actions_level);\par
  979     int err;\par
  980 \par
  981     if (unlikely(level >= EXEC_ACTIONS_LEVEL_LIMIT)) \{\par
  982         if (net_ratelimit())\par
  983             pr_warn("%s: packet loop detected, dropping.\\n",\par
  984                 ovs_dp_name(dp));\par
  985 \par
  986         kfree_skb(skb);\par
  987         return -ELOOP;\par
  988     \}\par
  989 \par
  990     this_cpu_inc(exec_actions_level);\par
  991     err = do_execute_actions(dp, skb, key,\par
  992                  acts->actions, acts->actions_len);\par
  993 \par
  994     if (!level)\par
  995         process_deferred_actions(dp);\par
  996 \par
  997     this_cpu_dec(exec_actions_level);\par
  998 \par
  999     /* This return status currently does not reflect the errors\par
 1000      * encounted during deferred actions execution. Probably needs to\par
 1001      * be fixed in the future.\par
 1002      */\par
 1003     return err;\par
 1004 \}\par
}
}
{\xe \v pop_mpls\:linux/actions.c}
{\xe \v linux/actions.c\:pop_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int pop_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const __be16  {\i ethertype}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   163 \{\par
  164     struct ethhdr *hdr;\par
  165     int err;\par
  166 \par
  167     err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\par
  168     if (unlikely(err))\par
  169         return err;\par
  170 \par
  171     skb_postpull_rcsum(skb, skb_mpls_header(skb), MPLS_HLEN);\par
  172 \par
  173     memmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),\par
  174         skb->mac_len);\par
  175 \par
  176     __skb_pull(skb, MPLS_HLEN);\par
  177     skb_reset_mac_header(skb);\par
  178 \par
  179     /* skb_mpls_header() is used to locate the ethertype\par
  180      * field correctly in the presence of VLAN tags.\par
  181      */\par
  182     hdr = (struct ethhdr *)(skb_mpls_header(skb) - ETH_HLEN);\par
  183     hdr->h_proto = ethertype;\par
  184     if (eth_p_mpls(skb->protocol))\par
  185         skb->protocol = ethertype;\par
  186 \par
  187     invalidate_flow_key(key);\par
  188     return 0;\par
  189 \}\par
}
}
{\xe \v pop_vlan\:linux/actions.c}
{\xe \v linux/actions.c\:pop_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int pop_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221 \{\par
  222     int err;\par
  223 \par
  224     err = skb_vlan_pop(skb);\par
  225     if (skb_vlan_tag_present(skb))\par
  226         invalidate_flow_key(key);\par
  227     else\par
  228         key->eth.tci = 0;\par
  229     return err;\par
  230 \}\par
}
}
{\xe \v process_deferred_actions\:linux/actions.c}
{\xe \v linux/actions.c\:process_deferred_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void process_deferred_actions (struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   948 \{\par
  949     struct action_fifo *fifo = this_cpu_ptr(action_fifos);\par
  950 \par
  951     /* Do not touch the FIFO in case there is no deferred actions. */\par
  952     if (action_fifo_is_empty(fifo))\par
  953         return;\par
  954 \par
  955     /* Finishing executing all deferred actions. */\par
  956     do \{\par
  957         struct deferred_action *da = action_fifo_get(fifo);\par
  958         struct sk_buff *skb = da->skb;\par
  959         struct sw_flow_key *key = &da->pkt_key;\par
  960         const struct nlattr *actions = da->actions;\par
  961 \par
  962         if (actions)\par
  963             do_execute_actions(dp, skb, key, actions,\par
  964                        nla_len(actions));\par
  965         else\par
  966             ovs_dp_process_packet(skb, key);\par
  967     \} while (!action_fifo_is_empty(fifo));\par
  968 \par
  969     /* Reset FIFO for the next packet.  */\par
  970     action_fifo_init(fifo);\par
  971 \}\par
}
}
{\xe \v push_mpls\:linux/actions.c}
{\xe \v linux/actions.c\:push_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int push_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct {\b ovs_action_push_mpls} *  {\i mpls}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   128 \{\par
  129     __be32 *new_mpls_lse;\par
  130     struct ethhdr *hdr;\par
  131 \par
  132     /* Networking stack do not allow simultaneous Tunnel and MPLS GSO. */\par
  133     if (skb_encapsulation(skb))\par
  134         return -ENOTSUPP;\par
  135 \par
  136     if (skb_cow_head(skb, MPLS_HLEN) < 0)\par
  137         return -ENOMEM;\par
  138 \par
  139     skb_push(skb, MPLS_HLEN);\par
  140     memmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),\par
  141         skb->mac_len);\par
  142     skb_reset_mac_header(skb);\par
  143 \par
  144     new_mpls_lse = (__be32 *)skb_mpls_header(skb);\par
  145     *new_mpls_lse = mpls->mpls_lse;\par
  146 \par
  147     if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  148         skb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,\par
  149                                  MPLS_HLEN, 0));\par
  150 \par
  151     hdr = eth_hdr(skb);\par
  152     hdr->h_proto = mpls->mpls_ethertype;\par
  153     if (!ovs_skb_get_inner_protocol(skb))\par
  154         ovs_skb_set_inner_protocol(skb, skb->protocol);\par
  155     skb->protocol = mpls->mpls_ethertype;\par
  156 \par
  157     invalidate_flow_key(key);\par
  158     return 0;\par
  159 \}\par
}
}
{\xe \v push_vlan\:linux/actions.c}
{\xe \v linux/actions.c\:push_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int push_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct {\b ovs_action_push_vlan} *  {\i vlan}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234 \{\par
  235     if (skb_vlan_tag_present(skb))\par
  236         invalidate_flow_key(key);\par
  237     else\par
  238         key->eth.tci = vlan->vlan_tci;\par
  239     return skb_vlan_push(skb, vlan->vlan_tpid,\par
  240                  ntohs(vlan->vlan_tci) & ~VLAN_TAG_PRESENT);\par
  241 \}\par
}
}
{\xe \v sample\:linux/actions.c}
{\xe \v linux/actions.c\:sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int sample (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, const struct nlattr *  {\i attr}, const struct nlattr *  {\i actions}, int  {\i actions_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   668 \{\par
  669     const struct nlattr *acts_list = NULL;\par
  670     const struct nlattr *a;\par
  671     int rem;\par
  672 \par
  673     for (a = nla_data(attr), rem = nla_len(attr); rem > 0;\par
  674          a = nla_next(a, &rem)) \{\par
  675         switch (nla_type(a)) \{\par
  676         case OVS_SAMPLE_ATTR_PROBABILITY:\par
  677             if (prandom_u32() >= nla_get_u32(a))\par
  678                 return 0;\par
  679             break;\par
  680 \par
  681         case OVS_SAMPLE_ATTR_ACTIONS:\par
  682             acts_list = a;\par
  683             break;\par
  684         \}\par
  685     \}\par
  686 \par
  687     rem = nla_len(acts_list);\par
  688     a = nla_data(acts_list);\par
  689 \par
  690     /* Actions list is empty, do nothing */\par
  691     if (unlikely(!rem))\par
  692         return 0;\par
  693 \par
  694     /* The only known usage of sample action is having a single user-space\par
  695      * action. Treat this usage as a special case.\par
  696      * The output_userspace() should clone the skb to be sent to the\par
  697      * user space. This skb will be consumed by its caller.\par
  698      */\par
  699     if (likely(nla_type(a) == OVS_ACTION_ATTR_USERSPACE &&\par
  700            nla_is_last(a, rem)))\par
  701         return output_userspace(dp, skb, key, a, actions, actions_len);\par
  702 \par
  703     skb = skb_clone(skb, GFP_ATOMIC);\par
  704     if (!skb)\par
  705         /* Skip the sample action when out of memory. */\par
  706         return 0;\par
  707 \par
  708     if (!add_deferred_actions(skb, key, a)) \{\par
  709         if (net_ratelimit())\par
  710             pr_warn("%s: deferred actions limit reached, dropping sample action\\n",\par
  711                 ovs_dp_name(dp));\par
  712 \par
  713         kfree_skb(skb);\par
  714     \}\par
  715     return 0;\par
  716 \}\par
}
}
{\xe \v set_eth_addr\:linux/actions.c}
{\xe \v linux/actions.c\:set_eth_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_eth_addr (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ethernet} *  {\i key}, const struct {\b ovs_key_ethernet} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     int err;\par
  260 \par
  261     err = skb_ensure_writable(skb, ETH_HLEN);\par
  262     if (unlikely(err))\par
  263         return err;\par
  264 \par
  265     skb_postpull_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\par
  266 \par
  267     ether_addr_copy_masked(eth_hdr(skb)->h_source, key->eth_src,\par
  268                    mask->eth_src);\par
  269     ether_addr_copy_masked(eth_hdr(skb)->h_dest, key->eth_dst,\par
  270                    mask->eth_dst);\par
  271 \par
  272     ovs_skb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\par
  273 \par
  274     ether_addr_copy(flow_key->eth.src, eth_hdr(skb)->h_source);\par
  275     ether_addr_copy(flow_key->eth.dst, eth_hdr(skb)->h_dest);\par
  276     return 0;\par
  277 \}\par
}
}
{\xe \v set_ip_addr\:linux/actions.c}
{\xe \v linux/actions.c\:set_ip_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ip_addr (struct sk_buff *  {\i skb}, struct iphdr *  {\i nh}, __be32 *  {\i addr}, __be32  {\i new_addr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   281 \{\par
  282     int transport_len = skb->len - skb_transport_offset(skb);\par
  283 \par
  284     if (nh->protocol == IPPROTO_TCP) \{\par
  285         if (likely(transport_len >= sizeof(struct tcphdr)))\par
  286             inet_proto_csum_replace4(&tcp_hdr(skb)->check, skb,\par
  287                          *addr, new_addr, 1);\par
  288     \} else if (nh->protocol == IPPROTO_UDP) \{\par
  289         if (likely(transport_len >= sizeof(struct udphdr))) \{\par
  290             struct udphdr *uh = udp_hdr(skb);\par
  291 \par
  292             if (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) \{\par
  293                 inet_proto_csum_replace4(&uh->check, skb,\par
  294                              *addr, new_addr, 1);\par
  295                 if (!uh->check)\par
  296                     uh->check = CSUM_MANGLED_0;\par
  297             \}\par
  298         \}\par
  299     \}\par
  300 \par
  301     csum_replace4(&nh->check, *addr, new_addr);\par
  302     skb_clear_hash(skb);\par
  303     *addr = new_addr;\par
  304 \}\par
}
}
{\xe \v set_ip_ttl\:linux/actions.c}
{\xe \v linux/actions.c\:set_ip_ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ip_ttl (struct sk_buff *  {\i skb}, struct iphdr *  {\i nh}, u8  {\i new_ttl}, u8  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   363 \{\par
  364     new_ttl = MASKED(nh->ttl, new_ttl, mask);\par
  365 \par
  366     csum_replace2(&nh->check, htons(nh->ttl << 8), htons(new_ttl << 8));\par
  367     nh->ttl = new_ttl;\par
  368 \}\par
}
}
{\xe \v set_ipv4\:linux/actions.c}
{\xe \v linux/actions.c\:set_ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_ipv4 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ipv4} *  {\i key}, const struct {\b ovs_key_ipv4} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   373 \{\par
  374     struct iphdr *nh;\par
  375     __be32 new_addr;\par
  376     int err;\par
  377 \par
  378     err = skb_ensure_writable(skb, skb_network_offset(skb) +\par
  379                   sizeof(struct iphdr));\par
  380     if (unlikely(err))\par
  381         return err;\par
  382 \par
  383     nh = ip_hdr(skb);\par
  384 \par
  385     /* Setting an IP addresses is typically only a side effect of\par
  386      * matching on them in the current userspace implementation, so it\par
  387      * makes sense to check if the value actually changed.\par
  388      */\par
  389     if (mask->ipv4_src) \{\par
  390         new_addr = MASKED(nh->saddr, key->ipv4_src, mask->ipv4_src);\par
  391 \par
  392         if (unlikely(new_addr != nh->saddr)) \{\par
  393             set_ip_addr(skb, nh, &nh->saddr, new_addr);\par
  394             flow_key->ipv4.addr.src = new_addr;\par
  395         \}\par
  396     \}\par
  397     if (mask->ipv4_dst) \{\par
  398         new_addr = MASKED(nh->daddr, key->ipv4_dst, mask->ipv4_dst);\par
  399 \par
  400         if (unlikely(new_addr != nh->daddr)) \{\par
  401             set_ip_addr(skb, nh, &nh->daddr, new_addr);\par
  402             flow_key->ipv4.addr.dst = new_addr;\par
  403         \}\par
  404     \}\par
  405     if (mask->ipv4_tos) \{\par
  406         ipv4_change_dsfield(nh, ~mask->ipv4_tos, key->ipv4_tos);\par
  407         flow_key->ip.tos = nh->tos;\par
  408     \}\par
  409     if (mask->ipv4_ttl) \{\par
  410         set_ip_ttl(skb, nh, key->ipv4_ttl, mask->ipv4_ttl);\par
  411         flow_key->ip.ttl = nh->ttl;\par
  412     \}\par
  413 \par
  414     return 0;\par
  415 \}\par
}
}
{\xe \v set_ipv6\:linux/actions.c}
{\xe \v linux/actions.c\:set_ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_ipv6 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_ipv6} *  {\i key}, const struct {\b ovs_key_ipv6} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   425 \{\par
  426     struct ipv6hdr *nh;\par
  427     int err;\par
  428 \par
  429     err = skb_ensure_writable(skb, skb_network_offset(skb) +\par
  430                   sizeof(struct ipv6hdr));\par
  431     if (unlikely(err))\par
  432         return err;\par
  433 \par
  434     nh = ipv6_hdr(skb);\par
  435 \par
  436     /* Setting an IP addresses is typically only a side effect of\par
  437      * matching on them in the current userspace implementation, so it\par
  438      * makes sense to check if the value actually changed.\par
  439      */\par
  440     if (is_ipv6_mask_nonzero(mask->ipv6_src)) \{\par
  441         __be32 *saddr = (__be32 *)&nh->saddr;\par
  442         __be32 masked[4];\par
  443 \par
  444         mask_ipv6_addr(saddr, key->ipv6_src, mask->ipv6_src, masked);\par
  445 \par
  446         if (unlikely(memcmp(saddr, masked, sizeof(masked)))) \{\par
  447             set_ipv6_addr(skb, key->ipv6_proto, saddr, masked,\par
  448                       true);\par
  449             memcpy(&flow_key->ipv6.addr.src, masked,\par
  450                    sizeof(flow_key->ipv6.addr.src));\par
  451         \}\par
  452     \}\par
  453     if (is_ipv6_mask_nonzero(mask->ipv6_dst)) \{\par
  454         unsigned int offset = 0;\par
  455         int flags = IP6_FH_F_SKIP_RH;\par
  456         bool recalc_csum = true;\par
  457         __be32 *daddr = (__be32 *)&nh->daddr;\par
  458         __be32 masked[4];\par
  459 \par
  460         mask_ipv6_addr(daddr, key->ipv6_dst, mask->ipv6_dst, masked);\par
  461 \par
  462         if (unlikely(memcmp(daddr, masked, sizeof(masked)))) \{\par
  463             if (ipv6_ext_hdr(nh->nexthdr))\par
  464                 recalc_csum = (ipv6_find_hdr(skb, &offset,\par
  465                                  NEXTHDR_ROUTING,\par
  466                                  NULL, &flags)\par
  467                            != NEXTHDR_ROUTING);\par
  468 \par
  469             set_ipv6_addr(skb, key->ipv6_proto, daddr, masked,\par
  470                       recalc_csum);\par
  471             memcpy(&flow_key->ipv6.addr.dst, masked,\par
  472                    sizeof(flow_key->ipv6.addr.dst));\par
  473         \}\par
  474     \}\par
  475     if (mask->ipv6_tclass) \{\par
  476         ipv6_change_dsfield(nh, ~mask->ipv6_tclass, key->ipv6_tclass);\par
  477         flow_key->ip.tos = ipv6_get_dsfield(nh);\par
  478     \}\par
  479     if (mask->ipv6_label) \{\par
  480         set_ipv6_fl(nh, ntohl(key->ipv6_label),\par
  481                 ntohl(mask->ipv6_label));\par
  482         flow_key->ipv6.label =\par
  483             *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\par
  484     \}\par
  485     if (mask->ipv6_hlimit) \{\par
  486         SET_MASKED(nh->hop_limit, key->ipv6_hlimit, mask->ipv6_hlimit);\par
  487         flow_key->ip.ttl = nh->hop_limit;\par
  488     \}\par
  489     return 0;\par
  490 \}\par
}
}
{\xe \v set_ipv6_addr\:linux/actions.c}
{\xe \v linux/actions.c\:set_ipv6_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ipv6_addr (struct sk_buff *  {\i skb}, u8  {\i l4_proto}, __be32  {\i addr}[4], const __be32  {\i new_addr}[4], {\b bool}  {\i recalculate_csum}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   345 \{\par
  346     if (likely(recalculate_csum))\par
  347         update_ipv6_checksum(skb, l4_proto, addr, new_addr);\par
  348 \par
  349     skb_clear_hash(skb);\par
  350     memcpy(addr, new_addr, sizeof(__be32[4]));\par
  351 \}\par
}
}
{\xe \v set_ipv6_fl\:linux/actions.c}
{\xe \v linux/actions.c\:set_ipv6_fl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_ipv6_fl (struct ipv6hdr *  {\i nh}, u32  {\i fl}, u32  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   354 \{\par
  355     /* Bits 21-24 are always unmasked, so this retains their values. */\par
  356     SET_MASKED(nh->flow_lbl[0], (u8)(fl >> 16), (u8)(mask >> 16));\par
  357     SET_MASKED(nh->flow_lbl[1], (u8)(fl >> 8), (u8)(mask >> 8));\par
  358     SET_MASKED(nh->flow_lbl[2], (u8)fl, (u8)mask);\par
  359 \}\par
}
}
{\xe \v set_mpls\:linux/actions.c}
{\xe \v linux/actions.c\:set_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_mpls (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const __be32 *  {\i mpls_lse}, const __be32 *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   197 \{\par
  198     __be32 *stack;\par
  199     __be32 lse;\par
  200     int err;\par
  201 \par
  202     err = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\par
  203     if (unlikely(err))\par
  204         return err;\par
  205 \par
  206     stack = (__be32 *)skb_mpls_header(skb);\par
  207     lse = MASKED(*stack, *mpls_lse, *mask);\par
  208     if (skb->ip_summed == CHECKSUM_COMPLETE) \{\par
  209         __be32 diff[] = \{ ~(*stack), lse \};\par
  210 \par
  211         skb->csum = ~csum_partial((char *)diff, sizeof(diff),\par
  212                       ~skb->csum);\par
  213     \}\par
  214 \par
  215     *stack = lse;\par
  216     flow_key->mpls.top_lse = lse;\par
  217     return 0;\par
  218 \}\par
}
}
{\xe \v set_sctp\:linux/actions.c}
{\xe \v linux/actions.c\:set_sctp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_sctp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_sctp} *  {\i key}, const struct {\b ovs_key_sctp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   574 \{\par
  575     unsigned int sctphoff = skb_transport_offset(skb);\par
  576     struct sctphdr *sh;\par
  577     __le32 old_correct_csum, new_csum, old_csum;\par
  578     int err;\par
  579 \par
  580     err = skb_ensure_writable(skb, sctphoff + sizeof(struct sctphdr));\par
  581     if (unlikely(err))\par
  582         return err;\par
  583 \par
  584     sh = sctp_hdr(skb);\par
  585     old_csum = sh->checksum;\par
  586     old_correct_csum = sctp_compute_cksum(skb, sctphoff);\par
  587 \par
  588     sh->source = MASKED(sh->source, key->sctp_src, mask->sctp_src);\par
  589     sh->dest = MASKED(sh->dest, key->sctp_dst, mask->sctp_dst);\par
  590 \par
  591     new_csum = sctp_compute_cksum(skb, sctphoff);\par
  592 \par
  593     /* Carry any checksum errors through. */\par
  594     sh->checksum = old_csum ^ old_correct_csum ^ new_csum;\par
  595 \par
  596     skb_clear_hash(skb);\par
  597     flow_key->tp.src = sh->source;\par
  598     flow_key->tp.dst = sh->dest;\par
  599 \par
  600     return 0;\par
  601 \}\par
}
}
{\xe \v set_tcp\:linux/actions.c}
{\xe \v linux/actions.c\:set_tcp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_tcp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_tcp} *  {\i key}, const struct {\b ovs_key_tcp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   545 \{\par
  546     struct tcphdr *th;\par
  547     __be16 src, dst;\par
  548     int err;\par
  549 \par
  550     err = skb_ensure_writable(skb, skb_transport_offset(skb) +\par
  551                   sizeof(struct tcphdr));\par
  552     if (unlikely(err))\par
  553         return err;\par
  554 \par
  555     th = tcp_hdr(skb);\par
  556     src = MASKED(th->source, key->tcp_src, mask->tcp_src);\par
  557     if (likely(src != th->source)) \{\par
  558         set_tp_port(skb, &th->source, src, &th->check);\par
  559         flow_key->tp.src = src;\par
  560     \}\par
  561     dst = MASKED(th->dest, key->tcp_dst, mask->tcp_dst);\par
  562     if (likely(dst != th->dest)) \{\par
  563         set_tp_port(skb, &th->dest, dst, &th->check);\par
  564         flow_key->tp.dst = dst;\par
  565     \}\par
  566     skb_clear_hash(skb);\par
  567 \par
  568     return 0;\par
  569 \}\par
}
}
{\xe \v set_tp_port\:linux/actions.c}
{\xe \v linux/actions.c\:set_tp_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_tp_port (struct sk_buff *  {\i skb}, __be16 *  {\i port}, __be16  {\i new_port}, {\b __sum16} *  {\i check}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   495 \{\par
  496     inet_proto_csum_replace2(check, skb, *port, new_port, 0);\par
  497     *port = new_port;\par
  498 \}\par
}
}
{\xe \v set_udp\:linux/actions.c}
{\xe \v linux/actions.c\:set_udp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_udp (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i flow_key}, const struct {\b ovs_key_udp} *  {\i key}, const struct {\b ovs_key_udp} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   503 \{\par
  504     struct udphdr *uh;\par
  505     __be16 src, dst;\par
  506     int err;\par
  507 \par
  508     err = skb_ensure_writable(skb, skb_transport_offset(skb) +\par
  509                   sizeof(struct udphdr));\par
  510     if (unlikely(err))\par
  511         return err;\par
  512 \par
  513     uh = udp_hdr(skb);\par
  514     /* Either of the masks is non-zero, so do not bother checking them. */\par
  515     src = MASKED(uh->source, key->udp_src, mask->udp_src);\par
  516     dst = MASKED(uh->dest, key->udp_dst, mask->udp_dst);\par
  517 \par
  518     if (uh->check && skb->ip_summed != CHECKSUM_PARTIAL) \{\par
  519         if (likely(src != uh->source)) \{\par
  520             set_tp_port(skb, &uh->source, src, &uh->check);\par
  521             flow_key->tp.src = src;\par
  522         \}\par
  523         if (likely(dst != uh->dest)) \{\par
  524             set_tp_port(skb, &uh->dest, dst, &uh->check);\par
  525             flow_key->tp.dst = dst;\par
  526         \}\par
  527 \par
  528         if (unlikely(!uh->check))\par
  529             uh->check = CSUM_MANGLED_0;\par
  530     \} else \{\par
  531         uh->source = src;\par
  532         uh->dest = dst;\par
  533         flow_key->tp.src = src;\par
  534         flow_key->tp.dst = dst;\par
  535     \}\par
  536 \par
  537     skb_clear_hash(skb);\par
  538 \par
  539     return 0;\par
  540 \}\par
}
}
{\xe \v update_ipv6_checksum\:linux/actions.c}
{\xe \v linux/actions.c\:update_ipv6_checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void update_ipv6_checksum (struct sk_buff *  {\i skb}, u8  {\i l4_proto}, __be32  {\i addr}[4], const __be32  {\i new_addr}[4]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309     int transport_len = skb->len - skb_transport_offset(skb);\par
  310 \par
  311     if (l4_proto == NEXTHDR_TCP) \{\par
  312         if (likely(transport_len >= sizeof(struct tcphdr)))\par
  313             inet_proto_csum_replace16(&tcp_hdr(skb)->check, skb,\par
  314                           addr, new_addr, 1);\par
  315     \} else if (l4_proto == NEXTHDR_UDP) \{\par
  316         if (likely(transport_len >= sizeof(struct udphdr))) \{\par
  317             struct udphdr *uh = udp_hdr(skb);\par
  318 \par
  319             if (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) \{\par
  320                 inet_proto_csum_replace16(&uh->check, skb,\par
  321                               addr, new_addr, 1);\par
  322                 if (!uh->check)\par
  323                     uh->check = CSUM_MANGLED_0;\par
  324             \}\par
  325         \}\par
  326     \} else if (l4_proto == NEXTHDR_ICMP) \{\par
  327         if (likely(transport_len >= sizeof(struct icmp6hdr)))\par
  328             inet_proto_csum_replace16(&icmp6_hdr(skb)->icmp6_cksum,\par
  329                           skb, addr, new_addr, 1);\par
  330     \}\par
  331 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v action_fifos\:linux/actions.c}
{\xe \v linux/actions.c\:action_fifos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b action_fifo} {\b __percpu}* action_fifos{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/compat.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/compat.h}
{\xe \v /home/vladn/git/ovs/datapath/compat.h}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/in.h>}\par
{\f2 #include <linux/in_route.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for compat.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GROUP_ID}(grp)\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rt_dst}(rt)\~ (rt->{\b dst})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b inet_sport}(sk)\~ (inet_sk(sk)->inet_sport)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtable * {\b find_route} (struct net *net, __be32 *saddr, __be32 daddr, u8 ipproto, u8 {\b tos}, u32 {\b skb_mark})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b skb_encapsulation} (struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v GROUP_ID\:compat.h}
{\xe \v compat.h\:GROUP_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GROUP_ID( grp)\~ 0}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v inet_sport\:compat.h}
{\xe \v compat.h\:inet_sport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define inet_sport( sk)\~ (inet_sk(sk)->inet_sport)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rt_dst\:compat.h}
{\xe \v compat.h\:rt_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rt_dst( rt)\~ (rt->{\b dst})}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v find_route\:compat.h}
{\xe \v compat.h\:find_route}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct rtable* find_route (struct net *  {\i net}, __be32 *  {\i saddr}, __be32  {\i daddr}, u8  {\i ipproto}, u8  {\i tos}, u32  {\i skb_mark}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49 \{\par
   50     struct rtable *rt;\par
   51     /* Tunnel configuration keeps DSCP part of TOS bits, But Linux\par
   52      * router expect RT_TOS bits only.\par
   53      */\par
   54 \par
   55 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)\par
   56     struct flowi fl = \{ .nl_u = \{ .ip4_u = \{\par
   57                     .daddr = daddr,\par
   58                     .saddr = *saddr,\par
   59                     .tos   = RT_TOS(tos) \} \},\par
   60                     .mark = skb_mark,\par
   61                     .proto = ipproto \};\par
   62 \par
   63     if (unlikely(ip_route_output_key(net, &rt, &fl)))\par
   64         return ERR_PTR(-EADDRNOTAVAIL);\par
   65     *saddr = fl.nl_u.ip4_u.saddr;\par
   66     return rt;\par
   67 #else\par
   68     struct flowi4 fl = \{ .daddr = daddr,\par
   69                  .saddr = *saddr,\par
   70                  .flowi4_tos = RT_TOS(tos),\par
   71                  .flowi4_mark = skb_mark,\par
   72                  .flowi4_proto = ipproto \};\par
   73 \par
   74     rt = ip_route_output_key(net, &fl);\par
   75     *saddr = fl.saddr;\par
   76     return rt;\par
   77 #endif\par
   78 \}\par
}
}
{\xe \v skb_encapsulation\:compat.h}
{\xe \v compat.h\:skb_encapsulation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} skb_encapsulation (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83     return skb->encapsulation;\par
   84 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/datapath.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/datapath.c}
{\xe \v /home/vladn/git/ovs/datapath/datapath.c}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/init.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/delay.h>}\par
{\f2 #include <linux/time.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/genetlink.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kthread.h>}\par
{\f2 #include <linux/mutex.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <linux/wait.h>}\par
{\f2 #include <asm/div64.h>}\par
{\f2 #include <linux/highmem.h>}\par
{\f2 #include <linux/netfilter_bridge.h>}\par
{\f2 #include <linux/netfilter_ipv4.h>}\par
{\f2 #include <linux/inetdevice.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/dmi.h>}\par
{\f2 #include <net/genetlink.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_table.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for datapath.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "datapath_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_net_id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_must_notify} (struct {\b genl_family} *family, struct genl_info *info, unsigned int group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_notify} (struct {\b genl_family} *family, struct genl_multicast_group *grp, struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DEFINE_MUTEX} (ovs_mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_lock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_unlock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b queue_gso_packets} (struct {\b datapath} *dp, struct sk_buff *, const struct {\b sw_flow_key} *, const struct {\b dp_upcall_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b queue_userspace_packet} (struct {\b datapath} *dp, struct sk_buff *, const struct {\b sw_flow_key} *, const struct {\b dp_upcall_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b get_dp_rcu} (struct net *net, int dp_ifindex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b get_dp} (struct net *net, int dp_ifindex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_dp_name} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b get_dpifindex} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b destroy_dp_rcu} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b vport_hash_bucket} (const struct {\b datapath} *dp, u16 port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_lookup_vport} (const struct {\b datapath} *dp, u16 port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b new_vport} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_detach_port} (struct {\b vport} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_process_packet} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_dp_upcall} (struct {\b datapath} *dp, struct sk_buff *skb, const struct {\b sw_flow_key} *key, const struct {\b dp_upcall_info} *upcall_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b upcall_msg_size} (const struct {\b dp_upcall_info} *upcall_info, unsigned int hdrlen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_packet_cmd_execute} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b get_dp_stats} (const struct {\b datapath} *dp, struct {\b ovs_dp_stats} *stats, struct {\b ovs_dp_megaflow_stats} *mega_stats)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_key} (const struct {\b sw_flow_id} *sfid, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_mask} (uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_actions} (uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b ovs_flow_cmd_msg_size} (const struct {\b sw_flow_actions} *acts, const struct {\b sw_flow_id} *sfid, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_stats} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_actions} (const struct {\b sw_flow} *flow, struct sk_buff *skb, int skb_orig_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_info} (const struct {\b sw_flow} *flow, int dp_ifindex, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd, u32 ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_flow_cmd_alloc_info} (const struct {\b sw_flow_actions} *acts, const struct {\b sw_flow_id} *sfid, struct genl_info *info, {\b bool} always, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_flow_cmd_build_info} (const struct {\b sw_flow} *flow, int dp_ifindex, struct genl_info *info, u8 cmd, {\b bool} always, u32 ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_actions} * {\b get_flow_actions} (const struct nlattr *a, const struct {\b sw_flow_key} *key, const struct {\b sw_flow_mask} *mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b ovs_dp_cmd_msg_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_fill_info} (struct {\b datapath} *dp, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_dp_cmd_alloc_info} (struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b lookup_datapath} (struct net *net, const struct {\b ovs_header} *{\b ovs_header}, struct nlattr *a[{\b OVS_DP_ATTR_MAX}+1])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_dp_reset_user_features} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_dp_change} (struct {\b datapath} *dp, struct nlattr *a[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __dp_destroy} (struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_fill_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_vport_cmd_alloc_info} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sk_buff * {\b ovs_vport_cmd_build_info} (struct {\b vport} *{\b vport}, u32 portid, u32 seq, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b lookup_vport} (struct net *net, const struct {\b ovs_header} *{\b ovs_header}, struct nlattr *a[{\b OVS_VPORT_ATTR_MAX}+1])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_unregister_genl} (int n_families)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b dp_register_genl} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __net_init {\b ovs_init_net} (struct net *net)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __net_exit {\b list_vports_from_net} (struct net *net, struct net *dnet, struct list_head *head)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __net_exit {\b ovs_exit_net} (struct net *dnet)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DEFINE_COMPAT_PNET_REG_FUNC} (device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b dp_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_cleanup} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b dp_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b dp_cleanup})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("Open vSwitch switching {\b datapath}")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_VERSION} (VERSION)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_net_id} {\b __read_mostly}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_packet_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_flow_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_datapath_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b flow_policy} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_multicast_group {\b ovs_dp_flow_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_multicast_group {\b ovs_dp_datapath_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct genl_multicast_group {\b ovs_dp_vport_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b packet_policy} [{\b OVS_PACKET_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_packet_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_flow_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b datapath_policy} [{\b OVS_DP_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_datapath_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b vport_policy} [{\b OVS_VPORT_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_vport_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b genl_family} {\b dp_vport_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} * {\b dp_genl_families} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct pernet_operations {\b ovs_net_ops}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:datapath.c}
{\xe \v datapath.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __dp_destroy\:datapath.c}
{\xe \v datapath.c\:__dp_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __dp_destroy (struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1614 \{\par
 1615     int i;\par
 1616 \par
 1617     for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 1618         struct vport *vport;\par
 1619         struct hlist_node *n;\par
 1620 \par
 1621         hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node)\par
 1622             if (vport->port_no != OVSP_LOCAL)\par
 1623                 ovs_dp_detach_port(vport);\par
 1624     \}\par
 1625 \par
 1626     list_del_rcu(&dp->list_node);\par
 1627 \par
 1628     /* OVSP_LOCAL is datapath internal port. We need to make sure that\par
 1629      * all ports in datapath are destroyed first before freeing datapath.\par
 1630      */\par
 1631     ovs_dp_detach_port(ovs_vport_ovsl(dp, OVSP_LOCAL));\par
 1632 \par
 1633     /* RCU destroy the flow table */\par
 1634     call_rcu(&dp->rcu, destroy_dp_rcu);\par
 1635 \}\par
}
}
{\xe \v DEFINE_COMPAT_PNET_REG_FUNC\:datapath.c}
{\xe \v datapath.c\:DEFINE_COMPAT_PNET_REG_FUNC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DEFINE_COMPAT_PNET_REG_FUNC (device )}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEFINE_MUTEX\:datapath.c}
{\xe \v datapath.c\:DEFINE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static DEFINE_MUTEX (ovs_mutex ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DOC: Locking:\par
All writes e.g. Writes to device state (add/remove datapath, port, set operations on vports, etc.), Writes to other state (flow table modifications, set miscellaneous datapath parameters, etc.) are protected by ovs_lock.\par
Reads are protected by RCU.\par
There are a few special cases (mostly stats) that have their own synchronization but they nest under all of above and don't interact with each other.\par
The RTNL lock nests inside ovs_mutex. \par
}}
{\xe \v destroy_dp_rcu\:datapath.c}
{\xe \v datapath.c\:destroy_dp_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void destroy_dp_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   203 \{\par
  204     struct datapath *dp = container_of(rcu, struct datapath, rcu);\par
  205 \par
  206     ovs_flow_tbl_destroy(&dp->table);\par
  207     free_percpu(dp->stats_percpu);\par
  208     release_net(ovs_dp_get_net(dp));\par
  209     kfree(dp->ports);\par
  210     kfree(dp);\par
  211 \}\par
}
}
{\xe \v dp_cleanup\:datapath.c}
{\xe \v datapath.c\:dp_cleanup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_cleanup (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2344 \{\par
 2345     dp_unregister_genl(ARRAY_SIZE(dp_genl_families));\par
 2346     ovs_netdev_exit();\par
 2347     unregister_netdevice_notifier(&ovs_dp_device_notifier);\par
 2348     unregister_pernet_device(&ovs_net_ops);\par
 2349     rcu_barrier();\par
 2350     ovs_vport_exit();\par
 2351     ovs_flow_exit();\par
 2352     ovs_internal_dev_rtnl_link_unregister();\par
 2353     action_fifos_exit();\par
 2354 \}\par
}
}
{\xe \v dp_init\:datapath.c}
{\xe \v datapath.c\:dp_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init dp_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2284 \{\par
 2285     int err;\par
 2286 \par
 2287     BUILD_BUG_ON(sizeof(struct ovs_skb_cb) > FIELD_SIZEOF(struct sk_buff, cb));\par
 2288 \par
 2289     pr_info("Open vSwitch switching datapath %s\\n", VERSION);\par
 2290 \par
 2291     err = action_fifos_init();\par
 2292     if (err)\par
 2293         goto error;\par
 2294 \par
 2295     err = ovs_internal_dev_rtnl_link_register();\par
 2296     if (err)\par
 2297         goto error_action_fifos_exit;\par
 2298 \par
 2299     err = ovs_flow_init();\par
 2300     if (err)\par
 2301         goto error_unreg_rtnl_link;\par
 2302 \par
 2303     err = ovs_vport_init();\par
 2304     if (err)\par
 2305         goto error_flow_exit;\par
 2306 \par
 2307     err = register_pernet_device(&ovs_net_ops);\par
 2308     if (err)\par
 2309         goto error_vport_exit;\par
 2310 \par
 2311     err = register_netdevice_notifier(&ovs_dp_device_notifier);\par
 2312     if (err)\par
 2313         goto error_netns_exit;\par
 2314 \par
 2315     err = ovs_netdev_init();\par
 2316     if (err)\par
 2317         goto error_unreg_notifier;\par
 2318 \par
 2319     err = dp_register_genl();\par
 2320     if (err < 0)\par
 2321         goto error_unreg_netdev;\par
 2322 \par
 2323     return 0;\par
 2324 \par
 2325 error_unreg_netdev:\par
 2326     ovs_netdev_exit();\par
 2327 error_unreg_notifier:\par
 2328     unregister_netdevice_notifier(&ovs_dp_device_notifier);\par
 2329 error_netns_exit:\par
 2330     unregister_pernet_device(&ovs_net_ops);\par
 2331 error_vport_exit:\par
 2332     ovs_vport_exit();\par
 2333 error_flow_exit:\par
 2334     ovs_flow_exit();\par
 2335 error_unreg_rtnl_link:\par
 2336     ovs_internal_dev_rtnl_link_unregister();\par
 2337 error_action_fifos_exit:\par
 2338     action_fifos_exit();\par
 2339 error:\par
 2340     return err;\par
 2341 \}\par
}
}
{\xe \v dp_register_genl\:datapath.c}
{\xe \v datapath.c\:dp_register_genl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int dp_register_genl (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2193 \{\par
 2194     int err;\par
 2195     int i;\par
 2196 \par
 2197     for (i = 0; i < ARRAY_SIZE(dp_genl_families); i++) \{\par
 2198 \par
 2199         err = genl_register_family(dp_genl_families[i]);\par
 2200         if (err)\par
 2201             goto error;\par
 2202     \}\par
 2203 \par
 2204     return 0;\par
 2205 \par
 2206 error:\par
 2207     dp_unregister_genl(i);\par
 2208     return err;\par
 2209 \}\par
}
}
{\xe \v dp_unregister_genl\:datapath.c}
{\xe \v datapath.c\:dp_unregister_genl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_unregister_genl (int  {\i n_families}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2185 \{\par
 2186     int i;\par
 2187 \par
 2188     for (i = 0; i < n_families; i++)\par
 2189         genl_unregister_family(dp_genl_families[i]);\par
 2190 \}\par
}
}
{\xe \v EXPORT_SYMBOL_GPL\:datapath.c}
{\xe \v datapath.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_net_id} )}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_dp\:datapath.c}
{\xe \v datapath.c\:get_dp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* get_dp (struct net *  {\i net}, int  {\i dp_ifindex}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   166 \{\par
  167     struct datapath *dp;\par
  168 \par
  169     WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_ovsl_is_held());\par
  170     rcu_read_lock();\par
  171     dp = get_dp_rcu(net, dp_ifindex);\par
  172     rcu_read_unlock();\par
  173 \par
  174     return dp;\par
  175 \}\par
}
}
{\xe \v get_dp_rcu\:datapath.c}
{\xe \v datapath.c\:get_dp_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* get_dp_rcu (struct net *  {\i net}, int  {\i dp_ifindex}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     struct net_device *dev = dev_get_by_index_rcu(net, dp_ifindex);\par
  152 \par
  153     if (dev) \{\par
  154         struct vport *vport = ovs_internal_dev_get_vport(dev);\par
  155         if (vport)\par
  156             return vport->dp;\par
  157     \}\par
  158 \par
  159     return NULL;\par
  160 \}\par
}
}
{\xe \v get_dp_stats\:datapath.c}
{\xe \v datapath.c\:get_dp_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void get_dp_stats (const struct {\b datapath} *  {\i dp}, struct {\b ovs_dp_stats} *  {\i stats}, struct {\b ovs_dp_megaflow_stats} *  {\i mega_stats}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   661 \{\par
  662     int i;\par
  663 \par
  664     memset(mega_stats, 0, sizeof(*mega_stats));\par
  665 \par
  666     stats->n_flows = ovs_flow_tbl_count(&dp->table);\par
  667     mega_stats->n_masks = ovs_flow_tbl_num_masks(&dp->table);\par
  668 \par
  669     stats->n_hit = stats->n_missed = stats->n_lost = 0;\par
  670 \par
  671     for_each_possible_cpu(i) \{\par
  672         const struct dp_stats_percpu *percpu_stats;\par
  673         struct dp_stats_percpu local_stats;\par
  674         unsigned int start;\par
  675 \par
  676         percpu_stats = per_cpu_ptr(dp->stats_percpu, i);\par
  677 \par
  678         do \{\par
  679             start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);\par
  680             local_stats = *percpu_stats;\par
  681         \} while (u64_stats_fetch_retry_irq(&percpu_stats->syncp, start));\par
  682 \par
  683         stats->n_hit += local_stats.n_hit;\par
  684         stats->n_missed += local_stats.n_missed;\par
  685         stats->n_lost += local_stats.n_lost;\par
  686         mega_stats->n_mask_hit += local_stats.n_mask_hit;\par
  687     \}\par
  688 \}\par
}
}
{\xe \v get_dpifindex\:datapath.c}
{\xe \v datapath.c\:get_dpifindex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int get_dpifindex (const struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   185 \{\par
  186     struct vport *local;\par
  187     int ifindex;\par
  188 \par
  189     rcu_read_lock();\par
  190 \par
  191     local = ovs_vport_rcu(dp, OVSP_LOCAL);\par
  192     if (local)\par
  193         ifindex = netdev_vport_priv(local)->dev->ifindex;\par
  194     else\par
  195         ifindex = 0;\par
  196 \par
  197     rcu_read_unlock();\par
  198 \par
  199     return ifindex;\par
  200 \}\par
}
}
{\xe \v get_flow_actions\:datapath.c}
{\xe \v datapath.c\:get_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_actions}* get_flow_actions (const struct nlattr *  {\i a}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_mask} *  {\i mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1056 \{\par
 1057     struct sw_flow_actions *acts;\par
 1058     struct sw_flow_key masked_key;\par
 1059     int error;\par
 1060 \par
 1061     ovs_flow_mask_key(&masked_key, key, mask);\par
 1062     error = ovs_nla_copy_actions(a, &masked_key, &acts, log);\par
 1063     if (error) \{\par
 1064         OVS_NLERR(log,\par
 1065               "Actions may not be safe on all matching packets");\par
 1066         return ERR_PTR(error);\par
 1067     \}\par
 1068 \par
 1069     return acts;\par
 1070 \}\par
}
}
{\xe \v list_vports_from_net\:datapath.c}
{\xe \v datapath.c\:list_vports_from_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __net_exit list_vports_from_net (struct net *  {\i net}, struct net *  {\i dnet}, struct list_head *  {\i head}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2222 \{\par
 2223     struct ovs_net *ovs_net = net_generic(net, ovs_net_id);\par
 2224     struct datapath *dp;\par
 2225 \par
 2226     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
 2227         int i;\par
 2228 \par
 2229         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 2230             struct vport *vport;\par
 2231 \par
 2232             hlist_for_each_entry(vport, &dp->ports[i], dp_hash_node) \{\par
 2233                 struct netdev_vport *netdev_vport;\par
 2234 \par
 2235                 if (vport->ops->type != OVS_VPORT_TYPE_INTERNAL)\par
 2236                     continue;\par
 2237 \par
 2238                 netdev_vport = netdev_vport_priv(vport);\par
 2239                 if (dev_net(netdev_vport->dev) == dnet)\par
 2240                     list_add(&vport->detach_list, head);\par
 2241             \}\par
 2242         \}\par
 2243     \}\par
 2244 \}\par
}
}
{\xe \v lookup_datapath\:datapath.c}
{\xe \v datapath.c\:lookup_datapath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* lookup_datapath (struct net *  {\i net}, const struct {\b ovs_header} *  {\i ovs_header}, struct nlattr *  {\i a}[OVS_DP_ATTR_MAX+1]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1475 \{\par
 1476     struct datapath *dp;\par
 1477 \par
 1478     if (!a[OVS_DP_ATTR_NAME])\par
 1479         dp = get_dp(net, ovs_header->dp_ifindex);\par
 1480     else \{\par
 1481         struct vport *vport;\par
 1482 \par
 1483         vport = ovs_vport_locate(net, nla_data(a[OVS_DP_ATTR_NAME]));\par
 1484         dp = vport && vport->port_no == OVSP_LOCAL ? vport->dp : NULL;\par
 1485     \}\par
 1486     return dp ? dp : ERR_PTR(-ENODEV);\par
 1487 \}\par
}
}
{\xe \v lookup_vport\:datapath.c}
{\xe \v datapath.c\:lookup_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* lookup_vport (struct net *  {\i net}, const struct {\b ovs_header} *  {\i ovs_header}, struct nlattr *  {\i a}[OVS_VPORT_ATTR_MAX+1]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1866 \{\par
 1867     struct datapath *dp;\par
 1868     struct vport *vport;\par
 1869 \par
 1870     if (a[OVS_VPORT_ATTR_NAME]) \{\par
 1871         vport = ovs_vport_locate(net, nla_data(a[OVS_VPORT_ATTR_NAME]));\par
 1872         if (!vport)\par
 1873             return ERR_PTR(-ENODEV);\par
 1874         if (ovs_header->dp_ifindex &&\par
 1875             ovs_header->dp_ifindex != get_dpifindex(vport->dp))\par
 1876             return ERR_PTR(-ENODEV);\par
 1877         return vport;\par
 1878     \} else if (a[OVS_VPORT_ATTR_PORT_NO]) \{\par
 1879         u32 port_no = nla_get_u32(a[OVS_VPORT_ATTR_PORT_NO]);\par
 1880 \par
 1881         if (port_no >= DP_MAX_PORTS)\par
 1882             return ERR_PTR(-EFBIG);\par
 1883 \par
 1884         dp = get_dp(net, ovs_header->dp_ifindex);\par
 1885         if (!dp)\par
 1886             return ERR_PTR(-ENODEV);\par
 1887 \par
 1888         vport = ovs_vport_ovsl_rcu(dp, port_no);\par
 1889         if (!vport)\par
 1890             return ERR_PTR(-ENODEV);\par
 1891         return vport;\par
 1892     \} else\par
 1893         return ERR_PTR(-EINVAL);\par
 1894 \}\par
}
}
{\xe \v MODULE_DESCRIPTION\:datapath.c}
{\xe \v datapath.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("Open vSwitch switching {\b datapath}" )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:datapath.c}
{\xe \v datapath.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b dp_cleanup} )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:datapath.c}
{\xe \v datapath.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b dp_init} )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:datapath.c}
{\xe \v datapath.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_VERSION\:datapath.c}
{\xe \v datapath.c\:MODULE_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_VERSION (VERSION )}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v new_vport\:datapath.c}
{\xe \v datapath.c\:new_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* new_vport (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   235 \{\par
  236     struct vport *vport;\par
  237 \par
  238     vport = ovs_vport_add(parms);\par
  239     if (!IS_ERR(vport)) \{\par
  240         struct datapath *dp = parms->dp;\par
  241         struct hlist_head *head = vport_hash_bucket(dp, vport->port_no);\par
  242 \par
  243         hlist_add_head_rcu(&vport->dp_hash_node, head);\par
  244     \}\par
  245     return vport;\par
  246 \}\par
}
}
{\xe \v ovs_dp_change\:datapath.c}
{\xe \v datapath.c\:ovs_dp_change}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_dp_change (struct {\b datapath} *  {\i dp}, struct nlattr *  {\i a}[]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1502 \{\par
 1503     if (a[OVS_DP_ATTR_USER_FEATURES])\par
 1504         dp->user_features = nla_get_u32(a[OVS_DP_ATTR_USER_FEATURES]);\par
 1505 \}\par
}
}
{\xe \v ovs_dp_cmd_alloc_info\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_dp_cmd_alloc_info (struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1467 \{\par
 1468     return genlmsg_new_unicast(ovs_dp_cmd_msg_size(), info, GFP_KERNEL);\par
 1469 \}\par
}
}
{\xe \v ovs_dp_cmd_del\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1638 \{\par
 1639     struct sk_buff *reply;\par
 1640     struct datapath *dp;\par
 1641     int err;\par
 1642 \par
 1643     reply = ovs_dp_cmd_alloc_info(info);\par
 1644     if (!reply)\par
 1645         return -ENOMEM;\par
 1646 \par
 1647     ovs_lock();\par
 1648     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1649     err = PTR_ERR(dp);\par
 1650     if (IS_ERR(dp))\par
 1651         goto err_unlock_free;\par
 1652 \par
 1653     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1654                    info->snd_seq, 0, OVS_DP_CMD_DEL);\par
 1655     BUG_ON(err < 0);\par
 1656 \par
 1657     __dp_destroy(dp);\par
 1658     ovs_unlock();\par
 1659 \par
 1660     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1661     return 0;\par
 1662 \par
 1663 err_unlock_free:\par
 1664     ovs_unlock();\par
 1665     kfree_skb(reply);\par
 1666     return err;\par
 1667 \}\par
}
}
{\xe \v ovs_dp_cmd_dump\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1732 \{\par
 1733     struct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);\par
 1734     struct datapath *dp;\par
 1735     int skip = cb->args[0];\par
 1736     int i = 0;\par
 1737 \par
 1738     ovs_lock();\par
 1739     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
 1740         if (i >= skip &&\par
 1741             ovs_dp_cmd_fill_info(dp, skb, NETLINK_CB(cb->skb).portid,\par
 1742                      cb->nlh->nlmsg_seq, NLM_F_MULTI,\par
 1743                      OVS_DP_CMD_NEW) < 0)\par
 1744             break;\par
 1745         i++;\par
 1746     \}\par
 1747     ovs_unlock();\par
 1748 \par
 1749     cb->args[0] = i;\par
 1750 \par
 1751     return skb->len;\par
 1752 \}\par
}
}
{\xe \v ovs_dp_cmd_fill_info\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_fill_info (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1427 \{\par
 1428     struct ovs_header *ovs_header;\par
 1429     struct ovs_dp_stats dp_stats;\par
 1430     struct ovs_dp_megaflow_stats dp_megaflow_stats;\par
 1431     int err;\par
 1432 \par
 1433     ovs_header = genlmsg_put(skb, portid, seq, &dp_datapath_genl_family,\par
 1434                    flags, cmd);\par
 1435     if (!ovs_header)\par
 1436         goto error;\par
 1437 \par
 1438     ovs_header->dp_ifindex = get_dpifindex(dp);\par
 1439 \par
 1440     err = nla_put_string(skb, OVS_DP_ATTR_NAME, ovs_dp_name(dp));\par
 1441     if (err)\par
 1442         goto nla_put_failure;\par
 1443 \par
 1444     get_dp_stats(dp, &dp_stats, &dp_megaflow_stats);\par
 1445     if (nla_put(skb, OVS_DP_ATTR_STATS, sizeof(struct ovs_dp_stats),\par
 1446             &dp_stats))\par
 1447         goto nla_put_failure;\par
 1448 \par
 1449     if (nla_put(skb, OVS_DP_ATTR_MEGAFLOW_STATS,\par
 1450             sizeof(struct ovs_dp_megaflow_stats),\par
 1451             &dp_megaflow_stats))\par
 1452         goto nla_put_failure;\par
 1453 \par
 1454     if (nla_put_u32(skb, OVS_DP_ATTR_USER_FEATURES, dp->user_features))\par
 1455         goto nla_put_failure;\par
 1456 \par
 1457     genlmsg_end(skb, ovs_header);\par
 1458     return 0;\par
 1459 \par
 1460 nla_put_failure:\par
 1461     genlmsg_cancel(skb, ovs_header);\par
 1462 error:\par
 1463     return -EMSGSIZE;\par
 1464 \}\par
}
}
{\xe \v ovs_dp_cmd_get\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1703 \{\par
 1704     struct sk_buff *reply;\par
 1705     struct datapath *dp;\par
 1706     int err;\par
 1707 \par
 1708     reply = ovs_dp_cmd_alloc_info(info);\par
 1709     if (!reply)\par
 1710         return -ENOMEM;\par
 1711 \par
 1712     ovs_lock();\par
 1713     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1714     if (IS_ERR(dp)) \{\par
 1715         err = PTR_ERR(dp);\par
 1716         goto err_unlock_free;\par
 1717     \}\par
 1718     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1719                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1720     BUG_ON(err < 0);\par
 1721     ovs_unlock();\par
 1722 \par
 1723     return genlmsg_reply(reply, info);\par
 1724 \par
 1725 err_unlock_free:\par
 1726     ovs_unlock();\par
 1727     kfree_skb(reply);\par
 1728     return err;\par
 1729 \}\par
}
}
{\xe \v ovs_dp_cmd_msg_size\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t ovs_dp_cmd_msg_size (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1413 \{\par
 1414     size_t msgsize = NLMSG_ALIGN(sizeof(struct ovs_header));\par
 1415 \par
 1416     msgsize += nla_total_size(IFNAMSIZ);\par
 1417     msgsize += nla_total_size(sizeof(struct ovs_dp_stats));\par
 1418     msgsize += nla_total_size(sizeof(struct ovs_dp_megaflow_stats));\par
 1419     msgsize += nla_total_size(sizeof(u32)); /* OVS_DP_ATTR_USER_FEATURES */\par
 1420 \par
 1421     return msgsize;\par
 1422 \}\par
}
}
{\xe \v ovs_dp_cmd_new\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1508 \{\par
 1509     struct nlattr **a = info->attrs;\par
 1510     struct vport_parms parms;\par
 1511     struct sk_buff *reply;\par
 1512     struct datapath *dp;\par
 1513     struct vport *vport;\par
 1514     struct ovs_net *ovs_net;\par
 1515     int err, i;\par
 1516 \par
 1517     err = -EINVAL;\par
 1518     if (!a[OVS_DP_ATTR_NAME] || !a[OVS_DP_ATTR_UPCALL_PID])\par
 1519         goto err;\par
 1520 \par
 1521     reply = ovs_dp_cmd_alloc_info(info);\par
 1522     if (!reply)\par
 1523         return -ENOMEM;\par
 1524 \par
 1525     err = -ENOMEM;\par
 1526     dp = kzalloc(sizeof(*dp), GFP_KERNEL);\par
 1527     if (dp == NULL)\par
 1528         goto err_free_reply;\par
 1529 \par
 1530     ovs_dp_set_net(dp, hold_net(sock_net(skb->sk)));\par
 1531 \par
 1532     /* Allocate table. */\par
 1533     err = ovs_flow_tbl_init(&dp->table);\par
 1534     if (err)\par
 1535         goto err_free_dp;\par
 1536 \par
 1537     dp->stats_percpu = netdev_alloc_pcpu_stats(struct dp_stats_percpu);\par
 1538     if (!dp->stats_percpu) \{\par
 1539         err = -ENOMEM;\par
 1540         goto err_destroy_table;\par
 1541     \}\par
 1542 \par
 1543     dp->ports = kmalloc(DP_VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\par
 1544                 GFP_KERNEL);\par
 1545     if (!dp->ports) \{\par
 1546         err = -ENOMEM;\par
 1547         goto err_destroy_percpu;\par
 1548     \}\par
 1549 \par
 1550     for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++)\par
 1551         INIT_HLIST_HEAD(&dp->ports[i]);\par
 1552 \par
 1553     /* Set up our datapath device. */\par
 1554     parms.name = nla_data(a[OVS_DP_ATTR_NAME]);\par
 1555     parms.type = OVS_VPORT_TYPE_INTERNAL;\par
 1556     parms.options = NULL;\par
 1557     parms.dp = dp;\par
 1558     parms.port_no = OVSP_LOCAL;\par
 1559     parms.upcall_portids = a[OVS_DP_ATTR_UPCALL_PID];\par
 1560 \par
 1561     ovs_dp_change(dp, a);\par
 1562 \par
 1563     /* So far only local changes have been made, now need the lock. */\par
 1564     ovs_lock();\par
 1565 \par
 1566     vport = new_vport(&parms);\par
 1567     if (IS_ERR(vport)) \{\par
 1568         err = PTR_ERR(vport);\par
 1569         if (err == -EBUSY)\par
 1570             err = -EEXIST;\par
 1571 \par
 1572         if (err == -EEXIST) \{\par
 1573             /* An outdated user space instance that does not understand\par
 1574              * the concept of user_features has attempted to create a new\par
 1575              * datapath and is likely to reuse it. Drop all user features.\par
 1576              */\par
 1577             if (info->genlhdr->version < OVS_DP_VER_FEATURES)\par
 1578                 ovs_dp_reset_user_features(skb, info);\par
 1579         \}\par
 1580 \par
 1581         goto err_destroy_ports_array;\par
 1582     \}\par
 1583 \par
 1584     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1585                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1586     BUG_ON(err < 0);\par
 1587 \par
 1588     ovs_net = net_generic(ovs_dp_get_net(dp), ovs_net_id);\par
 1589     list_add_tail_rcu(&dp->list_node, &ovs_net->dps);\par
 1590 \par
 1591     ovs_unlock();\par
 1592 \par
 1593     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1594     return 0;\par
 1595 \par
 1596 err_destroy_ports_array:\par
 1597     ovs_unlock();\par
 1598     kfree(dp->ports);\par
 1599 err_destroy_percpu:\par
 1600     free_percpu(dp->stats_percpu);\par
 1601 err_destroy_table:\par
 1602     ovs_flow_tbl_destroy(&dp->table);\par
 1603 err_free_dp:\par
 1604     release_net(ovs_dp_get_net(dp));\par
 1605     kfree(dp);\par
 1606 err_free_reply:\par
 1607     kfree_skb(reply);\par
 1608 err:\par
 1609     return err;\par
 1610 \}\par
}
}
{\xe \v ovs_dp_cmd_set\:datapath.c}
{\xe \v datapath.c\:ovs_dp_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1670 \{\par
 1671     struct sk_buff *reply;\par
 1672     struct datapath *dp;\par
 1673     int err;\par
 1674 \par
 1675     reply = ovs_dp_cmd_alloc_info(info);\par
 1676     if (!reply)\par
 1677         return -ENOMEM;\par
 1678 \par
 1679     ovs_lock();\par
 1680     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1681     err = PTR_ERR(dp);\par
 1682     if (IS_ERR(dp))\par
 1683         goto err_unlock_free;\par
 1684 \par
 1685     ovs_dp_change(dp, info->attrs);\par
 1686 \par
 1687     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1688                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1689     BUG_ON(err < 0);\par
 1690 \par
 1691     ovs_unlock();\par
 1692 \par
 1693     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1694     return 0;\par
 1695 \par
 1696 err_unlock_free:\par
 1697     ovs_unlock();\par
 1698     kfree_skb(reply);\par
 1699     return err;\par
 1700 \}\par
}
}
{\xe \v ovs_dp_detach_port\:datapath.c}
{\xe \v datapath.c\:ovs_dp_detach_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_detach_port (struct {\b vport} *  {\i p})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     ASSERT_OVSL();\par
  251 \par
  252     /* First drop references to device. */\par
  253     hlist_del_rcu(&p->dp_hash_node);\par
  254 \par
  255     /* Then destroy it. */\par
  256     ovs_vport_del(p);\par
  257 \}\par
}
}
{\xe \v ovs_dp_name\:datapath.c}
{\xe \v datapath.c\:ovs_dp_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_dp_name (const struct {\b datapath} *  {\i dp})}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179 \{\par
  180     struct vport *vport = ovs_vport_ovsl_rcu(dp, OVSP_LOCAL);\par
  181     return vport->ops->get_name(vport);\par
  182 \}\par
}
}
{\xe \v ovs_dp_process_packet\:datapath.c}
{\xe \v datapath.c\:ovs_dp_process_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_process_packet (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   261 \{\par
  262     const struct vport *p = OVS_CB(skb)->input_vport;\par
  263     struct datapath *dp = p->dp;\par
  264     struct sw_flow *flow;\par
  265     struct sw_flow_actions *sf_acts;\par
  266     struct dp_stats_percpu *stats;\par
  267     u64 *stats_counter;\par
  268     u32 n_mask_hit;\par
  269 \par
  270     stats = this_cpu_ptr(dp->stats_percpu);\par
  271 \par
  272     /* Look up flow. */\par
  273     flow = ovs_flow_tbl_lookup_stats(&dp->table, key, skb_get_hash(skb),\par
  274                      &n_mask_hit);\par
  275     if (unlikely(!flow)) \{\par
  276         struct dp_upcall_info upcall;\par
  277         int error;\par
  278 \par
  279         memset(&upcall, 0, sizeof(upcall));\par
  280         upcall.cmd = OVS_PACKET_CMD_MISS;\par
  281         upcall.portid = ovs_vport_find_upcall_portid(p, skb);\par
  282         error = ovs_dp_upcall(dp, skb, key, &upcall);\par
  283         if (unlikely(error))\par
  284             kfree_skb(skb);\par
  285         else\par
  286             consume_skb(skb);\par
  287         stats_counter = &stats->n_missed;\par
  288         goto out;\par
  289     \}\par
  290 \par
  291     ovs_flow_stats_update(flow, key->tp.flags, skb);\par
  292     sf_acts = rcu_dereference(flow->sf_acts);\par
  293     ovs_execute_actions(dp, skb, sf_acts, key);\par
  294 \par
  295     stats_counter = &stats->n_hit;\par
  296 \par
  297 out:\par
  298     /* Update datapath statistics. */\par
  299     u64_stats_update_begin(&stats->syncp);\par
  300     (*stats_counter)++;\par
  301     stats->n_mask_hit += n_mask_hit;\par
  302     u64_stats_update_end(&stats->syncp);\par
  303 \}\par
}
}
{\xe \v ovs_dp_reset_user_features\:datapath.c}
{\xe \v datapath.c\:ovs_dp_reset_user_features}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_dp_reset_user_features (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1490 \{\par
 1491     struct datapath *dp;\par
 1492 \par
 1493     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1494     if (IS_ERR(dp))\par
 1495         return;\par
 1496 \par
 1497     WARN(dp->user_features, "Dropping previously announced user features\\n");\par
 1498     dp->user_features = 0;\par
 1499 \}\par
}
}
{\xe \v ovs_dp_upcall\:datapath.c}
{\xe \v datapath.c\:ovs_dp_upcall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_dp_upcall (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info})}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309     struct dp_stats_percpu *stats;\par
  310     int err;\par
  311 \par
  312     if (upcall_info->portid == 0) \{\par
  313         err = -ENOTCONN;\par
  314         goto err;\par
  315     \}\par
  316 \par
  317     if (!skb_is_gso(skb))\par
  318         err = queue_userspace_packet(dp, skb, key, upcall_info);\par
  319     else\par
  320         err = queue_gso_packets(dp, skb, key, upcall_info);\par
  321     if (err)\par
  322         goto err;\par
  323 \par
  324     return 0;\par
  325 \par
  326 err:\par
  327     stats = this_cpu_ptr(dp->stats_percpu);\par
  328 \par
  329     u64_stats_update_begin(&stats->syncp);\par
  330     stats->n_lost++;\par
  331     u64_stats_update_end(&stats->syncp);\par
  332 \par
  333     return err;\par
  334 \}\par
}
}
{\xe \v ovs_exit_net\:datapath.c}
{\xe \v datapath.c\:ovs_exit_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __net_exit ovs_exit_net (struct net *  {\i dnet}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2247 \{\par
 2248     struct datapath *dp, *dp_next;\par
 2249     struct ovs_net *ovs_net = net_generic(dnet, ovs_net_id);\par
 2250     struct vport *vport, *vport_next;\par
 2251     struct net *net;\par
 2252     LIST_HEAD(head);\par
 2253 \par
 2254     ovs_lock();\par
 2255     list_for_each_entry_safe(dp, dp_next, &ovs_net->dps, list_node)\par
 2256         __dp_destroy(dp);\par
 2257 \par
 2258     rtnl_lock();\par
 2259     for_each_net(net)\par
 2260         list_vports_from_net(net, dnet, &head);\par
 2261     rtnl_unlock();\par
 2262 \par
 2263     /* Detach all vports from given namespace. */\par
 2264     list_for_each_entry_safe(vport, vport_next, &head, detach_list) \{\par
 2265         list_del(&vport->detach_list);\par
 2266         ovs_dp_detach_port(vport);\par
 2267     \}\par
 2268 \par
 2269     ovs_unlock();\par
 2270 \par
 2271     cancel_work_sync(&ovs_net->dp_notify_work);\par
 2272 \}\par
}
}
{\xe \v ovs_flow_cmd_alloc_info\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_flow_cmd_alloc_info (const struct {\b sw_flow_actions} *  {\i acts}, const struct {\b sw_flow_id} *  {\i sfid}, struct genl_info *  {\i info}, {\b bool}  {\i always}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   855 \{\par
  856     struct sk_buff *skb;\par
  857     size_t len;\par
  858 \par
  859     if (!always && !ovs_must_notify(&dp_flow_genl_family, info,\par
  860                     GROUP_ID(&ovs_dp_flow_multicast_group)))\par
  861         return NULL;\par
  862 \par
  863     len = ovs_flow_cmd_msg_size(acts, sfid, ufid_flags);\par
  864     skb = genlmsg_new_unicast(len, info, GFP_KERNEL);\par
  865     if (!skb)\par
  866         return ERR_PTR(-ENOMEM);\par
  867 \par
  868     return skb;\par
  869 \}\par
}
}
{\xe \v ovs_flow_cmd_build_info\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_build_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_flow_cmd_build_info (const struct {\b sw_flow} *  {\i flow}, int  {\i dp_ifindex}, struct genl_info *  {\i info}, u8  {\i cmd}, {\b bool}  {\i always}, u32  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   876 \{\par
  877     struct sk_buff *skb;\par
  878     int retval;\par
  879 \par
  880     skb = ovs_flow_cmd_alloc_info(ovsl_dereference(flow->sf_acts),\par
  881                       &flow->id, info, always, ufid_flags);\par
  882     if (IS_ERR_OR_NULL(skb))\par
  883         return skb;\par
  884 \par
  885     retval = ovs_flow_cmd_fill_info(flow, dp_ifindex, skb,\par
  886                     info->snd_portid, info->snd_seq, 0,\par
  887                     cmd, ufid_flags);\par
  888     BUG_ON(retval < 0);\par
  889     return skb;\par
  890 \}\par
}
}
{\xe \v ovs_flow_cmd_del\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1243 \{\par
 1244     struct nlattr **a = info->attrs;\par
 1245     struct ovs_header *ovs_header = info->userhdr;\par
 1246     struct sw_flow_key key;\par
 1247     struct sk_buff *reply;\par
 1248     struct sw_flow *flow = NULL;\par
 1249     struct datapath *dp;\par
 1250     struct sw_flow_match match;\par
 1251     struct sw_flow_id ufid;\par
 1252     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1253     int err;\par
 1254     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1255     bool ufid_present;\par
 1256 \par
 1257     ufid_present = ovs_nla_get_ufid(&ufid, a[OVS_FLOW_ATTR_UFID], log);\par
 1258     if (a[OVS_FLOW_ATTR_KEY]) \{\par
 1259         ovs_match_init(&match, &key, NULL);\par
 1260         err = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY], NULL,\par
 1261                     log);\par
 1262         if (unlikely(err))\par
 1263             return err;\par
 1264     \}\par
 1265 \par
 1266     ovs_lock();\par
 1267     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1268     if (unlikely(!dp)) \{\par
 1269         err = -ENODEV;\par
 1270         goto unlock;\par
 1271     \}\par
 1272 \par
 1273     if (unlikely(!a[OVS_FLOW_ATTR_KEY] && !ufid_present)) \{\par
 1274         err = ovs_flow_tbl_flush(&dp->table);\par
 1275         goto unlock;\par
 1276     \}\par
 1277 \par
 1278     if (ufid_present)\par
 1279         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &ufid);\par
 1280     else\par
 1281         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1282     if (unlikely(!flow)) \{\par
 1283         err = -ENOENT;\par
 1284         goto unlock;\par
 1285     \}\par
 1286 \par
 1287     ovs_flow_tbl_remove(&dp->table, flow);\par
 1288     ovs_unlock();\par
 1289 \par
 1290     reply = ovs_flow_cmd_alloc_info(rcu_dereference_raw(flow->sf_acts),\par
 1291                     &flow->id, info, false, ufid_flags);\par
 1292 \par
 1293     if (likely(reply)) \{\par
 1294         if (likely(!IS_ERR(reply))) \{\par
 1295             rcu_read_lock();    /*To keep RCU checker happy. */\par
 1296             err = ovs_flow_cmd_fill_info(flow, ovs_header->dp_ifindex,\par
 1297                              reply, info->snd_portid,\par
 1298                              info->snd_seq, 0,\par
 1299                              OVS_FLOW_CMD_DEL,\par
 1300                              ufid_flags);\par
 1301             rcu_read_unlock();\par
 1302             BUG_ON(err < 0);\par
 1303             ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1304         \} else \{\par
 1305             genl_set_err(&dp_flow_genl_family, sock_net(skb->sk), 0,\par
 1306                      GROUP_ID(&ovs_dp_flow_multicast_group), PTR_ERR(reply));\par
 1307 \par
 1308         \}\par
 1309     \}\par
 1310 \par
 1311     ovs_flow_free(flow, true);\par
 1312     return 0;\par
 1313 unlock:\par
 1314     ovs_unlock();\par
 1315     return err;\par
 1316 \}\par
}
}
{\xe \v ovs_flow_cmd_dump\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1319 \{\par
 1320     struct nlattr *a[__OVS_FLOW_ATTR_MAX];\par
 1321     struct ovs_header *ovs_header = genlmsg_data(nlmsg_data(cb->nlh));\par
 1322     struct table_instance *ti;\par
 1323     struct datapath *dp;\par
 1324     u32 ufid_flags;\par
 1325     int err;\par
 1326 \par
 1327     err = genlmsg_parse(cb->nlh, &dp_flow_genl_family, a,\par
 1328                 OVS_FLOW_ATTR_MAX, flow_policy);\par
 1329     if (err)\par
 1330         return err;\par
 1331     ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1332 \par
 1333     rcu_read_lock();\par
 1334     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1335     if (!dp) \{\par
 1336         rcu_read_unlock();\par
 1337         return -ENODEV;\par
 1338     \}\par
 1339 \par
 1340     ti = rcu_dereference(dp->table.ti);\par
 1341     for (;;) \{\par
 1342         struct sw_flow *flow;\par
 1343         u32 bucket, obj;\par
 1344 \par
 1345         bucket = cb->args[0];\par
 1346         obj = cb->args[1];\par
 1347         flow = ovs_flow_tbl_dump_next(ti, &bucket, &obj);\par
 1348         if (!flow)\par
 1349             break;\par
 1350 \par
 1351         if (ovs_flow_cmd_fill_info(flow, ovs_header->dp_ifindex, skb,\par
 1352                        NETLINK_CB(cb->skb).portid,\par
 1353                        cb->nlh->nlmsg_seq, NLM_F_MULTI,\par
 1354                        OVS_FLOW_CMD_NEW, ufid_flags) < 0)\par
 1355             break;\par
 1356 \par
 1357         cb->args[0] = bucket;\par
 1358         cb->args[1] = obj;\par
 1359     \}\par
 1360     rcu_read_unlock();\par
 1361     return skb->len;\par
 1362 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_actions\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_fill_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_actions (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb}, int  {\i skb_orig_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   762 \{\par
  763     struct nlattr *start;\par
  764     int err;\par
  765 \par
  766     /* If OVS_FLOW_ATTR_ACTIONS doesn't fit, skip dumping the actions if\par
  767      * this is the first flow to be dumped into 'skb'.  This is unusual for\par
  768      * Netlink but individual action lists can be longer than\par
  769      * NLMSG_GOODSIZE and thus entirely undumpable if we didn't do this.\par
  770      * The userspace caller can always fetch the actions separately if it\par
  771      * really wants them.  (Most userspace callers in fact don't care.)\par
  772      *\par
  773      * This can only fail for dump operations because the skb is always\par
  774      * properly sized for single flows.\par
  775      */\par
  776     start = nla_nest_start(skb, OVS_FLOW_ATTR_ACTIONS);\par
  777     if (start) \{\par
  778         const struct sw_flow_actions *sf_acts;\par
  779 \par
  780         sf_acts = rcu_dereference_ovsl(flow->sf_acts);\par
  781         err = ovs_nla_put_actions(sf_acts->actions,\par
  782                       sf_acts->actions_len, skb);\par
  783 \par
  784         if (!err)\par
  785             nla_nest_end(skb, start);\par
  786         else \{\par
  787             if (skb_orig_len)\par
  788                 return err;\par
  789 \par
  790             nla_nest_cancel(skb, start);\par
  791         \}\par
  792     \} else if (skb_orig_len) \{\par
  793         return -EMSGSIZE;\par
  794     \}\par
  795 \par
  796     return 0;\par
  797 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_info\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_info (const struct {\b sw_flow} *  {\i flow}, int  {\i dp_ifindex}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}, u32  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   803 \{\par
  804     const int skb_orig_len = skb->len;\par
  805     struct ovs_header *ovs_header;\par
  806     int err;\par
  807 \par
  808     ovs_header = genlmsg_put(skb, portid, seq, &dp_flow_genl_family,\par
  809                  flags, cmd);\par
  810     if (!ovs_header)\par
  811         return -EMSGSIZE;\par
  812 \par
  813     ovs_header->dp_ifindex = dp_ifindex;\par
  814 \par
  815     err = ovs_nla_put_identifier(flow, skb);\par
  816     if (err)\par
  817         goto error;\par
  818 \par
  819     if (should_fill_key(&flow->id, ufid_flags)) \{\par
  820         err = ovs_nla_put_masked_key(flow, skb);\par
  821         if (err)\par
  822             goto error;\par
  823     \}\par
  824 \par
  825     if (should_fill_mask(ufid_flags)) \{\par
  826         err = ovs_nla_put_mask(flow, skb);\par
  827         if (err)\par
  828             goto error;\par
  829     \}\par
  830 \par
  831     err = ovs_flow_cmd_fill_stats(flow, skb);\par
  832     if (err)\par
  833         goto error;\par
  834 \par
  835     if (should_fill_actions(ufid_flags)) \{\par
  836         err = ovs_flow_cmd_fill_actions(flow, skb, skb_orig_len);\par
  837         if (err)\par
  838             goto error;\par
  839     \}\par
  840 \par
  841     genlmsg_end(skb, ovs_header);\par
  842     return 0;\par
  843 \par
  844 error:\par
  845     genlmsg_cancel(skb, ovs_header);\par
  846     return err;\par
  847 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_stats\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_fill_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_stats (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   737 \{\par
  738     struct ovs_flow_stats stats;\par
  739     __be16 tcp_flags;\par
  740     unsigned long used;\par
  741 \par
  742     ovs_flow_stats_get(flow, &stats, &used, &tcp_flags);\par
  743 \par
  744     if (used &&\par
  745         nla_put_u64(skb, OVS_FLOW_ATTR_USED, ovs_flow_used_time(used)))\par
  746         return -EMSGSIZE;\par
  747 \par
  748     if (stats.n_packets &&\par
  749         nla_put(skb, OVS_FLOW_ATTR_STATS, sizeof(struct ovs_flow_stats), &stats))\par
  750         return -EMSGSIZE;\par
  751 \par
  752     if ((u8)ntohs(tcp_flags) &&\par
  753          nla_put_u8(skb, OVS_FLOW_ATTR_TCP_FLAGS, (u8)ntohs(tcp_flags)))\par
  754         return -EMSGSIZE;\par
  755 \par
  756     return 0;\par
  757 \}\par
}
}
{\xe \v ovs_flow_cmd_get\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1185 \{\par
 1186     struct nlattr **a = info->attrs;\par
 1187     struct ovs_header *ovs_header = info->userhdr;\par
 1188     struct sw_flow_key key;\par
 1189     struct sk_buff *reply;\par
 1190     struct sw_flow *flow;\par
 1191     struct datapath *dp;\par
 1192     struct sw_flow_match match;\par
 1193     struct sw_flow_id ufid;\par
 1194     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1195     int err = 0;\par
 1196     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1197     bool ufid_present;\par
 1198 \par
 1199     ufid_present = ovs_nla_get_ufid(&ufid, a[OVS_FLOW_ATTR_UFID], log);\par
 1200     if (a[OVS_FLOW_ATTR_KEY]) \{\par
 1201         ovs_match_init(&match, &key, NULL);\par
 1202         err = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY], NULL,\par
 1203                     log);\par
 1204     \} else if (!ufid_present) \{\par
 1205         OVS_NLERR(log,\par
 1206               "Flow get message rejected, Key attribute missing.");\par
 1207         err = -EINVAL;\par
 1208     \}\par
 1209     if (err)\par
 1210         return err;\par
 1211 \par
 1212     ovs_lock();\par
 1213     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1214     if (!dp) \{\par
 1215         err = -ENODEV;\par
 1216         goto unlock;\par
 1217     \}\par
 1218 \par
 1219     if (ufid_present)\par
 1220         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &ufid);\par
 1221     else\par
 1222         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1223     if (!flow) \{\par
 1224         err = -ENOENT;\par
 1225         goto unlock;\par
 1226     \}\par
 1227 \par
 1228     reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex, info,\par
 1229                     OVS_FLOW_CMD_NEW, true, ufid_flags);\par
 1230     if (IS_ERR(reply)) \{\par
 1231         err = PTR_ERR(reply);\par
 1232         goto unlock;\par
 1233     \}\par
 1234 \par
 1235     ovs_unlock();\par
 1236     return genlmsg_reply(reply, info);\par
 1237 unlock:\par
 1238     ovs_unlock();\par
 1239     return err;\par
 1240 \}\par
}
}
{\xe \v ovs_flow_cmd_msg_size\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t ovs_flow_cmd_msg_size (const struct {\b sw_flow_actions} *  {\i acts}, const struct {\b sw_flow_id} *  {\i sfid}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{\par
  710     size_t len = NLMSG_ALIGN(sizeof(struct ovs_header));\par
  711 \par
  712     /* OVS_FLOW_ATTR_UFID */\par
  713     if (sfid && ovs_identifier_is_ufid(sfid))\par
  714         len += nla_total_size(sfid->ufid_len);\par
  715 \par
  716     /* OVS_FLOW_ATTR_KEY */\par
  717     if (!sfid || should_fill_key(sfid, ufid_flags))\par
  718         len += nla_total_size(ovs_key_attr_size());\par
  719 \par
  720     /* OVS_FLOW_ATTR_MASK */\par
  721     if (should_fill_mask(ufid_flags))\par
  722         len += nla_total_size(ovs_key_attr_size());\par
  723 \par
  724     /* OVS_FLOW_ATTR_ACTIONS */\par
  725     if (should_fill_actions(ufid_flags))\par
  726         len += nla_total_size(acts->actions_len);\par
  727 \par
  728     return len\par
  729         + nla_total_size(sizeof(struct ovs_flow_stats)) /* OVS_FLOW_ATTR_STATS */\par
  730         + nla_total_size(1) /* OVS_FLOW_ATTR_TCP_FLAGS */\par
  731         + nla_total_size(8); /* OVS_FLOW_ATTR_USED */\par
  732 \}\par
}
}
{\xe \v ovs_flow_cmd_new\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   893 \{\par
  894     struct nlattr **a = info->attrs;\par
  895     struct ovs_header *ovs_header = info->userhdr;\par
  896     struct sw_flow *flow = NULL, *new_flow;\par
  897     struct sw_flow_mask mask;\par
  898     struct sk_buff *reply;\par
  899     struct datapath *dp;\par
  900     struct sw_flow_key key;\par
  901     struct sw_flow_actions *acts;\par
  902     struct sw_flow_match match;\par
  903     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
  904     int error;\par
  905     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
  906 \par
  907     /* Must have key and actions. */\par
  908     error = -EINVAL;\par
  909     if (!a[OVS_FLOW_ATTR_KEY]) \{\par
  910         OVS_NLERR(log, "Flow key attr not present in new flow.");\par
  911         goto error;\par
  912     \}\par
  913     if (!a[OVS_FLOW_ATTR_ACTIONS]) \{\par
  914         OVS_NLERR(log, "Flow actions attr not present in new flow.");\par
  915         goto error;\par
  916     \}\par
  917 \par
  918     /* Most of the time we need to allocate a new flow, do it before\par
  919      * locking.\par
  920      */\par
  921     new_flow = ovs_flow_alloc();\par
  922     if (IS_ERR(new_flow)) \{\par
  923         error = PTR_ERR(new_flow);\par
  924         goto error;\par
  925     \}\par
  926 \par
  927     /* Extract key. */\par
  928     ovs_match_init(&match, &key, &mask);\par
  929     error = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY],\par
  930                   a[OVS_FLOW_ATTR_MASK], log);\par
  931     if (error)\par
  932         goto err_kfree_flow;\par
  933 \par
  934     ovs_flow_mask_key(&new_flow->key, &key, &mask);\par
  935 \par
  936     /* Extract flow identifier. */\par
  937     error = ovs_nla_get_identifier(&new_flow->id, a[OVS_FLOW_ATTR_UFID],\par
  938                        &key, log);\par
  939     if (error)\par
  940         goto err_kfree_flow;\par
  941 \par
  942     /* Validate actions. */\par
  943     error = ovs_nla_copy_actions(a[OVS_FLOW_ATTR_ACTIONS], &new_flow->key,\par
  944                      &acts, log);\par
  945     if (error) \{\par
  946         OVS_NLERR(log, "Flow actions may not be safe on all matching packets.");\par
  947         goto err_kfree_flow;\par
  948     \}\par
  949 \par
  950     reply = ovs_flow_cmd_alloc_info(acts, &new_flow->id, info, false,\par
  951                     ufid_flags);\par
  952     if (IS_ERR(reply)) \{\par
  953         error = PTR_ERR(reply);\par
  954         goto err_kfree_acts;\par
  955     \}\par
  956 \par
  957     ovs_lock();\par
  958     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
  959     if (unlikely(!dp)) \{\par
  960         error = -ENODEV;\par
  961         goto err_unlock_ovs;\par
  962     \}\par
  963 \par
  964     /* Check if this is a duplicate flow */\par
  965     if (ovs_identifier_is_ufid(&new_flow->id))\par
  966         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &new_flow->id);\par
  967     if (!flow)\par
  968         flow = ovs_flow_tbl_lookup(&dp->table, &key);\par
  969     if (likely(!flow)) \{\par
  970         rcu_assign_pointer(new_flow->sf_acts, acts);\par
  971 \par
  972         /* Put flow in bucket. */\par
  973         error = ovs_flow_tbl_insert(&dp->table, new_flow, &mask);\par
  974         if (unlikely(error)) \{\par
  975             acts = NULL;\par
  976             goto err_unlock_ovs;\par
  977         \}\par
  978 \par
  979         if (unlikely(reply)) \{\par
  980             error = ovs_flow_cmd_fill_info(new_flow,\par
  981                                ovs_header->dp_ifindex,\par
  982                                reply, info->snd_portid,\par
  983                                info->snd_seq, 0,\par
  984                                OVS_FLOW_CMD_NEW,\par
  985                                ufid_flags);\par
  986             BUG_ON(error < 0);\par
  987         \}\par
  988         ovs_unlock();\par
  989     \} else \{\par
  990         struct sw_flow_actions *old_acts;\par
  991 \par
  992         /* Bail out if we're not allowed to modify an existing flow.\par
  993          * We accept NLM_F_CREATE in place of the intended NLM_F_EXCL\par
  994          * because Generic Netlink treats the latter as a dump\par
  995          * request.  We also accept NLM_F_EXCL in case that bug ever\par
  996          * gets fixed.\par
  997          */\par
  998         if (unlikely(info->nlhdr->nlmsg_flags & (NLM_F_CREATE\par
  999                              | NLM_F_EXCL))) \{\par
 1000             error = -EEXIST;\par
 1001             goto err_unlock_ovs;\par
 1002         \}\par
 1003         /* The flow identifier has to be the same for flow updates.\par
 1004          * Look for any overlapping flow.\par
 1005          */\par
 1006         if (unlikely(!ovs_flow_cmp(flow, &match))) \{\par
 1007             if (ovs_identifier_is_key(&flow->id))\par
 1008                 flow = ovs_flow_tbl_lookup_exact(&dp->table,\par
 1009                                  &match);\par
 1010             else /* UFID matches but key is different */\par
 1011                 flow = NULL;\par
 1012             if (!flow) \{\par
 1013                 error = -ENOENT;\par
 1014                 goto err_unlock_ovs;\par
 1015             \}\par
 1016         \}\par
 1017         /* Update actions. */\par
 1018         old_acts = ovsl_dereference(flow->sf_acts);\par
 1019         rcu_assign_pointer(flow->sf_acts, acts);\par
 1020 \par
 1021         if (unlikely(reply)) \{\par
 1022             error = ovs_flow_cmd_fill_info(flow,\par
 1023                                ovs_header->dp_ifindex,\par
 1024                                reply, info->snd_portid,\par
 1025                                info->snd_seq, 0,\par
 1026                                OVS_FLOW_CMD_NEW,\par
 1027                                ufid_flags);\par
 1028             BUG_ON(error < 0);\par
 1029         \}\par
 1030         ovs_unlock();\par
 1031 \par
 1032         ovs_nla_free_flow_actions(old_acts);\par
 1033         ovs_flow_free(new_flow, false);\par
 1034     \}\par
 1035 \par
 1036     if (reply)\par
 1037         ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1038     return 0;\par
 1039 \par
 1040 err_unlock_ovs:\par
 1041     ovs_unlock();\par
 1042     kfree_skb(reply);\par
 1043 err_kfree_acts:\par
 1044     kfree(acts);\par
 1045 err_kfree_flow:\par
 1046     ovs_flow_free(new_flow, false);\par
 1047 error:\par
 1048     return error;\par
 1049 \}\par
}
}
{\xe \v ovs_flow_cmd_set\:datapath.c}
{\xe \v datapath.c\:ovs_flow_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1073 \{\par
 1074     struct nlattr **a = info->attrs;\par
 1075     struct ovs_header *ovs_header = info->userhdr;\par
 1076     struct sw_flow_key key;\par
 1077     struct sw_flow *flow;\par
 1078     struct sw_flow_mask mask;\par
 1079     struct sk_buff *reply = NULL;\par
 1080     struct datapath *dp;\par
 1081     struct sw_flow_actions *old_acts = NULL, *acts = NULL;\par
 1082     struct sw_flow_match match;\par
 1083     struct sw_flow_id sfid;\par
 1084     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1085     int error;\par
 1086     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1087     bool ufid_present;\par
 1088 \par
 1089     /* Extract key. */\par
 1090     error = -EINVAL;\par
 1091     if (!a[OVS_FLOW_ATTR_KEY]) \{\par
 1092         OVS_NLERR(log, "Flow key attribute not present in set flow.");\par
 1093         goto error;\par
 1094     \}\par
 1095 \par
 1096     ufid_present = ovs_nla_get_ufid(&sfid, a[OVS_FLOW_ATTR_UFID], log);\par
 1097     ovs_match_init(&match, &key, &mask);\par
 1098     error = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY],\par
 1099                   a[OVS_FLOW_ATTR_MASK], log);\par
 1100     if (error)\par
 1101         goto error;\par
 1102 \par
 1103     /* Validate actions. */\par
 1104     if (a[OVS_FLOW_ATTR_ACTIONS]) \{\par
 1105         acts = get_flow_actions(a[OVS_FLOW_ATTR_ACTIONS], &key, &mask,\par
 1106                     log);\par
 1107         if (IS_ERR(acts)) \{\par
 1108             error = PTR_ERR(acts);\par
 1109             goto error;\par
 1110         \}\par
 1111 \par
 1112         /* Can allocate before locking if have acts. */\par
 1113         reply = ovs_flow_cmd_alloc_info(acts, &sfid, info, false,\par
 1114                         ufid_flags);\par
 1115         if (IS_ERR(reply)) \{\par
 1116             error = PTR_ERR(reply);\par
 1117             goto err_kfree_acts;\par
 1118         \}\par
 1119     \}\par
 1120 \par
 1121     ovs_lock();\par
 1122     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1123     if (unlikely(!dp)) \{\par
 1124         error = -ENODEV;\par
 1125         goto err_unlock_ovs;\par
 1126     \}\par
 1127     /* Check that the flow exists. */\par
 1128     if (ufid_present)\par
 1129         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &sfid);\par
 1130     else\par
 1131         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1132     if (unlikely(!flow)) \{\par
 1133         error = -ENOENT;\par
 1134         goto err_unlock_ovs;\par
 1135     \}\par
 1136 \par
 1137     /* Update actions, if present. */\par
 1138     if (likely(acts)) \{\par
 1139         old_acts = ovsl_dereference(flow->sf_acts);\par
 1140         rcu_assign_pointer(flow->sf_acts, acts);\par
 1141 \par
 1142         if (unlikely(reply)) \{\par
 1143             error = ovs_flow_cmd_fill_info(flow,\par
 1144                                ovs_header->dp_ifindex,\par
 1145                                reply, info->snd_portid,\par
 1146                                info->snd_seq, 0,\par
 1147                                OVS_FLOW_CMD_NEW,\par
 1148                                ufid_flags);\par
 1149             BUG_ON(error < 0);\par
 1150         \}\par
 1151     \} else \{\par
 1152         /* Could not alloc without acts before locking. */\par
 1153         reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex,\par
 1154                         info, OVS_FLOW_CMD_NEW, false,\par
 1155                         ufid_flags);\par
 1156 \par
 1157         if (unlikely(IS_ERR(reply))) \{\par
 1158             error = PTR_ERR(reply);\par
 1159             goto err_unlock_ovs;\par
 1160         \}\par
 1161     \}\par
 1162 \par
 1163     /* Clear stats. */\par
 1164     if (a[OVS_FLOW_ATTR_CLEAR])\par
 1165         ovs_flow_stats_clear(flow);\par
 1166     ovs_unlock();\par
 1167 \par
 1168     if (reply)\par
 1169         ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1170     if (old_acts)\par
 1171         ovs_nla_free_flow_actions(old_acts);\par
 1172 \par
 1173     return 0;\par
 1174 \par
 1175 err_unlock_ovs:\par
 1176     ovs_unlock();\par
 1177     kfree_skb(reply);\par
 1178 err_kfree_acts:\par
 1179     kfree(acts);\par
 1180 error:\par
 1181     return error;\par
 1182 \}\par
}
}
{\xe \v ovs_init_net\:datapath.c}
{\xe \v datapath.c\:ovs_init_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __net_init ovs_init_net (struct net *  {\i net}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2212 \{\par
 2213     struct ovs_net *ovs_net = net_generic(net, ovs_net_id);\par
 2214 \par
 2215     INIT_LIST_HEAD(&ovs_net->dps);\par
 2216     INIT_WORK(&ovs_net->dp_notify_work, ovs_dp_notify_wq);\par
 2217     return 0;\par
 2218 \}\par
}
}
{\xe \v ovs_lock\:datapath.c}
{\xe \v datapath.c\:ovs_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_lock (void )}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   121 \{\par
  122     mutex_lock(&ovs_mutex);\par
  123 \}\par
}
}
{\xe \v ovs_lookup_vport\:datapath.c}
{\xe \v datapath.c\:ovs_lookup_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_lookup_vport (const struct {\b datapath} *  {\i dp}, u16  {\i port_no})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221 \{\par
  222     struct vport *vport;\par
  223     struct hlist_head *head;\par
  224 \par
  225     head = vport_hash_bucket(dp, port_no);\par
  226     hlist_for_each_entry_rcu(vport, head, dp_hash_node) \{\par
  227         if (vport->port_no == port_no)\par
  228             return vport;\par
  229     \}\par
  230     return NULL;\par
  231 \}\par
}
}
{\xe \v ovs_must_notify\:datapath.c}
{\xe \v datapath.c\:ovs_must_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_must_notify (struct {\b genl_family} *  {\i family}, struct genl_info *  {\i info}, unsigned int  {\i group}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89 \{\par
   90     return info->nlhdr->nlmsg_flags & NLM_F_ECHO ||\par
   91            genl_has_listeners(family, genl_info_net(info), group);\par
   92 \}\par
}
}
{\xe \v ovs_notify\:datapath.c}
{\xe \v datapath.c\:ovs_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_notify (struct {\b genl_family} *  {\i family}, struct genl_multicast_group *  {\i grp}, struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    96 \{\par
   97     genl_notify(family, skb, genl_info_net(info),\par
   98             info->snd_portid, GROUP_ID(grp), info->nlhdr, GFP_KERNEL);\par
   99 \}\par
}
}
{\xe \v ovs_packet_cmd_execute\:datapath.c}
{\xe \v datapath.c\:ovs_packet_cmd_execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_packet_cmd_execute (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   537 \{\par
  538     struct ovs_header *ovs_header = info->userhdr;\par
  539     struct nlattr **a = info->attrs;\par
  540     struct sw_flow_actions *acts;\par
  541     struct sk_buff *packet;\par
  542     struct sw_flow *flow;\par
  543     struct sw_flow_actions *sf_acts;\par
  544     struct datapath *dp;\par
  545     struct ethhdr *eth;\par
  546     struct vport *input_vport;\par
  547     int len;\par
  548     int err;\par
  549     bool log = !a[OVS_PACKET_ATTR_PROBE];\par
  550 \par
  551     err = -EINVAL;\par
  552     if (!a[OVS_PACKET_ATTR_PACKET] || !a[OVS_PACKET_ATTR_KEY] ||\par
  553         !a[OVS_PACKET_ATTR_ACTIONS])\par
  554         goto err;\par
  555 \par
  556     len = nla_len(a[OVS_PACKET_ATTR_PACKET]);\par
  557     packet = __dev_alloc_skb(NET_IP_ALIGN + len, GFP_KERNEL);\par
  558     err = -ENOMEM;\par
  559     if (!packet)\par
  560         goto err;\par
  561     skb_reserve(packet, NET_IP_ALIGN);\par
  562 \par
  563     nla_memcpy(__skb_put(packet, len), a[OVS_PACKET_ATTR_PACKET], len);\par
  564 \par
  565     skb_reset_mac_header(packet);\par
  566     eth = eth_hdr(packet);\par
  567 \par
  568     /* Normally, setting the skb 'protocol' field would be handled by a\par
  569      * call to eth_type_trans(), but it assumes there's a sending\par
  570      * device, which we may not have.\par
  571      */\par
  572     if (eth_proto_is_802_3(eth->h_proto))\par
  573         packet->protocol = eth->h_proto;\par
  574     else\par
  575         packet->protocol = htons(ETH_P_802_2);\par
  576 \par
  577     /* Build an sw_flow for sending this packet. */\par
  578     flow = ovs_flow_alloc();\par
  579     err = PTR_ERR(flow);\par
  580     if (IS_ERR(flow))\par
  581         goto err_kfree_skb;\par
  582 \par
  583     err = ovs_flow_key_extract_userspace(a[OVS_PACKET_ATTR_KEY], packet,\par
  584                          &flow->key, log);\par
  585     if (err)\par
  586         goto err_flow_free;\par
  587 \par
  588     err = ovs_nla_copy_actions(a[OVS_PACKET_ATTR_ACTIONS],\par
  589                    &flow->key, &acts, log);\par
  590     if (err)\par
  591         goto err_flow_free;\par
  592 \par
  593     rcu_assign_pointer(flow->sf_acts, acts);\par
  594     OVS_CB(packet)->egress_tun_info = NULL;\par
  595     packet->priority = flow->key.phy.priority;\par
  596     packet->mark = flow->key.phy.skb_mark;\par
  597 \par
  598     rcu_read_lock();\par
  599     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
  600     err = -ENODEV;\par
  601     if (!dp)\par
  602         goto err_unlock;\par
  603 \par
  604     input_vport = ovs_vport_rcu(dp, flow->key.phy.in_port);\par
  605     if (!input_vport)\par
  606         input_vport = ovs_vport_rcu(dp, OVSP_LOCAL);\par
  607 \par
  608     if (!input_vport)\par
  609         goto err_unlock;\par
  610 \par
  611     OVS_CB(packet)->input_vport = input_vport;\par
  612     sf_acts = rcu_dereference(flow->sf_acts);\par
  613 \par
  614     local_bh_disable();\par
  615     err = ovs_execute_actions(dp, packet, sf_acts, &flow->key);\par
  616     local_bh_enable();\par
  617     rcu_read_unlock();\par
  618 \par
  619     ovs_flow_free(flow, false);\par
  620     return err;\par
  621 \par
  622 err_unlock:\par
  623     rcu_read_unlock();\par
  624 err_flow_free:\par
  625     ovs_flow_free(flow, false);\par
  626 err_kfree_skb:\par
  627     kfree_skb(packet);\par
  628 err:\par
  629     return err;\par
  630 \}\par
}
}
{\xe \v ovs_unlock\:datapath.c}
{\xe \v datapath.c\:ovs_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_unlock (void )}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126 \{\par
  127     mutex_unlock(&ovs_mutex);\par
  128 \}\par
}
}
{\xe \v ovs_vport_cmd_alloc_info\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_vport_cmd_alloc_info (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1841 \{\par
 1842     return nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\par
 1843 \}\par
}
}
{\xe \v ovs_vport_cmd_build_info\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_build_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sk_buff* ovs_vport_cmd_build_info (struct {\b vport} *  {\i vport}, u32  {\i portid}, u32  {\i seq}, u8  {\i cmd})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1848 \{\par
 1849     struct sk_buff *skb;\par
 1850     int retval;\par
 1851 \par
 1852     skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\par
 1853     if (!skb)\par
 1854         return ERR_PTR(-ENOMEM);\par
 1855 \par
 1856     retval = ovs_vport_cmd_fill_info(vport, skb, portid, seq, 0, cmd);\par
 1857     BUG_ON(retval < 0);\par
 1858 \par
 1859     return skb;\par
 1860 \}\par
}
}
{\xe \v ovs_vport_cmd_del\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2025 \{\par
 2026     struct nlattr **a = info->attrs;\par
 2027     struct sk_buff *reply;\par
 2028     struct vport *vport;\par
 2029     int err;\par
 2030 \par
 2031     reply = ovs_vport_cmd_alloc_info();\par
 2032     if (!reply)\par
 2033         return -ENOMEM;\par
 2034 \par
 2035     ovs_lock();\par
 2036     vport = lookup_vport(sock_net(skb->sk), info->userhdr, a);\par
 2037     err = PTR_ERR(vport);\par
 2038     if (IS_ERR(vport))\par
 2039         goto exit_unlock_free;\par
 2040 \par
 2041     if (vport->port_no == OVSP_LOCAL) \{\par
 2042         err = -EINVAL;\par
 2043         goto exit_unlock_free;\par
 2044     \}\par
 2045 \par
 2046     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2047                       info->snd_seq, 0, OVS_VPORT_CMD_DEL);\par
 2048     BUG_ON(err < 0);\par
 2049     ovs_dp_detach_port(vport);\par
 2050     ovs_unlock();\par
 2051 \par
 2052     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 2053     return 0;\par
 2054 \par
 2055 exit_unlock_free:\par
 2056     ovs_unlock();\par
 2057     kfree_skb(reply);\par
 2058     return err;\par
 2059 \}\par
}
}
{\xe \v ovs_vport_cmd_dump\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2092 \{\par
 2093     struct ovs_header *ovs_header = genlmsg_data(nlmsg_data(cb->nlh));\par
 2094     struct datapath *dp;\par
 2095     int bucket = cb->args[0], skip = cb->args[1];\par
 2096     int i, j = 0;\par
 2097 \par
 2098     rcu_read_lock();\par
 2099     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 2100     if (!dp) \{\par
 2101         rcu_read_unlock();\par
 2102         return -ENODEV;\par
 2103     \}\par
 2104     for (i = bucket; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 2105         struct vport *vport;\par
 2106 \par
 2107         j = 0;\par
 2108         hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node) \{\par
 2109             if (j >= skip &&\par
 2110                 ovs_vport_cmd_fill_info(vport, skb,\par
 2111                             NETLINK_CB(cb->skb).portid,\par
 2112                             cb->nlh->nlmsg_seq,\par
 2113                             NLM_F_MULTI,\par
 2114                             OVS_VPORT_CMD_NEW) < 0)\par
 2115                 goto out;\par
 2116 \par
 2117             j++;\par
 2118         \}\par
 2119         skip = 0;\par
 2120     \}\par
 2121 out:\par
 2122     rcu_read_unlock();\par
 2123 \par
 2124     cb->args[0] = i;\par
 2125     cb->args[1] = j;\par
 2126 \par
 2127     return skb->len;\par
 2128 \}\par
}
}
{\xe \v ovs_vport_cmd_fill_info\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_fill_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1801 \{\par
 1802     struct ovs_header *ovs_header;\par
 1803     struct ovs_vport_stats vport_stats;\par
 1804     int err;\par
 1805 \par
 1806     ovs_header = genlmsg_put(skb, portid, seq, &dp_vport_genl_family,\par
 1807                  flags, cmd);\par
 1808     if (!ovs_header)\par
 1809         return -EMSGSIZE;\par
 1810 \par
 1811     ovs_header->dp_ifindex = get_dpifindex(vport->dp);\par
 1812 \par
 1813     if (nla_put_u32(skb, OVS_VPORT_ATTR_PORT_NO, vport->port_no) ||\par
 1814         nla_put_u32(skb, OVS_VPORT_ATTR_TYPE, vport->ops->type) ||\par
 1815         nla_put_string(skb, OVS_VPORT_ATTR_NAME, vport->ops->get_name(vport)))\par
 1816         goto nla_put_failure;\par
 1817 \par
 1818     ovs_vport_get_stats(vport, &vport_stats);\par
 1819     if (nla_put(skb, OVS_VPORT_ATTR_STATS, sizeof(struct ovs_vport_stats),\par
 1820             &vport_stats))\par
 1821         goto nla_put_failure;\par
 1822 \par
 1823     if (ovs_vport_get_upcall_portids(vport, skb))\par
 1824         goto nla_put_failure;\par
 1825 \par
 1826     err = ovs_vport_get_options(vport, skb);\par
 1827     if (err == -EMSGSIZE)\par
 1828         goto error;\par
 1829 \par
 1830     genlmsg_end(skb, ovs_header);\par
 1831     return 0;\par
 1832 \par
 1833 nla_put_failure:\par
 1834     err = -EMSGSIZE;\par
 1835 error:\par
 1836     genlmsg_cancel(skb, ovs_header);\par
 1837     return err;\par
 1838 \}\par
}
}
{\xe \v ovs_vport_cmd_get\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2062 \{\par
 2063     struct nlattr **a = info->attrs;\par
 2064     struct ovs_header *ovs_header = info->userhdr;\par
 2065     struct sk_buff *reply;\par
 2066     struct vport *vport;\par
 2067     int err;\par
 2068 \par
 2069     reply = ovs_vport_cmd_alloc_info();\par
 2070     if (!reply)\par
 2071         return -ENOMEM;\par
 2072 \par
 2073     rcu_read_lock();\par
 2074     vport = lookup_vport(sock_net(skb->sk), ovs_header, a);\par
 2075     err = PTR_ERR(vport);\par
 2076     if (IS_ERR(vport))\par
 2077         goto exit_unlock_free;\par
 2078     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2079                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 2080     BUG_ON(err < 0);\par
 2081     rcu_read_unlock();\par
 2082 \par
 2083     return genlmsg_reply(reply, info);\par
 2084 \par
 2085 exit_unlock_free:\par
 2086     rcu_read_unlock();\par
 2087     kfree_skb(reply);\par
 2088     return err;\par
 2089 \}\par
}
}
{\xe \v ovs_vport_cmd_new\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1897 \{\par
 1898     struct nlattr **a = info->attrs;\par
 1899     struct ovs_header *ovs_header = info->userhdr;\par
 1900     struct vport_parms parms;\par
 1901     struct sk_buff *reply;\par
 1902     struct vport *vport;\par
 1903     struct datapath *dp;\par
 1904     u32 port_no;\par
 1905     int err;\par
 1906 \par
 1907     if (!a[OVS_VPORT_ATTR_NAME] || !a[OVS_VPORT_ATTR_TYPE] ||\par
 1908         !a[OVS_VPORT_ATTR_UPCALL_PID])\par
 1909         return -EINVAL;\par
 1910 \par
 1911     port_no = a[OVS_VPORT_ATTR_PORT_NO]\par
 1912         ? nla_get_u32(a[OVS_VPORT_ATTR_PORT_NO]) : 0;\par
 1913     if (port_no >= DP_MAX_PORTS)\par
 1914         return -EFBIG;\par
 1915 \par
 1916     reply = ovs_vport_cmd_alloc_info();\par
 1917     if (!reply)\par
 1918         return -ENOMEM;\par
 1919 \par
 1920     ovs_lock();\par
 1921 restart:\par
 1922     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1923     err = -ENODEV;\par
 1924     if (!dp)\par
 1925         goto exit_unlock_free;\par
 1926 \par
 1927     if (port_no) \{\par
 1928         vport = ovs_vport_ovsl(dp, port_no);\par
 1929         err = -EBUSY;\par
 1930         if (vport)\par
 1931             goto exit_unlock_free;\par
 1932     \} else \{\par
 1933         for (port_no = 1; ; port_no++) \{\par
 1934             if (port_no >= DP_MAX_PORTS) \{\par
 1935                 err = -EFBIG;\par
 1936                 goto exit_unlock_free;\par
 1937             \}\par
 1938             vport = ovs_vport_ovsl(dp, port_no);\par
 1939             if (!vport)\par
 1940                 break;\par
 1941         \}\par
 1942     \}\par
 1943 \par
 1944     parms.name = nla_data(a[OVS_VPORT_ATTR_NAME]);\par
 1945     parms.type = nla_get_u32(a[OVS_VPORT_ATTR_TYPE]);\par
 1946     parms.options = a[OVS_VPORT_ATTR_OPTIONS];\par
 1947     parms.dp = dp;\par
 1948     parms.port_no = port_no;\par
 1949     parms.upcall_portids = a[OVS_VPORT_ATTR_UPCALL_PID];\par
 1950 \par
 1951     vport = new_vport(&parms);\par
 1952     err = PTR_ERR(vport);\par
 1953     if (IS_ERR(vport)) \{\par
 1954         if (err == -EAGAIN)\par
 1955             goto restart;\par
 1956         goto exit_unlock_free;\par
 1957     \}\par
 1958 \par
 1959     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 1960                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 1961     BUG_ON(err < 0);\par
 1962     ovs_unlock();\par
 1963 \par
 1964     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 1965     return 0;\par
 1966 \par
 1967 exit_unlock_free:\par
 1968     ovs_unlock();\par
 1969     kfree_skb(reply);\par
 1970     return err;\par
 1971 \}\par
}
}
{\xe \v ovs_vport_cmd_set\:datapath.c}
{\xe \v datapath.c\:ovs_vport_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1974 \{\par
 1975     struct nlattr **a = info->attrs;\par
 1976     struct sk_buff *reply;\par
 1977     struct vport *vport;\par
 1978     int err;\par
 1979 \par
 1980     reply = ovs_vport_cmd_alloc_info();\par
 1981     if (!reply)\par
 1982         return -ENOMEM;\par
 1983 \par
 1984     ovs_lock();\par
 1985     vport = lookup_vport(sock_net(skb->sk), info->userhdr, a);\par
 1986     err = PTR_ERR(vport);\par
 1987     if (IS_ERR(vport))\par
 1988         goto exit_unlock_free;\par
 1989 \par
 1990     if (a[OVS_VPORT_ATTR_TYPE] &&\par
 1991         nla_get_u32(a[OVS_VPORT_ATTR_TYPE]) != vport->ops->type) \{\par
 1992         err = -EINVAL;\par
 1993         goto exit_unlock_free;\par
 1994     \}\par
 1995 \par
 1996     if (a[OVS_VPORT_ATTR_OPTIONS]) \{\par
 1997         err = ovs_vport_set_options(vport, a[OVS_VPORT_ATTR_OPTIONS]);\par
 1998         if (err)\par
 1999             goto exit_unlock_free;\par
 2000     \}\par
 2001 \par
 2002     if (a[OVS_VPORT_ATTR_UPCALL_PID]) \{\par
 2003         struct nlattr *ids = a[OVS_VPORT_ATTR_UPCALL_PID];\par
 2004 \par
 2005         err = ovs_vport_set_upcall_portids(vport, ids);\par
 2006         if (err)\par
 2007             goto exit_unlock_free;\par
 2008     \}\par
 2009 \par
 2010     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2011                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 2012     BUG_ON(err < 0);\par
 2013     ovs_unlock();\par
 2014 \par
 2015     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 2016     return 0;\par
 2017 \par
 2018 exit_unlock_free:\par
 2019     ovs_unlock();\par
 2020     kfree_skb(reply);\par
 2021     return err;\par
 2022 \}\par
}
}
{\xe \v queue_gso_packets\:datapath.c}
{\xe \v datapath.c\:queue_gso_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int queue_gso_packets (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   339 \{\par
  340     unsigned short gso_type = skb_shinfo(skb)->gso_type;\par
  341     struct sw_flow_key later_key;\par
  342     struct sk_buff *segs, *nskb;\par
  343     struct ovs_skb_cb ovs_cb;\par
  344     int err;\par
  345 \par
  346     ovs_cb = *OVS_CB(skb);\par
  347     segs = __skb_gso_segment(skb, NETIF_F_SG, false);\par
  348     *OVS_CB(skb) = ovs_cb;\par
  349     if (IS_ERR(segs))\par
  350         return PTR_ERR(segs);\par
  351     if (segs == NULL)\par
  352         return -EINVAL;\par
  353 \par
  354     if (gso_type & SKB_GSO_UDP) \{\par
  355         /* The initial flow key extracted by ovs_flow_key_extract()\par
  356          * in this case is for a first fragment, so we need to\par
  357          * properly mark later fragments.\par
  358          */\par
  359         later_key = *key;\par
  360         later_key.ip.frag = OVS_FRAG_TYPE_LATER;\par
  361     \}\par
  362 \par
  363     /* Queue all of the segments. */\par
  364     skb = segs;\par
  365     do \{\par
  366         *OVS_CB(skb) = ovs_cb;\par
  367         if (gso_type & SKB_GSO_UDP && skb != segs)\par
  368             key = &later_key;\par
  369 \par
  370         err = queue_userspace_packet(dp, skb, key, upcall_info);\par
  371         if (err)\par
  372             break;\par
  373 \par
  374     \} while ((skb = skb->next));\par
  375 \par
  376     /* Free all of the segments. */\par
  377     skb = segs;\par
  378     do \{\par
  379         nskb = skb->next;\par
  380         if (err)\par
  381             kfree_skb(skb);\par
  382         else\par
  383             consume_skb(skb);\par
  384     \} while ((skb = nskb));\par
  385     return err;\par
  386 \}\par
}
}
{\xe \v queue_userspace_packet\:datapath.c}
{\xe \v datapath.c\:queue_userspace_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int queue_userspace_packet (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   413 \{\par
  414     struct ovs_header *upcall;\par
  415     struct sk_buff *nskb = NULL;\par
  416     struct sk_buff *user_skb = NULL; /* to be queued to userspace */\par
  417     struct nlattr *nla;\par
  418     struct genl_info info = \{\par
  419 #ifdef HAVE_GENLMSG_NEW_UNICAST\par
  420         .dst_sk = ovs_dp_get_net(dp)->genl_sock,\par
  421 #endif\par
  422         .snd_portid = upcall_info->portid,\par
  423     \};\par
  424     size_t len;\par
  425     unsigned int hlen;\par
  426     int err, dp_ifindex;\par
  427 \par
  428     dp_ifindex = get_dpifindex(dp);\par
  429     if (!dp_ifindex)\par
  430         return -ENODEV;\par
  431 \par
  432     if (skb_vlan_tag_present(skb)) \{\par
  433         nskb = skb_clone(skb, GFP_ATOMIC);\par
  434         if (!nskb)\par
  435             return -ENOMEM;\par
  436 \par
  437         nskb = vlan_insert_tag_set_proto(nskb, nskb->vlan_proto, skb_vlan_tag_get(nskb));\par
  438         if (!nskb)\par
  439             return -ENOMEM;\par
  440 \par
  441         vlan_set_tci(nskb, 0);\par
  442 \par
  443         skb = nskb;\par
  444     \}\par
  445 \par
  446     if (nla_attr_size(skb->len) > USHRT_MAX) \{\par
  447         err = -EFBIG;\par
  448         goto out;\par
  449     \}\par
  450 \par
  451     /* Complete checksum if needed */\par
  452     if (skb->ip_summed == CHECKSUM_PARTIAL &&\par
  453         (err = skb_checksum_help(skb)))\par
  454         goto out;\par
  455 \par
  456     /* Older versions of OVS user space enforce alignment of the last\par
  457      * Netlink attribute to NLA_ALIGNTO which would require extensive\par
  458      * padding logic. Only perform zerocopy if padding is not required.\par
  459      */\par
  460     if (dp->user_features & OVS_DP_F_UNALIGNED)\par
  461         hlen = skb_zerocopy_headlen(skb);\par
  462     else\par
  463         hlen = skb->len;\par
  464 \par
  465     len = upcall_msg_size(upcall_info, hlen);\par
  466     user_skb = genlmsg_new_unicast(len, &info, GFP_ATOMIC);\par
  467     if (!user_skb) \{\par
  468         err = -ENOMEM;\par
  469         goto out;\par
  470     \}\par
  471 \par
  472     upcall = genlmsg_put(user_skb, 0, 0, &dp_packet_genl_family,\par
  473                  0, upcall_info->cmd);\par
  474     upcall->dp_ifindex = dp_ifindex;\par
  475 \par
  476     err = ovs_nla_put_key(key, key, OVS_PACKET_ATTR_KEY, false, user_skb);\par
  477     BUG_ON(err);\par
  478 \par
  479     if (upcall_info->userdata)\par
  480         __nla_put(user_skb, OVS_PACKET_ATTR_USERDATA,\par
  481               nla_len(upcall_info->userdata),\par
  482               nla_data(upcall_info->userdata));\par
  483 \par
  484     if (upcall_info->egress_tun_info) \{\par
  485         nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_EGRESS_TUN_KEY);\par
  486         err = ovs_nla_put_egress_tunnel_key(user_skb,\par
  487                             upcall_info->egress_tun_info);\par
  488         BUG_ON(err);\par
  489         nla_nest_end(user_skb, nla);\par
  490     \}\par
  491 \par
  492     if (upcall_info->actions_len) \{\par
  493         nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_ACTIONS);\par
  494         err = ovs_nla_put_actions(upcall_info->actions,\par
  495                       upcall_info->actions_len,\par
  496                       user_skb);\par
  497         if (!err)\par
  498             nla_nest_end(user_skb, nla);\par
  499         else\par
  500             nla_nest_cancel(user_skb, nla);\par
  501     \}\par
  502 \par
  503     /* Only reserve room for attribute header, packet data is added\par
  504      * in skb_zerocopy()\par
  505      */\par
  506     if (!(nla = nla_reserve(user_skb, OVS_PACKET_ATTR_PACKET, 0))) \{\par
  507         err = -ENOBUFS;\par
  508         goto out;\par
  509     \}\par
  510     nla->nla_len = nla_attr_size(skb->len);\par
  511 \par
  512     err = skb_zerocopy(user_skb, skb, skb->len, hlen);\par
  513     if (err)\par
  514         goto out;\par
  515 \par
  516     /* Pad OVS_PACKET_ATTR_PACKET if linear copy was performed */\par
  517     if (!(dp->user_features & OVS_DP_F_UNALIGNED)) \{\par
  518         size_t plen = NLA_ALIGN(user_skb->len) - user_skb->len;\par
  519 \par
  520         if (plen > 0)\par
  521             memset(skb_put(user_skb, plen), 0, plen);\par
  522     \}\par
  523 \par
  524     ((struct nlmsghdr *) user_skb->data)->nlmsg_len = user_skb->len;\par
  525 \par
  526     err = genlmsg_unicast(ovs_dp_get_net(dp), user_skb, upcall_info->portid);\par
  527     user_skb = NULL;\par
  528 out:\par
  529     if (err)\par
  530         skb_tx_error(skb);\par
  531     kfree_skb(user_skb);\par
  532     kfree_skb(nskb);\par
  533     return err;\par
  534 \}\par
}
}
{\xe \v should_fill_actions\:datapath.c}
{\xe \v datapath.c\:should_fill_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_actions (uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   702 \{\par
  703     return !(ufid_flags & OVS_UFID_F_OMIT_ACTIONS);\par
  704 \}\par
}
}
{\xe \v should_fill_key\:datapath.c}
{\xe \v datapath.c\:should_fill_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_key (const struct {\b sw_flow_id} *  {\i sfid}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   691 \{\par
  692     return ovs_identifier_is_ufid(sfid) &&\par
  693            !(ufid_flags & OVS_UFID_F_OMIT_KEY);\par
  694 \}\par
}
}
{\xe \v should_fill_mask\:datapath.c}
{\xe \v datapath.c\:should_fill_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_mask (uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   697 \{\par
  698     return !(ufid_flags & OVS_UFID_F_OMIT_MASK);\par
  699 \}\par
}
}
{\xe \v upcall_msg_size\:datapath.c}
{\xe \v datapath.c\:upcall_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t upcall_msg_size (const struct {\b dp_upcall_info} *  {\i upcall_info}, unsigned int  {\i hdrlen}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   390 \{\par
  391     size_t size = NLMSG_ALIGN(sizeof(struct ovs_header))\par
  392         + nla_total_size(hdrlen) /* OVS_PACKET_ATTR_PACKET */\par
  393         + nla_total_size(ovs_key_attr_size()); /* OVS_PACKET_ATTR_KEY */\par
  394 \par
  395     /* OVS_PACKET_ATTR_USERDATA */\par
  396     if (upcall_info->userdata)\par
  397         size += NLA_ALIGN(upcall_info->userdata->nla_len);\par
  398 \par
  399     /* OVS_PACKET_ATTR_EGRESS_TUN_KEY */\par
  400     if (upcall_info->egress_tun_info)\par
  401         size += nla_total_size(ovs_tun_key_attr_size());\par
  402 \par
  403     /* OVS_PACKET_ATTR_ACTIONS */\par
  404     if (upcall_info->actions_len)\par
  405         size += nla_total_size(upcall_info->actions_len);\par
  406 \par
  407     return size;\par
  408 \}\par
}
}
{\xe \v vport_hash_bucket\:datapath.c}
{\xe \v datapath.c\:vport_hash_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* vport_hash_bucket (const struct {\b datapath} *  {\i dp}, u16  {\i port_no}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   215 \{\par
  216     return &dp->ports[port_no & (DP_VPORT_HASH_BUCKETS - 1)];\par
  217 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:datapath.c}
{\xe \v datapath.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ovs_net_id} __read_mostly}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v datapath_policy\:datapath.c}
{\xe \v datapath.c\:datapath_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy datapath_policy[{\b OVS_DP_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_DP_ATTR_NAME] = \{ .type = NLA_NUL_STRING, .len = IFNAMSIZ - 1 \},\par
    [OVS_DP_ATTR_UPCALL_PID] = \{ .type = NLA_U32 \},\par
    [OVS_DP_ATTR_USER_FEATURES] = \{ .type = NLA_U32 \},\par
\}\par
}
}
{\xe \v dp_datapath_genl_family\:datapath.c}
{\xe \v datapath.c\:dp_datapath_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_datapath_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_DATAPATH_FAMILY,\par
    .version = OVS_DATAPATH_VERSION,\par
    .maxattr = OVS_DP_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_datapath_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_datapath_genl_ops),\par
    .mcgrps = &ovs_dp_datapath_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_datapath_genl_ops\:datapath.c}
{\xe \v datapath.c\:dp_datapath_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_datapath_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_DP_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_new\par
    \},\par
    \{ .cmd = OVS_DP_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_del\par
    \},\par
    \{ .cmd = OVS_DP_CMD_GET,\par
      .flags = 0,           \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_get,\par
      .dumpit = ovs_dp_cmd_dump\par
    \},\par
    \{ .cmd = OVS_DP_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v dp_flow_genl_family\:datapath.c}
{\xe \v datapath.c\:dp_flow_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_flow_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_FLOW_FAMILY,\par
    .version = OVS_FLOW_VERSION,\par
    .maxattr = OVS_FLOW_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_flow_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_flow_genl_ops),\par
    .mcgrps = &ovs_dp_flow_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_flow_genl_ops\:datapath.c}
{\xe \v datapath.c\:dp_flow_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_flow_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_FLOW_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_new\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_del\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_GET,\par
      .flags = 0,           \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_get,\par
      .dumpit = ovs_flow_cmd_dump\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v dp_genl_families\:datapath.c}
{\xe \v datapath.c\:dp_genl_families}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family}* dp_genl_families[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    &dp_datapath_genl_family,\par
    &dp_vport_genl_family,\par
    &dp_flow_genl_family,\par
    &dp_packet_genl_family,\par
\}\par
}
}
{\xe \v dp_packet_genl_family\:datapath.c}
{\xe \v datapath.c\:dp_packet_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_packet_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_PACKET_FAMILY,\par
    .version = OVS_PACKET_VERSION,\par
    .maxattr = OVS_PACKET_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_packet_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_packet_genl_ops),\par
\}\par
}
}
{\xe \v dp_packet_genl_ops\:datapath.c}
{\xe \v datapath.c\:dp_packet_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_packet_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_PACKET_CMD_EXECUTE,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = packet_policy,\par
      .doit = ovs_packet_cmd_execute\par
    \}\par
\}\par
}
}
{\xe \v dp_vport_genl_family\:datapath.c}
{\xe \v datapath.c\:dp_vport_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family} dp_vport_genl_family}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_VPORT_FAMILY,\par
    .version = OVS_VPORT_VERSION,\par
    .maxattr = OVS_VPORT_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_vport_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_vport_genl_ops),\par
    .mcgrps = &ovs_dp_vport_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_vport_genl_ops\:datapath.c}
{\xe \v datapath.c\:dp_vport_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_vport_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_VPORT_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_new\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_del\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_GET,\par
      .flags = 0,           \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_get,\par
      .dumpit = ovs_vport_cmd_dump\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v flow_policy\:datapath.c}
{\xe \v datapath.c\:flow_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct nla_policy flow_policy{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_FLOW_ATTR_KEY] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_MASK] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_ACTIONS] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_CLEAR] = \{ .type = NLA_FLAG \},\par
    [OVS_FLOW_ATTR_PROBE] = \{ .type = NLA_FLAG \},\par
    [OVS_FLOW_ATTR_UFID] = \{ .type = NLA_UNSPEC, .len = 1 \},\par
    [OVS_FLOW_ATTR_UFID_FLAGS] = \{ .type = NLA_U32 \},\par
\}\par
}
}
{\xe \v ovs_dp_datapath_multicast_group\:datapath.c}
{\xe \v datapath.c\:ovs_dp_datapath_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_datapath_multicast_group{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_DATAPATH_MCGROUP\par
\}\par
}
}
{\xe \v ovs_dp_flow_multicast_group\:datapath.c}
{\xe \v datapath.c\:ovs_dp_flow_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_flow_multicast_group{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_FLOW_MCGROUP\par
\}\par
}
}
{\xe \v ovs_dp_vport_multicast_group\:datapath.c}
{\xe \v datapath.c\:ovs_dp_vport_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_vport_multicast_group}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_VPORT_MCGROUP\par
\}\par
}
}
{\xe \v ovs_net_ops\:datapath.c}
{\xe \v datapath.c\:ovs_net_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct pernet_operations ovs_net_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .init = ovs_init_net,\par
    .exit = ovs_exit_net,\par
    .id   = &ovs_net_id,\par
    .size = sizeof(struct ovs_net),\par
\}\par
}
}
{\xe \v packet_policy\:datapath.c}
{\xe \v datapath.c\:packet_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy packet_policy[{\b OVS_PACKET_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_PACKET_ATTR_PACKET] = \{ .len = ETH_HLEN \},\par
    [OVS_PACKET_ATTR_KEY] = \{ .type = NLA_NESTED \},\par
    [OVS_PACKET_ATTR_ACTIONS] = \{ .type = NLA_NESTED \},\par
    [OVS_PACKET_ATTR_PROBE] = \{ .type = NLA_FLAG \},\par
\}\par
}
}
{\xe \v vport_policy\:datapath.c}
{\xe \v datapath.c\:vport_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy vport_policy[{\b OVS_VPORT_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VPORT_ATTR_NAME] = \{ .type = NLA_NUL_STRING, .len = IFNAMSIZ - 1 \},\par
    [OVS_VPORT_ATTR_STATS] = \{ .len = sizeof(struct ovs_vport_stats) \},\par
    [OVS_VPORT_ATTR_PORT_NO] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_TYPE] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_UPCALL_PID] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_OPTIONS] = \{ .type = NLA_NESTED \},\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/datapath.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/datapath.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/datapath.c}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/init.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/delay.h>}\par
{\f2 #include <linux/time.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/genetlink.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kthread.h>}\par
{\f2 #include <linux/mutex.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <linux/wait.h>}\par
{\f2 #include <asm/div64.h>}\par
{\f2 #include <linux/highmem.h>}\par
{\f2 #include <linux/netfilter_bridge.h>}\par
{\f2 #include <linux/netfilter_ipv4.h>}\par
{\f2 #include <linux/inetdevice.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/dmi.h>}\par
{\f2 #include <net/genetlink.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_table.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for datapath.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2datapath_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_net_id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_must_notify} (struct {\b genl_family} *family, struct genl_info *info, unsigned int group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_notify} (struct {\b genl_family} *family, struct genl_multicast_group *grp, struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b DEFINE_MUTEX} (ovs_mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_lock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_unlock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b queue_gso_packets} (struct {\b datapath} *dp, struct sk_buff *, const struct {\b sw_flow_key} *, const struct {\b dp_upcall_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b queue_userspace_packet} (struct {\b datapath} *dp, struct sk_buff *, const struct {\b sw_flow_key} *, const struct {\b dp_upcall_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b get_dp_rcu} (struct net *net, int dp_ifindex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b get_dp} (struct net *net, int dp_ifindex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_dp_name} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b get_dpifindex} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b destroy_dp_rcu} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b vport_hash_bucket} (const struct {\b datapath} *dp, u16 port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_lookup_vport} (const struct {\b datapath} *dp, u16 port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b new_vport} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_detach_port} (struct {\b vport} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_process_packet} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_dp_upcall} (struct {\b datapath} *dp, struct sk_buff *skb, const struct {\b sw_flow_key} *key, const struct {\b dp_upcall_info} *upcall_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b upcall_msg_size} (const struct {\b dp_upcall_info} *upcall_info, unsigned int hdrlen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_packet_cmd_execute} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b get_dp_stats} (const struct {\b datapath} *dp, struct {\b ovs_dp_stats} *stats, struct {\b ovs_dp_megaflow_stats} *mega_stats)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_key} (const struct {\b sw_flow_id} *sfid, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_mask} (uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b should_fill_actions} (uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b ovs_flow_cmd_msg_size} (const struct {\b sw_flow_actions} *acts, const struct {\b sw_flow_id} *sfid, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_stats} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_actions} (const struct {\b sw_flow} *flow, struct sk_buff *skb, int skb_orig_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_fill_info} (const struct {\b sw_flow} *flow, int dp_ifindex, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd, u32 ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_flow_cmd_alloc_info} (const struct {\b sw_flow_actions} *acts, const struct {\b sw_flow_id} *sfid, struct genl_info *info, {\b bool} always, uint32_t ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_flow_cmd_build_info} (const struct {\b sw_flow} *flow, int dp_ifindex, struct genl_info *info, u8 cmd, {\b bool} always, u32 ufid_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_actions} * {\b get_flow_actions} (const struct nlattr *a, const struct {\b sw_flow_key} *key, const struct {\b sw_flow_mask} *mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_flow_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b ovs_dp_cmd_msg_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_fill_info} (struct {\b datapath} *dp, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_dp_cmd_alloc_info} (struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b datapath} * {\b lookup_datapath} (struct net *net, const struct {\b ovs_header} *{\b ovs_header}, struct nlattr *a[{\b OVS_DP_ATTR_MAX}+1])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_dp_reset_user_features} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_dp_change} (struct {\b datapath} *dp, struct nlattr *a[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __dp_destroy} (struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_dp_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_fill_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, u32 portid, u32 seq, u32 {\b flags}, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b ovs_vport_cmd_alloc_info} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sk_buff * {\b ovs_vport_cmd_build_info} (struct {\b vport} *{\b vport}, u32 portid, u32 seq, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b lookup_vport} (struct net *net, const struct {\b ovs_header} *{\b ovs_header}, struct nlattr *a[{\b OVS_VPORT_ATTR_MAX}+1])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_new} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_set} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_del} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_get} (struct sk_buff *skb, struct genl_info *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_vport_cmd_dump} (struct sk_buff *skb, struct netlink_callback *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_unregister_genl} (int n_families)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b dp_register_genl} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __net_init {\b ovs_init_net} (struct net *net)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __net_exit {\b list_vports_from_net} (struct net *net, struct net *dnet, struct list_head *head)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __net_exit {\b ovs_exit_net} (struct net *dnet)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DEFINE_COMPAT_PNET_REG_FUNC} (device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b dp_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_cleanup} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b dp_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b dp_cleanup})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("Open vSwitch switching {\b datapath}")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_VERSION} (VERSION)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_net_id} {\b __read_mostly}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_packet_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_flow_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} {\b dp_datapath_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b flow_policy} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_multicast_group {\b ovs_dp_flow_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_multicast_group {\b ovs_dp_datapath_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct genl_multicast_group {\b ovs_dp_vport_multicast_group}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b packet_policy} [{\b OVS_PACKET_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_packet_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_flow_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b datapath_policy} [{\b OVS_DP_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_datapath_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b vport_policy} [{\b OVS_VPORT_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genl_ops {\b dp_vport_genl_ops} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b genl_family} {\b dp_vport_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b genl_family} * {\b dp_genl_families} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct pernet_operations {\b ovs_net_ops}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:linux/datapath.c}
{\xe \v linux/datapath.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __dp_destroy\:linux/datapath.c}
{\xe \v linux/datapath.c\:__dp_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __dp_destroy (struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1614 \{\par
 1615     int i;\par
 1616 \par
 1617     for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 1618         struct vport *vport;\par
 1619         struct hlist_node *n;\par
 1620 \par
 1621         hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node)\par
 1622             if (vport->port_no != OVSP_LOCAL)\par
 1623                 ovs_dp_detach_port(vport);\par
 1624     \}\par
 1625 \par
 1626     list_del_rcu(&dp->list_node);\par
 1627 \par
 1628     /* OVSP_LOCAL is datapath internal port. We need to make sure that\par
 1629      * all ports in datapath are destroyed first before freeing datapath.\par
 1630      */\par
 1631     ovs_dp_detach_port(ovs_vport_ovsl(dp, OVSP_LOCAL));\par
 1632 \par
 1633     /* RCU destroy the flow table */\par
 1634     call_rcu(&dp->rcu, destroy_dp_rcu);\par
 1635 \}\par
}
}
{\xe \v DEFINE_COMPAT_PNET_REG_FUNC\:linux/datapath.c}
{\xe \v linux/datapath.c\:DEFINE_COMPAT_PNET_REG_FUNC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DEFINE_COMPAT_PNET_REG_FUNC (device )}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEFINE_MUTEX\:linux/datapath.c}
{\xe \v linux/datapath.c\:DEFINE_MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static DEFINE_MUTEX (ovs_mutex ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DOC: Locking:\par
All writes e.g. Writes to device state (add/remove datapath, port, set operations on vports, etc.), Writes to other state (flow table modifications, set miscellaneous datapath parameters, etc.) are protected by ovs_lock.\par
Reads are protected by RCU.\par
There are a few special cases (mostly stats) that have their own synchronization but they nest under all of above and don't interact with each other.\par
The RTNL lock nests inside ovs_mutex. \par
}}
{\xe \v destroy_dp_rcu\:linux/datapath.c}
{\xe \v linux/datapath.c\:destroy_dp_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void destroy_dp_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   203 \{\par
  204     struct datapath *dp = container_of(rcu, struct datapath, rcu);\par
  205 \par
  206     ovs_flow_tbl_destroy(&dp->table);\par
  207     free_percpu(dp->stats_percpu);\par
  208     release_net(ovs_dp_get_net(dp));\par
  209     kfree(dp->ports);\par
  210     kfree(dp);\par
  211 \}\par
}
}
{\xe \v dp_cleanup\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_cleanup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_cleanup (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2344 \{\par
 2345     dp_unregister_genl(ARRAY_SIZE(dp_genl_families));\par
 2346     ovs_netdev_exit();\par
 2347     unregister_netdevice_notifier(&ovs_dp_device_notifier);\par
 2348     unregister_pernet_device(&ovs_net_ops);\par
 2349     rcu_barrier();\par
 2350     ovs_vport_exit();\par
 2351     ovs_flow_exit();\par
 2352     ovs_internal_dev_rtnl_link_unregister();\par
 2353     action_fifos_exit();\par
 2354 \}\par
}
}
{\xe \v dp_init\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init dp_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2284 \{\par
 2285     int err;\par
 2286 \par
 2287     BUILD_BUG_ON(sizeof(struct ovs_skb_cb) > FIELD_SIZEOF(struct sk_buff, cb));\par
 2288 \par
 2289     pr_info("Open vSwitch switching datapath %s\\n", VERSION);\par
 2290 \par
 2291     err = action_fifos_init();\par
 2292     if (err)\par
 2293         goto error;\par
 2294 \par
 2295     err = ovs_internal_dev_rtnl_link_register();\par
 2296     if (err)\par
 2297         goto error_action_fifos_exit;\par
 2298 \par
 2299     err = ovs_flow_init();\par
 2300     if (err)\par
 2301         goto error_unreg_rtnl_link;\par
 2302 \par
 2303     err = ovs_vport_init();\par
 2304     if (err)\par
 2305         goto error_flow_exit;\par
 2306 \par
 2307     err = register_pernet_device(&ovs_net_ops);\par
 2308     if (err)\par
 2309         goto error_vport_exit;\par
 2310 \par
 2311     err = register_netdevice_notifier(&ovs_dp_device_notifier);\par
 2312     if (err)\par
 2313         goto error_netns_exit;\par
 2314 \par
 2315     err = ovs_netdev_init();\par
 2316     if (err)\par
 2317         goto error_unreg_notifier;\par
 2318 \par
 2319     err = dp_register_genl();\par
 2320     if (err < 0)\par
 2321         goto error_unreg_netdev;\par
 2322 \par
 2323     return 0;\par
 2324 \par
 2325 error_unreg_netdev:\par
 2326     ovs_netdev_exit();\par
 2327 error_unreg_notifier:\par
 2328     unregister_netdevice_notifier(&ovs_dp_device_notifier);\par
 2329 error_netns_exit:\par
 2330     unregister_pernet_device(&ovs_net_ops);\par
 2331 error_vport_exit:\par
 2332     ovs_vport_exit();\par
 2333 error_flow_exit:\par
 2334     ovs_flow_exit();\par
 2335 error_unreg_rtnl_link:\par
 2336     ovs_internal_dev_rtnl_link_unregister();\par
 2337 error_action_fifos_exit:\par
 2338     action_fifos_exit();\par
 2339 error:\par
 2340     return err;\par
 2341 \}\par
}
}
{\xe \v dp_register_genl\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_register_genl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int dp_register_genl (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2193 \{\par
 2194     int err;\par
 2195     int i;\par
 2196 \par
 2197     for (i = 0; i < ARRAY_SIZE(dp_genl_families); i++) \{\par
 2198 \par
 2199         err = genl_register_family(dp_genl_families[i]);\par
 2200         if (err)\par
 2201             goto error;\par
 2202     \}\par
 2203 \par
 2204     return 0;\par
 2205 \par
 2206 error:\par
 2207     dp_unregister_genl(i);\par
 2208     return err;\par
 2209 \}\par
}
}
{\xe \v dp_unregister_genl\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_unregister_genl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_unregister_genl (int  {\i n_families}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2185 \{\par
 2186     int i;\par
 2187 \par
 2188     for (i = 0; i < n_families; i++)\par
 2189         genl_unregister_family(dp_genl_families[i]);\par
 2190 \}\par
}
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/datapath.c}
{\xe \v linux/datapath.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_net_id} )}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_dp\:linux/datapath.c}
{\xe \v linux/datapath.c\:get_dp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* get_dp (struct net *  {\i net}, int  {\i dp_ifindex}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   166 \{\par
  167     struct datapath *dp;\par
  168 \par
  169     WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_ovsl_is_held());\par
  170     rcu_read_lock();\par
  171     dp = get_dp_rcu(net, dp_ifindex);\par
  172     rcu_read_unlock();\par
  173 \par
  174     return dp;\par
  175 \}\par
}
}
{\xe \v get_dp_rcu\:linux/datapath.c}
{\xe \v linux/datapath.c\:get_dp_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* get_dp_rcu (struct net *  {\i net}, int  {\i dp_ifindex}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     struct net_device *dev = dev_get_by_index_rcu(net, dp_ifindex);\par
  152 \par
  153     if (dev) \{\par
  154         struct vport *vport = ovs_internal_dev_get_vport(dev);\par
  155         if (vport)\par
  156             return vport->dp;\par
  157     \}\par
  158 \par
  159     return NULL;\par
  160 \}\par
}
}
{\xe \v get_dp_stats\:linux/datapath.c}
{\xe \v linux/datapath.c\:get_dp_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void get_dp_stats (const struct {\b datapath} *  {\i dp}, struct {\b ovs_dp_stats} *  {\i stats}, struct {\b ovs_dp_megaflow_stats} *  {\i mega_stats}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   661 \{\par
  662     int i;\par
  663 \par
  664     memset(mega_stats, 0, sizeof(*mega_stats));\par
  665 \par
  666     stats->n_flows = ovs_flow_tbl_count(&dp->table);\par
  667     mega_stats->n_masks = ovs_flow_tbl_num_masks(&dp->table);\par
  668 \par
  669     stats->n_hit = stats->n_missed = stats->n_lost = 0;\par
  670 \par
  671     for_each_possible_cpu(i) \{\par
  672         const struct dp_stats_percpu *percpu_stats;\par
  673         struct dp_stats_percpu local_stats;\par
  674         unsigned int start;\par
  675 \par
  676         percpu_stats = per_cpu_ptr(dp->stats_percpu, i);\par
  677 \par
  678         do \{\par
  679             start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);\par
  680             local_stats = *percpu_stats;\par
  681         \} while (u64_stats_fetch_retry_irq(&percpu_stats->syncp, start));\par
  682 \par
  683         stats->n_hit += local_stats.n_hit;\par
  684         stats->n_missed += local_stats.n_missed;\par
  685         stats->n_lost += local_stats.n_lost;\par
  686         mega_stats->n_mask_hit += local_stats.n_mask_hit;\par
  687     \}\par
  688 \}\par
}
}
{\xe \v get_dpifindex\:linux/datapath.c}
{\xe \v linux/datapath.c\:get_dpifindex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int get_dpifindex (const struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   185 \{\par
  186     struct vport *local;\par
  187     int ifindex;\par
  188 \par
  189     rcu_read_lock();\par
  190 \par
  191     local = ovs_vport_rcu(dp, OVSP_LOCAL);\par
  192     if (local)\par
  193         ifindex = netdev_vport_priv(local)->dev->ifindex;\par
  194     else\par
  195         ifindex = 0;\par
  196 \par
  197     rcu_read_unlock();\par
  198 \par
  199     return ifindex;\par
  200 \}\par
}
}
{\xe \v get_flow_actions\:linux/datapath.c}
{\xe \v linux/datapath.c\:get_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_actions}* get_flow_actions (const struct nlattr *  {\i a}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_mask} *  {\i mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1056 \{\par
 1057     struct sw_flow_actions *acts;\par
 1058     struct sw_flow_key masked_key;\par
 1059     int error;\par
 1060 \par
 1061     ovs_flow_mask_key(&masked_key, key, mask);\par
 1062     error = ovs_nla_copy_actions(a, &masked_key, &acts, log);\par
 1063     if (error) \{\par
 1064         OVS_NLERR(log,\par
 1065               "Actions may not be safe on all matching packets");\par
 1066         return ERR_PTR(error);\par
 1067     \}\par
 1068 \par
 1069     return acts;\par
 1070 \}\par
}
}
{\xe \v list_vports_from_net\:linux/datapath.c}
{\xe \v linux/datapath.c\:list_vports_from_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __net_exit list_vports_from_net (struct net *  {\i net}, struct net *  {\i dnet}, struct list_head *  {\i head}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2222 \{\par
 2223     struct ovs_net *ovs_net = net_generic(net, ovs_net_id);\par
 2224     struct datapath *dp;\par
 2225 \par
 2226     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
 2227         int i;\par
 2228 \par
 2229         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 2230             struct vport *vport;\par
 2231 \par
 2232             hlist_for_each_entry(vport, &dp->ports[i], dp_hash_node) \{\par
 2233                 struct netdev_vport *netdev_vport;\par
 2234 \par
 2235                 if (vport->ops->type != OVS_VPORT_TYPE_INTERNAL)\par
 2236                     continue;\par
 2237 \par
 2238                 netdev_vport = netdev_vport_priv(vport);\par
 2239                 if (dev_net(netdev_vport->dev) == dnet)\par
 2240                     list_add(&vport->detach_list, head);\par
 2241             \}\par
 2242         \}\par
 2243     \}\par
 2244 \}\par
}
}
{\xe \v lookup_datapath\:linux/datapath.c}
{\xe \v linux/datapath.c\:lookup_datapath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b datapath}* lookup_datapath (struct net *  {\i net}, const struct {\b ovs_header} *  {\i ovs_header}, struct nlattr *  {\i a}[OVS_DP_ATTR_MAX+1]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1475 \{\par
 1476     struct datapath *dp;\par
 1477 \par
 1478     if (!a[OVS_DP_ATTR_NAME])\par
 1479         dp = get_dp(net, ovs_header->dp_ifindex);\par
 1480     else \{\par
 1481         struct vport *vport;\par
 1482 \par
 1483         vport = ovs_vport_locate(net, nla_data(a[OVS_DP_ATTR_NAME]));\par
 1484         dp = vport && vport->port_no == OVSP_LOCAL ? vport->dp : NULL;\par
 1485     \}\par
 1486     return dp ? dp : ERR_PTR(-ENODEV);\par
 1487 \}\par
}
}
{\xe \v lookup_vport\:linux/datapath.c}
{\xe \v linux/datapath.c\:lookup_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* lookup_vport (struct net *  {\i net}, const struct {\b ovs_header} *  {\i ovs_header}, struct nlattr *  {\i a}[OVS_VPORT_ATTR_MAX+1]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1866 \{\par
 1867     struct datapath *dp;\par
 1868     struct vport *vport;\par
 1869 \par
 1870     if (a[OVS_VPORT_ATTR_NAME]) \{\par
 1871         vport = ovs_vport_locate(net, nla_data(a[OVS_VPORT_ATTR_NAME]));\par
 1872         if (!vport)\par
 1873             return ERR_PTR(-ENODEV);\par
 1874         if (ovs_header->dp_ifindex &&\par
 1875             ovs_header->dp_ifindex != get_dpifindex(vport->dp))\par
 1876             return ERR_PTR(-ENODEV);\par
 1877         return vport;\par
 1878     \} else if (a[OVS_VPORT_ATTR_PORT_NO]) \{\par
 1879         u32 port_no = nla_get_u32(a[OVS_VPORT_ATTR_PORT_NO]);\par
 1880 \par
 1881         if (port_no >= DP_MAX_PORTS)\par
 1882             return ERR_PTR(-EFBIG);\par
 1883 \par
 1884         dp = get_dp(net, ovs_header->dp_ifindex);\par
 1885         if (!dp)\par
 1886             return ERR_PTR(-ENODEV);\par
 1887 \par
 1888         vport = ovs_vport_ovsl_rcu(dp, port_no);\par
 1889         if (!vport)\par
 1890             return ERR_PTR(-ENODEV);\par
 1891         return vport;\par
 1892     \} else\par
 1893         return ERR_PTR(-EINVAL);\par
 1894 \}\par
}
}
{\xe \v MODULE_DESCRIPTION\:linux/datapath.c}
{\xe \v linux/datapath.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("Open vSwitch switching {\b datapath}" )}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:linux/datapath.c}
{\xe \v linux/datapath.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b dp_cleanup} )}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:linux/datapath.c}
{\xe \v linux/datapath.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b dp_init} )}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:linux/datapath.c}
{\xe \v linux/datapath.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_VERSION\:linux/datapath.c}
{\xe \v linux/datapath.c\:MODULE_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_VERSION (VERSION )}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v new_vport\:linux/datapath.c}
{\xe \v linux/datapath.c\:new_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* new_vport (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   235 \{\par
  236     struct vport *vport;\par
  237 \par
  238     vport = ovs_vport_add(parms);\par
  239     if (!IS_ERR(vport)) \{\par
  240         struct datapath *dp = parms->dp;\par
  241         struct hlist_head *head = vport_hash_bucket(dp, vport->port_no);\par
  242 \par
  243         hlist_add_head_rcu(&vport->dp_hash_node, head);\par
  244     \}\par
  245     return vport;\par
  246 \}\par
}
}
{\xe \v ovs_dp_change\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_change}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_dp_change (struct {\b datapath} *  {\i dp}, struct nlattr *  {\i a}[]){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1502 \{\par
 1503     if (a[OVS_DP_ATTR_USER_FEATURES])\par
 1504         dp->user_features = nla_get_u32(a[OVS_DP_ATTR_USER_FEATURES]);\par
 1505 \}\par
}
}
{\xe \v ovs_dp_cmd_alloc_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_dp_cmd_alloc_info (struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1467 \{\par
 1468     return genlmsg_new_unicast(ovs_dp_cmd_msg_size(), info, GFP_KERNEL);\par
 1469 \}\par
}
}
{\xe \v ovs_dp_cmd_del\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1638 \{\par
 1639     struct sk_buff *reply;\par
 1640     struct datapath *dp;\par
 1641     int err;\par
 1642 \par
 1643     reply = ovs_dp_cmd_alloc_info(info);\par
 1644     if (!reply)\par
 1645         return -ENOMEM;\par
 1646 \par
 1647     ovs_lock();\par
 1648     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1649     err = PTR_ERR(dp);\par
 1650     if (IS_ERR(dp))\par
 1651         goto err_unlock_free;\par
 1652 \par
 1653     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1654                    info->snd_seq, 0, OVS_DP_CMD_DEL);\par
 1655     BUG_ON(err < 0);\par
 1656 \par
 1657     __dp_destroy(dp);\par
 1658     ovs_unlock();\par
 1659 \par
 1660     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1661     return 0;\par
 1662 \par
 1663 err_unlock_free:\par
 1664     ovs_unlock();\par
 1665     kfree_skb(reply);\par
 1666     return err;\par
 1667 \}\par
}
}
{\xe \v ovs_dp_cmd_dump\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1732 \{\par
 1733     struct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);\par
 1734     struct datapath *dp;\par
 1735     int skip = cb->args[0];\par
 1736     int i = 0;\par
 1737 \par
 1738     ovs_lock();\par
 1739     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
 1740         if (i >= skip &&\par
 1741             ovs_dp_cmd_fill_info(dp, skb, NETLINK_CB(cb->skb).portid,\par
 1742                      cb->nlh->nlmsg_seq, NLM_F_MULTI,\par
 1743                      OVS_DP_CMD_NEW) < 0)\par
 1744             break;\par
 1745         i++;\par
 1746     \}\par
 1747     ovs_unlock();\par
 1748 \par
 1749     cb->args[0] = i;\par
 1750 \par
 1751     return skb->len;\par
 1752 \}\par
}
}
{\xe \v ovs_dp_cmd_fill_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_fill_info (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1427 \{\par
 1428     struct ovs_header *ovs_header;\par
 1429     struct ovs_dp_stats dp_stats;\par
 1430     struct ovs_dp_megaflow_stats dp_megaflow_stats;\par
 1431     int err;\par
 1432 \par
 1433     ovs_header = genlmsg_put(skb, portid, seq, &dp_datapath_genl_family,\par
 1434                    flags, cmd);\par
 1435     if (!ovs_header)\par
 1436         goto error;\par
 1437 \par
 1438     ovs_header->dp_ifindex = get_dpifindex(dp);\par
 1439 \par
 1440     err = nla_put_string(skb, OVS_DP_ATTR_NAME, ovs_dp_name(dp));\par
 1441     if (err)\par
 1442         goto nla_put_failure;\par
 1443 \par
 1444     get_dp_stats(dp, &dp_stats, &dp_megaflow_stats);\par
 1445     if (nla_put(skb, OVS_DP_ATTR_STATS, sizeof(struct ovs_dp_stats),\par
 1446             &dp_stats))\par
 1447         goto nla_put_failure;\par
 1448 \par
 1449     if (nla_put(skb, OVS_DP_ATTR_MEGAFLOW_STATS,\par
 1450             sizeof(struct ovs_dp_megaflow_stats),\par
 1451             &dp_megaflow_stats))\par
 1452         goto nla_put_failure;\par
 1453 \par
 1454     if (nla_put_u32(skb, OVS_DP_ATTR_USER_FEATURES, dp->user_features))\par
 1455         goto nla_put_failure;\par
 1456 \par
 1457     genlmsg_end(skb, ovs_header);\par
 1458     return 0;\par
 1459 \par
 1460 nla_put_failure:\par
 1461     genlmsg_cancel(skb, ovs_header);\par
 1462 error:\par
 1463     return -EMSGSIZE;\par
 1464 \}\par
}
}
{\xe \v ovs_dp_cmd_get\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1703 \{\par
 1704     struct sk_buff *reply;\par
 1705     struct datapath *dp;\par
 1706     int err;\par
 1707 \par
 1708     reply = ovs_dp_cmd_alloc_info(info);\par
 1709     if (!reply)\par
 1710         return -ENOMEM;\par
 1711 \par
 1712     ovs_lock();\par
 1713     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1714     if (IS_ERR(dp)) \{\par
 1715         err = PTR_ERR(dp);\par
 1716         goto err_unlock_free;\par
 1717     \}\par
 1718     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1719                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1720     BUG_ON(err < 0);\par
 1721     ovs_unlock();\par
 1722 \par
 1723     return genlmsg_reply(reply, info);\par
 1724 \par
 1725 err_unlock_free:\par
 1726     ovs_unlock();\par
 1727     kfree_skb(reply);\par
 1728     return err;\par
 1729 \}\par
}
}
{\xe \v ovs_dp_cmd_msg_size\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t ovs_dp_cmd_msg_size (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1413 \{\par
 1414     size_t msgsize = NLMSG_ALIGN(sizeof(struct ovs_header));\par
 1415 \par
 1416     msgsize += nla_total_size(IFNAMSIZ);\par
 1417     msgsize += nla_total_size(sizeof(struct ovs_dp_stats));\par
 1418     msgsize += nla_total_size(sizeof(struct ovs_dp_megaflow_stats));\par
 1419     msgsize += nla_total_size(sizeof(u32)); /* OVS_DP_ATTR_USER_FEATURES */\par
 1420 \par
 1421     return msgsize;\par
 1422 \}\par
}
}
{\xe \v ovs_dp_cmd_new\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1508 \{\par
 1509     struct nlattr **a = info->attrs;\par
 1510     struct vport_parms parms;\par
 1511     struct sk_buff *reply;\par
 1512     struct datapath *dp;\par
 1513     struct vport *vport;\par
 1514     struct ovs_net *ovs_net;\par
 1515     int err, i;\par
 1516 \par
 1517     err = -EINVAL;\par
 1518     if (!a[OVS_DP_ATTR_NAME] || !a[OVS_DP_ATTR_UPCALL_PID])\par
 1519         goto err;\par
 1520 \par
 1521     reply = ovs_dp_cmd_alloc_info(info);\par
 1522     if (!reply)\par
 1523         return -ENOMEM;\par
 1524 \par
 1525     err = -ENOMEM;\par
 1526     dp = kzalloc(sizeof(*dp), GFP_KERNEL);\par
 1527     if (dp == NULL)\par
 1528         goto err_free_reply;\par
 1529 \par
 1530     ovs_dp_set_net(dp, hold_net(sock_net(skb->sk)));\par
 1531 \par
 1532     /* Allocate table. */\par
 1533     err = ovs_flow_tbl_init(&dp->table);\par
 1534     if (err)\par
 1535         goto err_free_dp;\par
 1536 \par
 1537     dp->stats_percpu = netdev_alloc_pcpu_stats(struct dp_stats_percpu);\par
 1538     if (!dp->stats_percpu) \{\par
 1539         err = -ENOMEM;\par
 1540         goto err_destroy_table;\par
 1541     \}\par
 1542 \par
 1543     dp->ports = kmalloc(DP_VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\par
 1544                 GFP_KERNEL);\par
 1545     if (!dp->ports) \{\par
 1546         err = -ENOMEM;\par
 1547         goto err_destroy_percpu;\par
 1548     \}\par
 1549 \par
 1550     for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++)\par
 1551         INIT_HLIST_HEAD(&dp->ports[i]);\par
 1552 \par
 1553     /* Set up our datapath device. */\par
 1554     parms.name = nla_data(a[OVS_DP_ATTR_NAME]);\par
 1555     parms.type = OVS_VPORT_TYPE_INTERNAL;\par
 1556     parms.options = NULL;\par
 1557     parms.dp = dp;\par
 1558     parms.port_no = OVSP_LOCAL;\par
 1559     parms.upcall_portids = a[OVS_DP_ATTR_UPCALL_PID];\par
 1560 \par
 1561     ovs_dp_change(dp, a);\par
 1562 \par
 1563     /* So far only local changes have been made, now need the lock. */\par
 1564     ovs_lock();\par
 1565 \par
 1566     vport = new_vport(&parms);\par
 1567     if (IS_ERR(vport)) \{\par
 1568         err = PTR_ERR(vport);\par
 1569         if (err == -EBUSY)\par
 1570             err = -EEXIST;\par
 1571 \par
 1572         if (err == -EEXIST) \{\par
 1573             /* An outdated user space instance that does not understand\par
 1574              * the concept of user_features has attempted to create a new\par
 1575              * datapath and is likely to reuse it. Drop all user features.\par
 1576              */\par
 1577             if (info->genlhdr->version < OVS_DP_VER_FEATURES)\par
 1578                 ovs_dp_reset_user_features(skb, info);\par
 1579         \}\par
 1580 \par
 1581         goto err_destroy_ports_array;\par
 1582     \}\par
 1583 \par
 1584     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1585                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1586     BUG_ON(err < 0);\par
 1587 \par
 1588     ovs_net = net_generic(ovs_dp_get_net(dp), ovs_net_id);\par
 1589     list_add_tail_rcu(&dp->list_node, &ovs_net->dps);\par
 1590 \par
 1591     ovs_unlock();\par
 1592 \par
 1593     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1594     return 0;\par
 1595 \par
 1596 err_destroy_ports_array:\par
 1597     ovs_unlock();\par
 1598     kfree(dp->ports);\par
 1599 err_destroy_percpu:\par
 1600     free_percpu(dp->stats_percpu);\par
 1601 err_destroy_table:\par
 1602     ovs_flow_tbl_destroy(&dp->table);\par
 1603 err_free_dp:\par
 1604     release_net(ovs_dp_get_net(dp));\par
 1605     kfree(dp);\par
 1606 err_free_reply:\par
 1607     kfree_skb(reply);\par
 1608 err:\par
 1609     return err;\par
 1610 \}\par
}
}
{\xe \v ovs_dp_cmd_set\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_dp_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1670 \{\par
 1671     struct sk_buff *reply;\par
 1672     struct datapath *dp;\par
 1673     int err;\par
 1674 \par
 1675     reply = ovs_dp_cmd_alloc_info(info);\par
 1676     if (!reply)\par
 1677         return -ENOMEM;\par
 1678 \par
 1679     ovs_lock();\par
 1680     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1681     err = PTR_ERR(dp);\par
 1682     if (IS_ERR(dp))\par
 1683         goto err_unlock_free;\par
 1684 \par
 1685     ovs_dp_change(dp, info->attrs);\par
 1686 \par
 1687     err = ovs_dp_cmd_fill_info(dp, reply, info->snd_portid,\par
 1688                    info->snd_seq, 0, OVS_DP_CMD_NEW);\par
 1689     BUG_ON(err < 0);\par
 1690 \par
 1691     ovs_unlock();\par
 1692 \par
 1693     ovs_notify(&dp_datapath_genl_family, &ovs_dp_datapath_multicast_group, reply, info);\par
 1694     return 0;\par
 1695 \par
 1696 err_unlock_free:\par
 1697     ovs_unlock();\par
 1698     kfree_skb(reply);\par
 1699     return err;\par
 1700 \}\par
}
}
{\xe \v ovs_dp_detach_port\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_detach_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_detach_port (struct {\b vport} *  {\i p})}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     ASSERT_OVSL();\par
  251 \par
  252     /* First drop references to device. */\par
  253     hlist_del_rcu(&p->dp_hash_node);\par
  254 \par
  255     /* Then destroy it. */\par
  256     ovs_vport_del(p);\par
  257 \}\par
}
}
{\xe \v ovs_dp_name\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_dp_name (const struct {\b datapath} *  {\i dp})}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179 \{\par
  180     struct vport *vport = ovs_vport_ovsl_rcu(dp, OVSP_LOCAL);\par
  181     return vport->ops->get_name(vport);\par
  182 \}\par
}
}
{\xe \v ovs_dp_process_packet\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_process_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_process_packet (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   261 \{\par
  262     const struct vport *p = OVS_CB(skb)->input_vport;\par
  263     struct datapath *dp = p->dp;\par
  264     struct sw_flow *flow;\par
  265     struct sw_flow_actions *sf_acts;\par
  266     struct dp_stats_percpu *stats;\par
  267     u64 *stats_counter;\par
  268     u32 n_mask_hit;\par
  269 \par
  270     stats = this_cpu_ptr(dp->stats_percpu);\par
  271 \par
  272     /* Look up flow. */\par
  273     flow = ovs_flow_tbl_lookup_stats(&dp->table, key, skb_get_hash(skb),\par
  274                      &n_mask_hit);\par
  275     if (unlikely(!flow)) \{\par
  276         struct dp_upcall_info upcall;\par
  277         int error;\par
  278 \par
  279         memset(&upcall, 0, sizeof(upcall));\par
  280         upcall.cmd = OVS_PACKET_CMD_MISS;\par
  281         upcall.portid = ovs_vport_find_upcall_portid(p, skb);\par
  282         error = ovs_dp_upcall(dp, skb, key, &upcall);\par
  283         if (unlikely(error))\par
  284             kfree_skb(skb);\par
  285         else\par
  286             consume_skb(skb);\par
  287         stats_counter = &stats->n_missed;\par
  288         goto out;\par
  289     \}\par
  290 \par
  291     ovs_flow_stats_update(flow, key->tp.flags, skb);\par
  292     sf_acts = rcu_dereference(flow->sf_acts);\par
  293     ovs_execute_actions(dp, skb, sf_acts, key);\par
  294 \par
  295     stats_counter = &stats->n_hit;\par
  296 \par
  297 out:\par
  298     /* Update datapath statistics. */\par
  299     u64_stats_update_begin(&stats->syncp);\par
  300     (*stats_counter)++;\par
  301     stats->n_mask_hit += n_mask_hit;\par
  302     u64_stats_update_end(&stats->syncp);\par
  303 \}\par
}
}
{\xe \v ovs_dp_reset_user_features\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_reset_user_features}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_dp_reset_user_features (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1490 \{\par
 1491     struct datapath *dp;\par
 1492 \par
 1493     dp = lookup_datapath(sock_net(skb->sk), info->userhdr, info->attrs);\par
 1494     if (IS_ERR(dp))\par
 1495         return;\par
 1496 \par
 1497     WARN(dp->user_features, "Dropping previously announced user features\\n");\par
 1498     dp->user_features = 0;\par
 1499 \}\par
}
}
{\xe \v ovs_dp_upcall\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_upcall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_dp_upcall (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309     struct dp_stats_percpu *stats;\par
  310     int err;\par
  311 \par
  312     if (upcall_info->portid == 0) \{\par
  313         err = -ENOTCONN;\par
  314         goto err;\par
  315     \}\par
  316 \par
  317     if (!skb_is_gso(skb))\par
  318         err = queue_userspace_packet(dp, skb, key, upcall_info);\par
  319     else\par
  320         err = queue_gso_packets(dp, skb, key, upcall_info);\par
  321     if (err)\par
  322         goto err;\par
  323 \par
  324     return 0;\par
  325 \par
  326 err:\par
  327     stats = this_cpu_ptr(dp->stats_percpu);\par
  328 \par
  329     u64_stats_update_begin(&stats->syncp);\par
  330     stats->n_lost++;\par
  331     u64_stats_update_end(&stats->syncp);\par
  332 \par
  333     return err;\par
  334 \}\par
}
}
{\xe \v ovs_exit_net\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_exit_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __net_exit ovs_exit_net (struct net *  {\i dnet}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2247 \{\par
 2248     struct datapath *dp, *dp_next;\par
 2249     struct ovs_net *ovs_net = net_generic(dnet, ovs_net_id);\par
 2250     struct vport *vport, *vport_next;\par
 2251     struct net *net;\par
 2252     LIST_HEAD(head);\par
 2253 \par
 2254     ovs_lock();\par
 2255     list_for_each_entry_safe(dp, dp_next, &ovs_net->dps, list_node)\par
 2256         __dp_destroy(dp);\par
 2257 \par
 2258     rtnl_lock();\par
 2259     for_each_net(net)\par
 2260         list_vports_from_net(net, dnet, &head);\par
 2261     rtnl_unlock();\par
 2262 \par
 2263     /* Detach all vports from given namespace. */\par
 2264     list_for_each_entry_safe(vport, vport_next, &head, detach_list) \{\par
 2265         list_del(&vport->detach_list);\par
 2266         ovs_dp_detach_port(vport);\par
 2267     \}\par
 2268 \par
 2269     ovs_unlock();\par
 2270 \par
 2271     cancel_work_sync(&ovs_net->dp_notify_work);\par
 2272 \}\par
}
}
{\xe \v ovs_flow_cmd_alloc_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_flow_cmd_alloc_info (const struct {\b sw_flow_actions} *  {\i acts}, const struct {\b sw_flow_id} *  {\i sfid}, struct genl_info *  {\i info}, {\b bool}  {\i always}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   855 \{\par
  856     struct sk_buff *skb;\par
  857     size_t len;\par
  858 \par
  859     if (!always && !ovs_must_notify(&dp_flow_genl_family, info,\par
  860                     GROUP_ID(&ovs_dp_flow_multicast_group)))\par
  861         return NULL;\par
  862 \par
  863     len = ovs_flow_cmd_msg_size(acts, sfid, ufid_flags);\par
  864     skb = genlmsg_new_unicast(len, info, GFP_KERNEL);\par
  865     if (!skb)\par
  866         return ERR_PTR(-ENOMEM);\par
  867 \par
  868     return skb;\par
  869 \}\par
}
}
{\xe \v ovs_flow_cmd_build_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_build_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_flow_cmd_build_info (const struct {\b sw_flow} *  {\i flow}, int  {\i dp_ifindex}, struct genl_info *  {\i info}, u8  {\i cmd}, {\b bool}  {\i always}, u32  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   876 \{\par
  877     struct sk_buff *skb;\par
  878     int retval;\par
  879 \par
  880     skb = ovs_flow_cmd_alloc_info(ovsl_dereference(flow->sf_acts),\par
  881                       &flow->id, info, always, ufid_flags);\par
  882     if (IS_ERR_OR_NULL(skb))\par
  883         return skb;\par
  884 \par
  885     retval = ovs_flow_cmd_fill_info(flow, dp_ifindex, skb,\par
  886                     info->snd_portid, info->snd_seq, 0,\par
  887                     cmd, ufid_flags);\par
  888     BUG_ON(retval < 0);\par
  889     return skb;\par
  890 \}\par
}
}
{\xe \v ovs_flow_cmd_del\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1243 \{\par
 1244     struct nlattr **a = info->attrs;\par
 1245     struct ovs_header *ovs_header = info->userhdr;\par
 1246     struct sw_flow_key key;\par
 1247     struct sk_buff *reply;\par
 1248     struct sw_flow *flow = NULL;\par
 1249     struct datapath *dp;\par
 1250     struct sw_flow_match match;\par
 1251     struct sw_flow_id ufid;\par
 1252     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1253     int err;\par
 1254     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1255     bool ufid_present;\par
 1256 \par
 1257     ufid_present = ovs_nla_get_ufid(&ufid, a[OVS_FLOW_ATTR_UFID], log);\par
 1258     if (a[OVS_FLOW_ATTR_KEY]) \{\par
 1259         ovs_match_init(&match, &key, NULL);\par
 1260         err = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY], NULL,\par
 1261                     log);\par
 1262         if (unlikely(err))\par
 1263             return err;\par
 1264     \}\par
 1265 \par
 1266     ovs_lock();\par
 1267     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1268     if (unlikely(!dp)) \{\par
 1269         err = -ENODEV;\par
 1270         goto unlock;\par
 1271     \}\par
 1272 \par
 1273     if (unlikely(!a[OVS_FLOW_ATTR_KEY] && !ufid_present)) \{\par
 1274         err = ovs_flow_tbl_flush(&dp->table);\par
 1275         goto unlock;\par
 1276     \}\par
 1277 \par
 1278     if (ufid_present)\par
 1279         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &ufid);\par
 1280     else\par
 1281         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1282     if (unlikely(!flow)) \{\par
 1283         err = -ENOENT;\par
 1284         goto unlock;\par
 1285     \}\par
 1286 \par
 1287     ovs_flow_tbl_remove(&dp->table, flow);\par
 1288     ovs_unlock();\par
 1289 \par
 1290     reply = ovs_flow_cmd_alloc_info(rcu_dereference_raw(flow->sf_acts),\par
 1291                     &flow->id, info, false, ufid_flags);\par
 1292 \par
 1293     if (likely(reply)) \{\par
 1294         if (likely(!IS_ERR(reply))) \{\par
 1295             rcu_read_lock();    /*To keep RCU checker happy. */\par
 1296             err = ovs_flow_cmd_fill_info(flow, ovs_header->dp_ifindex,\par
 1297                              reply, info->snd_portid,\par
 1298                              info->snd_seq, 0,\par
 1299                              OVS_FLOW_CMD_DEL,\par
 1300                              ufid_flags);\par
 1301             rcu_read_unlock();\par
 1302             BUG_ON(err < 0);\par
 1303             ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1304         \} else \{\par
 1305             genl_set_err(&dp_flow_genl_family, sock_net(skb->sk), 0,\par
 1306                      GROUP_ID(&ovs_dp_flow_multicast_group), PTR_ERR(reply));\par
 1307 \par
 1308         \}\par
 1309     \}\par
 1310 \par
 1311     ovs_flow_free(flow, true);\par
 1312     return 0;\par
 1313 unlock:\par
 1314     ovs_unlock();\par
 1315     return err;\par
 1316 \}\par
}
}
{\xe \v ovs_flow_cmd_dump\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1319 \{\par
 1320     struct nlattr *a[__OVS_FLOW_ATTR_MAX];\par
 1321     struct ovs_header *ovs_header = genlmsg_data(nlmsg_data(cb->nlh));\par
 1322     struct table_instance *ti;\par
 1323     struct datapath *dp;\par
 1324     u32 ufid_flags;\par
 1325     int err;\par
 1326 \par
 1327     err = genlmsg_parse(cb->nlh, &dp_flow_genl_family, a,\par
 1328                 OVS_FLOW_ATTR_MAX, flow_policy);\par
 1329     if (err)\par
 1330         return err;\par
 1331     ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1332 \par
 1333     rcu_read_lock();\par
 1334     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1335     if (!dp) \{\par
 1336         rcu_read_unlock();\par
 1337         return -ENODEV;\par
 1338     \}\par
 1339 \par
 1340     ti = rcu_dereference(dp->table.ti);\par
 1341     for (;;) \{\par
 1342         struct sw_flow *flow;\par
 1343         u32 bucket, obj;\par
 1344 \par
 1345         bucket = cb->args[0];\par
 1346         obj = cb->args[1];\par
 1347         flow = ovs_flow_tbl_dump_next(ti, &bucket, &obj);\par
 1348         if (!flow)\par
 1349             break;\par
 1350 \par
 1351         if (ovs_flow_cmd_fill_info(flow, ovs_header->dp_ifindex, skb,\par
 1352                        NETLINK_CB(cb->skb).portid,\par
 1353                        cb->nlh->nlmsg_seq, NLM_F_MULTI,\par
 1354                        OVS_FLOW_CMD_NEW, ufid_flags) < 0)\par
 1355             break;\par
 1356 \par
 1357         cb->args[0] = bucket;\par
 1358         cb->args[1] = obj;\par
 1359     \}\par
 1360     rcu_read_unlock();\par
 1361     return skb->len;\par
 1362 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_actions\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_fill_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_actions (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb}, int  {\i skb_orig_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   762 \{\par
  763     struct nlattr *start;\par
  764     int err;\par
  765 \par
  766     /* If OVS_FLOW_ATTR_ACTIONS doesn't fit, skip dumping the actions if\par
  767      * this is the first flow to be dumped into 'skb'.  This is unusual for\par
  768      * Netlink but individual action lists can be longer than\par
  769      * NLMSG_GOODSIZE and thus entirely undumpable if we didn't do this.\par
  770      * The userspace caller can always fetch the actions separately if it\par
  771      * really wants them.  (Most userspace callers in fact don't care.)\par
  772      *\par
  773      * This can only fail for dump operations because the skb is always\par
  774      * properly sized for single flows.\par
  775      */\par
  776     start = nla_nest_start(skb, OVS_FLOW_ATTR_ACTIONS);\par
  777     if (start) \{\par
  778         const struct sw_flow_actions *sf_acts;\par
  779 \par
  780         sf_acts = rcu_dereference_ovsl(flow->sf_acts);\par
  781         err = ovs_nla_put_actions(sf_acts->actions,\par
  782                       sf_acts->actions_len, skb);\par
  783 \par
  784         if (!err)\par
  785             nla_nest_end(skb, start);\par
  786         else \{\par
  787             if (skb_orig_len)\par
  788                 return err;\par
  789 \par
  790             nla_nest_cancel(skb, start);\par
  791         \}\par
  792     \} else if (skb_orig_len) \{\par
  793         return -EMSGSIZE;\par
  794     \}\par
  795 \par
  796     return 0;\par
  797 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_info (const struct {\b sw_flow} *  {\i flow}, int  {\i dp_ifindex}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}, u32  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   803 \{\par
  804     const int skb_orig_len = skb->len;\par
  805     struct ovs_header *ovs_header;\par
  806     int err;\par
  807 \par
  808     ovs_header = genlmsg_put(skb, portid, seq, &dp_flow_genl_family,\par
  809                  flags, cmd);\par
  810     if (!ovs_header)\par
  811         return -EMSGSIZE;\par
  812 \par
  813     ovs_header->dp_ifindex = dp_ifindex;\par
  814 \par
  815     err = ovs_nla_put_identifier(flow, skb);\par
  816     if (err)\par
  817         goto error;\par
  818 \par
  819     if (should_fill_key(&flow->id, ufid_flags)) \{\par
  820         err = ovs_nla_put_masked_key(flow, skb);\par
  821         if (err)\par
  822             goto error;\par
  823     \}\par
  824 \par
  825     if (should_fill_mask(ufid_flags)) \{\par
  826         err = ovs_nla_put_mask(flow, skb);\par
  827         if (err)\par
  828             goto error;\par
  829     \}\par
  830 \par
  831     err = ovs_flow_cmd_fill_stats(flow, skb);\par
  832     if (err)\par
  833         goto error;\par
  834 \par
  835     if (should_fill_actions(ufid_flags)) \{\par
  836         err = ovs_flow_cmd_fill_actions(flow, skb, skb_orig_len);\par
  837         if (err)\par
  838             goto error;\par
  839     \}\par
  840 \par
  841     genlmsg_end(skb, ovs_header);\par
  842     return 0;\par
  843 \par
  844 error:\par
  845     genlmsg_cancel(skb, ovs_header);\par
  846     return err;\par
  847 \}\par
}
}
{\xe \v ovs_flow_cmd_fill_stats\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_fill_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_fill_stats (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   737 \{\par
  738     struct ovs_flow_stats stats;\par
  739     __be16 tcp_flags;\par
  740     unsigned long used;\par
  741 \par
  742     ovs_flow_stats_get(flow, &stats, &used, &tcp_flags);\par
  743 \par
  744     if (used &&\par
  745         nla_put_u64(skb, OVS_FLOW_ATTR_USED, ovs_flow_used_time(used)))\par
  746         return -EMSGSIZE;\par
  747 \par
  748     if (stats.n_packets &&\par
  749         nla_put(skb, OVS_FLOW_ATTR_STATS, sizeof(struct ovs_flow_stats), &stats))\par
  750         return -EMSGSIZE;\par
  751 \par
  752     if ((u8)ntohs(tcp_flags) &&\par
  753          nla_put_u8(skb, OVS_FLOW_ATTR_TCP_FLAGS, (u8)ntohs(tcp_flags)))\par
  754         return -EMSGSIZE;\par
  755 \par
  756     return 0;\par
  757 \}\par
}
}
{\xe \v ovs_flow_cmd_get\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1185 \{\par
 1186     struct nlattr **a = info->attrs;\par
 1187     struct ovs_header *ovs_header = info->userhdr;\par
 1188     struct sw_flow_key key;\par
 1189     struct sk_buff *reply;\par
 1190     struct sw_flow *flow;\par
 1191     struct datapath *dp;\par
 1192     struct sw_flow_match match;\par
 1193     struct sw_flow_id ufid;\par
 1194     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1195     int err = 0;\par
 1196     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1197     bool ufid_present;\par
 1198 \par
 1199     ufid_present = ovs_nla_get_ufid(&ufid, a[OVS_FLOW_ATTR_UFID], log);\par
 1200     if (a[OVS_FLOW_ATTR_KEY]) \{\par
 1201         ovs_match_init(&match, &key, NULL);\par
 1202         err = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY], NULL,\par
 1203                     log);\par
 1204     \} else if (!ufid_present) \{\par
 1205         OVS_NLERR(log,\par
 1206               "Flow get message rejected, Key attribute missing.");\par
 1207         err = -EINVAL;\par
 1208     \}\par
 1209     if (err)\par
 1210         return err;\par
 1211 \par
 1212     ovs_lock();\par
 1213     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1214     if (!dp) \{\par
 1215         err = -ENODEV;\par
 1216         goto unlock;\par
 1217     \}\par
 1218 \par
 1219     if (ufid_present)\par
 1220         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &ufid);\par
 1221     else\par
 1222         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1223     if (!flow) \{\par
 1224         err = -ENOENT;\par
 1225         goto unlock;\par
 1226     \}\par
 1227 \par
 1228     reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex, info,\par
 1229                     OVS_FLOW_CMD_NEW, true, ufid_flags);\par
 1230     if (IS_ERR(reply)) \{\par
 1231         err = PTR_ERR(reply);\par
 1232         goto unlock;\par
 1233     \}\par
 1234 \par
 1235     ovs_unlock();\par
 1236     return genlmsg_reply(reply, info);\par
 1237 unlock:\par
 1238     ovs_unlock();\par
 1239     return err;\par
 1240 \}\par
}
}
{\xe \v ovs_flow_cmd_msg_size\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t ovs_flow_cmd_msg_size (const struct {\b sw_flow_actions} *  {\i acts}, const struct {\b sw_flow_id} *  {\i sfid}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   709 \{\par
  710     size_t len = NLMSG_ALIGN(sizeof(struct ovs_header));\par
  711 \par
  712     /* OVS_FLOW_ATTR_UFID */\par
  713     if (sfid && ovs_identifier_is_ufid(sfid))\par
  714         len += nla_total_size(sfid->ufid_len);\par
  715 \par
  716     /* OVS_FLOW_ATTR_KEY */\par
  717     if (!sfid || should_fill_key(sfid, ufid_flags))\par
  718         len += nla_total_size(ovs_key_attr_size());\par
  719 \par
  720     /* OVS_FLOW_ATTR_MASK */\par
  721     if (should_fill_mask(ufid_flags))\par
  722         len += nla_total_size(ovs_key_attr_size());\par
  723 \par
  724     /* OVS_FLOW_ATTR_ACTIONS */\par
  725     if (should_fill_actions(ufid_flags))\par
  726         len += nla_total_size(acts->actions_len);\par
  727 \par
  728     return len\par
  729         + nla_total_size(sizeof(struct ovs_flow_stats)) /* OVS_FLOW_ATTR_STATS */\par
  730         + nla_total_size(1) /* OVS_FLOW_ATTR_TCP_FLAGS */\par
  731         + nla_total_size(8); /* OVS_FLOW_ATTR_USED */\par
  732 \}\par
}
}
{\xe \v ovs_flow_cmd_new\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   893 \{\par
  894     struct nlattr **a = info->attrs;\par
  895     struct ovs_header *ovs_header = info->userhdr;\par
  896     struct sw_flow *flow = NULL, *new_flow;\par
  897     struct sw_flow_mask mask;\par
  898     struct sk_buff *reply;\par
  899     struct datapath *dp;\par
  900     struct sw_flow_key key;\par
  901     struct sw_flow_actions *acts;\par
  902     struct sw_flow_match match;\par
  903     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
  904     int error;\par
  905     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
  906 \par
  907     /* Must have key and actions. */\par
  908     error = -EINVAL;\par
  909     if (!a[OVS_FLOW_ATTR_KEY]) \{\par
  910         OVS_NLERR(log, "Flow key attr not present in new flow.");\par
  911         goto error;\par
  912     \}\par
  913     if (!a[OVS_FLOW_ATTR_ACTIONS]) \{\par
  914         OVS_NLERR(log, "Flow actions attr not present in new flow.");\par
  915         goto error;\par
  916     \}\par
  917 \par
  918     /* Most of the time we need to allocate a new flow, do it before\par
  919      * locking.\par
  920      */\par
  921     new_flow = ovs_flow_alloc();\par
  922     if (IS_ERR(new_flow)) \{\par
  923         error = PTR_ERR(new_flow);\par
  924         goto error;\par
  925     \}\par
  926 \par
  927     /* Extract key. */\par
  928     ovs_match_init(&match, &key, &mask);\par
  929     error = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY],\par
  930                   a[OVS_FLOW_ATTR_MASK], log);\par
  931     if (error)\par
  932         goto err_kfree_flow;\par
  933 \par
  934     ovs_flow_mask_key(&new_flow->key, &key, &mask);\par
  935 \par
  936     /* Extract flow identifier. */\par
  937     error = ovs_nla_get_identifier(&new_flow->id, a[OVS_FLOW_ATTR_UFID],\par
  938                        &key, log);\par
  939     if (error)\par
  940         goto err_kfree_flow;\par
  941 \par
  942     /* Validate actions. */\par
  943     error = ovs_nla_copy_actions(a[OVS_FLOW_ATTR_ACTIONS], &new_flow->key,\par
  944                      &acts, log);\par
  945     if (error) \{\par
  946         OVS_NLERR(log, "Flow actions may not be safe on all matching packets.");\par
  947         goto err_kfree_flow;\par
  948     \}\par
  949 \par
  950     reply = ovs_flow_cmd_alloc_info(acts, &new_flow->id, info, false,\par
  951                     ufid_flags);\par
  952     if (IS_ERR(reply)) \{\par
  953         error = PTR_ERR(reply);\par
  954         goto err_kfree_acts;\par
  955     \}\par
  956 \par
  957     ovs_lock();\par
  958     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
  959     if (unlikely(!dp)) \{\par
  960         error = -ENODEV;\par
  961         goto err_unlock_ovs;\par
  962     \}\par
  963 \par
  964     /* Check if this is a duplicate flow */\par
  965     if (ovs_identifier_is_ufid(&new_flow->id))\par
  966         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &new_flow->id);\par
  967     if (!flow)\par
  968         flow = ovs_flow_tbl_lookup(&dp->table, &key);\par
  969     if (likely(!flow)) \{\par
  970         rcu_assign_pointer(new_flow->sf_acts, acts);\par
  971 \par
  972         /* Put flow in bucket. */\par
  973         error = ovs_flow_tbl_insert(&dp->table, new_flow, &mask);\par
  974         if (unlikely(error)) \{\par
  975             acts = NULL;\par
  976             goto err_unlock_ovs;\par
  977         \}\par
  978 \par
  979         if (unlikely(reply)) \{\par
  980             error = ovs_flow_cmd_fill_info(new_flow,\par
  981                                ovs_header->dp_ifindex,\par
  982                                reply, info->snd_portid,\par
  983                                info->snd_seq, 0,\par
  984                                OVS_FLOW_CMD_NEW,\par
  985                                ufid_flags);\par
  986             BUG_ON(error < 0);\par
  987         \}\par
  988         ovs_unlock();\par
  989     \} else \{\par
  990         struct sw_flow_actions *old_acts;\par
  991 \par
  992         /* Bail out if we're not allowed to modify an existing flow.\par
  993          * We accept NLM_F_CREATE in place of the intended NLM_F_EXCL\par
  994          * because Generic Netlink treats the latter as a dump\par
  995          * request.  We also accept NLM_F_EXCL in case that bug ever\par
  996          * gets fixed.\par
  997          */\par
  998         if (unlikely(info->nlhdr->nlmsg_flags & (NLM_F_CREATE\par
  999                              | NLM_F_EXCL))) \{\par
 1000             error = -EEXIST;\par
 1001             goto err_unlock_ovs;\par
 1002         \}\par
 1003         /* The flow identifier has to be the same for flow updates.\par
 1004          * Look for any overlapping flow.\par
 1005          */\par
 1006         if (unlikely(!ovs_flow_cmp(flow, &match))) \{\par
 1007             if (ovs_identifier_is_key(&flow->id))\par
 1008                 flow = ovs_flow_tbl_lookup_exact(&dp->table,\par
 1009                                  &match);\par
 1010             else /* UFID matches but key is different */\par
 1011                 flow = NULL;\par
 1012             if (!flow) \{\par
 1013                 error = -ENOENT;\par
 1014                 goto err_unlock_ovs;\par
 1015             \}\par
 1016         \}\par
 1017         /* Update actions. */\par
 1018         old_acts = ovsl_dereference(flow->sf_acts);\par
 1019         rcu_assign_pointer(flow->sf_acts, acts);\par
 1020 \par
 1021         if (unlikely(reply)) \{\par
 1022             error = ovs_flow_cmd_fill_info(flow,\par
 1023                                ovs_header->dp_ifindex,\par
 1024                                reply, info->snd_portid,\par
 1025                                info->snd_seq, 0,\par
 1026                                OVS_FLOW_CMD_NEW,\par
 1027                                ufid_flags);\par
 1028             BUG_ON(error < 0);\par
 1029         \}\par
 1030         ovs_unlock();\par
 1031 \par
 1032         ovs_nla_free_flow_actions(old_acts);\par
 1033         ovs_flow_free(new_flow, false);\par
 1034     \}\par
 1035 \par
 1036     if (reply)\par
 1037         ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1038     return 0;\par
 1039 \par
 1040 err_unlock_ovs:\par
 1041     ovs_unlock();\par
 1042     kfree_skb(reply);\par
 1043 err_kfree_acts:\par
 1044     kfree(acts);\par
 1045 err_kfree_flow:\par
 1046     ovs_flow_free(new_flow, false);\par
 1047 error:\par
 1048     return error;\par
 1049 \}\par
}
}
{\xe \v ovs_flow_cmd_set\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_flow_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_flow_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1073 \{\par
 1074     struct nlattr **a = info->attrs;\par
 1075     struct ovs_header *ovs_header = info->userhdr;\par
 1076     struct sw_flow_key key;\par
 1077     struct sw_flow *flow;\par
 1078     struct sw_flow_mask mask;\par
 1079     struct sk_buff *reply = NULL;\par
 1080     struct datapath *dp;\par
 1081     struct sw_flow_actions *old_acts = NULL, *acts = NULL;\par
 1082     struct sw_flow_match match;\par
 1083     struct sw_flow_id sfid;\par
 1084     u32 ufid_flags = ovs_nla_get_ufid_flags(a[OVS_FLOW_ATTR_UFID_FLAGS]);\par
 1085     int error;\par
 1086     bool log = !a[OVS_FLOW_ATTR_PROBE];\par
 1087     bool ufid_present;\par
 1088 \par
 1089     /* Extract key. */\par
 1090     error = -EINVAL;\par
 1091     if (!a[OVS_FLOW_ATTR_KEY]) \{\par
 1092         OVS_NLERR(log, "Flow key attribute not present in set flow.");\par
 1093         goto error;\par
 1094     \}\par
 1095 \par
 1096     ufid_present = ovs_nla_get_ufid(&sfid, a[OVS_FLOW_ATTR_UFID], log);\par
 1097     ovs_match_init(&match, &key, &mask);\par
 1098     error = ovs_nla_get_match(&match, a[OVS_FLOW_ATTR_KEY],\par
 1099                   a[OVS_FLOW_ATTR_MASK], log);\par
 1100     if (error)\par
 1101         goto error;\par
 1102 \par
 1103     /* Validate actions. */\par
 1104     if (a[OVS_FLOW_ATTR_ACTIONS]) \{\par
 1105         acts = get_flow_actions(a[OVS_FLOW_ATTR_ACTIONS], &key, &mask,\par
 1106                     log);\par
 1107         if (IS_ERR(acts)) \{\par
 1108             error = PTR_ERR(acts);\par
 1109             goto error;\par
 1110         \}\par
 1111 \par
 1112         /* Can allocate before locking if have acts. */\par
 1113         reply = ovs_flow_cmd_alloc_info(acts, &sfid, info, false,\par
 1114                         ufid_flags);\par
 1115         if (IS_ERR(reply)) \{\par
 1116             error = PTR_ERR(reply);\par
 1117             goto err_kfree_acts;\par
 1118         \}\par
 1119     \}\par
 1120 \par
 1121     ovs_lock();\par
 1122     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1123     if (unlikely(!dp)) \{\par
 1124         error = -ENODEV;\par
 1125         goto err_unlock_ovs;\par
 1126     \}\par
 1127     /* Check that the flow exists. */\par
 1128     if (ufid_present)\par
 1129         flow = ovs_flow_tbl_lookup_ufid(&dp->table, &sfid);\par
 1130     else\par
 1131         flow = ovs_flow_tbl_lookup_exact(&dp->table, &match);\par
 1132     if (unlikely(!flow)) \{\par
 1133         error = -ENOENT;\par
 1134         goto err_unlock_ovs;\par
 1135     \}\par
 1136 \par
 1137     /* Update actions, if present. */\par
 1138     if (likely(acts)) \{\par
 1139         old_acts = ovsl_dereference(flow->sf_acts);\par
 1140         rcu_assign_pointer(flow->sf_acts, acts);\par
 1141 \par
 1142         if (unlikely(reply)) \{\par
 1143             error = ovs_flow_cmd_fill_info(flow,\par
 1144                                ovs_header->dp_ifindex,\par
 1145                                reply, info->snd_portid,\par
 1146                                info->snd_seq, 0,\par
 1147                                OVS_FLOW_CMD_NEW,\par
 1148                                ufid_flags);\par
 1149             BUG_ON(error < 0);\par
 1150         \}\par
 1151     \} else \{\par
 1152         /* Could not alloc without acts before locking. */\par
 1153         reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex,\par
 1154                         info, OVS_FLOW_CMD_NEW, false,\par
 1155                         ufid_flags);\par
 1156 \par
 1157         if (unlikely(IS_ERR(reply))) \{\par
 1158             error = PTR_ERR(reply);\par
 1159             goto err_unlock_ovs;\par
 1160         \}\par
 1161     \}\par
 1162 \par
 1163     /* Clear stats. */\par
 1164     if (a[OVS_FLOW_ATTR_CLEAR])\par
 1165         ovs_flow_stats_clear(flow);\par
 1166     ovs_unlock();\par
 1167 \par
 1168     if (reply)\par
 1169         ovs_notify(&dp_flow_genl_family, &ovs_dp_flow_multicast_group, reply, info);\par
 1170     if (old_acts)\par
 1171         ovs_nla_free_flow_actions(old_acts);\par
 1172 \par
 1173     return 0;\par
 1174 \par
 1175 err_unlock_ovs:\par
 1176     ovs_unlock();\par
 1177     kfree_skb(reply);\par
 1178 err_kfree_acts:\par
 1179     kfree(acts);\par
 1180 error:\par
 1181     return error;\par
 1182 \}\par
}
}
{\xe \v ovs_init_net\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_init_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __net_init ovs_init_net (struct net *  {\i net}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2212 \{\par
 2213     struct ovs_net *ovs_net = net_generic(net, ovs_net_id);\par
 2214 \par
 2215     INIT_LIST_HEAD(&ovs_net->dps);\par
 2216     INIT_WORK(&ovs_net->dp_notify_work, ovs_dp_notify_wq);\par
 2217     return 0;\par
 2218 \}\par
}
}
{\xe \v ovs_lock\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_lock (void )}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   121 \{\par
  122     mutex_lock(&ovs_mutex);\par
  123 \}\par
}
}
{\xe \v ovs_lookup_vport\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_lookup_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_lookup_vport (const struct {\b datapath} *  {\i dp}, u16  {\i port_no})}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221 \{\par
  222     struct vport *vport;\par
  223     struct hlist_head *head;\par
  224 \par
  225     head = vport_hash_bucket(dp, port_no);\par
  226     hlist_for_each_entry_rcu(vport, head, dp_hash_node) \{\par
  227         if (vport->port_no == port_no)\par
  228             return vport;\par
  229     \}\par
  230     return NULL;\par
  231 \}\par
}
}
{\xe \v ovs_must_notify\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_must_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_must_notify (struct {\b genl_family} *  {\i family}, struct genl_info *  {\i info}, unsigned int  {\i group}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89 \{\par
   90     return info->nlhdr->nlmsg_flags & NLM_F_ECHO ||\par
   91            genl_has_listeners(family, genl_info_net(info), group);\par
   92 \}\par
}
}
{\xe \v ovs_notify\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_notify (struct {\b genl_family} *  {\i family}, struct genl_multicast_group *  {\i grp}, struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    96 \{\par
   97     genl_notify(family, skb, genl_info_net(info),\par
   98             info->snd_portid, GROUP_ID(grp), info->nlhdr, GFP_KERNEL);\par
   99 \}\par
}
}
{\xe \v ovs_packet_cmd_execute\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_packet_cmd_execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_packet_cmd_execute (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   537 \{\par
  538     struct ovs_header *ovs_header = info->userhdr;\par
  539     struct nlattr **a = info->attrs;\par
  540     struct sw_flow_actions *acts;\par
  541     struct sk_buff *packet;\par
  542     struct sw_flow *flow;\par
  543     struct sw_flow_actions *sf_acts;\par
  544     struct datapath *dp;\par
  545     struct ethhdr *eth;\par
  546     struct vport *input_vport;\par
  547     int len;\par
  548     int err;\par
  549     bool log = !a[OVS_PACKET_ATTR_PROBE];\par
  550 \par
  551     err = -EINVAL;\par
  552     if (!a[OVS_PACKET_ATTR_PACKET] || !a[OVS_PACKET_ATTR_KEY] ||\par
  553         !a[OVS_PACKET_ATTR_ACTIONS])\par
  554         goto err;\par
  555 \par
  556     len = nla_len(a[OVS_PACKET_ATTR_PACKET]);\par
  557     packet = __dev_alloc_skb(NET_IP_ALIGN + len, GFP_KERNEL);\par
  558     err = -ENOMEM;\par
  559     if (!packet)\par
  560         goto err;\par
  561     skb_reserve(packet, NET_IP_ALIGN);\par
  562 \par
  563     nla_memcpy(__skb_put(packet, len), a[OVS_PACKET_ATTR_PACKET], len);\par
  564 \par
  565     skb_reset_mac_header(packet);\par
  566     eth = eth_hdr(packet);\par
  567 \par
  568     /* Normally, setting the skb 'protocol' field would be handled by a\par
  569      * call to eth_type_trans(), but it assumes there's a sending\par
  570      * device, which we may not have.\par
  571      */\par
  572     if (eth_proto_is_802_3(eth->h_proto))\par
  573         packet->protocol = eth->h_proto;\par
  574     else\par
  575         packet->protocol = htons(ETH_P_802_2);\par
  576 \par
  577     /* Build an sw_flow for sending this packet. */\par
  578     flow = ovs_flow_alloc();\par
  579     err = PTR_ERR(flow);\par
  580     if (IS_ERR(flow))\par
  581         goto err_kfree_skb;\par
  582 \par
  583     err = ovs_flow_key_extract_userspace(a[OVS_PACKET_ATTR_KEY], packet,\par
  584                          &flow->key, log);\par
  585     if (err)\par
  586         goto err_flow_free;\par
  587 \par
  588     err = ovs_nla_copy_actions(a[OVS_PACKET_ATTR_ACTIONS],\par
  589                    &flow->key, &acts, log);\par
  590     if (err)\par
  591         goto err_flow_free;\par
  592 \par
  593     rcu_assign_pointer(flow->sf_acts, acts);\par
  594     OVS_CB(packet)->egress_tun_info = NULL;\par
  595     packet->priority = flow->key.phy.priority;\par
  596     packet->mark = flow->key.phy.skb_mark;\par
  597 \par
  598     rcu_read_lock();\par
  599     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
  600     err = -ENODEV;\par
  601     if (!dp)\par
  602         goto err_unlock;\par
  603 \par
  604     input_vport = ovs_vport_rcu(dp, flow->key.phy.in_port);\par
  605     if (!input_vport)\par
  606         input_vport = ovs_vport_rcu(dp, OVSP_LOCAL);\par
  607 \par
  608     if (!input_vport)\par
  609         goto err_unlock;\par
  610 \par
  611     OVS_CB(packet)->input_vport = input_vport;\par
  612     sf_acts = rcu_dereference(flow->sf_acts);\par
  613 \par
  614     local_bh_disable();\par
  615     err = ovs_execute_actions(dp, packet, sf_acts, &flow->key);\par
  616     local_bh_enable();\par
  617     rcu_read_unlock();\par
  618 \par
  619     ovs_flow_free(flow, false);\par
  620     return err;\par
  621 \par
  622 err_unlock:\par
  623     rcu_read_unlock();\par
  624 err_flow_free:\par
  625     ovs_flow_free(flow, false);\par
  626 err_kfree_skb:\par
  627     kfree_skb(packet);\par
  628 err:\par
  629     return err;\par
  630 \}\par
}
}
{\xe \v ovs_unlock\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_unlock (void )}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126 \{\par
  127     mutex_unlock(&ovs_mutex);\par
  128 \}\par
}
}
{\xe \v ovs_vport_cmd_alloc_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_alloc_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* ovs_vport_cmd_alloc_info (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1841 \{\par
 1842     return nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\par
 1843 \}\par
}
}
{\xe \v ovs_vport_cmd_build_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_build_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sk_buff* ovs_vport_cmd_build_info (struct {\b vport} *  {\i vport}, u32  {\i portid}, u32  {\i seq}, u8  {\i cmd})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1848 \{\par
 1849     struct sk_buff *skb;\par
 1850     int retval;\par
 1851 \par
 1852     skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\par
 1853     if (!skb)\par
 1854         return ERR_PTR(-ENOMEM);\par
 1855 \par
 1856     retval = ovs_vport_cmd_fill_info(vport, skb, portid, seq, 0, cmd);\par
 1857     BUG_ON(retval < 0);\par
 1858 \par
 1859     return skb;\par
 1860 \}\par
}
}
{\xe \v ovs_vport_cmd_del\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_del (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2025 \{\par
 2026     struct nlattr **a = info->attrs;\par
 2027     struct sk_buff *reply;\par
 2028     struct vport *vport;\par
 2029     int err;\par
 2030 \par
 2031     reply = ovs_vport_cmd_alloc_info();\par
 2032     if (!reply)\par
 2033         return -ENOMEM;\par
 2034 \par
 2035     ovs_lock();\par
 2036     vport = lookup_vport(sock_net(skb->sk), info->userhdr, a);\par
 2037     err = PTR_ERR(vport);\par
 2038     if (IS_ERR(vport))\par
 2039         goto exit_unlock_free;\par
 2040 \par
 2041     if (vport->port_no == OVSP_LOCAL) \{\par
 2042         err = -EINVAL;\par
 2043         goto exit_unlock_free;\par
 2044     \}\par
 2045 \par
 2046     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2047                       info->snd_seq, 0, OVS_VPORT_CMD_DEL);\par
 2048     BUG_ON(err < 0);\par
 2049     ovs_dp_detach_port(vport);\par
 2050     ovs_unlock();\par
 2051 \par
 2052     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 2053     return 0;\par
 2054 \par
 2055 exit_unlock_free:\par
 2056     ovs_unlock();\par
 2057     kfree_skb(reply);\par
 2058     return err;\par
 2059 \}\par
}
}
{\xe \v ovs_vport_cmd_dump\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_dump (struct sk_buff *  {\i skb}, struct netlink_callback *  {\i cb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2092 \{\par
 2093     struct ovs_header *ovs_header = genlmsg_data(nlmsg_data(cb->nlh));\par
 2094     struct datapath *dp;\par
 2095     int bucket = cb->args[0], skip = cb->args[1];\par
 2096     int i, j = 0;\par
 2097 \par
 2098     rcu_read_lock();\par
 2099     dp = get_dp_rcu(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 2100     if (!dp) \{\par
 2101         rcu_read_unlock();\par
 2102         return -ENODEV;\par
 2103     \}\par
 2104     for (i = bucket; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
 2105         struct vport *vport;\par
 2106 \par
 2107         j = 0;\par
 2108         hlist_for_each_entry_rcu(vport, &dp->ports[i], dp_hash_node) \{\par
 2109             if (j >= skip &&\par
 2110                 ovs_vport_cmd_fill_info(vport, skb,\par
 2111                             NETLINK_CB(cb->skb).portid,\par
 2112                             cb->nlh->nlmsg_seq,\par
 2113                             NLM_F_MULTI,\par
 2114                             OVS_VPORT_CMD_NEW) < 0)\par
 2115                 goto out;\par
 2116 \par
 2117             j++;\par
 2118         \}\par
 2119         skip = 0;\par
 2120     \}\par
 2121 out:\par
 2122     rcu_read_unlock();\par
 2123 \par
 2124     cb->args[0] = i;\par
 2125     cb->args[1] = j;\par
 2126 \par
 2127     return skb->len;\par
 2128 \}\par
}
}
{\xe \v ovs_vport_cmd_fill_info\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_fill_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_fill_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, u32  {\i flags}, u8  {\i cmd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1801 \{\par
 1802     struct ovs_header *ovs_header;\par
 1803     struct ovs_vport_stats vport_stats;\par
 1804     int err;\par
 1805 \par
 1806     ovs_header = genlmsg_put(skb, portid, seq, &dp_vport_genl_family,\par
 1807                  flags, cmd);\par
 1808     if (!ovs_header)\par
 1809         return -EMSGSIZE;\par
 1810 \par
 1811     ovs_header->dp_ifindex = get_dpifindex(vport->dp);\par
 1812 \par
 1813     if (nla_put_u32(skb, OVS_VPORT_ATTR_PORT_NO, vport->port_no) ||\par
 1814         nla_put_u32(skb, OVS_VPORT_ATTR_TYPE, vport->ops->type) ||\par
 1815         nla_put_string(skb, OVS_VPORT_ATTR_NAME, vport->ops->get_name(vport)))\par
 1816         goto nla_put_failure;\par
 1817 \par
 1818     ovs_vport_get_stats(vport, &vport_stats);\par
 1819     if (nla_put(skb, OVS_VPORT_ATTR_STATS, sizeof(struct ovs_vport_stats),\par
 1820             &vport_stats))\par
 1821         goto nla_put_failure;\par
 1822 \par
 1823     if (ovs_vport_get_upcall_portids(vport, skb))\par
 1824         goto nla_put_failure;\par
 1825 \par
 1826     err = ovs_vport_get_options(vport, skb);\par
 1827     if (err == -EMSGSIZE)\par
 1828         goto error;\par
 1829 \par
 1830     genlmsg_end(skb, ovs_header);\par
 1831     return 0;\par
 1832 \par
 1833 nla_put_failure:\par
 1834     err = -EMSGSIZE;\par
 1835 error:\par
 1836     genlmsg_cancel(skb, ovs_header);\par
 1837     return err;\par
 1838 \}\par
}
}
{\xe \v ovs_vport_cmd_get\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_get (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2062 \{\par
 2063     struct nlattr **a = info->attrs;\par
 2064     struct ovs_header *ovs_header = info->userhdr;\par
 2065     struct sk_buff *reply;\par
 2066     struct vport *vport;\par
 2067     int err;\par
 2068 \par
 2069     reply = ovs_vport_cmd_alloc_info();\par
 2070     if (!reply)\par
 2071         return -ENOMEM;\par
 2072 \par
 2073     rcu_read_lock();\par
 2074     vport = lookup_vport(sock_net(skb->sk), ovs_header, a);\par
 2075     err = PTR_ERR(vport);\par
 2076     if (IS_ERR(vport))\par
 2077         goto exit_unlock_free;\par
 2078     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2079                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 2080     BUG_ON(err < 0);\par
 2081     rcu_read_unlock();\par
 2082 \par
 2083     return genlmsg_reply(reply, info);\par
 2084 \par
 2085 exit_unlock_free:\par
 2086     rcu_read_unlock();\par
 2087     kfree_skb(reply);\par
 2088     return err;\par
 2089 \}\par
}
}
{\xe \v ovs_vport_cmd_new\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_new (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1897 \{\par
 1898     struct nlattr **a = info->attrs;\par
 1899     struct ovs_header *ovs_header = info->userhdr;\par
 1900     struct vport_parms parms;\par
 1901     struct sk_buff *reply;\par
 1902     struct vport *vport;\par
 1903     struct datapath *dp;\par
 1904     u32 port_no;\par
 1905     int err;\par
 1906 \par
 1907     if (!a[OVS_VPORT_ATTR_NAME] || !a[OVS_VPORT_ATTR_TYPE] ||\par
 1908         !a[OVS_VPORT_ATTR_UPCALL_PID])\par
 1909         return -EINVAL;\par
 1910 \par
 1911     port_no = a[OVS_VPORT_ATTR_PORT_NO]\par
 1912         ? nla_get_u32(a[OVS_VPORT_ATTR_PORT_NO]) : 0;\par
 1913     if (port_no >= DP_MAX_PORTS)\par
 1914         return -EFBIG;\par
 1915 \par
 1916     reply = ovs_vport_cmd_alloc_info();\par
 1917     if (!reply)\par
 1918         return -ENOMEM;\par
 1919 \par
 1920     ovs_lock();\par
 1921 restart:\par
 1922     dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\par
 1923     err = -ENODEV;\par
 1924     if (!dp)\par
 1925         goto exit_unlock_free;\par
 1926 \par
 1927     if (port_no) \{\par
 1928         vport = ovs_vport_ovsl(dp, port_no);\par
 1929         err = -EBUSY;\par
 1930         if (vport)\par
 1931             goto exit_unlock_free;\par
 1932     \} else \{\par
 1933         for (port_no = 1; ; port_no++) \{\par
 1934             if (port_no >= DP_MAX_PORTS) \{\par
 1935                 err = -EFBIG;\par
 1936                 goto exit_unlock_free;\par
 1937             \}\par
 1938             vport = ovs_vport_ovsl(dp, port_no);\par
 1939             if (!vport)\par
 1940                 break;\par
 1941         \}\par
 1942     \}\par
 1943 \par
 1944     parms.name = nla_data(a[OVS_VPORT_ATTR_NAME]);\par
 1945     parms.type = nla_get_u32(a[OVS_VPORT_ATTR_TYPE]);\par
 1946     parms.options = a[OVS_VPORT_ATTR_OPTIONS];\par
 1947     parms.dp = dp;\par
 1948     parms.port_no = port_no;\par
 1949     parms.upcall_portids = a[OVS_VPORT_ATTR_UPCALL_PID];\par
 1950 \par
 1951     vport = new_vport(&parms);\par
 1952     err = PTR_ERR(vport);\par
 1953     if (IS_ERR(vport)) \{\par
 1954         if (err == -EAGAIN)\par
 1955             goto restart;\par
 1956         goto exit_unlock_free;\par
 1957     \}\par
 1958 \par
 1959     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 1960                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 1961     BUG_ON(err < 0);\par
 1962     ovs_unlock();\par
 1963 \par
 1964     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 1965     return 0;\par
 1966 \par
 1967 exit_unlock_free:\par
 1968     ovs_unlock();\par
 1969     kfree_skb(reply);\par
 1970     return err;\par
 1971 \}\par
}
}
{\xe \v ovs_vport_cmd_set\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_vport_cmd_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_vport_cmd_set (struct sk_buff *  {\i skb}, struct genl_info *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1974 \{\par
 1975     struct nlattr **a = info->attrs;\par
 1976     struct sk_buff *reply;\par
 1977     struct vport *vport;\par
 1978     int err;\par
 1979 \par
 1980     reply = ovs_vport_cmd_alloc_info();\par
 1981     if (!reply)\par
 1982         return -ENOMEM;\par
 1983 \par
 1984     ovs_lock();\par
 1985     vport = lookup_vport(sock_net(skb->sk), info->userhdr, a);\par
 1986     err = PTR_ERR(vport);\par
 1987     if (IS_ERR(vport))\par
 1988         goto exit_unlock_free;\par
 1989 \par
 1990     if (a[OVS_VPORT_ATTR_TYPE] &&\par
 1991         nla_get_u32(a[OVS_VPORT_ATTR_TYPE]) != vport->ops->type) \{\par
 1992         err = -EINVAL;\par
 1993         goto exit_unlock_free;\par
 1994     \}\par
 1995 \par
 1996     if (a[OVS_VPORT_ATTR_OPTIONS]) \{\par
 1997         err = ovs_vport_set_options(vport, a[OVS_VPORT_ATTR_OPTIONS]);\par
 1998         if (err)\par
 1999             goto exit_unlock_free;\par
 2000     \}\par
 2001 \par
 2002     if (a[OVS_VPORT_ATTR_UPCALL_PID]) \{\par
 2003         struct nlattr *ids = a[OVS_VPORT_ATTR_UPCALL_PID];\par
 2004 \par
 2005         err = ovs_vport_set_upcall_portids(vport, ids);\par
 2006         if (err)\par
 2007             goto exit_unlock_free;\par
 2008     \}\par
 2009 \par
 2010     err = ovs_vport_cmd_fill_info(vport, reply, info->snd_portid,\par
 2011                       info->snd_seq, 0, OVS_VPORT_CMD_NEW);\par
 2012     BUG_ON(err < 0);\par
 2013     ovs_unlock();\par
 2014 \par
 2015     ovs_notify(&dp_vport_genl_family, &ovs_dp_vport_multicast_group, reply, info);\par
 2016     return 0;\par
 2017 \par
 2018 exit_unlock_free:\par
 2019     ovs_unlock();\par
 2020     kfree_skb(reply);\par
 2021     return err;\par
 2022 \}\par
}
}
{\xe \v queue_gso_packets\:linux/datapath.c}
{\xe \v linux/datapath.c\:queue_gso_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int queue_gso_packets (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   339 \{\par
  340     unsigned short gso_type = skb_shinfo(skb)->gso_type;\par
  341     struct sw_flow_key later_key;\par
  342     struct sk_buff *segs, *nskb;\par
  343     struct ovs_skb_cb ovs_cb;\par
  344     int err;\par
  345 \par
  346     ovs_cb = *OVS_CB(skb);\par
  347     segs = __skb_gso_segment(skb, NETIF_F_SG, false);\par
  348     *OVS_CB(skb) = ovs_cb;\par
  349     if (IS_ERR(segs))\par
  350         return PTR_ERR(segs);\par
  351     if (segs == NULL)\par
  352         return -EINVAL;\par
  353 \par
  354     if (gso_type & SKB_GSO_UDP) \{\par
  355         /* The initial flow key extracted by ovs_flow_key_extract()\par
  356          * in this case is for a first fragment, so we need to\par
  357          * properly mark later fragments.\par
  358          */\par
  359         later_key = *key;\par
  360         later_key.ip.frag = OVS_FRAG_TYPE_LATER;\par
  361     \}\par
  362 \par
  363     /* Queue all of the segments. */\par
  364     skb = segs;\par
  365     do \{\par
  366         *OVS_CB(skb) = ovs_cb;\par
  367         if (gso_type & SKB_GSO_UDP && skb != segs)\par
  368             key = &later_key;\par
  369 \par
  370         err = queue_userspace_packet(dp, skb, key, upcall_info);\par
  371         if (err)\par
  372             break;\par
  373 \par
  374     \} while ((skb = skb->next));\par
  375 \par
  376     /* Free all of the segments. */\par
  377     skb = segs;\par
  378     do \{\par
  379         nskb = skb->next;\par
  380         if (err)\par
  381             kfree_skb(skb);\par
  382         else\par
  383             consume_skb(skb);\par
  384     \} while ((skb = nskb));\par
  385     return err;\par
  386 \}\par
}
}
{\xe \v queue_userspace_packet\:linux/datapath.c}
{\xe \v linux/datapath.c\:queue_userspace_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int queue_userspace_packet (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b dp_upcall_info} *  {\i upcall_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   413 \{\par
  414     struct ovs_header *upcall;\par
  415     struct sk_buff *nskb = NULL;\par
  416     struct sk_buff *user_skb = NULL; /* to be queued to userspace */\par
  417     struct nlattr *nla;\par
  418     struct genl_info info = \{\par
  419 #ifdef HAVE_GENLMSG_NEW_UNICAST\par
  420         .dst_sk = ovs_dp_get_net(dp)->genl_sock,\par
  421 #endif\par
  422         .snd_portid = upcall_info->portid,\par
  423     \};\par
  424     size_t len;\par
  425     unsigned int hlen;\par
  426     int err, dp_ifindex;\par
  427 \par
  428     dp_ifindex = get_dpifindex(dp);\par
  429     if (!dp_ifindex)\par
  430         return -ENODEV;\par
  431 \par
  432     if (skb_vlan_tag_present(skb)) \{\par
  433         nskb = skb_clone(skb, GFP_ATOMIC);\par
  434         if (!nskb)\par
  435             return -ENOMEM;\par
  436 \par
  437         nskb = vlan_insert_tag_set_proto(nskb, nskb->vlan_proto, skb_vlan_tag_get(nskb));\par
  438         if (!nskb)\par
  439             return -ENOMEM;\par
  440 \par
  441         vlan_set_tci(nskb, 0);\par
  442 \par
  443         skb = nskb;\par
  444     \}\par
  445 \par
  446     if (nla_attr_size(skb->len) > USHRT_MAX) \{\par
  447         err = -EFBIG;\par
  448         goto out;\par
  449     \}\par
  450 \par
  451     /* Complete checksum if needed */\par
  452     if (skb->ip_summed == CHECKSUM_PARTIAL &&\par
  453         (err = skb_checksum_help(skb)))\par
  454         goto out;\par
  455 \par
  456     /* Older versions of OVS user space enforce alignment of the last\par
  457      * Netlink attribute to NLA_ALIGNTO which would require extensive\par
  458      * padding logic. Only perform zerocopy if padding is not required.\par
  459      */\par
  460     if (dp->user_features & OVS_DP_F_UNALIGNED)\par
  461         hlen = skb_zerocopy_headlen(skb);\par
  462     else\par
  463         hlen = skb->len;\par
  464 \par
  465     len = upcall_msg_size(upcall_info, hlen);\par
  466     user_skb = genlmsg_new_unicast(len, &info, GFP_ATOMIC);\par
  467     if (!user_skb) \{\par
  468         err = -ENOMEM;\par
  469         goto out;\par
  470     \}\par
  471 \par
  472     upcall = genlmsg_put(user_skb, 0, 0, &dp_packet_genl_family,\par
  473                  0, upcall_info->cmd);\par
  474     upcall->dp_ifindex = dp_ifindex;\par
  475 \par
  476     err = ovs_nla_put_key(key, key, OVS_PACKET_ATTR_KEY, false, user_skb);\par
  477     BUG_ON(err);\par
  478 \par
  479     if (upcall_info->userdata)\par
  480         __nla_put(user_skb, OVS_PACKET_ATTR_USERDATA,\par
  481               nla_len(upcall_info->userdata),\par
  482               nla_data(upcall_info->userdata));\par
  483 \par
  484     if (upcall_info->egress_tun_info) \{\par
  485         nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_EGRESS_TUN_KEY);\par
  486         err = ovs_nla_put_egress_tunnel_key(user_skb,\par
  487                             upcall_info->egress_tun_info);\par
  488         BUG_ON(err);\par
  489         nla_nest_end(user_skb, nla);\par
  490     \}\par
  491 \par
  492     if (upcall_info->actions_len) \{\par
  493         nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_ACTIONS);\par
  494         err = ovs_nla_put_actions(upcall_info->actions,\par
  495                       upcall_info->actions_len,\par
  496                       user_skb);\par
  497         if (!err)\par
  498             nla_nest_end(user_skb, nla);\par
  499         else\par
  500             nla_nest_cancel(user_skb, nla);\par
  501     \}\par
  502 \par
  503     /* Only reserve room for attribute header, packet data is added\par
  504      * in skb_zerocopy()\par
  505      */\par
  506     if (!(nla = nla_reserve(user_skb, OVS_PACKET_ATTR_PACKET, 0))) \{\par
  507         err = -ENOBUFS;\par
  508         goto out;\par
  509     \}\par
  510     nla->nla_len = nla_attr_size(skb->len);\par
  511 \par
  512     err = skb_zerocopy(user_skb, skb, skb->len, hlen);\par
  513     if (err)\par
  514         goto out;\par
  515 \par
  516     /* Pad OVS_PACKET_ATTR_PACKET if linear copy was performed */\par
  517     if (!(dp->user_features & OVS_DP_F_UNALIGNED)) \{\par
  518         size_t plen = NLA_ALIGN(user_skb->len) - user_skb->len;\par
  519 \par
  520         if (plen > 0)\par
  521             memset(skb_put(user_skb, plen), 0, plen);\par
  522     \}\par
  523 \par
  524     ((struct nlmsghdr *) user_skb->data)->nlmsg_len = user_skb->len;\par
  525 \par
  526     err = genlmsg_unicast(ovs_dp_get_net(dp), user_skb, upcall_info->portid);\par
  527     user_skb = NULL;\par
  528 out:\par
  529     if (err)\par
  530         skb_tx_error(skb);\par
  531     kfree_skb(user_skb);\par
  532     kfree_skb(nskb);\par
  533     return err;\par
  534 \}\par
}
}
{\xe \v should_fill_actions\:linux/datapath.c}
{\xe \v linux/datapath.c\:should_fill_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_actions (uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   702 \{\par
  703     return !(ufid_flags & OVS_UFID_F_OMIT_ACTIONS);\par
  704 \}\par
}
}
{\xe \v should_fill_key\:linux/datapath.c}
{\xe \v linux/datapath.c\:should_fill_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_key (const struct {\b sw_flow_id} *  {\i sfid}, uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   691 \{\par
  692     return ovs_identifier_is_ufid(sfid) &&\par
  693            !(ufid_flags & OVS_UFID_F_OMIT_KEY);\par
  694 \}\par
}
}
{\xe \v should_fill_mask\:linux/datapath.c}
{\xe \v linux/datapath.c\:should_fill_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} should_fill_mask (uint32_t  {\i ufid_flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   697 \{\par
  698     return !(ufid_flags & OVS_UFID_F_OMIT_MASK);\par
  699 \}\par
}
}
{\xe \v upcall_msg_size\:linux/datapath.c}
{\xe \v linux/datapath.c\:upcall_msg_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t upcall_msg_size (const struct {\b dp_upcall_info} *  {\i upcall_info}, unsigned int  {\i hdrlen}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   390 \{\par
  391     size_t size = NLMSG_ALIGN(sizeof(struct ovs_header))\par
  392         + nla_total_size(hdrlen) /* OVS_PACKET_ATTR_PACKET */\par
  393         + nla_total_size(ovs_key_attr_size()); /* OVS_PACKET_ATTR_KEY */\par
  394 \par
  395     /* OVS_PACKET_ATTR_USERDATA */\par
  396     if (upcall_info->userdata)\par
  397         size += NLA_ALIGN(upcall_info->userdata->nla_len);\par
  398 \par
  399     /* OVS_PACKET_ATTR_EGRESS_TUN_KEY */\par
  400     if (upcall_info->egress_tun_info)\par
  401         size += nla_total_size(ovs_tun_key_attr_size());\par
  402 \par
  403     /* OVS_PACKET_ATTR_ACTIONS */\par
  404     if (upcall_info->actions_len)\par
  405         size += nla_total_size(upcall_info->actions_len);\par
  406 \par
  407     return size;\par
  408 \}\par
}
}
{\xe \v vport_hash_bucket\:linux/datapath.c}
{\xe \v linux/datapath.c\:vport_hash_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* vport_hash_bucket (const struct {\b datapath} *  {\i dp}, u16  {\i port_no}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   215 \{\par
  216     return &dp->ports[port_no & (DP_VPORT_HASH_BUCKETS - 1)];\par
  217 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:linux/datapath.c}
{\xe \v linux/datapath.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ovs_net_id} __read_mostly}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v datapath_policy\:linux/datapath.c}
{\xe \v linux/datapath.c\:datapath_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy datapath_policy[{\b OVS_DP_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_DP_ATTR_NAME] = \{ .type = NLA_NUL_STRING, .len = IFNAMSIZ - 1 \},\par
    [OVS_DP_ATTR_UPCALL_PID] = \{ .type = NLA_U32 \},\par
    [OVS_DP_ATTR_USER_FEATURES] = \{ .type = NLA_U32 \},\par
\}\par
}
}
{\xe \v dp_datapath_genl_family\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_datapath_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_datapath_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_DATAPATH_FAMILY,\par
    .version = OVS_DATAPATH_VERSION,\par
    .maxattr = OVS_DP_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_datapath_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_datapath_genl_ops),\par
    .mcgrps = &ovs_dp_datapath_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_datapath_genl_ops\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_datapath_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_datapath_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_DP_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_new\par
    \},\par
    \{ .cmd = OVS_DP_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_del\par
    \},\par
    \{ .cmd = OVS_DP_CMD_GET,\par
      .flags = 0,           \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_get,\par
      .dumpit = ovs_dp_cmd_dump\par
    \},\par
    \{ .cmd = OVS_DP_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = datapath_policy,\par
      .doit = ovs_dp_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v dp_flow_genl_family\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_flow_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_flow_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_FLOW_FAMILY,\par
    .version = OVS_FLOW_VERSION,\par
    .maxattr = OVS_FLOW_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_flow_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_flow_genl_ops),\par
    .mcgrps = &ovs_dp_flow_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_flow_genl_ops\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_flow_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_flow_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_FLOW_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_new\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_del\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_GET,\par
      .flags = 0,           \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_get,\par
      .dumpit = ovs_flow_cmd_dump\par
    \},\par
    \{ .cmd = OVS_FLOW_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = flow_policy,\par
      .doit = ovs_flow_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v dp_genl_families\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_genl_families}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family}* dp_genl_families[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    &dp_datapath_genl_family,\par
    &dp_vport_genl_family,\par
    &dp_flow_genl_family,\par
    &dp_packet_genl_family,\par
\}\par
}
}
{\xe \v dp_packet_genl_family\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_packet_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b genl_family} dp_packet_genl_family{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_PACKET_FAMILY,\par
    .version = OVS_PACKET_VERSION,\par
    .maxattr = OVS_PACKET_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_packet_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_packet_genl_ops),\par
\}\par
}
}
{\xe \v dp_packet_genl_ops\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_packet_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_packet_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_PACKET_CMD_EXECUTE,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = packet_policy,\par
      .doit = ovs_packet_cmd_execute\par
    \}\par
\}\par
}
}
{\xe \v dp_vport_genl_family\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_vport_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family} dp_vport_genl_family}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .id = GENL_ID_GENERATE,\par
    .hdrsize = sizeof(struct ovs_header),\par
    .name = OVS_VPORT_FAMILY,\par
    .version = OVS_VPORT_VERSION,\par
    .maxattr = OVS_VPORT_ATTR_MAX,\par
    .netnsok = true,\par
    .parallel_ops = true,\par
    .ops = dp_vport_genl_ops,\par
    .n_ops = ARRAY_SIZE(dp_vport_genl_ops),\par
    .mcgrps = &ovs_dp_vport_multicast_group,\par
    .n_mcgrps = 1,\par
\}\par
}
}
{\xe \v dp_vport_genl_ops\:linux/datapath.c}
{\xe \v linux/datapath.c\:dp_vport_genl_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_ops dp_vport_genl_ops[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    \{ .cmd = OVS_VPORT_CMD_NEW,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_new\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_DEL,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_del\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_GET,\par
      .flags = 0,           \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_get,\par
      .dumpit = ovs_vport_cmd_dump\par
    \},\par
    \{ .cmd = OVS_VPORT_CMD_SET,\par
      .flags = GENL_ADMIN_PERM, \par
      .policy = vport_policy,\par
      .doit = ovs_vport_cmd_set,\par
    \},\par
\}\par
}
}
{\xe \v flow_policy\:linux/datapath.c}
{\xe \v linux/datapath.c\:flow_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct nla_policy flow_policy{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_FLOW_ATTR_KEY] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_MASK] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_ACTIONS] = \{ .type = NLA_NESTED \},\par
    [OVS_FLOW_ATTR_CLEAR] = \{ .type = NLA_FLAG \},\par
    [OVS_FLOW_ATTR_PROBE] = \{ .type = NLA_FLAG \},\par
    [OVS_FLOW_ATTR_UFID] = \{ .type = NLA_UNSPEC, .len = 1 \},\par
    [OVS_FLOW_ATTR_UFID_FLAGS] = \{ .type = NLA_U32 \},\par
\}\par
}
}
{\xe \v ovs_dp_datapath_multicast_group\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_datapath_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_datapath_multicast_group{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_DATAPATH_MCGROUP\par
\}\par
}
}
{\xe \v ovs_dp_flow_multicast_group\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_flow_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_flow_multicast_group{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_FLOW_MCGROUP\par
\}\par
}
}
{\xe \v ovs_dp_vport_multicast_group\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_dp_vport_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_vport_multicast_group}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .name = OVS_VPORT_MCGROUP\par
\}\par
}
}
{\xe \v ovs_net_ops\:linux/datapath.c}
{\xe \v linux/datapath.c\:ovs_net_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct pernet_operations ovs_net_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .init = ovs_init_net,\par
    .exit = ovs_exit_net,\par
    .id   = &ovs_net_id,\par
    .size = sizeof(struct ovs_net),\par
\}\par
}
}
{\xe \v packet_policy\:linux/datapath.c}
{\xe \v linux/datapath.c\:packet_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy packet_policy[{\b OVS_PACKET_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_PACKET_ATTR_PACKET] = \{ .len = ETH_HLEN \},\par
    [OVS_PACKET_ATTR_KEY] = \{ .type = NLA_NESTED \},\par
    [OVS_PACKET_ATTR_ACTIONS] = \{ .type = NLA_NESTED \},\par
    [OVS_PACKET_ATTR_PROBE] = \{ .type = NLA_FLAG \},\par
\}\par
}
}
{\xe \v vport_policy\:linux/datapath.c}
{\xe \v linux/datapath.c\:vport_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy vport_policy[{\b OVS_VPORT_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VPORT_ATTR_NAME] = \{ .type = NLA_NUL_STRING, .len = IFNAMSIZ - 1 \},\par
    [OVS_VPORT_ATTR_STATS] = \{ .len = sizeof(struct ovs_vport_stats) \},\par
    [OVS_VPORT_ATTR_PORT_NO] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_TYPE] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_UPCALL_PID] = \{ .type = NLA_U32 \},\par
    [OVS_VPORT_ATTR_OPTIONS] = \{ .type = NLA_NESTED \},\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/datapath.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/datapath.h}
{\xe \v /home/vladn/git/ovs/datapath/datapath.h}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <asm/page.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/mutex.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/u64_stats_sync.h>}\par
{\f2 #include "compat.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_table.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for datapath.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "datapath_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "datapath_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dp_stats_percpu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b datapath}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_skb_cb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dp_upcall_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_net}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DP_MAX_PORTS}\~ {\b USHRT_MAX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DP_VPORT_HASH_BUCKETS}\~ 1024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAMPLE_ACTION_DEPTH}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_CB}(skb)\~ ((struct {\b ovs_skb_cb} *)(skb)->cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b lockdep_ovsl_is_held}()\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_OVSL}()\~ WARN_ON(!{\b lockdep_ovsl_is_held}())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ovsl_dereference}(p)\~ {\b rcu_dereference_protected}(p, {\b lockdep_ovsl_is_held}())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_ovsl}(p)\~ {\b rcu_dereference_check}(p, {\b lockdep_ovsl_is_held}())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_NLERR}(logging_allowed,  fmt, ...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_lock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_unlock} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct net * {\b ovs_dp_get_net} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_dp_set_net} (struct {\b datapath} *dp, struct net *net)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_lookup_vport} (const struct {\b datapath} *dp, u16 port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b ovs_vport_rcu} (const struct {\b datapath} *dp, int port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b ovs_vport_ovsl_rcu} (const struct {\b datapath} *dp, int port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b ovs_vport_ovsl} (const struct {\b datapath} *dp, int port_no)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_process_packet} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_detach_port} (struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_dp_upcall} (struct {\b datapath} *, struct sk_buff *, const struct {\b sw_flow_key} *, const struct {\b dp_upcall_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_dp_name} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sk_buff * {\b ovs_vport_cmd_build_info} (struct {\b vport} *, u32 pid, u32 seq, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_execute_actions} (struct {\b datapath} *dp, struct sk_buff *skb, const struct {\b sw_flow_actions} *, struct {\b sw_flow_key} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_notify_wq} (struct work_struct *work)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b action_fifos_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b action_fifos_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_net_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct notifier_block {\b ovs_dp_device_notifier}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b genl_family} {\b dp_vport_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct genl_multicast_group {\b ovs_dp_vport_multicast_group}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ASSERT_OVSL\:datapath.h}
{\xe \v datapath.h\:ASSERT_OVSL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_OVSL()\~ WARN_ON(!{\b lockdep_ovsl_is_held}())}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DP_MAX_PORTS\:datapath.h}
{\xe \v datapath.h\:DP_MAX_PORTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DP_MAX_PORTS\~ {\b USHRT_MAX}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DP_VPORT_HASH_BUCKETS\:datapath.h}
{\xe \v datapath.h\:DP_VPORT_HASH_BUCKETS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DP_VPORT_HASH_BUCKETS\~ 1024}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lockdep_ovsl_is_held\:datapath.h}
{\xe \v datapath.h\:lockdep_ovsl_is_held}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define lockdep_ovsl_is_held()\~ 1}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_CB\:datapath.h}
{\xe \v datapath.h\:OVS_CB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_CB( skb)\~ ((struct {\b ovs_skb_cb} *)(skb)->cb)}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_NLERR\:datapath.h}
{\xe \v datapath.h\:OVS_NLERR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_NLERR( logging_allowed,  fmt,   {\i ...})}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                \\\par
    if (logging_allowed && net_ratelimit())         \\\par
        pr_info("netlink: " fmt "\\n", ##__VA_ARGS__);   \\\par
\} while (0)\par
}
}
{\xe \v ovsl_dereference\:datapath.h}
{\xe \v datapath.h\:ovsl_dereference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ovsl_dereference( p)\~ {\b rcu_dereference_protected}(p, {\b lockdep_ovsl_is_held}())}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_dereference_ovsl\:datapath.h}
{\xe \v datapath.h\:rcu_dereference_ovsl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_ovsl( p)\~ {\b rcu_dereference_check}(p, {\b lockdep_ovsl_is_held}())}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SAMPLE_ACTION_DEPTH\:datapath.h}
{\xe \v datapath.h\:SAMPLE_ACTION_DEPTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAMPLE_ACTION_DEPTH\~ 3}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v action_fifos_exit\:datapath.h}
{\xe \v datapath.h\:action_fifos_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void action_fifos_exit (void )}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1016 \{\par
 1017     free_percpu(action_fifos);\par
 1018 \}\par
}
}
{\xe \v action_fifos_init\:datapath.h}
{\xe \v datapath.h\:action_fifos_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int action_fifos_init (void )}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1007 \{\par
 1008     action_fifos = alloc_percpu(struct action_fifo);\par
 1009     if (!action_fifos)\par
 1010         return -ENOMEM;\par
 1011 \par
 1012     return 0;\par
 1013 \}\par
}
}
{\xe \v ovs_dp_detach_port\:datapath.h}
{\xe \v datapath.h\:ovs_dp_detach_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_detach_port (struct {\b vport} * )}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     ASSERT_OVSL();\par
  251 \par
  252     /* First drop references to device. */\par
  253     hlist_del_rcu(&p->dp_hash_node);\par
  254 \par
  255     /* Then destroy it. */\par
  256     ovs_vport_del(p);\par
  257 \}\par
}
}
{\xe \v ovs_dp_get_net\:datapath.h}
{\xe \v datapath.h\:ovs_dp_get_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct net* ovs_dp_get_net (const struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   158 \{\par
  159     return read_pnet(&dp->net);\par
  160 \}\par
}
}
{\xe \v ovs_dp_name\:datapath.h}
{\xe \v datapath.h\:ovs_dp_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_dp_name (const struct {\b datapath} *  {\i dp})}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179 \{\par
  180     struct vport *vport = ovs_vport_ovsl_rcu(dp, OVSP_LOCAL);\par
  181     return vport->ops->get_name(vport);\par
  182 \}\par
}
}
{\xe \v ovs_dp_notify_wq\:datapath.h}
{\xe \v datapath.h\:ovs_dp_notify_wq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_notify_wq (struct work_struct *  {\i work})}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     struct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);\par
   52     struct datapath *dp;\par
   53 \par
   54     ovs_lock();\par
   55     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
   56         int i;\par
   57 \par
   58         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
   59             struct vport *vport;\par
   60             struct hlist_node *n;\par
   61 \par
   62             hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) \{\par
   63                 struct netdev_vport *netdev_vport;\par
   64 \par
   65                 if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)\par
   66                     continue;\par
   67 \par
   68                 netdev_vport = netdev_vport_priv(vport);\par
   69                 if (!(ovs_netdev_get_vport(netdev_vport->dev)))\par
   70                     dp_detach_port_notify(vport);\par
   71             \}\par
   72         \}\par
   73     \}\par
   74     ovs_unlock();\par
   75 \}\par
}
}
{\xe \v ovs_dp_process_packet\:datapath.h}
{\xe \v datapath.h\:ovs_dp_process_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_process_packet (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   261 \{\par
  262     const struct vport *p = OVS_CB(skb)->input_vport;\par
  263     struct datapath *dp = p->dp;\par
  264     struct sw_flow *flow;\par
  265     struct sw_flow_actions *sf_acts;\par
  266     struct dp_stats_percpu *stats;\par
  267     u64 *stats_counter;\par
  268     u32 n_mask_hit;\par
  269 \par
  270     stats = this_cpu_ptr(dp->stats_percpu);\par
  271 \par
  272     /* Look up flow. */\par
  273     flow = ovs_flow_tbl_lookup_stats(&dp->table, key, skb_get_hash(skb),\par
  274                      &n_mask_hit);\par
  275     if (unlikely(!flow)) \{\par
  276         struct dp_upcall_info upcall;\par
  277         int error;\par
  278 \par
  279         memset(&upcall, 0, sizeof(upcall));\par
  280         upcall.cmd = OVS_PACKET_CMD_MISS;\par
  281         upcall.portid = ovs_vport_find_upcall_portid(p, skb);\par
  282         error = ovs_dp_upcall(dp, skb, key, &upcall);\par
  283         if (unlikely(error))\par
  284             kfree_skb(skb);\par
  285         else\par
  286             consume_skb(skb);\par
  287         stats_counter = &stats->n_missed;\par
  288         goto out;\par
  289     \}\par
  290 \par
  291     ovs_flow_stats_update(flow, key->tp.flags, skb);\par
  292     sf_acts = rcu_dereference(flow->sf_acts);\par
  293     ovs_execute_actions(dp, skb, sf_acts, key);\par
  294 \par
  295     stats_counter = &stats->n_hit;\par
  296 \par
  297 out:\par
  298     /* Update datapath statistics. */\par
  299     u64_stats_update_begin(&stats->syncp);\par
  300     (*stats_counter)++;\par
  301     stats->n_mask_hit += n_mask_hit;\par
  302     u64_stats_update_end(&stats->syncp);\par
  303 \}\par
}
}
{\xe \v ovs_dp_set_net\:datapath.h}
{\xe \v datapath.h\:ovs_dp_set_net}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_dp_set_net (struct {\b datapath} *  {\i dp}, struct net *  {\i net}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   163 \{\par
  164     write_pnet(&dp->net, net);\par
  165 \}\par
}
}
{\xe \v ovs_dp_upcall\:datapath.h}
{\xe \v datapath.h\:ovs_dp_upcall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_dp_upcall (struct {\b datapath} * , struct sk_buff * , const struct {\b sw_flow_key} * , const struct {\b dp_upcall_info} * )}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308 \{\par
  309     struct dp_stats_percpu *stats;\par
  310     int err;\par
  311 \par
  312     if (upcall_info->portid == 0) \{\par
  313         err = -ENOTCONN;\par
  314         goto err;\par
  315     \}\par
  316 \par
  317     if (!skb_is_gso(skb))\par
  318         err = queue_userspace_packet(dp, skb, key, upcall_info);\par
  319     else\par
  320         err = queue_gso_packets(dp, skb, key, upcall_info);\par
  321     if (err)\par
  322         goto err;\par
  323 \par
  324     return 0;\par
  325 \par
  326 err:\par
  327     stats = this_cpu_ptr(dp->stats_percpu);\par
  328 \par
  329     u64_stats_update_begin(&stats->syncp);\par
  330     stats->n_lost++;\par
  331     u64_stats_update_end(&stats->syncp);\par
  332 \par
  333     return err;\par
  334 \}\par
}
}
{\xe \v ovs_execute_actions\:datapath.h}
{\xe \v datapath.h\:ovs_execute_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_execute_actions (struct {\b datapath} *  {\i dp}, struct sk_buff *  {\i skb}, const struct {\b sw_flow_actions} * , struct {\b sw_flow_key} * )}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   977 \{\par
  978     int level = this_cpu_read(exec_actions_level);\par
  979     int err;\par
  980 \par
  981     if (unlikely(level >= EXEC_ACTIONS_LEVEL_LIMIT)) \{\par
  982         if (net_ratelimit())\par
  983             pr_warn("%s: packet loop detected, dropping.\\n",\par
  984                 ovs_dp_name(dp));\par
  985 \par
  986         kfree_skb(skb);\par
  987         return -ELOOP;\par
  988     \}\par
  989 \par
  990     this_cpu_inc(exec_actions_level);\par
  991     err = do_execute_actions(dp, skb, key,\par
  992                  acts->actions, acts->actions_len);\par
  993 \par
  994     if (!level)\par
  995         process_deferred_actions(dp);\par
  996 \par
  997     this_cpu_dec(exec_actions_level);\par
  998 \par
  999     /* This return status currently does not reflect the errors\par
 1000      * encounted during deferred actions execution. Probably needs to\par
 1001      * be fixed in the future.\par
 1002      */\par
 1003     return err;\par
 1004 \}\par
}
}
{\xe \v ovs_lock\:datapath.h}
{\xe \v datapath.h\:ovs_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_lock (void )}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   121 \{\par
  122     mutex_lock(&ovs_mutex);\par
  123 \}\par
}
}
{\xe \v ovs_lookup_vport\:datapath.h}
{\xe \v datapath.h\:ovs_lookup_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_lookup_vport (const struct {\b datapath} *  {\i dp}, u16  {\i port_no})}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221 \{\par
  222     struct vport *vport;\par
  223     struct hlist_head *head;\par
  224 \par
  225     head = vport_hash_bucket(dp, port_no);\par
  226     hlist_for_each_entry_rcu(vport, head, dp_hash_node) \{\par
  227         if (vport->port_no == port_no)\par
  228             return vport;\par
  229     \}\par
  230     return NULL;\par
  231 \}\par
}
}
{\xe \v ovs_unlock\:datapath.h}
{\xe \v datapath.h\:ovs_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_unlock (void )}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126 \{\par
  127     mutex_unlock(&ovs_mutex);\par
  128 \}\par
}
}
{\xe \v ovs_vport_cmd_build_info\:datapath.h}
{\xe \v datapath.h\:ovs_vport_cmd_build_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sk_buff* ovs_vport_cmd_build_info (struct {\b vport} * , u32  {\i pid}, u32  {\i seq}, u8  {\i cmd})}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1848 \{\par
 1849     struct sk_buff *skb;\par
 1850     int retval;\par
 1851 \par
 1852     skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\par
 1853     if (!skb)\par
 1854         return ERR_PTR(-ENOMEM);\par
 1855 \par
 1856     retval = ovs_vport_cmd_fill_info(vport, skb, portid, seq, 0, cmd);\par
 1857     BUG_ON(retval < 0);\par
 1858 \par
 1859     return skb;\par
 1860 \}\par
}
}
{\xe \v ovs_vport_ovsl\:datapath.h}
{\xe \v datapath.h\:ovs_vport_ovsl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* ovs_vport_ovsl (const struct {\b datapath} *  {\i dp}, int  {\i port_no}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182 \{\par
  183     ASSERT_OVSL();\par
  184     return ovs_lookup_vport(dp, port_no);\par
  185 \}\par
}
}
{\xe \v ovs_vport_ovsl_rcu\:datapath.h}
{\xe \v datapath.h\:ovs_vport_ovsl_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* ovs_vport_ovsl_rcu (const struct {\b datapath} *  {\i dp}, int  {\i port_no}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_ovsl_is_held());\par
  178     return ovs_lookup_vport(dp, port_no);\par
  179 \}\par
}
}
{\xe \v ovs_vport_rcu\:datapath.h}
{\xe \v datapath.h\:ovs_vport_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* ovs_vport_rcu (const struct {\b datapath} *  {\i dp}, int  {\i port_no}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   170 \{\par
  171     WARN_ON_ONCE(!rcu_read_lock_held());\par
  172     return ovs_lookup_vport(dp, port_no);\par
  173 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dp_vport_genl_family\:datapath.h}
{\xe \v datapath.h\:dp_vport_genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b genl_family} dp_vport_genl_family}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_dp_device_notifier\:datapath.h}
{\xe \v datapath.h\:ovs_dp_device_notifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct notifier_block ovs_dp_device_notifier}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_dp_vport_multicast_group\:datapath.h}
{\xe \v datapath.h\:ovs_dp_vport_multicast_group}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct genl_multicast_group ovs_dp_vport_multicast_group}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_net_id\:datapath.h}
{\xe \v datapath.h\:ovs_net_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_net_id}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/dp_notify.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/dp_notify.c}
{\xe \v /home/vladn/git/ovs/datapath/dp_notify.c}
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/genetlink.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dp_notify.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dp__notify_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_detach_port_notify} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_notify_wq} (struct work_struct *work)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b dp_device_event} (struct notifier_block *unused, unsigned long event, void *ptr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct notifier_block {\b ovs_dp_device_notifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dp_detach_port_notify\:dp_notify.c}
{\xe \v dp_notify.c\:dp_detach_port_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_detach_port_notify (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    29 \{\par
   30     struct sk_buff *notify;\par
   31     struct datapath *dp;\par
   32 \par
   33     dp = vport->dp;\par
   34     notify = ovs_vport_cmd_build_info(vport, 0, 0, OVS_VPORT_CMD_DEL);\par
   35     ovs_dp_detach_port(vport);\par
   36     if (IS_ERR(notify)) \{\par
   37         genl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,\par
   38                  GROUP_ID(&ovs_dp_vport_multicast_group),\par
   39                  PTR_ERR(notify));\par
   40         return;\par
   41     \}\par
   42 \par
   43     genlmsg_multicast_netns(&dp_vport_genl_family,\par
   44                 ovs_dp_get_net(dp), notify, 0,\par
   45                 GROUP_ID(&ovs_dp_vport_multicast_group),\par
   46                 GFP_KERNEL);\par
   47 \}\par
}
}
{\xe \v dp_device_event\:dp_notify.c}
{\xe \v dp_notify.c\:dp_device_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int dp_device_event (struct notifier_block *  {\i unused}, unsigned long  {\i event}, void *  {\i ptr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    79 \{\par
   80     struct ovs_net *ovs_net;\par
   81     struct net_device *dev = netdev_notifier_info_to_dev(ptr);\par
   82     struct vport *vport = NULL;\par
   83 \par
   84     if (!ovs_is_internal_dev(dev))\par
   85         vport = ovs_netdev_get_vport(dev);\par
   86 \par
   87     if (!vport)\par
   88         return NOTIFY_DONE;\par
   89 \par
   90     if (event == NETDEV_UNREGISTER) \{\par
   91         /* upper_dev_unlink and decrement promisc immediately */\par
   92         ovs_netdev_detach_dev(vport);\par
   93 \par
   94         /* schedule vport destroy, dev_put and genl notification */\par
   95         ovs_net = net_generic(dev_net(dev), ovs_net_id);\par
   96         queue_work(system_wq, &ovs_net->dp_notify_work);\par
   97     \}\par
   98 \par
   99     return NOTIFY_DONE;\par
  100 \}\par
}
}
{\xe \v ovs_dp_notify_wq\:dp_notify.c}
{\xe \v dp_notify.c\:ovs_dp_notify_wq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_notify_wq (struct work_struct *  {\i work})}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     struct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);\par
   52     struct datapath *dp;\par
   53 \par
   54     ovs_lock();\par
   55     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
   56         int i;\par
   57 \par
   58         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
   59             struct vport *vport;\par
   60             struct hlist_node *n;\par
   61 \par
   62             hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) \{\par
   63                 struct netdev_vport *netdev_vport;\par
   64 \par
   65                 if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)\par
   66                     continue;\par
   67 \par
   68                 netdev_vport = netdev_vport_priv(vport);\par
   69                 if (!(ovs_netdev_get_vport(netdev_vport->dev)))\par
   70                     dp_detach_port_notify(vport);\par
   71             \}\par
   72         \}\par
   73     \}\par
   74     ovs_unlock();\par
   75 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_dp_device_notifier\:dp_notify.c}
{\xe \v dp_notify.c\:ovs_dp_device_notifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct notifier_block ovs_dp_device_notifier}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .notifier_call = dp_device_event\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/dp_notify.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/dp_notify.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/dp_notify.c}
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/genetlink.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dp_notify.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2dp__notify_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dp_detach_port_notify} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_dp_notify_wq} (struct work_struct *work)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b dp_device_event} (struct notifier_block *unused, unsigned long event, void *ptr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct notifier_block {\b ovs_dp_device_notifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dp_detach_port_notify\:linux/dp_notify.c}
{\xe \v linux/dp_notify.c\:dp_detach_port_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dp_detach_port_notify (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    29 \{\par
   30     struct sk_buff *notify;\par
   31     struct datapath *dp;\par
   32 \par
   33     dp = vport->dp;\par
   34     notify = ovs_vport_cmd_build_info(vport, 0, 0, OVS_VPORT_CMD_DEL);\par
   35     ovs_dp_detach_port(vport);\par
   36     if (IS_ERR(notify)) \{\par
   37         genl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,\par
   38                  GROUP_ID(&ovs_dp_vport_multicast_group),\par
   39                  PTR_ERR(notify));\par
   40         return;\par
   41     \}\par
   42 \par
   43     genlmsg_multicast_netns(&dp_vport_genl_family,\par
   44                 ovs_dp_get_net(dp), notify, 0,\par
   45                 GROUP_ID(&ovs_dp_vport_multicast_group),\par
   46                 GFP_KERNEL);\par
   47 \}\par
}
}
{\xe \v dp_device_event\:linux/dp_notify.c}
{\xe \v linux/dp_notify.c\:dp_device_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int dp_device_event (struct notifier_block *  {\i unused}, unsigned long  {\i event}, void *  {\i ptr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    79 \{\par
   80     struct ovs_net *ovs_net;\par
   81     struct net_device *dev = netdev_notifier_info_to_dev(ptr);\par
   82     struct vport *vport = NULL;\par
   83 \par
   84     if (!ovs_is_internal_dev(dev))\par
   85         vport = ovs_netdev_get_vport(dev);\par
   86 \par
   87     if (!vport)\par
   88         return NOTIFY_DONE;\par
   89 \par
   90     if (event == NETDEV_UNREGISTER) \{\par
   91         /* upper_dev_unlink and decrement promisc immediately */\par
   92         ovs_netdev_detach_dev(vport);\par
   93 \par
   94         /* schedule vport destroy, dev_put and genl notification */\par
   95         ovs_net = net_generic(dev_net(dev), ovs_net_id);\par
   96         queue_work(system_wq, &ovs_net->dp_notify_work);\par
   97     \}\par
   98 \par
   99     return NOTIFY_DONE;\par
  100 \}\par
}
}
{\xe \v ovs_dp_notify_wq\:linux/dp_notify.c}
{\xe \v linux/dp_notify.c\:ovs_dp_notify_wq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_dp_notify_wq (struct work_struct *  {\i work})}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     struct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);\par
   52     struct datapath *dp;\par
   53 \par
   54     ovs_lock();\par
   55     list_for_each_entry(dp, &ovs_net->dps, list_node) \{\par
   56         int i;\par
   57 \par
   58         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) \{\par
   59             struct vport *vport;\par
   60             struct hlist_node *n;\par
   61 \par
   62             hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) \{\par
   63                 struct netdev_vport *netdev_vport;\par
   64 \par
   65                 if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)\par
   66                     continue;\par
   67 \par
   68                 netdev_vport = netdev_vport_priv(vport);\par
   69                 if (!(ovs_netdev_get_vport(netdev_vport->dev)))\par
   70                     dp_detach_port_notify(vport);\par
   71             \}\par
   72         \}\par
   73     \}\par
   74     ovs_unlock();\par
   75 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_dp_device_notifier\:linux/dp_notify.c}
{\xe \v linux/dp_notify.c\:ovs_dp_device_notifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct notifier_block ovs_dp_device_notifier}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .notifier_call = dp_device_event\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow.c}
{\xe \v /home/vladn/git/ovs/datapath/flow.c}
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/mpls.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/smp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCP_FLAGS_BE16}({\b tp})\~ (*(__be16 *)&tcp_flag_word({\b tp}) & htons(0x0FFF))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b ovs_flow_used_time} (unsigned long flow_jiffies)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_update} (struct {\b sw_flow} *flow, __be16 tcp_flags, const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_get} (const struct {\b sw_flow} *flow, struct {\b ovs_flow_stats} *ovs_stats, unsigned long *used, __be16 *tcp_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_clear} (struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b check_header} (struct sk_buff *skb, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b arphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b check_iphdr} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b tcphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b udphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b sctphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b icmphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_ipv6hdr} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b icmp6hdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be16 {\b parse_ethertype} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_icmpv6} (struct sk_buff *skb, struct {\b sw_flow_key} *key, int nh_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b key_extract} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_update} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract} (const struct {\b ovs_tunnel_info} *tun_info, struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract_userspace} (const struct nlattr *attr, struct sk_buff *skb, struct {\b sw_flow_key} *key, {\b bool} log)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TCP_FLAGS_BE16\:flow.c}
{\xe \v flow.c\:TCP_FLAGS_BE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCP_FLAGS_BE16( {\b tp})\~ (*(__be16 *)&tcp_flag_word({\b tp}) & htons(0x0FFF))}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arphdr_ok\:flow.c}
{\xe \v flow.c\:arphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} arphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   189 \{\par
  190     return pskb_may_pull(skb, skb_network_offset(skb) +\par
  191                   sizeof(struct arp_eth_header));\par
  192 \}\par
}
}
{\xe \v check_header\:flow.c}
{\xe \v flow.c\:check_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int check_header (struct sk_buff *  {\i skb}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   180 \{\par
  181     if (unlikely(skb->len < len))\par
  182         return -EINVAL;\par
  183     if (unlikely(!pskb_may_pull(skb, len)))\par
  184         return -ENOMEM;\par
  185     return 0;\par
  186 \}\par
}
}
{\xe \v check_iphdr\:flow.c}
{\xe \v flow.c\:check_iphdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int check_iphdr (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195 \{\par
  196     unsigned int nh_ofs = skb_network_offset(skb);\par
  197     unsigned int ip_len;\par
  198     int err;\par
  199 \par
  200     err = check_header(skb, nh_ofs + sizeof(struct iphdr));\par
  201     if (unlikely(err))\par
  202         return err;\par
  203 \par
  204     ip_len = ip_hdrlen(skb);\par
  205     if (unlikely(ip_len < sizeof(struct iphdr) ||\par
  206              skb->len < nh_ofs + ip_len))\par
  207         return -EINVAL;\par
  208 \par
  209     skb_set_transport_header(skb, nh_ofs + ip_len);\par
  210     return 0;\par
  211 \}\par
}
}
{\xe \v icmp6hdr_ok\:flow.c}
{\xe \v flow.c\:icmp6hdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} icmp6hdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  294                   sizeof(struct icmp6hdr));\par
  295 \}\par
}
}
{\xe \v icmphdr_ok\:flow.c}
{\xe \v flow.c\:icmphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} icmphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   242 \{\par
  243     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  244                   sizeof(struct icmphdr));\par
  245 \}\par
}
}
{\xe \v key_extract\:flow.c}
{\xe \v flow.c\:key_extract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int key_extract (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
key_extract - extracts a flow key from an Ethernet frame. : sk_buff that contains the frame, with skb->data pointing to the Ethernet header : output flow key\par
The caller must ensure that skb->len >= ETH_HLEN.\par
Returns 0 if successful, otherwise a negative errno value.\par
Initializes  header pointers as follows:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->mac_header: the Ethernet header.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->network_header: just past the Ethernet header, or just past the VLAN header, to the first byte of the Ethernet payload.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->transport_header: If key->eth.type is ETH_P_IP or ETH_P_IPV6 on output, then just past the IP header, if one is present and of a correct length, otherwise the same as skb->network_header. For other key->eth.type values it is left untouched. \par}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   454 \{\par
  455     int error;\par
  456     struct ethhdr *eth;\par
  457 \par
  458     /* Flags are always used as part of stats */\par
  459     key->tp.flags = 0;\par
  460 \par
  461     skb_reset_mac_header(skb);\par
  462 \par
  463     /* Link layer.  We are guaranteed to have at least the 14 byte Ethernet\par
  464      * header in the linear data area.\par
  465      */\par
  466     eth = eth_hdr(skb);\par
  467     ether_addr_copy(key->eth.src, eth->h_source);\par
  468     ether_addr_copy(key->eth.dst, eth->h_dest);\par
  469 \par
  470     __skb_pull(skb, 2 * ETH_ALEN);\par
  471     /* We are going to push all headers that we pull, so no need to\par
  472      * update skb->csum here.\par
  473      */\par
  474 \par
  475     key->eth.tci = 0;\par
  476     if (skb_vlan_tag_present(skb))\par
  477         key->eth.tci = htons(vlan_get_tci(skb));\par
  478     else if (eth->h_proto == htons(ETH_P_8021Q))\par
  479         if (unlikely(parse_vlan(skb, key)))\par
  480             return -ENOMEM;\par
  481 \par
  482     key->eth.type = parse_ethertype(skb);\par
  483     if (unlikely(key->eth.type == htons(0)))\par
  484         return -ENOMEM;\par
  485 \par
  486     skb_reset_network_header(skb);\par
  487     skb_reset_mac_len(skb);\par
  488     __skb_push(skb, skb->data - skb_mac_header(skb));\par
  489 \par
  490     /* Network layer. */\par
  491     if (key->eth.type == htons(ETH_P_IP)) \{\par
  492         struct iphdr *nh;\par
  493         __be16 offset;\par
  494 \par
  495         error = check_iphdr(skb);\par
  496         if (unlikely(error)) \{\par
  497             memset(&key->ip, 0, sizeof(key->ip));\par
  498             memset(&key->ipv4, 0, sizeof(key->ipv4));\par
  499             if (error == -EINVAL) \{\par
  500                 skb->transport_header = skb->network_header;\par
  501                 error = 0;\par
  502             \}\par
  503             return error;\par
  504         \}\par
  505 \par
  506         nh = ip_hdr(skb);\par
  507         key->ipv4.addr.src = nh->saddr;\par
  508         key->ipv4.addr.dst = nh->daddr;\par
  509 \par
  510         key->ip.proto = nh->protocol;\par
  511         key->ip.tos = nh->tos;\par
  512         key->ip.ttl = nh->ttl;\par
  513 \par
  514         offset = nh->frag_off & htons(IP_OFFSET);\par
  515         if (offset) \{\par
  516             key->ip.frag = OVS_FRAG_TYPE_LATER;\par
  517             return 0;\par
  518         \}\par
  519         if (nh->frag_off & htons(IP_MF) ||\par
  520             skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\par
  521             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  522         else\par
  523             key->ip.frag = OVS_FRAG_TYPE_NONE;\par
  524 \par
  525         /* Transport layer. */\par
  526         if (key->ip.proto == IPPROTO_TCP) \{\par
  527             if (tcphdr_ok(skb)) \{\par
  528                 struct tcphdr *tcp = tcp_hdr(skb);\par
  529                 key->tp.src = tcp->source;\par
  530                 key->tp.dst = tcp->dest;\par
  531                 key->tp.flags = TCP_FLAGS_BE16(tcp);\par
  532             \} else \{\par
  533                 memset(&key->tp, 0, sizeof(key->tp));\par
  534             \}\par
  535 \par
  536         \} else if (key->ip.proto == IPPROTO_UDP) \{\par
  537             if (udphdr_ok(skb)) \{\par
  538                 struct udphdr *udp = udp_hdr(skb);\par
  539                 key->tp.src = udp->source;\par
  540                 key->tp.dst = udp->dest;\par
  541             \} else \{\par
  542                 memset(&key->tp, 0, sizeof(key->tp));\par
  543             \}\par
  544         \} else if (key->ip.proto == IPPROTO_SCTP) \{\par
  545             if (sctphdr_ok(skb)) \{\par
  546                 struct sctphdr *sctp = sctp_hdr(skb);\par
  547                 key->tp.src = sctp->source;\par
  548                 key->tp.dst = sctp->dest;\par
  549             \} else \{\par
  550                 memset(&key->tp, 0, sizeof(key->tp));\par
  551             \}\par
  552         \} else if (key->ip.proto == IPPROTO_ICMP) \{\par
  553             if (icmphdr_ok(skb)) \{\par
  554                 struct icmphdr *icmp = icmp_hdr(skb);\par
  555                 /* The ICMP type and code fields use the 16-bit\par
  556                  * transport port fields, so we need to store\par
  557                  * them in 16-bit network byte order.\par
  558                  */\par
  559                 key->tp.src = htons(icmp->type);\par
  560                 key->tp.dst = htons(icmp->code);\par
  561             \} else \{\par
  562                 memset(&key->tp, 0, sizeof(key->tp));\par
  563             \}\par
  564         \}\par
  565 \par
  566     \} else if (key->eth.type == htons(ETH_P_ARP) ||\par
  567            key->eth.type == htons(ETH_P_RARP)) \{\par
  568         struct arp_eth_header *arp;\par
  569         bool arp_available = arphdr_ok(skb);\par
  570 \par
  571         arp = (struct arp_eth_header *)skb_network_header(skb);\par
  572 \par
  573         if (arp_available &&\par
  574             arp->ar_hrd == htons(ARPHRD_ETHER) &&\par
  575             arp->ar_pro == htons(ETH_P_IP) &&\par
  576             arp->ar_hln == ETH_ALEN &&\par
  577             arp->ar_pln == 4) \{\par
  578 \par
  579             /* We only match on the lower 8 bits of the opcode. */\par
  580             if (ntohs(arp->ar_op) <= 0xff)\par
  581                 key->ip.proto = ntohs(arp->ar_op);\par
  582             else\par
  583                 key->ip.proto = 0;\par
  584 \par
  585             memcpy(&key->ipv4.addr.src, arp->ar_sip, sizeof(key->ipv4.addr.src));\par
  586             memcpy(&key->ipv4.addr.dst, arp->ar_tip, sizeof(key->ipv4.addr.dst));\par
  587             ether_addr_copy(key->ipv4.arp.sha, arp->ar_sha);\par
  588             ether_addr_copy(key->ipv4.arp.tha, arp->ar_tha);\par
  589         \} else \{\par
  590             memset(&key->ip, 0, sizeof(key->ip));\par
  591             memset(&key->ipv4, 0, sizeof(key->ipv4));\par
  592         \}\par
  593     \} else if (eth_p_mpls(key->eth.type)) \{\par
  594         size_t stack_len = MPLS_HLEN;\par
  595 \par
  596         /* In the presence of an MPLS label stack the end of the L2\par
  597          * header and the beginning of the L3 header differ.\par
  598          *\par
  599          * Advance network_header to the beginning of the L3\par
  600          * header. mac_len corresponds to the end of the L2 header.\par
  601          */\par
  602         while (1) \{\par
  603             __be32 lse;\par
  604 \par
  605             error = check_header(skb, skb->mac_len + stack_len);\par
  606             if (unlikely(error))\par
  607                 return 0;\par
  608 \par
  609             memcpy(&lse, skb_network_header(skb), MPLS_HLEN);\par
  610 \par
  611             if (stack_len == MPLS_HLEN)\par
  612                 memcpy(&key->mpls.top_lse, &lse, MPLS_HLEN);\par
  613 \par
  614             skb_set_network_header(skb, skb->mac_len + stack_len);\par
  615             if (lse & htonl(MPLS_LS_S_MASK))\par
  616                 break;\par
  617 \par
  618             stack_len += MPLS_HLEN;\par
  619         \}\par
  620     \} else if (key->eth.type == htons(ETH_P_IPV6)) \{\par
  621         int nh_len;             /* IPv6 Header + Extensions */\par
  622 \par
  623         nh_len = parse_ipv6hdr(skb, key);\par
  624         if (unlikely(nh_len < 0)) \{\par
  625             memset(&key->ip, 0, sizeof(key->ip));\par
  626             memset(&key->ipv6.addr, 0, sizeof(key->ipv6.addr));\par
  627             if (nh_len == -EINVAL) \{\par
  628                 skb->transport_header = skb->network_header;\par
  629                 error = 0;\par
  630             \} else \{\par
  631                 error = nh_len;\par
  632             \}\par
  633             return error;\par
  634         \}\par
  635 \par
  636         if (key->ip.frag == OVS_FRAG_TYPE_LATER)\par
  637             return 0;\par
  638         if (skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\par
  639             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  640 \par
  641         /* Transport layer. */\par
  642         if (key->ip.proto == NEXTHDR_TCP) \{\par
  643             if (tcphdr_ok(skb)) \{\par
  644                 struct tcphdr *tcp = tcp_hdr(skb);\par
  645                 key->tp.src = tcp->source;\par
  646                 key->tp.dst = tcp->dest;\par
  647                 key->tp.flags = TCP_FLAGS_BE16(tcp);\par
  648             \} else \{\par
  649                 memset(&key->tp, 0, sizeof(key->tp));\par
  650             \}\par
  651         \} else if (key->ip.proto == NEXTHDR_UDP) \{\par
  652             if (udphdr_ok(skb)) \{\par
  653                 struct udphdr *udp = udp_hdr(skb);\par
  654                 key->tp.src = udp->source;\par
  655                 key->tp.dst = udp->dest;\par
  656             \} else \{\par
  657                 memset(&key->tp, 0, sizeof(key->tp));\par
  658             \}\par
  659         \} else if (key->ip.proto == NEXTHDR_SCTP) \{\par
  660             if (sctphdr_ok(skb)) \{\par
  661                 struct sctphdr *sctp = sctp_hdr(skb);\par
  662                 key->tp.src = sctp->source;\par
  663                 key->tp.dst = sctp->dest;\par
  664             \} else \{\par
  665                 memset(&key->tp, 0, sizeof(key->tp));\par
  666             \}\par
  667         \} else if (key->ip.proto == NEXTHDR_ICMP) \{\par
  668             if (icmp6hdr_ok(skb)) \{\par
  669                 error = parse_icmpv6(skb, key, nh_len);\par
  670                 if (error)\par
  671                     return error;\par
  672             \} else \{\par
  673                 memset(&key->tp, 0, sizeof(key->tp));\par
  674             \}\par
  675         \}\par
  676     \}\par
  677     return 0;\par
  678 \}\par
}
}
{\xe \v ovs_flow_key_extract\:flow.c}
{\xe \v flow.c\:ovs_flow_key_extract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract (const struct {\b ovs_tunnel_info} *  {\i tun_info}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   687 \{\par
  688     /* Extract metadata from packet. */\par
  689     if (tun_info) \{\par
  690         memcpy(&key->tun_key, &tun_info->tunnel, sizeof(key->tun_key));\par
  691 \par
  692         BUILD_BUG_ON(((1 << (sizeof(tun_info->options_len) * 8)) - 1) >\par
  693                  sizeof(key->tun_opts));\par
  694 \par
  695         if (tun_info->options) \{\par
  696             memcpy(TUN_METADATA_OPTS(key, tun_info->options_len),\par
  697                    tun_info->options, tun_info->options_len);\par
  698             key->tun_opts_len = tun_info->options_len;\par
  699         \} else \{\par
  700             key->tun_opts_len = 0;\par
  701         \}\par
  702     \} else \{\par
  703         key->tun_opts_len = 0;\par
  704         memset(&key->tun_key, 0, sizeof(key->tun_key));\par
  705     \}\par
  706 \par
  707     key->phy.priority = skb->priority;\par
  708     key->phy.in_port = OVS_CB(skb)->input_vport->port_no;\par
  709     key->phy.skb_mark = skb->mark;\par
  710     key->ovs_flow_hash = 0;\par
  711     key->recirc_id = 0;\par
  712 \par
  713     return key_extract(skb, key);\par
  714 \}\par
}
}
{\xe \v ovs_flow_key_extract_userspace\:flow.c}
{\xe \v flow.c\:ovs_flow_key_extract_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract_userspace (const struct nlattr *  {\i attr}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   719 \{\par
  720     int err;\par
  721 \par
  722     /* Extract metadata from netlink attributes. */\par
  723     err = ovs_nla_get_flow_metadata(attr, key, log);\par
  724     if (err)\par
  725         return err;\par
  726 \par
  727     return key_extract(skb, key);\par
  728 \}\par
}
}
{\xe \v ovs_flow_key_update\:flow.c}
{\xe \v flow.c\:ovs_flow_key_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_update (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   681 \{\par
  682     return key_extract(skb, key);\par
  683 \}\par
}
}
{\xe \v ovs_flow_stats_clear\:flow.c}
{\xe \v flow.c\:ovs_flow_stats_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_clear (struct {\b sw_flow} *  {\i flow})}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163     int node;\par
  164 \par
  165     for_each_node(node) \{\par
  166         struct flow_stats *stats = ovsl_dereference(flow->stats[node]);\par
  167 \par
  168         if (stats) \{\par
  169             spin_lock_bh(&stats->lock);\par
  170             stats->used = 0;\par
  171             stats->packet_count = 0;\par
  172             stats->byte_count = 0;\par
  173             stats->tcp_flags = 0;\par
  174             spin_unlock_bh(&stats->lock);\par
  175         \}\par
  176     \}\par
  177 \}\par
}
}
{\xe \v ovs_flow_stats_get\:flow.c}
{\xe \v flow.c\:ovs_flow_stats_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_get (const struct {\b sw_flow} *  {\i flow}, struct {\b ovs_flow_stats} *  {\i ovs_stats}, unsigned long *  {\i used}, __be16 *  {\i tcp_flags})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     int node;\par
  137 \par
  138     *used = 0;\par
  139     *tcp_flags = 0;\par
  140     memset(ovs_stats, 0, sizeof(*ovs_stats));\par
  141 \par
  142     for_each_node(node) \{\par
  143         struct flow_stats *stats = rcu_dereference_ovsl(flow->stats[node]);\par
  144 \par
  145         if (stats) \{\par
  146             /* Local CPU may write on non-local stats, so we must\par
  147              * block bottom-halves here.\par
  148              */\par
  149             spin_lock_bh(&stats->lock);\par
  150             if (!*used || time_after(stats->used, *used))\par
  151                 *used = stats->used;\par
  152             *tcp_flags |= stats->tcp_flags;\par
  153             ovs_stats->n_packets += stats->packet_count;\par
  154             ovs_stats->n_bytes += stats->byte_count;\par
  155             spin_unlock_bh(&stats->lock);\par
  156         \}\par
  157     \}\par
  158 \}\par
}
}
{\xe \v ovs_flow_stats_update\:flow.c}
{\xe \v flow.c\:ovs_flow_stats_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_update (struct {\b sw_flow} *  {\i flow}, __be16  {\i tcp_flags}, const struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     struct flow_stats *stats;\par
   73     int node = numa_node_id();\par
   74     int len = skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
   75 \par
   76     stats = rcu_dereference(flow->stats[node]);\par
   77 \par
   78     /* Check if already have node-specific stats. */\par
   79     if (likely(stats)) \{\par
   80         spin_lock(&stats->lock);\par
   81         /* Mark if we write on the pre-allocated stats. */\par
   82         if (node == 0 && unlikely(flow->stats_last_writer != node))\par
   83             flow->stats_last_writer = node;\par
   84     \} else \{\par
   85         stats = rcu_dereference(flow->stats[0]); /* Pre-allocated. */\par
   86         spin_lock(&stats->lock);\par
   87 \par
   88         /* If the current NUMA-node is the only writer on the\par
   89          * pre-allocated stats keep using them.\par
   90          */\par
   91         if (unlikely(flow->stats_last_writer != node)) \{\par
   92             /* A previous locker may have already allocated the\par
   93              * stats, so we need to check again.  If node-specific\par
   94              * stats were already allocated, we update the pre-\par
   95              * allocated stats as we have already locked them.\par
   96              */\par
   97             if (likely(flow->stats_last_writer != NUMA_NO_NODE)\par
   98                 && likely(!rcu_access_pointer(flow->stats[node]))) \{\par
   99                 /* Try to allocate node-specific stats. */\par
  100                 struct flow_stats *new_stats;\par
  101 \par
  102                 new_stats =\par
  103                     kmem_cache_alloc_node(flow_stats_cache,\par
  104                                   GFP_THISNODE |\par
  105                                   __GFP_NOMEMALLOC,\par
  106                                   node);\par
  107                 if (likely(new_stats)) \{\par
  108                     new_stats->used = jiffies;\par
  109                     new_stats->packet_count = 1;\par
  110                     new_stats->byte_count = len;\par
  111                     new_stats->tcp_flags = tcp_flags;\par
  112                     spin_lock_init(&new_stats->lock);\par
  113 \par
  114                     rcu_assign_pointer(flow->stats[node],\par
  115                                new_stats);\par
  116                     goto unlock;\par
  117                 \}\par
  118             \}\par
  119             flow->stats_last_writer = node;\par
  120         \}\par
  121     \}\par
  122 \par
  123     stats->used = jiffies;\par
  124     stats->packet_count++;\par
  125     stats->byte_count += len;\par
  126     stats->tcp_flags |= tcp_flags;\par
  127 unlock:\par
  128     spin_unlock(&stats->lock);\par
  129 \}\par
}
}
{\xe \v ovs_flow_used_time\:flow.c}
{\xe \v flow.c\:ovs_flow_used_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 ovs_flow_used_time (unsigned long  {\i flow_jiffies})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     struct timespec cur_ts;\par
   57     u64 cur_ms, idle_ms;\par
   58 \par
   59     ktime_get_ts(&cur_ts);\par
   60     idle_ms = jiffies_to_msecs(jiffies - flow_jiffies);\par
   61     cur_ms = (u64)cur_ts.tv_sec * MSEC_PER_SEC +\par
   62          cur_ts.tv_nsec / NSEC_PER_MSEC;\par
   63 \par
   64     return cur_ms - idle_ms;\par
   65 \}\par
}
}
{\xe \v parse_ethertype\:flow.c}
{\xe \v flow.c\:parse_ethertype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be16 parse_ethertype (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   320 \{\par
  321     struct llc_snap_hdr \{\par
  322         u8  dsap;  /* Always 0xAA */\par
  323         u8  ssap;  /* Always 0xAA */\par
  324         u8  ctrl;\par
  325         u8  oui[3];\par
  326         __be16 ethertype;\par
  327     \};\par
  328     struct llc_snap_hdr *llc;\par
  329     __be16 proto;\par
  330 \par
  331     proto = *(__be16 *) skb->data;\par
  332     __skb_pull(skb, sizeof(__be16));\par
  333 \par
  334     if (eth_proto_is_802_3(proto))\par
  335         return proto;\par
  336 \par
  337     if (skb->len < sizeof(struct llc_snap_hdr))\par
  338         return htons(ETH_P_802_2);\par
  339 \par
  340     if (unlikely(!pskb_may_pull(skb, sizeof(struct llc_snap_hdr))))\par
  341         return htons(0);\par
  342 \par
  343     llc = (struct llc_snap_hdr *) skb->data;\par
  344     if (llc->dsap != LLC_SAP_SNAP ||\par
  345         llc->ssap != LLC_SAP_SNAP ||\par
  346         (llc->oui[0] | llc->oui[1] | llc->oui[2]) != 0)\par
  347         return htons(ETH_P_802_2);\par
  348 \par
  349     __skb_pull(skb, sizeof(struct llc_snap_hdr));\par
  350 \par
  351     if (eth_proto_is_802_3(llc->ethertype))\par
  352         return llc->ethertype;\par
  353 \par
  354     return htons(ETH_P_802_2);\par
  355 \}\par
}
}
{\xe \v parse_icmpv6\:flow.c}
{\xe \v flow.c\:parse_icmpv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_icmpv6 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, int  {\i nh_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   359 \{\par
  360     struct icmp6hdr *icmp = icmp6_hdr(skb);\par
  361 \par
  362     /* The ICMPv6 type and code fields use the 16-bit transport port\par
  363      * fields, so we need to store them in 16-bit network byte order.\par
  364      */\par
  365     key->tp.src = htons(icmp->icmp6_type);\par
  366     key->tp.dst = htons(icmp->icmp6_code);\par
  367     memset(&key->ipv6.nd, 0, sizeof(key->ipv6.nd));\par
  368 \par
  369     if (icmp->icmp6_code == 0 &&\par
  370         (icmp->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION ||\par
  371          icmp->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT)) \{\par
  372         int icmp_len = skb->len - skb_transport_offset(skb);\par
  373         struct nd_msg *nd;\par
  374         int offset;\par
  375 \par
  376         /* In order to process neighbor discovery options, we need the\par
  377          * entire packet.\par
  378          */\par
  379         if (unlikely(icmp_len < sizeof(*nd)))\par
  380             return 0;\par
  381 \par
  382         if (unlikely(skb_linearize(skb)))\par
  383             return -ENOMEM;\par
  384 \par
  385         nd = (struct nd_msg *)skb_transport_header(skb);\par
  386         key->ipv6.nd.target = nd->target;\par
  387 \par
  388         icmp_len -= sizeof(*nd);\par
  389         offset = 0;\par
  390         while (icmp_len >= 8) \{\par
  391             struct nd_opt_hdr *nd_opt =\par
  392                  (struct nd_opt_hdr *)(nd->opt + offset);\par
  393             int opt_len = nd_opt->nd_opt_len * 8;\par
  394 \par
  395             if (unlikely(!opt_len || opt_len > icmp_len))\par
  396                 return 0;\par
  397 \par
  398             /* Store the link layer address if the appropriate\par
  399              * option is provided.  It is considered an error if\par
  400              * the same link layer option is specified twice.\par
  401              */\par
  402             if (nd_opt->nd_opt_type == ND_OPT_SOURCE_LL_ADDR\par
  403                 && opt_len == 8) \{\par
  404                 if (unlikely(!is_zero_ether_addr(key->ipv6.nd.sll)))\par
  405                     goto invalid;\par
  406                 ether_addr_copy(key->ipv6.nd.sll,\par
  407                         &nd->opt[offset+sizeof(*nd_opt)]);\par
  408             \} else if (nd_opt->nd_opt_type == ND_OPT_TARGET_LL_ADDR\par
  409                    && opt_len == 8) \{\par
  410                 if (unlikely(!is_zero_ether_addr(key->ipv6.nd.tll)))\par
  411                     goto invalid;\par
  412                 ether_addr_copy(key->ipv6.nd.tll,\par
  413                         &nd->opt[offset+sizeof(*nd_opt)]);\par
  414             \}\par
  415 \par
  416             icmp_len -= opt_len;\par
  417             offset += opt_len;\par
  418         \}\par
  419     \}\par
  420 \par
  421     return 0;\par
  422 \par
  423 invalid:\par
  424     memset(&key->ipv6.nd.target, 0, sizeof(key->ipv6.nd.target));\par
  425     memset(key->ipv6.nd.sll, 0, sizeof(key->ipv6.nd.sll));\par
  426     memset(key->ipv6.nd.tll, 0, sizeof(key->ipv6.nd.tll));\par
  427 \par
  428     return 0;\par
  429 \}\par
}
}
{\xe \v parse_ipv6hdr\:flow.c}
{\xe \v flow.c\:parse_ipv6hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_ipv6hdr (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   248 \{\par
  249     unsigned int nh_ofs = skb_network_offset(skb);\par
  250     unsigned int nh_len;\par
  251     int payload_ofs;\par
  252     struct ipv6hdr *nh;\par
  253     uint8_t nexthdr;\par
  254     __be16 frag_off;\par
  255     int err;\par
  256 \par
  257     err = check_header(skb, nh_ofs + sizeof(*nh));\par
  258     if (unlikely(err))\par
  259         return err;\par
  260 \par
  261     nh = ipv6_hdr(skb);\par
  262     nexthdr = nh->nexthdr;\par
  263     payload_ofs = (u8 *)(nh + 1) - skb->data;\par
  264 \par
  265     key->ip.proto = NEXTHDR_NONE;\par
  266     key->ip.tos = ipv6_get_dsfield(nh);\par
  267     key->ip.ttl = nh->hop_limit;\par
  268     key->ipv6.label = *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\par
  269     key->ipv6.addr.src = nh->saddr;\par
  270     key->ipv6.addr.dst = nh->daddr;\par
  271 \par
  272     payload_ofs = ipv6_skip_exthdr(skb, payload_ofs, &nexthdr, &frag_off);\par
  273     if (unlikely(payload_ofs < 0))\par
  274         return -EINVAL;\par
  275 \par
  276     if (frag_off) \{\par
  277         if (frag_off & htons(~0x7))\par
  278             key->ip.frag = OVS_FRAG_TYPE_LATER;\par
  279         else\par
  280             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  281     \} else \{\par
  282         key->ip.frag = OVS_FRAG_TYPE_NONE;\par
  283     \}\par
  284 \par
  285     nh_len = payload_ofs - nh_ofs;\par
  286     skb_set_transport_header(skb, nh_ofs + nh_len);\par
  287     key->ip.proto = nexthdr;\par
  288     return nh_len;\par
  289 \}\par
}
}
{\xe \v parse_vlan\:flow.c}
{\xe \v flow.c\:parse_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   298 \{\par
  299     struct qtag_prefix \{\par
  300         __be16 eth_type; /* ETH_P_8021Q */\par
  301         __be16 tci;\par
  302     \};\par
  303     struct qtag_prefix *qp;\par
  304 \par
  305     if (unlikely(skb->len < sizeof(struct qtag_prefix) + sizeof(__be16)))\par
  306         return 0;\par
  307 \par
  308     if (unlikely(!pskb_may_pull(skb, sizeof(struct qtag_prefix) +\par
  309                      sizeof(__be16))))\par
  310         return -ENOMEM;\par
  311 \par
  312     qp = (struct qtag_prefix *) skb->data;\par
  313     key->eth.tci = qp->tci | htons(VLAN_TAG_PRESENT);\par
  314     __skb_pull(skb, sizeof(struct qtag_prefix));\par
  315 \par
  316     return 0;\par
  317 \}\par
}
}
{\xe \v sctphdr_ok\:flow.c}
{\xe \v flow.c\:sctphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} sctphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   236 \{\par
  237     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  238                   sizeof(struct sctphdr));\par
  239 \}\par
}
}
{\xe \v tcphdr_ok\:flow.c}
{\xe \v flow.c\:tcphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} tcphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   214 \{\par
  215     int th_ofs = skb_transport_offset(skb);\par
  216     int tcp_len;\par
  217 \par
  218     if (unlikely(!pskb_may_pull(skb, th_ofs + sizeof(struct tcphdr))))\par
  219         return false;\par
  220 \par
  221     tcp_len = tcp_hdrlen(skb);\par
  222     if (unlikely(tcp_len < sizeof(struct tcphdr) ||\par
  223              skb->len < th_ofs + tcp_len))\par
  224         return false;\par
  225 \par
  226     return true;\par
  227 \}\par
}
}
{\xe \v udphdr_ok\:flow.c}
{\xe \v flow.c\:udphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} udphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   230 \{\par
  231     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  232                   sizeof(struct udphdr));\par
  233 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/flow.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/flow.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/flow.c}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/mpls.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/smp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2flow_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCP_FLAGS_BE16}({\b tp})\~ (*(__be16 *)&tcp_flag_word({\b tp}) & htons(0x0FFF))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b ovs_flow_used_time} (unsigned long flow_jiffies)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_update} (struct {\b sw_flow} *flow, __be16 tcp_flags, const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_get} (const struct {\b sw_flow} *flow, struct {\b ovs_flow_stats} *ovs_stats, unsigned long *used, __be16 *tcp_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_clear} (struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b check_header} (struct sk_buff *skb, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b arphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b check_iphdr} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b tcphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b udphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b sctphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b icmphdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_ipv6hdr} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b icmp6hdr_ok} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_vlan} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be16 {\b parse_ethertype} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_icmpv6} (struct sk_buff *skb, struct {\b sw_flow_key} *key, int nh_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b key_extract} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_update} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract} (const struct {\b ovs_tunnel_info} *tun_info, struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract_userspace} (const struct nlattr *attr, struct sk_buff *skb, struct {\b sw_flow_key} *key, {\b bool} log)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TCP_FLAGS_BE16\:linux/flow.c}
{\xe \v linux/flow.c\:TCP_FLAGS_BE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCP_FLAGS_BE16( {\b tp})\~ (*(__be16 *)&tcp_flag_word({\b tp}) & htons(0x0FFF))}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arphdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:arphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} arphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   189 \{\par
  190     return pskb_may_pull(skb, skb_network_offset(skb) +\par
  191                   sizeof(struct arp_eth_header));\par
  192 \}\par
}
}
{\xe \v check_header\:linux/flow.c}
{\xe \v linux/flow.c\:check_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int check_header (struct sk_buff *  {\i skb}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   180 \{\par
  181     if (unlikely(skb->len < len))\par
  182         return -EINVAL;\par
  183     if (unlikely(!pskb_may_pull(skb, len)))\par
  184         return -ENOMEM;\par
  185     return 0;\par
  186 \}\par
}
}
{\xe \v check_iphdr\:linux/flow.c}
{\xe \v linux/flow.c\:check_iphdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int check_iphdr (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195 \{\par
  196     unsigned int nh_ofs = skb_network_offset(skb);\par
  197     unsigned int ip_len;\par
  198     int err;\par
  199 \par
  200     err = check_header(skb, nh_ofs + sizeof(struct iphdr));\par
  201     if (unlikely(err))\par
  202         return err;\par
  203 \par
  204     ip_len = ip_hdrlen(skb);\par
  205     if (unlikely(ip_len < sizeof(struct iphdr) ||\par
  206              skb->len < nh_ofs + ip_len))\par
  207         return -EINVAL;\par
  208 \par
  209     skb_set_transport_header(skb, nh_ofs + ip_len);\par
  210     return 0;\par
  211 \}\par
}
}
{\xe \v icmp6hdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:icmp6hdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} icmp6hdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  294                   sizeof(struct icmp6hdr));\par
  295 \}\par
}
}
{\xe \v icmphdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:icmphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} icmphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   242 \{\par
  243     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  244                   sizeof(struct icmphdr));\par
  245 \}\par
}
}
{\xe \v key_extract\:linux/flow.c}
{\xe \v linux/flow.c\:key_extract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int key_extract (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
key_extract - extracts a flow key from an Ethernet frame. : sk_buff that contains the frame, with skb->data pointing to the Ethernet header : output flow key\par
The caller must ensure that skb->len >= ETH_HLEN.\par
Returns 0 if successful, otherwise a negative errno value.\par
Initializes  header pointers as follows:\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->mac_header: the Ethernet header.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->network_header: just past the Ethernet header, or just past the VLAN header, to the first byte of the Ethernet payload.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
skb->transport_header: If key->eth.type is ETH_P_IP or ETH_P_IPV6 on output, then just past the IP header, if one is present and of a correct length, otherwise the same as skb->network_header. For other key->eth.type values it is left untouched. \par}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   454 \{\par
  455     int error;\par
  456     struct ethhdr *eth;\par
  457 \par
  458     /* Flags are always used as part of stats */\par
  459     key->tp.flags = 0;\par
  460 \par
  461     skb_reset_mac_header(skb);\par
  462 \par
  463     /* Link layer.  We are guaranteed to have at least the 14 byte Ethernet\par
  464      * header in the linear data area.\par
  465      */\par
  466     eth = eth_hdr(skb);\par
  467     ether_addr_copy(key->eth.src, eth->h_source);\par
  468     ether_addr_copy(key->eth.dst, eth->h_dest);\par
  469 \par
  470     __skb_pull(skb, 2 * ETH_ALEN);\par
  471     /* We are going to push all headers that we pull, so no need to\par
  472      * update skb->csum here.\par
  473      */\par
  474 \par
  475     key->eth.tci = 0;\par
  476     if (skb_vlan_tag_present(skb))\par
  477         key->eth.tci = htons(vlan_get_tci(skb));\par
  478     else if (eth->h_proto == htons(ETH_P_8021Q))\par
  479         if (unlikely(parse_vlan(skb, key)))\par
  480             return -ENOMEM;\par
  481 \par
  482     key->eth.type = parse_ethertype(skb);\par
  483     if (unlikely(key->eth.type == htons(0)))\par
  484         return -ENOMEM;\par
  485 \par
  486     skb_reset_network_header(skb);\par
  487     skb_reset_mac_len(skb);\par
  488     __skb_push(skb, skb->data - skb_mac_header(skb));\par
  489 \par
  490     /* Network layer. */\par
  491     if (key->eth.type == htons(ETH_P_IP)) \{\par
  492         struct iphdr *nh;\par
  493         __be16 offset;\par
  494 \par
  495         error = check_iphdr(skb);\par
  496         if (unlikely(error)) \{\par
  497             memset(&key->ip, 0, sizeof(key->ip));\par
  498             memset(&key->ipv4, 0, sizeof(key->ipv4));\par
  499             if (error == -EINVAL) \{\par
  500                 skb->transport_header = skb->network_header;\par
  501                 error = 0;\par
  502             \}\par
  503             return error;\par
  504         \}\par
  505 \par
  506         nh = ip_hdr(skb);\par
  507         key->ipv4.addr.src = nh->saddr;\par
  508         key->ipv4.addr.dst = nh->daddr;\par
  509 \par
  510         key->ip.proto = nh->protocol;\par
  511         key->ip.tos = nh->tos;\par
  512         key->ip.ttl = nh->ttl;\par
  513 \par
  514         offset = nh->frag_off & htons(IP_OFFSET);\par
  515         if (offset) \{\par
  516             key->ip.frag = OVS_FRAG_TYPE_LATER;\par
  517             return 0;\par
  518         \}\par
  519         if (nh->frag_off & htons(IP_MF) ||\par
  520             skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\par
  521             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  522         else\par
  523             key->ip.frag = OVS_FRAG_TYPE_NONE;\par
  524 \par
  525         /* Transport layer. */\par
  526         if (key->ip.proto == IPPROTO_TCP) \{\par
  527             if (tcphdr_ok(skb)) \{\par
  528                 struct tcphdr *tcp = tcp_hdr(skb);\par
  529                 key->tp.src = tcp->source;\par
  530                 key->tp.dst = tcp->dest;\par
  531                 key->tp.flags = TCP_FLAGS_BE16(tcp);\par
  532             \} else \{\par
  533                 memset(&key->tp, 0, sizeof(key->tp));\par
  534             \}\par
  535 \par
  536         \} else if (key->ip.proto == IPPROTO_UDP) \{\par
  537             if (udphdr_ok(skb)) \{\par
  538                 struct udphdr *udp = udp_hdr(skb);\par
  539                 key->tp.src = udp->source;\par
  540                 key->tp.dst = udp->dest;\par
  541             \} else \{\par
  542                 memset(&key->tp, 0, sizeof(key->tp));\par
  543             \}\par
  544         \} else if (key->ip.proto == IPPROTO_SCTP) \{\par
  545             if (sctphdr_ok(skb)) \{\par
  546                 struct sctphdr *sctp = sctp_hdr(skb);\par
  547                 key->tp.src = sctp->source;\par
  548                 key->tp.dst = sctp->dest;\par
  549             \} else \{\par
  550                 memset(&key->tp, 0, sizeof(key->tp));\par
  551             \}\par
  552         \} else if (key->ip.proto == IPPROTO_ICMP) \{\par
  553             if (icmphdr_ok(skb)) \{\par
  554                 struct icmphdr *icmp = icmp_hdr(skb);\par
  555                 /* The ICMP type and code fields use the 16-bit\par
  556                  * transport port fields, so we need to store\par
  557                  * them in 16-bit network byte order.\par
  558                  */\par
  559                 key->tp.src = htons(icmp->type);\par
  560                 key->tp.dst = htons(icmp->code);\par
  561             \} else \{\par
  562                 memset(&key->tp, 0, sizeof(key->tp));\par
  563             \}\par
  564         \}\par
  565 \par
  566     \} else if (key->eth.type == htons(ETH_P_ARP) ||\par
  567            key->eth.type == htons(ETH_P_RARP)) \{\par
  568         struct arp_eth_header *arp;\par
  569         bool arp_available = arphdr_ok(skb);\par
  570 \par
  571         arp = (struct arp_eth_header *)skb_network_header(skb);\par
  572 \par
  573         if (arp_available &&\par
  574             arp->ar_hrd == htons(ARPHRD_ETHER) &&\par
  575             arp->ar_pro == htons(ETH_P_IP) &&\par
  576             arp->ar_hln == ETH_ALEN &&\par
  577             arp->ar_pln == 4) \{\par
  578 \par
  579             /* We only match on the lower 8 bits of the opcode. */\par
  580             if (ntohs(arp->ar_op) <= 0xff)\par
  581                 key->ip.proto = ntohs(arp->ar_op);\par
  582             else\par
  583                 key->ip.proto = 0;\par
  584 \par
  585             memcpy(&key->ipv4.addr.src, arp->ar_sip, sizeof(key->ipv4.addr.src));\par
  586             memcpy(&key->ipv4.addr.dst, arp->ar_tip, sizeof(key->ipv4.addr.dst));\par
  587             ether_addr_copy(key->ipv4.arp.sha, arp->ar_sha);\par
  588             ether_addr_copy(key->ipv4.arp.tha, arp->ar_tha);\par
  589         \} else \{\par
  590             memset(&key->ip, 0, sizeof(key->ip));\par
  591             memset(&key->ipv4, 0, sizeof(key->ipv4));\par
  592         \}\par
  593     \} else if (eth_p_mpls(key->eth.type)) \{\par
  594         size_t stack_len = MPLS_HLEN;\par
  595 \par
  596         /* In the presence of an MPLS label stack the end of the L2\par
  597          * header and the beginning of the L3 header differ.\par
  598          *\par
  599          * Advance network_header to the beginning of the L3\par
  600          * header. mac_len corresponds to the end of the L2 header.\par
  601          */\par
  602         while (1) \{\par
  603             __be32 lse;\par
  604 \par
  605             error = check_header(skb, skb->mac_len + stack_len);\par
  606             if (unlikely(error))\par
  607                 return 0;\par
  608 \par
  609             memcpy(&lse, skb_network_header(skb), MPLS_HLEN);\par
  610 \par
  611             if (stack_len == MPLS_HLEN)\par
  612                 memcpy(&key->mpls.top_lse, &lse, MPLS_HLEN);\par
  613 \par
  614             skb_set_network_header(skb, skb->mac_len + stack_len);\par
  615             if (lse & htonl(MPLS_LS_S_MASK))\par
  616                 break;\par
  617 \par
  618             stack_len += MPLS_HLEN;\par
  619         \}\par
  620     \} else if (key->eth.type == htons(ETH_P_IPV6)) \{\par
  621         int nh_len;             /* IPv6 Header + Extensions */\par
  622 \par
  623         nh_len = parse_ipv6hdr(skb, key);\par
  624         if (unlikely(nh_len < 0)) \{\par
  625             memset(&key->ip, 0, sizeof(key->ip));\par
  626             memset(&key->ipv6.addr, 0, sizeof(key->ipv6.addr));\par
  627             if (nh_len == -EINVAL) \{\par
  628                 skb->transport_header = skb->network_header;\par
  629                 error = 0;\par
  630             \} else \{\par
  631                 error = nh_len;\par
  632             \}\par
  633             return error;\par
  634         \}\par
  635 \par
  636         if (key->ip.frag == OVS_FRAG_TYPE_LATER)\par
  637             return 0;\par
  638         if (skb_shinfo(skb)->gso_type & SKB_GSO_UDP)\par
  639             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  640 \par
  641         /* Transport layer. */\par
  642         if (key->ip.proto == NEXTHDR_TCP) \{\par
  643             if (tcphdr_ok(skb)) \{\par
  644                 struct tcphdr *tcp = tcp_hdr(skb);\par
  645                 key->tp.src = tcp->source;\par
  646                 key->tp.dst = tcp->dest;\par
  647                 key->tp.flags = TCP_FLAGS_BE16(tcp);\par
  648             \} else \{\par
  649                 memset(&key->tp, 0, sizeof(key->tp));\par
  650             \}\par
  651         \} else if (key->ip.proto == NEXTHDR_UDP) \{\par
  652             if (udphdr_ok(skb)) \{\par
  653                 struct udphdr *udp = udp_hdr(skb);\par
  654                 key->tp.src = udp->source;\par
  655                 key->tp.dst = udp->dest;\par
  656             \} else \{\par
  657                 memset(&key->tp, 0, sizeof(key->tp));\par
  658             \}\par
  659         \} else if (key->ip.proto == NEXTHDR_SCTP) \{\par
  660             if (sctphdr_ok(skb)) \{\par
  661                 struct sctphdr *sctp = sctp_hdr(skb);\par
  662                 key->tp.src = sctp->source;\par
  663                 key->tp.dst = sctp->dest;\par
  664             \} else \{\par
  665                 memset(&key->tp, 0, sizeof(key->tp));\par
  666             \}\par
  667         \} else if (key->ip.proto == NEXTHDR_ICMP) \{\par
  668             if (icmp6hdr_ok(skb)) \{\par
  669                 error = parse_icmpv6(skb, key, nh_len);\par
  670                 if (error)\par
  671                     return error;\par
  672             \} else \{\par
  673                 memset(&key->tp, 0, sizeof(key->tp));\par
  674             \}\par
  675         \}\par
  676     \}\par
  677     return 0;\par
  678 \}\par
}
}
{\xe \v ovs_flow_key_extract\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_key_extract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract (const struct {\b ovs_tunnel_info} *  {\i tun_info}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   687 \{\par
  688     /* Extract metadata from packet. */\par
  689     if (tun_info) \{\par
  690         memcpy(&key->tun_key, &tun_info->tunnel, sizeof(key->tun_key));\par
  691 \par
  692         BUILD_BUG_ON(((1 << (sizeof(tun_info->options_len) * 8)) - 1) >\par
  693                  sizeof(key->tun_opts));\par
  694 \par
  695         if (tun_info->options) \{\par
  696             memcpy(TUN_METADATA_OPTS(key, tun_info->options_len),\par
  697                    tun_info->options, tun_info->options_len);\par
  698             key->tun_opts_len = tun_info->options_len;\par
  699         \} else \{\par
  700             key->tun_opts_len = 0;\par
  701         \}\par
  702     \} else \{\par
  703         key->tun_opts_len = 0;\par
  704         memset(&key->tun_key, 0, sizeof(key->tun_key));\par
  705     \}\par
  706 \par
  707     key->phy.priority = skb->priority;\par
  708     key->phy.in_port = OVS_CB(skb)->input_vport->port_no;\par
  709     key->phy.skb_mark = skb->mark;\par
  710     key->ovs_flow_hash = 0;\par
  711     key->recirc_id = 0;\par
  712 \par
  713     return key_extract(skb, key);\par
  714 \}\par
}
}
{\xe \v ovs_flow_key_extract_userspace\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_key_extract_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract_userspace (const struct nlattr *  {\i attr}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   719 \{\par
  720     int err;\par
  721 \par
  722     /* Extract metadata from netlink attributes. */\par
  723     err = ovs_nla_get_flow_metadata(attr, key, log);\par
  724     if (err)\par
  725         return err;\par
  726 \par
  727     return key_extract(skb, key);\par
  728 \}\par
}
}
{\xe \v ovs_flow_key_update\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_key_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_update (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   681 \{\par
  682     return key_extract(skb, key);\par
  683 \}\par
}
}
{\xe \v ovs_flow_stats_clear\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_stats_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_clear (struct {\b sw_flow} *  {\i flow})}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163     int node;\par
  164 \par
  165     for_each_node(node) \{\par
  166         struct flow_stats *stats = ovsl_dereference(flow->stats[node]);\par
  167 \par
  168         if (stats) \{\par
  169             spin_lock_bh(&stats->lock);\par
  170             stats->used = 0;\par
  171             stats->packet_count = 0;\par
  172             stats->byte_count = 0;\par
  173             stats->tcp_flags = 0;\par
  174             spin_unlock_bh(&stats->lock);\par
  175         \}\par
  176     \}\par
  177 \}\par
}
}
{\xe \v ovs_flow_stats_get\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_stats_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_get (const struct {\b sw_flow} *  {\i flow}, struct {\b ovs_flow_stats} *  {\i ovs_stats}, unsigned long *  {\i used}, __be16 *  {\i tcp_flags})}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     int node;\par
  137 \par
  138     *used = 0;\par
  139     *tcp_flags = 0;\par
  140     memset(ovs_stats, 0, sizeof(*ovs_stats));\par
  141 \par
  142     for_each_node(node) \{\par
  143         struct flow_stats *stats = rcu_dereference_ovsl(flow->stats[node]);\par
  144 \par
  145         if (stats) \{\par
  146             /* Local CPU may write on non-local stats, so we must\par
  147              * block bottom-halves here.\par
  148              */\par
  149             spin_lock_bh(&stats->lock);\par
  150             if (!*used || time_after(stats->used, *used))\par
  151                 *used = stats->used;\par
  152             *tcp_flags |= stats->tcp_flags;\par
  153             ovs_stats->n_packets += stats->packet_count;\par
  154             ovs_stats->n_bytes += stats->byte_count;\par
  155             spin_unlock_bh(&stats->lock);\par
  156         \}\par
  157     \}\par
  158 \}\par
}
}
{\xe \v ovs_flow_stats_update\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_stats_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_update (struct {\b sw_flow} *  {\i flow}, __be16  {\i tcp_flags}, const struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     struct flow_stats *stats;\par
   73     int node = numa_node_id();\par
   74     int len = skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
   75 \par
   76     stats = rcu_dereference(flow->stats[node]);\par
   77 \par
   78     /* Check if already have node-specific stats. */\par
   79     if (likely(stats)) \{\par
   80         spin_lock(&stats->lock);\par
   81         /* Mark if we write on the pre-allocated stats. */\par
   82         if (node == 0 && unlikely(flow->stats_last_writer != node))\par
   83             flow->stats_last_writer = node;\par
   84     \} else \{\par
   85         stats = rcu_dereference(flow->stats[0]); /* Pre-allocated. */\par
   86         spin_lock(&stats->lock);\par
   87 \par
   88         /* If the current NUMA-node is the only writer on the\par
   89          * pre-allocated stats keep using them.\par
   90          */\par
   91         if (unlikely(flow->stats_last_writer != node)) \{\par
   92             /* A previous locker may have already allocated the\par
   93              * stats, so we need to check again.  If node-specific\par
   94              * stats were already allocated, we update the pre-\par
   95              * allocated stats as we have already locked them.\par
   96              */\par
   97             if (likely(flow->stats_last_writer != NUMA_NO_NODE)\par
   98                 && likely(!rcu_access_pointer(flow->stats[node]))) \{\par
   99                 /* Try to allocate node-specific stats. */\par
  100                 struct flow_stats *new_stats;\par
  101 \par
  102                 new_stats =\par
  103                     kmem_cache_alloc_node(flow_stats_cache,\par
  104                                   GFP_THISNODE |\par
  105                                   __GFP_NOMEMALLOC,\par
  106                                   node);\par
  107                 if (likely(new_stats)) \{\par
  108                     new_stats->used = jiffies;\par
  109                     new_stats->packet_count = 1;\par
  110                     new_stats->byte_count = len;\par
  111                     new_stats->tcp_flags = tcp_flags;\par
  112                     spin_lock_init(&new_stats->lock);\par
  113 \par
  114                     rcu_assign_pointer(flow->stats[node],\par
  115                                new_stats);\par
  116                     goto unlock;\par
  117                 \}\par
  118             \}\par
  119             flow->stats_last_writer = node;\par
  120         \}\par
  121     \}\par
  122 \par
  123     stats->used = jiffies;\par
  124     stats->packet_count++;\par
  125     stats->byte_count += len;\par
  126     stats->tcp_flags |= tcp_flags;\par
  127 unlock:\par
  128     spin_unlock(&stats->lock);\par
  129 \}\par
}
}
{\xe \v ovs_flow_used_time\:linux/flow.c}
{\xe \v linux/flow.c\:ovs_flow_used_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 ovs_flow_used_time (unsigned long  {\i flow_jiffies})}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     struct timespec cur_ts;\par
   57     u64 cur_ms, idle_ms;\par
   58 \par
   59     ktime_get_ts(&cur_ts);\par
   60     idle_ms = jiffies_to_msecs(jiffies - flow_jiffies);\par
   61     cur_ms = (u64)cur_ts.tv_sec * MSEC_PER_SEC +\par
   62          cur_ts.tv_nsec / NSEC_PER_MSEC;\par
   63 \par
   64     return cur_ms - idle_ms;\par
   65 \}\par
}
}
{\xe \v parse_ethertype\:linux/flow.c}
{\xe \v linux/flow.c\:parse_ethertype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be16 parse_ethertype (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   320 \{\par
  321     struct llc_snap_hdr \{\par
  322         u8  dsap;  /* Always 0xAA */\par
  323         u8  ssap;  /* Always 0xAA */\par
  324         u8  ctrl;\par
  325         u8  oui[3];\par
  326         __be16 ethertype;\par
  327     \};\par
  328     struct llc_snap_hdr *llc;\par
  329     __be16 proto;\par
  330 \par
  331     proto = *(__be16 *) skb->data;\par
  332     __skb_pull(skb, sizeof(__be16));\par
  333 \par
  334     if (eth_proto_is_802_3(proto))\par
  335         return proto;\par
  336 \par
  337     if (skb->len < sizeof(struct llc_snap_hdr))\par
  338         return htons(ETH_P_802_2);\par
  339 \par
  340     if (unlikely(!pskb_may_pull(skb, sizeof(struct llc_snap_hdr))))\par
  341         return htons(0);\par
  342 \par
  343     llc = (struct llc_snap_hdr *) skb->data;\par
  344     if (llc->dsap != LLC_SAP_SNAP ||\par
  345         llc->ssap != LLC_SAP_SNAP ||\par
  346         (llc->oui[0] | llc->oui[1] | llc->oui[2]) != 0)\par
  347         return htons(ETH_P_802_2);\par
  348 \par
  349     __skb_pull(skb, sizeof(struct llc_snap_hdr));\par
  350 \par
  351     if (eth_proto_is_802_3(llc->ethertype))\par
  352         return llc->ethertype;\par
  353 \par
  354     return htons(ETH_P_802_2);\par
  355 \}\par
}
}
{\xe \v parse_icmpv6\:linux/flow.c}
{\xe \v linux/flow.c\:parse_icmpv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_icmpv6 (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, int  {\i nh_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   359 \{\par
  360     struct icmp6hdr *icmp = icmp6_hdr(skb);\par
  361 \par
  362     /* The ICMPv6 type and code fields use the 16-bit transport port\par
  363      * fields, so we need to store them in 16-bit network byte order.\par
  364      */\par
  365     key->tp.src = htons(icmp->icmp6_type);\par
  366     key->tp.dst = htons(icmp->icmp6_code);\par
  367     memset(&key->ipv6.nd, 0, sizeof(key->ipv6.nd));\par
  368 \par
  369     if (icmp->icmp6_code == 0 &&\par
  370         (icmp->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION ||\par
  371          icmp->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT)) \{\par
  372         int icmp_len = skb->len - skb_transport_offset(skb);\par
  373         struct nd_msg *nd;\par
  374         int offset;\par
  375 \par
  376         /* In order to process neighbor discovery options, we need the\par
  377          * entire packet.\par
  378          */\par
  379         if (unlikely(icmp_len < sizeof(*nd)))\par
  380             return 0;\par
  381 \par
  382         if (unlikely(skb_linearize(skb)))\par
  383             return -ENOMEM;\par
  384 \par
  385         nd = (struct nd_msg *)skb_transport_header(skb);\par
  386         key->ipv6.nd.target = nd->target;\par
  387 \par
  388         icmp_len -= sizeof(*nd);\par
  389         offset = 0;\par
  390         while (icmp_len >= 8) \{\par
  391             struct nd_opt_hdr *nd_opt =\par
  392                  (struct nd_opt_hdr *)(nd->opt + offset);\par
  393             int opt_len = nd_opt->nd_opt_len * 8;\par
  394 \par
  395             if (unlikely(!opt_len || opt_len > icmp_len))\par
  396                 return 0;\par
  397 \par
  398             /* Store the link layer address if the appropriate\par
  399              * option is provided.  It is considered an error if\par
  400              * the same link layer option is specified twice.\par
  401              */\par
  402             if (nd_opt->nd_opt_type == ND_OPT_SOURCE_LL_ADDR\par
  403                 && opt_len == 8) \{\par
  404                 if (unlikely(!is_zero_ether_addr(key->ipv6.nd.sll)))\par
  405                     goto invalid;\par
  406                 ether_addr_copy(key->ipv6.nd.sll,\par
  407                         &nd->opt[offset+sizeof(*nd_opt)]);\par
  408             \} else if (nd_opt->nd_opt_type == ND_OPT_TARGET_LL_ADDR\par
  409                    && opt_len == 8) \{\par
  410                 if (unlikely(!is_zero_ether_addr(key->ipv6.nd.tll)))\par
  411                     goto invalid;\par
  412                 ether_addr_copy(key->ipv6.nd.tll,\par
  413                         &nd->opt[offset+sizeof(*nd_opt)]);\par
  414             \}\par
  415 \par
  416             icmp_len -= opt_len;\par
  417             offset += opt_len;\par
  418         \}\par
  419     \}\par
  420 \par
  421     return 0;\par
  422 \par
  423 invalid:\par
  424     memset(&key->ipv6.nd.target, 0, sizeof(key->ipv6.nd.target));\par
  425     memset(key->ipv6.nd.sll, 0, sizeof(key->ipv6.nd.sll));\par
  426     memset(key->ipv6.nd.tll, 0, sizeof(key->ipv6.nd.tll));\par
  427 \par
  428     return 0;\par
  429 \}\par
}
}
{\xe \v parse_ipv6hdr\:linux/flow.c}
{\xe \v linux/flow.c\:parse_ipv6hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_ipv6hdr (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   248 \{\par
  249     unsigned int nh_ofs = skb_network_offset(skb);\par
  250     unsigned int nh_len;\par
  251     int payload_ofs;\par
  252     struct ipv6hdr *nh;\par
  253     uint8_t nexthdr;\par
  254     __be16 frag_off;\par
  255     int err;\par
  256 \par
  257     err = check_header(skb, nh_ofs + sizeof(*nh));\par
  258     if (unlikely(err))\par
  259         return err;\par
  260 \par
  261     nh = ipv6_hdr(skb);\par
  262     nexthdr = nh->nexthdr;\par
  263     payload_ofs = (u8 *)(nh + 1) - skb->data;\par
  264 \par
  265     key->ip.proto = NEXTHDR_NONE;\par
  266     key->ip.tos = ipv6_get_dsfield(nh);\par
  267     key->ip.ttl = nh->hop_limit;\par
  268     key->ipv6.label = *(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\par
  269     key->ipv6.addr.src = nh->saddr;\par
  270     key->ipv6.addr.dst = nh->daddr;\par
  271 \par
  272     payload_ofs = ipv6_skip_exthdr(skb, payload_ofs, &nexthdr, &frag_off);\par
  273     if (unlikely(payload_ofs < 0))\par
  274         return -EINVAL;\par
  275 \par
  276     if (frag_off) \{\par
  277         if (frag_off & htons(~0x7))\par
  278             key->ip.frag = OVS_FRAG_TYPE_LATER;\par
  279         else\par
  280             key->ip.frag = OVS_FRAG_TYPE_FIRST;\par
  281     \} else \{\par
  282         key->ip.frag = OVS_FRAG_TYPE_NONE;\par
  283     \}\par
  284 \par
  285     nh_len = payload_ofs - nh_ofs;\par
  286     skb_set_transport_header(skb, nh_ofs + nh_len);\par
  287     key->ip.proto = nexthdr;\par
  288     return nh_len;\par
  289 \}\par
}
}
{\xe \v parse_vlan\:linux/flow.c}
{\xe \v linux/flow.c\:parse_vlan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_vlan (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   298 \{\par
  299     struct qtag_prefix \{\par
  300         __be16 eth_type; /* ETH_P_8021Q */\par
  301         __be16 tci;\par
  302     \};\par
  303     struct qtag_prefix *qp;\par
  304 \par
  305     if (unlikely(skb->len < sizeof(struct qtag_prefix) + sizeof(__be16)))\par
  306         return 0;\par
  307 \par
  308     if (unlikely(!pskb_may_pull(skb, sizeof(struct qtag_prefix) +\par
  309                      sizeof(__be16))))\par
  310         return -ENOMEM;\par
  311 \par
  312     qp = (struct qtag_prefix *) skb->data;\par
  313     key->eth.tci = qp->tci | htons(VLAN_TAG_PRESENT);\par
  314     __skb_pull(skb, sizeof(struct qtag_prefix));\par
  315 \par
  316     return 0;\par
  317 \}\par
}
}
{\xe \v sctphdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:sctphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} sctphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   236 \{\par
  237     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  238                   sizeof(struct sctphdr));\par
  239 \}\par
}
}
{\xe \v tcphdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:tcphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} tcphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   214 \{\par
  215     int th_ofs = skb_transport_offset(skb);\par
  216     int tcp_len;\par
  217 \par
  218     if (unlikely(!pskb_may_pull(skb, th_ofs + sizeof(struct tcphdr))))\par
  219         return false;\par
  220 \par
  221     tcp_len = tcp_hdrlen(skb);\par
  222     if (unlikely(tcp_len < sizeof(struct tcphdr) ||\par
  223              skb->len < th_ofs + tcp_len))\par
  224         return false;\par
  225 \par
  226     return true;\par
  227 \}\par
}
}
{\xe \v udphdr_ok\:linux/flow.c}
{\xe \v linux/flow.c\:udphdr_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} udphdr_ok (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   230 \{\par
  231     return pskb_may_pull(skb, skb_transport_offset(skb) +\par
  232                   sizeof(struct udphdr));\par
  233 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow.h}
{\xe \v /home/vladn/git/ovs/datapath/flow.h}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/cache.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/in6.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/time.h>}\par
{\f2 #include <linux/flex_array.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4_tunnel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_tunnel_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key_range}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_match}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_actions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b flow_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arp_eth_header}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_TUNNEL_KEY_SIZE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUN_METADATA_OFFSET}(opt_len)\~ (FIELD_SIZEOF(struct {\b sw_flow_key}, {\b tun_opts}) - opt_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUN_METADATA_OPTS}(flow_key,  opt_len)\~ ((void *)((flow_key)->{\b tun_opts} + {\b TUN_METADATA_OFFSET}(opt_len)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_SW_FLOW_KEY_METADATA_SIZE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_UFID_LENGTH}\~ 16 /* 128 bits */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4_tunnel} {\b __aligned} (4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __ovs_flow_tun_info_init} (struct {\b ovs_tunnel_info} *tun_info, __be32 saddr, __be32 daddr, u8 {\b tos}, u8 {\b ttl}, __be16 {\b tp_src}, __be16 {\b tp_dst}, __be64 {\b tun_id}, __be16 {\b tun_flags}, const void *opts, u8 opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_flow_tun_info_init} (struct {\b ovs_tunnel_info} *tun_info, const struct iphdr *iph, __be16 {\b tp_src}, __be16 {\b tp_dst}, __be64 {\b tun_id}, __be16 {\b tun_flags}, const void *opts, u8 opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow_key} {\b __aligned} (BITS_PER_LONG/8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_identifier_is_ufid} (const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_identifier_is_key} (const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_update} (struct {\b sw_flow} *, __be16 tcp_flags, const struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_get} (const struct {\b sw_flow} *, struct {\b ovs_flow_stats} *, unsigned long *used, __be16 *tcp_flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_stats_clear} (struct {\b sw_flow} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u64 {\b ovs_flow_used_time} (unsigned long flow_jiffies)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_update} (struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract} (const struct {\b ovs_tunnel_info} *tun_info, struct sk_buff *skb, struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_key_extract_userspace} (const struct nlattr *attr, struct sk_buff *skb, struct {\b sw_flow_key} *key, {\b bool} log)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be64 {\b tun_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be32 {\b ipv4_dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tun_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b ipv4_tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b ipv4_ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tp_src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__be16 {\b tp_dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_tunnel_info} {\b __aligned}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b tun_opts} [255]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u8 {\b tun_opts_len}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4_tunnel} {\b tun_key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b priority}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u32 {\b skb_mark}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u16 {\b in_port}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b phy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_flow_hash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b recirc_id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u8 {\b src} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ u8 {\b dst} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b tci}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b type}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b eth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __be32 {\b top_lse}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b mpls}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b proto}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u8 {\b frag}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ip}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b dst}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ __be16 {\b flags}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b tp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ __be32 {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ __be32 {\b dst}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b sha} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b tha} [ETH_ALEN]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b arp}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b src}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b dst}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ __be32 {\b label}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ struct in6_addr {\b target}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b sll} [ETH_ALEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \~ u8 {\b tll} [ETH_ALEN]\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ \} {\b nd}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b ipv6}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arp_eth_header} {\b __packed}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_UFID_LENGTH\:flow.h}
{\xe \v flow.h\:MAX_UFID_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_UFID_LENGTH\~ 16 /* 128 bits */}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_SW_FLOW_KEY_METADATA_SIZE\:flow.h}
{\xe \v flow.h\:OVS_SW_FLOW_KEY_METADATA_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_SW_FLOW_KEY_METADATA_SIZE}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (offsetof(struct sw_flow_key, recirc_id) +  \\\par
    FIELD_SIZEOF(struct sw_flow_key, recirc_id))\par
}
}
{\xe \v OVS_TUNNEL_KEY_SIZE\:flow.h}
{\xe \v flow.h\:OVS_TUNNEL_KEY_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_TUNNEL_KEY_SIZE}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (offsetof(struct ovs_key_ipv4_tunnel, tp_dst) +     \\\par
     FIELD_SIZEOF(struct ovs_key_ipv4_tunnel, tp_dst))\par
}
}
{\xe \v TUN_METADATA_OFFSET\:flow.h}
{\xe \v flow.h\:TUN_METADATA_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUN_METADATA_OFFSET( opt_len)\~ (FIELD_SIZEOF(struct {\b sw_flow_key}, {\b tun_opts}) - opt_len)}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUN_METADATA_OPTS\:flow.h}
{\xe \v flow.h\:TUN_METADATA_OPTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUN_METADATA_OPTS( flow_key,  opt_len)\~ ((void *)((flow_key)->{\b tun_opts} + {\b TUN_METADATA_OFFSET}(opt_len)))}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __aligned\:flow.h}
{\xe \v flow.h\:__aligned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key} __aligned (BITS_PER_LONG/  {\i 8})}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __aligned\:flow.h}
{\xe \v flow.h\:__aligned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ovs_key_ipv4_tunnel} __aligned (4 )}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __ovs_flow_tun_info_init\:flow.h}
{\xe \v flow.h\:__ovs_flow_tun_info_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __ovs_flow_tun_info_init (struct {\b ovs_tunnel_info} *  {\i tun_info}, __be32  {\i saddr}, __be32  {\i daddr}, u8  {\i tos}, u8  {\i ttl}, __be16  {\i tp_src}, __be16  {\i tp_dst}, __be64  {\i tun_id}, __be16  {\i tun_flags}, const void *  {\i opts}, u8  {\i opts_len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    78 \{\par
   79     tun_info->tunnel.tun_id = tun_id;\par
   80     tun_info->tunnel.ipv4_src = saddr;\par
   81     tun_info->tunnel.ipv4_dst = daddr;\par
   82     tun_info->tunnel.ipv4_tos = tos;\par
   83     tun_info->tunnel.ipv4_ttl = ttl;\par
   84     tun_info->tunnel.tun_flags = tun_flags;\par
   85 \par
   86     /* For the tunnel types on the top of IPsec, the tp_src and tp_dst of\par
   87      * the upper tunnel are used.\par
   88      * E.g: GRE over IPSEC, the tp_src and tp_port are zero.\par
   89      */\par
   90     tun_info->tunnel.tp_src = tp_src;\par
   91     tun_info->tunnel.tp_dst = tp_dst;\par
   92 \par
   93     /* Clear struct padding. */\par
   94     if (sizeof(tun_info->tunnel) != OVS_TUNNEL_KEY_SIZE)\par
   95         memset((unsigned char *)&tun_info->tunnel + OVS_TUNNEL_KEY_SIZE,\par
   96                0, sizeof(tun_info->tunnel) - OVS_TUNNEL_KEY_SIZE);\par
   97 \par
   98     tun_info->options = opts;\par
   99     tun_info->options_len = opts_len;\par
  100 \}\par
}
}
{\xe \v ovs_flow_key_extract\:flow.h}
{\xe \v flow.h\:ovs_flow_key_extract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract (const struct {\b ovs_tunnel_info} *  {\i tun_info}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   687 \{\par
  688     /* Extract metadata from packet. */\par
  689     if (tun_info) \{\par
  690         memcpy(&key->tun_key, &tun_info->tunnel, sizeof(key->tun_key));\par
  691 \par
  692         BUILD_BUG_ON(((1 << (sizeof(tun_info->options_len) * 8)) - 1) >\par
  693                  sizeof(key->tun_opts));\par
  694 \par
  695         if (tun_info->options) \{\par
  696             memcpy(TUN_METADATA_OPTS(key, tun_info->options_len),\par
  697                    tun_info->options, tun_info->options_len);\par
  698             key->tun_opts_len = tun_info->options_len;\par
  699         \} else \{\par
  700             key->tun_opts_len = 0;\par
  701         \}\par
  702     \} else \{\par
  703         key->tun_opts_len = 0;\par
  704         memset(&key->tun_key, 0, sizeof(key->tun_key));\par
  705     \}\par
  706 \par
  707     key->phy.priority = skb->priority;\par
  708     key->phy.in_port = OVS_CB(skb)->input_vport->port_no;\par
  709     key->phy.skb_mark = skb->mark;\par
  710     key->ovs_flow_hash = 0;\par
  711     key->recirc_id = 0;\par
  712 \par
  713     return key_extract(skb, key);\par
  714 \}\par
}
}
{\xe \v ovs_flow_key_extract_userspace\:flow.h}
{\xe \v flow.h\:ovs_flow_key_extract_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_extract_userspace (const struct nlattr *  {\i attr}, struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   719 \{\par
  720     int err;\par
  721 \par
  722     /* Extract metadata from netlink attributes. */\par
  723     err = ovs_nla_get_flow_metadata(attr, key, log);\par
  724     if (err)\par
  725         return err;\par
  726 \par
  727     return key_extract(skb, key);\par
  728 \}\par
}
}
{\xe \v ovs_flow_key_update\:flow.h}
{\xe \v flow.h\:ovs_flow_key_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_key_update (struct sk_buff *  {\i skb}, struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   681 \{\par
  682     return key_extract(skb, key);\par
  683 \}\par
}
}
{\xe \v ovs_flow_stats_clear\:flow.h}
{\xe \v flow.h\:ovs_flow_stats_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_clear (struct {\b sw_flow} * )}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163     int node;\par
  164 \par
  165     for_each_node(node) \{\par
  166         struct flow_stats *stats = ovsl_dereference(flow->stats[node]);\par
  167 \par
  168         if (stats) \{\par
  169             spin_lock_bh(&stats->lock);\par
  170             stats->used = 0;\par
  171             stats->packet_count = 0;\par
  172             stats->byte_count = 0;\par
  173             stats->tcp_flags = 0;\par
  174             spin_unlock_bh(&stats->lock);\par
  175         \}\par
  176     \}\par
  177 \}\par
}
}
{\xe \v ovs_flow_stats_get\:flow.h}
{\xe \v flow.h\:ovs_flow_stats_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_get (const struct {\b sw_flow} * , struct {\b ovs_flow_stats} * , unsigned long *  {\i used}, __be16 *  {\i tcp_flags})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     int node;\par
  137 \par
  138     *used = 0;\par
  139     *tcp_flags = 0;\par
  140     memset(ovs_stats, 0, sizeof(*ovs_stats));\par
  141 \par
  142     for_each_node(node) \{\par
  143         struct flow_stats *stats = rcu_dereference_ovsl(flow->stats[node]);\par
  144 \par
  145         if (stats) \{\par
  146             /* Local CPU may write on non-local stats, so we must\par
  147              * block bottom-halves here.\par
  148              */\par
  149             spin_lock_bh(&stats->lock);\par
  150             if (!*used || time_after(stats->used, *used))\par
  151                 *used = stats->used;\par
  152             *tcp_flags |= stats->tcp_flags;\par
  153             ovs_stats->n_packets += stats->packet_count;\par
  154             ovs_stats->n_bytes += stats->byte_count;\par
  155             spin_unlock_bh(&stats->lock);\par
  156         \}\par
  157     \}\par
  158 \}\par
}
}
{\xe \v ovs_flow_stats_update\:flow.h}
{\xe \v flow.h\:ovs_flow_stats_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_stats_update (struct {\b sw_flow} * , __be16  {\i tcp_flags}, const struct sk_buff * )}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{\par
   72     struct flow_stats *stats;\par
   73     int node = numa_node_id();\par
   74     int len = skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
   75 \par
   76     stats = rcu_dereference(flow->stats[node]);\par
   77 \par
   78     /* Check if already have node-specific stats. */\par
   79     if (likely(stats)) \{\par
   80         spin_lock(&stats->lock);\par
   81         /* Mark if we write on the pre-allocated stats. */\par
   82         if (node == 0 && unlikely(flow->stats_last_writer != node))\par
   83             flow->stats_last_writer = node;\par
   84     \} else \{\par
   85         stats = rcu_dereference(flow->stats[0]); /* Pre-allocated. */\par
   86         spin_lock(&stats->lock);\par
   87 \par
   88         /* If the current NUMA-node is the only writer on the\par
   89          * pre-allocated stats keep using them.\par
   90          */\par
   91         if (unlikely(flow->stats_last_writer != node)) \{\par
   92             /* A previous locker may have already allocated the\par
   93              * stats, so we need to check again.  If node-specific\par
   94              * stats were already allocated, we update the pre-\par
   95              * allocated stats as we have already locked them.\par
   96              */\par
   97             if (likely(flow->stats_last_writer != NUMA_NO_NODE)\par
   98                 && likely(!rcu_access_pointer(flow->stats[node]))) \{\par
   99                 /* Try to allocate node-specific stats. */\par
  100                 struct flow_stats *new_stats;\par
  101 \par
  102                 new_stats =\par
  103                     kmem_cache_alloc_node(flow_stats_cache,\par
  104                                   GFP_THISNODE |\par
  105                                   __GFP_NOMEMALLOC,\par
  106                                   node);\par
  107                 if (likely(new_stats)) \{\par
  108                     new_stats->used = jiffies;\par
  109                     new_stats->packet_count = 1;\par
  110                     new_stats->byte_count = len;\par
  111                     new_stats->tcp_flags = tcp_flags;\par
  112                     spin_lock_init(&new_stats->lock);\par
  113 \par
  114                     rcu_assign_pointer(flow->stats[node],\par
  115                                new_stats);\par
  116                     goto unlock;\par
  117                 \}\par
  118             \}\par
  119             flow->stats_last_writer = node;\par
  120         \}\par
  121     \}\par
  122 \par
  123     stats->used = jiffies;\par
  124     stats->packet_count++;\par
  125     stats->byte_count += len;\par
  126     stats->tcp_flags |= tcp_flags;\par
  127 unlock:\par
  128     spin_unlock(&stats->lock);\par
  129 \}\par
}
}
{\xe \v ovs_flow_tun_info_init\:flow.h}
{\xe \v flow.h\:ovs_flow_tun_info_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_flow_tun_info_init (struct {\b ovs_tunnel_info} *  {\i tun_info}, const struct iphdr *  {\i iph}, __be16  {\i tp_src}, __be16  {\i tp_dst}, __be64  {\i tun_id}, __be16  {\i tun_flags}, const void *  {\i opts}, u8  {\i opts_len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   110 \{\par
  111     __ovs_flow_tun_info_init(tun_info, iph->saddr, iph->daddr,\par
  112                  iph->tos, iph->ttl,\par
  113                  tp_src, tp_dst,\par
  114                  tun_id, tun_flags,\par
  115                  opts, opts_len);\par
  116 \}\par
}
}
{\xe \v ovs_flow_used_time\:flow.h}
{\xe \v flow.h\:ovs_flow_used_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u64 ovs_flow_used_time (unsigned long  {\i flow_jiffies})}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     struct timespec cur_ts;\par
   57     u64 cur_ms, idle_ms;\par
   58 \par
   59     ktime_get_ts(&cur_ts);\par
   60     idle_ms = jiffies_to_msecs(jiffies - flow_jiffies);\par
   61     cur_ms = (u64)cur_ts.tv_sec * MSEC_PER_SEC +\par
   62          cur_ts.tv_nsec / NSEC_PER_MSEC;\par
   63 \par
   64     return cur_ms - idle_ms;\par
   65 \}\par
}
}
{\xe \v ovs_identifier_is_key\:flow.h}
{\xe \v flow.h\:ovs_identifier_is_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_identifier_is_key (const struct {\b sw_flow_id} *  {\i sfid}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   263 \{\par
  264     return !ovs_identifier_is_ufid(sfid);\par
  265 \}\par
}
}
{\xe \v ovs_identifier_is_ufid\:flow.h}
{\xe \v flow.h\:ovs_identifier_is_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_identifier_is_ufid (const struct {\b sw_flow_id} *  {\i sfid}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     return sfid->ufid_len;\par
  260 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \} }}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \} }}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __aligned\:flow.h}
{\xe \v flow.h\:__aligned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow_key_range} __aligned}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __packed\:flow.h}
{\xe \v flow.h\:__packed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b arp_eth_header}  __packed}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v addr\:flow.h}
{\xe \v flow.h\:addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   addr}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v arp\:flow.h}
{\xe \v flow.h\:arp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   arp}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v dst\:flow.h}
{\xe \v flow.h\:dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr dst}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v eth\:flow.h}
{\xe \v flow.h\:eth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   eth}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flags\:flow.h}
{\xe \v flow.h\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 flags}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v frag\:flow.h}
{\xe \v flow.h\:frag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 frag}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v in_port\:flow.h}
{\xe \v flow.h\:in_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u16 in_port}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ip\:flow.h}
{\xe \v flow.h\:ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   ip}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4\:flow.h}
{\xe \v flow.h\:ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   ipv4}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_dst\:flow.h}
{\xe \v flow.h\:ipv4_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ipv4_dst}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_src\:flow.h}
{\xe \v flow.h\:ipv4_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 ipv4_src}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_tos\:flow.h}
{\xe \v flow.h\:ipv4_tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ipv4_tos}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv4_ttl\:flow.h}
{\xe \v flow.h\:ipv4_ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ipv4_ttl}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ipv6\:flow.h}
{\xe \v flow.h\:ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   ipv6}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v label\:flow.h}
{\xe \v flow.h\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 label}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mpls\:flow.h}
{\xe \v flow.h\:mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   mpls}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nd\:flow.h}
{\xe \v flow.h\:nd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   nd}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_flow_hash\:flow.h}
{\xe \v flow.h\:ovs_flow_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_flow_hash}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v phy\:flow.h}
{\xe \v flow.h\:phy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}  phy}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v priority\:flow.h}
{\xe \v flow.h\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 priority}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v proto\:flow.h}
{\xe \v flow.h\:proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 proto}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v recirc_id\:flow.h}
{\xe \v flow.h\:recirc_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 recirc_id}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sha\:flow.h}
{\xe \v flow.h\:sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_mark\:flow.h}
{\xe \v flow.h\:skb_mark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 skb_mark}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sll\:flow.h}
{\xe \v flow.h\:sll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 sll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v src\:flow.h}
{\xe \v flow.h\:src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr src}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v target\:flow.h}
{\xe \v flow.h\:target}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct in6_addr target}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tci\:flow.h}
{\xe \v flow.h\:tci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tci}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tha\:flow.h}
{\xe \v flow.h\:tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 tha[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tll\:flow.h}
{\xe \v flow.h\:tll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 tll[ETH_ALEN]}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v top_lse\:flow.h}
{\xe \v flow.h\:top_lse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be32 top_lse}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tos\:flow.h}
{\xe \v flow.h\:tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 tos}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp\:flow.h}
{\xe \v flow.h\:tp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   tp}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp_dst\:flow.h}
{\xe \v flow.h\:tp_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tp_dst}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tp_src\:flow.h}
{\xe \v flow.h\:tp_src}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tp_src}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ttl\:flow.h}
{\xe \v flow.h\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 ttl}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_flags\:flow.h}
{\xe \v flow.h\:tun_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 tun_flags}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_id\:flow.h}
{\xe \v flow.h\:tun_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be64 tun_id}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_key\:flow.h}
{\xe \v flow.h\:tun_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ovs_key_ipv4_tunnel} tun_key}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_opts\:flow.h}
{\xe \v flow.h\:tun_opts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 tun_opts[255]}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tun_opts_len\:flow.h}
{\xe \v flow.h\:tun_opts_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u8 tun_opts_len}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:flow.h}
{\xe \v flow.h\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__be16 type}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow_netlink.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow_netlink.c}
{\xe \v /home/vladn/git/ovs/datapath/flow_netlink.c}
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/geneve.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vport-vxlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_netlink.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__netlink_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_len_tbl}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_ATTR_NESTED}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_PUT}(match,  field,  value,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMCPY_OFFSET}(match,  offset,  value_p,  len,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMCPY}(match,  field,  value_p,  len,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMSET_FIELD}(match,  field,  value,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_ACTIONS_BUFSIZE}\~ (32 * 1024)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b update_range} (struct {\b sw_flow_match} *match, size_t offset, size_t size, {\b bool} is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b match_validate} (const struct {\b sw_flow_match} *match, u64 key_attrs, u64 mask_attrs, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_tun_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_all_zero} (const u8 *fp, size_t size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __parse_flow_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log, {\b bool} nz)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_flow_mask_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_flow_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genev_tun_opt_from_nlattr} (const struct nlattr *a, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_tun_opt_from_nlattr} (const struct nlattr *a, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ipv4_tun_from_nlattr} (const struct nlattr *attr, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_opt_to_nlattr} (struct sk_buff *skb, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ipv4_tun_to_nlattr} (struct sk_buff *skb, const struct {\b ovs_key_ipv4_tunnel} *output, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ipv4_tun_to_nlattr} (struct sk_buff *skb, const struct {\b ovs_key_ipv4_tunnel} *output, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_egress_tunnel_key} (struct sk_buff *skb, const struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b metadata_from_nlattrs} (struct {\b sw_flow_match} *match, u64 *attrs, const struct nlattr **a, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_key_from_nlattrs} (struct {\b sw_flow_match} *match, u64 attrs, const struct nlattr **a, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b nlattr_set} (struct nlattr *attr, u8 val, const struct {\b ovs_len_tbl} *tbl)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_set_nlattr} (struct nlattr *attr, u8 val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_match} (struct {\b sw_flow_match} *match, const struct nlattr *nla_key, const struct nlattr *nla_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b get_ufid_len} (const struct nlattr *attr, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_nla_get_ufid} (struct {\b sw_flow_id} *sfid, const struct nlattr *attr, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_identifier} (struct {\b sw_flow_id} *sfid, const struct nlattr *ufid, const struct {\b sw_flow_key} *key, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_nla_get_ufid_flags} (const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_flow_metadata} (const struct nlattr *attr, struct {\b sw_flow_key} *key, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ovs_nla_put_key} (const struct {\b sw_flow_key} *swkey, const struct {\b sw_flow_key} *output, {\b bool} is_mask, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_key} (const struct {\b sw_flow_key} *swkey, const struct {\b sw_flow_key} *output, int attr, {\b bool} is_mask, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_identifier} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_masked_key} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_mask} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_actions} * {\b nla_alloc_flow_actions} (int size, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_acts_callback} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_nla_free_flow_actions} (struct {\b sw_flow_actions} *sf_acts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct nlattr * {\b reserve_sfa_size} (struct {\b sw_flow_actions} **sfa, int attr_len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct nlattr * {\b __add_action} (struct {\b sw_flow_actions} **sfa, int attrtype, void *data, int len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b add_action} (struct {\b sw_flow_actions} **sfa, int attrtype, void *data, int len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b add_nested_action_start} (struct {\b sw_flow_actions} **sfa, int attrtype, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_nested_action_end} (struct {\b sw_flow_actions} *sfa, int st_offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ovs_nla_copy_actions} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, int depth, struct {\b sw_flow_actions} **sfa, __be16 eth_type, __be16 vlan_tci, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_and_copy_sample} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, int depth, struct {\b sw_flow_actions} **sfa, __be16 eth_type, __be16 vlan_tci, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_match_init} (struct {\b sw_flow_match} *match, struct {\b sw_flow_key} *key, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_geneve_opts} (struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_and_copy_set_tun} (const struct nlattr *attr, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b validate_masked} (u8 *data, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_set} (const struct nlattr *a, const struct {\b sw_flow_key} *flow_key, struct {\b sw_flow_actions} **sfa, {\b bool} *skip_copy, __be16 eth_type, {\b bool} masked, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_userspace} (const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b copy_action} (const struct nlattr *from, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_copy_actions} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sample_action_to_attr} (const struct nlattr *attr, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_action_to_attr} (const struct nlattr *a, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b masked_set_action_to_set_action_attr} (const struct nlattr *a, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_actions} (const struct nlattr *attr, int len, struct sk_buff *skb)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct {\b ovs_len_tbl} {\b ovs_tunnel_key_lens} [{\b OVS_TUNNEL_KEY_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct {\b ovs_len_tbl} {\b ovs_key_lens} [{\b OVS_KEY_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b vxlan_opt_policy} [{\b OVS_VXLAN_EXT_MAX}+1]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_ACTIONS_BUFSIZE\:flow_netlink.c}
{\xe \v flow_netlink.c\:MAX_ACTIONS_BUFSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_ACTIONS_BUFSIZE\~ (32 * 1024)}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_ATTR_NESTED\:flow_netlink.c}
{\xe \v flow_netlink.c\:OVS_ATTR_NESTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_ATTR_NESTED\~ -1}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:flow_netlink.c}
{\xe \v flow_netlink.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SW_FLOW_KEY_MEMCPY\:flow_netlink.c}
{\xe \v flow_netlink.c\:SW_FLOW_KEY_MEMCPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMCPY( match,  field,  value_p,  len,  is_mask)}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SW_FLOW_KEY_MEMCPY_OFFSET(match, offsetof(struct sw_flow_key, field), \\\par
                  value_p, len, is_mask)\par
}
}
{\xe \v SW_FLOW_KEY_MEMCPY_OFFSET\:flow_netlink.c}
{\xe \v flow_netlink.c\:SW_FLOW_KEY_MEMCPY_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMCPY_OFFSET( match,  offset,  value_p,  len,  is_mask)}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                    \\\par
        update_range(match, offset, len, is_mask);          \\\par
        if (is_mask)                            \\\par
            memcpy((u8 *)&(match)->mask->key + offset, value_p, len);\\\par
        else                                \\\par
            memcpy((u8 *)(match)->key + offset, value_p, len);  \\\par
    \} while (0)\par
}
}
{\xe \v SW_FLOW_KEY_MEMSET_FIELD\:flow_netlink.c}
{\xe \v flow_netlink.c\:SW_FLOW_KEY_MEMSET_FIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMSET_FIELD( match,  field,  value,  is_mask)}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                    \\\par
        update_range(match, offsetof(struct sw_flow_key, field),    \\\par
                 sizeof((match)->key->field), is_mask);     \\\par
        if (is_mask)                            \\\par
            memset((u8 *)&(match)->mask->key.field, value,      \\\par
                   sizeof((match)->mask->key.field));       \\\par
        else                                \\\par
            memset((u8 *)&(match)->key->field, value,           \\\par
                   sizeof((match)->key->field));                \\\par
    \} while (0)\par
}
}
{\xe \v SW_FLOW_KEY_PUT\:flow_netlink.c}
{\xe \v flow_netlink.c\:SW_FLOW_KEY_PUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_PUT( match,  field,  value,  is_mask)}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{ \\\par
        update_range(match, offsetof(struct sw_flow_key, field),    \\\par
                 sizeof((match)->key->field), is_mask);     \\\par
        if (is_mask)                            \\\par
            (match)->mask->key.field = value;           \\\par
        else                                \\\par
            (match)->key->field = value;                    \\\par
    \} while (0)\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __add_action\:flow_netlink.c}
{\xe \v flow_netlink.c\:__add_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct nlattr* __add_action (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, void *  {\i data}, int  {\i len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1604 \{\par
 1605     struct nlattr *a;\par
 1606 \par
 1607     a = reserve_sfa_size(sfa, nla_attr_size(len), log);\par
 1608     if (IS_ERR(a))\par
 1609         return a;\par
 1610 \par
 1611     a->nla_type = attrtype;\par
 1612     a->nla_len = nla_attr_size(len);\par
 1613 \par
 1614     if (data)\par
 1615         memcpy(nla_data(a), data, len);\par
 1616     memset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\par
 1617 \par
 1618     return a;\par
 1619 \}\par
}
}
{\xe \v __ipv4_tun_to_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:__ipv4_tun_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ipv4_tun_to_nlattr (struct sk_buff *  {\i skb}, const struct {\b ovs_key_ipv4_tunnel} *  {\i output}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   646 \{\par
  647     if (output->tun_flags & TUNNEL_KEY &&\par
  648         nla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id))\par
  649         return -EMSGSIZE;\par
  650     if (output->ipv4_src &&\par
  651         nla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC, output->ipv4_src))\par
  652         return -EMSGSIZE;\par
  653     if (output->ipv4_dst &&\par
  654         nla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST, output->ipv4_dst))\par
  655         return -EMSGSIZE;\par
  656     if (output->ipv4_tos &&\par
  657         nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->ipv4_tos))\par
  658         return -EMSGSIZE;\par
  659     if (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ipv4_ttl))\par
  660         return -EMSGSIZE;\par
  661     if ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\par
  662         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\par
  663         return -EMSGSIZE;\par
  664     if ((output->tun_flags & TUNNEL_CSUM) &&\par
  665         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\par
  666         return -EMSGSIZE;\par
  667     if (output->tp_src &&\par
  668         nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_SRC, output->tp_src))\par
  669         return -EMSGSIZE;\par
  670     if (output->tp_dst &&\par
  671         nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_DST, output->tp_dst))\par
  672         return -EMSGSIZE;\par
  673     if ((output->tun_flags & TUNNEL_OAM) &&\par
  674         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_OAM))\par
  675         return -EMSGSIZE;\par
  676     if (tun_opts) \{\par
  677         if (output->tun_flags & TUNNEL_GENEVE_OPT &&\par
  678             nla_put(skb, OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,\par
  679                 swkey_tun_opts_len, tun_opts))\par
  680             return -EMSGSIZE;\par
  681                else if (output->tun_flags & TUNNEL_VXLAN_OPT &&\par
  682             vxlan_opt_to_nlattr(skb, tun_opts, swkey_tun_opts_len))\par
  683             return -EMSGSIZE;\par
  684     \}\par
  685 \par
  686     return 0;\par
  687 \}\par
}
}
{\xe \v __ovs_nla_copy_actions\:flow_netlink.c}
{\xe \v flow_netlink.c\:__ovs_nla_copy_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ovs_nla_copy_actions (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, int  {\i depth}, struct {\b sw_flow_actions} **  {\i sfa}, __be16  {\i eth_type}, __be16  {\i vlan_tci}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2027 \{\par
 2028     const struct nlattr *a;\par
 2029     int rem, err;\par
 2030 \par
 2031     if (depth >= SAMPLE_ACTION_DEPTH)\par
 2032         return -EOVERFLOW;\par
 2033 \par
 2034     nla_for_each_nested(a, attr, rem) \{\par
 2035         /* Expected argument lengths, (u32)-1 for variable length. */\par
 2036         static const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = \{\par
 2037             [OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\par
 2038             [OVS_ACTION_ATTR_RECIRC] = sizeof(u32),\par
 2039             [OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\par
 2040             [OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),\par
 2041             [OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),\par
 2042             [OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\par
 2043             [OVS_ACTION_ATTR_POP_VLAN] = 0,\par
 2044             [OVS_ACTION_ATTR_SET] = (u32)-1,\par
 2045             [OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,\par
 2046             [OVS_ACTION_ATTR_SAMPLE] = (u32)-1,\par
 2047             [OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash)\par
 2048         \};\par
 2049         const struct ovs_action_push_vlan *vlan;\par
 2050         int type = nla_type(a);\par
 2051         bool skip_copy;\par
 2052 \par
 2053         if (type > OVS_ACTION_ATTR_MAX ||\par
 2054             (action_lens[type] != nla_len(a) &&\par
 2055              action_lens[type] != (u32)-1))\par
 2056             return -EINVAL;\par
 2057 \par
 2058         skip_copy = false;\par
 2059         switch (type) \{\par
 2060         case OVS_ACTION_ATTR_UNSPEC:\par
 2061             return -EINVAL;\par
 2062 \par
 2063         case OVS_ACTION_ATTR_USERSPACE:\par
 2064             err = validate_userspace(a);\par
 2065             if (err)\par
 2066                 return err;\par
 2067             break;\par
 2068 \par
 2069         case OVS_ACTION_ATTR_OUTPUT:\par
 2070             if (nla_get_u32(a) >= DP_MAX_PORTS)\par
 2071                 return -EINVAL;\par
 2072             break;\par
 2073 \par
 2074         case OVS_ACTION_ATTR_HASH: \{\par
 2075             const struct ovs_action_hash *act_hash = nla_data(a);\par
 2076 \par
 2077             switch (act_hash->hash_alg) \{\par
 2078             case OVS_HASH_ALG_L4:\par
 2079                 break;\par
 2080             default:\par
 2081                 return  -EINVAL;\par
 2082             \}\par
 2083 \par
 2084             break;\par
 2085         \}\par
 2086 \par
 2087         case OVS_ACTION_ATTR_POP_VLAN:\par
 2088             vlan_tci = htons(0);\par
 2089             break;\par
 2090 \par
 2091         case OVS_ACTION_ATTR_PUSH_VLAN:\par
 2092             vlan = nla_data(a);\par
 2093             if (vlan->vlan_tpid != htons(ETH_P_8021Q))\par
 2094                 return -EINVAL;\par
 2095             if (!(vlan->vlan_tci & htons(VLAN_TAG_PRESENT)))\par
 2096                 return -EINVAL;\par
 2097             vlan_tci = vlan->vlan_tci;\par
 2098             break;\par
 2099 \par
 2100         case OVS_ACTION_ATTR_RECIRC:\par
 2101             break;\par
 2102 \par
 2103         case OVS_ACTION_ATTR_PUSH_MPLS: \{\par
 2104             const struct ovs_action_push_mpls *mpls = nla_data(a);\par
 2105 \par
 2106             if (!eth_p_mpls(mpls->mpls_ethertype))\par
 2107                 return -EINVAL;\par
 2108             /* Prohibit push MPLS other than to a white list\par
 2109              * for packets that have a known tag order.\par
 2110              */\par
 2111             if (vlan_tci & htons(VLAN_TAG_PRESENT) ||\par
 2112                 (eth_type != htons(ETH_P_IP) &&\par
 2113                  eth_type != htons(ETH_P_IPV6) &&\par
 2114                  eth_type != htons(ETH_P_ARP) &&\par
 2115                  eth_type != htons(ETH_P_RARP) &&\par
 2116                  !eth_p_mpls(eth_type)))\par
 2117                 return -EINVAL;\par
 2118             eth_type = mpls->mpls_ethertype;\par
 2119             break;\par
 2120         \}\par
 2121 \par
 2122         case OVS_ACTION_ATTR_POP_MPLS:\par
 2123             if (vlan_tci & htons(VLAN_TAG_PRESENT) ||\par
 2124                 !eth_p_mpls(eth_type))\par
 2125                 return -EINVAL;\par
 2126 \par
 2127             /* Disallow subsequent L2.5+ set and mpls_pop actions\par
 2128              * as there is no check here to ensure that the new\par
 2129              * eth_type is valid and thus set actions could\par
 2130              * write off the end of the packet or otherwise\par
 2131              * corrupt it.\par
 2132              *\par
 2133              * Support for these actions is planned using packet\par
 2134              * recirculation.\par
 2135              */\par
 2136             eth_type = htons(0);\par
 2137             break;\par
 2138 \par
 2139         case OVS_ACTION_ATTR_SET:\par
 2140             err = validate_set(a, key, sfa,\par
 2141                        &skip_copy, eth_type, false, log);\par
 2142             if (err)\par
 2143                 return err;\par
 2144             break;\par
 2145 \par
 2146         case OVS_ACTION_ATTR_SET_MASKED:\par
 2147             err = validate_set(a, key, sfa,\par
 2148                        &skip_copy, eth_type, true, log);\par
 2149             if (err)\par
 2150                 return err;\par
 2151             break;\par
 2152 \par
 2153         case OVS_ACTION_ATTR_SAMPLE:\par
 2154             err = validate_and_copy_sample(a, key, depth, sfa,\par
 2155                                eth_type, vlan_tci, log);\par
 2156             if (err)\par
 2157                 return err;\par
 2158             skip_copy = true;\par
 2159             break;\par
 2160 \par
 2161         default:\par
 2162             OVS_NLERR(log, "Unknown Action type %d", type);\par
 2163             return -EINVAL;\par
 2164         \}\par
 2165         if (!skip_copy) \{\par
 2166             err = copy_action(a, sfa, log);\par
 2167             if (err)\par
 2168                 return err;\par
 2169         \}\par
 2170     \}\par
 2171 \par
 2172     if (rem > 0)\par
 2173         return -EINVAL;\par
 2174 \par
 2175     return 0;\par
 2176 \}\par
}
}
{\xe \v __ovs_nla_put_key\:flow_netlink.c}
{\xe \v flow_netlink.c\:__ovs_nla_put_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ovs_nla_put_key (const struct {\b sw_flow_key} *  {\i swkey}, const struct {\b sw_flow_key} *  {\i output}, {\b bool}  {\i is_mask}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1277 \{\par
 1278     struct ovs_key_ethernet *eth_key;\par
 1279     struct nlattr *nla, *encap;\par
 1280 \par
 1281     if (nla_put_u32(skb, OVS_KEY_ATTR_RECIRC_ID, output->recirc_id))\par
 1282         goto nla_put_failure;\par
 1283 \par
 1284     if (nla_put_u32(skb, OVS_KEY_ATTR_DP_HASH, output->ovs_flow_hash))\par
 1285         goto nla_put_failure;\par
 1286 \par
 1287     if (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\par
 1288         goto nla_put_failure;\par
 1289 \par
 1290     if ((swkey->tun_key.ipv4_dst || is_mask)) \{\par
 1291         const void *opts = NULL;\par
 1292 \par
 1293         if (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)\par
 1294             opts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);\par
 1295 \par
 1296         if (ipv4_tun_to_nlattr(skb, &output->tun_key, opts,\par
 1297                        swkey->tun_opts_len))\par
 1298             goto nla_put_failure;\par
 1299     \}\par
 1300 \par
 1301     if (swkey->phy.in_port == DP_MAX_PORTS) \{\par
 1302         if (is_mask && (output->phy.in_port == 0xffff))\par
 1303             if (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\par
 1304                 goto nla_put_failure;\par
 1305     \} else \{\par
 1306         u16 upper_u16;\par
 1307         upper_u16 = !is_mask ? 0 : 0xffff;\par
 1308 \par
 1309         if (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\par
 1310                 (upper_u16 << 16) | output->phy.in_port))\par
 1311             goto nla_put_failure;\par
 1312     \}\par
 1313 \par
 1314     if (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\par
 1315         goto nla_put_failure;\par
 1316 \par
 1317     nla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\par
 1318     if (!nla)\par
 1319         goto nla_put_failure;\par
 1320 \par
 1321     eth_key = nla_data(nla);\par
 1322     ether_addr_copy(eth_key->eth_src, output->eth.src);\par
 1323     ether_addr_copy(eth_key->eth_dst, output->eth.dst);\par
 1324 \par
 1325     if (swkey->eth.tci || swkey->eth.type == htons(ETH_P_8021Q)) \{\par
 1326         __be16 eth_type;\par
 1327         eth_type = !is_mask ? htons(ETH_P_8021Q) : htons(0xffff);\par
 1328         if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\par
 1329             nla_put_be16(skb, OVS_KEY_ATTR_VLAN, output->eth.tci))\par
 1330             goto nla_put_failure;\par
 1331         encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);\par
 1332         if (!swkey->eth.tci)\par
 1333             goto unencap;\par
 1334     \} else\par
 1335         encap = NULL;\par
 1336 \par
 1337     if (swkey->eth.type == htons(ETH_P_802_2)) \{\par
 1338         /*\par
 1339          * Ethertype 802.2 is represented in the netlink with omitted\par
 1340          * OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and\par
 1341          * 0xffff in the mask attribute.  Ethertype can also\par
 1342          * be wildcarded.\par
 1343          */\par
 1344         if (is_mask && output->eth.type)\par
 1345             if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\par
 1346                         output->eth.type))\par
 1347                 goto nla_put_failure;\par
 1348         goto unencap;\par
 1349     \}\par
 1350 \par
 1351     if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\par
 1352         goto nla_put_failure;\par
 1353 \par
 1354     if (swkey->eth.type == htons(ETH_P_IP)) \{\par
 1355         struct ovs_key_ipv4 *ipv4_key;\par
 1356 \par
 1357         nla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\par
 1358         if (!nla)\par
 1359             goto nla_put_failure;\par
 1360         ipv4_key = nla_data(nla);\par
 1361         ipv4_key->ipv4_src = output->ipv4.addr.src;\par
 1362         ipv4_key->ipv4_dst = output->ipv4.addr.dst;\par
 1363         ipv4_key->ipv4_proto = output->ip.proto;\par
 1364         ipv4_key->ipv4_tos = output->ip.tos;\par
 1365         ipv4_key->ipv4_ttl = output->ip.ttl;\par
 1366         ipv4_key->ipv4_frag = output->ip.frag;\par
 1367     \} else if (swkey->eth.type == htons(ETH_P_IPV6)) \{\par
 1368         struct ovs_key_ipv6 *ipv6_key;\par
 1369 \par
 1370         nla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\par
 1371         if (!nla)\par
 1372             goto nla_put_failure;\par
 1373         ipv6_key = nla_data(nla);\par
 1374         memcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\par
 1375                 sizeof(ipv6_key->ipv6_src));\par
 1376         memcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\par
 1377                 sizeof(ipv6_key->ipv6_dst));\par
 1378         ipv6_key->ipv6_label = output->ipv6.label;\par
 1379         ipv6_key->ipv6_proto = output->ip.proto;\par
 1380         ipv6_key->ipv6_tclass = output->ip.tos;\par
 1381         ipv6_key->ipv6_hlimit = output->ip.ttl;\par
 1382         ipv6_key->ipv6_frag = output->ip.frag;\par
 1383     \} else if (swkey->eth.type == htons(ETH_P_ARP) ||\par
 1384            swkey->eth.type == htons(ETH_P_RARP)) \{\par
 1385         struct ovs_key_arp *arp_key;\par
 1386 \par
 1387         nla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\par
 1388         if (!nla)\par
 1389             goto nla_put_failure;\par
 1390         arp_key = nla_data(nla);\par
 1391         memset(arp_key, 0, sizeof(struct ovs_key_arp));\par
 1392         arp_key->arp_sip = output->ipv4.addr.src;\par
 1393         arp_key->arp_tip = output->ipv4.addr.dst;\par
 1394         arp_key->arp_op = htons(output->ip.proto);\par
 1395         ether_addr_copy(arp_key->arp_sha, output->ipv4.arp.sha);\par
 1396         ether_addr_copy(arp_key->arp_tha, output->ipv4.arp.tha);\par
 1397     \} else if (eth_p_mpls(swkey->eth.type)) \{\par
 1398         struct ovs_key_mpls *mpls_key;\par
 1399 \par
 1400         nla = nla_reserve(skb, OVS_KEY_ATTR_MPLS, sizeof(*mpls_key));\par
 1401         if (!nla)\par
 1402             goto nla_put_failure;\par
 1403         mpls_key = nla_data(nla);\par
 1404         mpls_key->mpls_lse = output->mpls.top_lse;\par
 1405     \}\par
 1406 \par
 1407     if ((swkey->eth.type == htons(ETH_P_IP) ||\par
 1408          swkey->eth.type == htons(ETH_P_IPV6)) &&\par
 1409          swkey->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
 1410 \par
 1411         if (swkey->ip.proto == IPPROTO_TCP) \{\par
 1412             struct ovs_key_tcp *tcp_key;\par
 1413 \par
 1414             nla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\par
 1415             if (!nla)\par
 1416                 goto nla_put_failure;\par
 1417             tcp_key = nla_data(nla);\par
 1418             tcp_key->tcp_src = output->tp.src;\par
 1419             tcp_key->tcp_dst = output->tp.dst;\par
 1420             if (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\par
 1421                      output->tp.flags))\par
 1422                 goto nla_put_failure;\par
 1423         \} else if (swkey->ip.proto == IPPROTO_UDP) \{\par
 1424             struct ovs_key_udp *udp_key;\par
 1425 \par
 1426             nla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\par
 1427             if (!nla)\par
 1428                 goto nla_put_failure;\par
 1429             udp_key = nla_data(nla);\par
 1430             udp_key->udp_src = output->tp.src;\par
 1431             udp_key->udp_dst = output->tp.dst;\par
 1432         \} else if (swkey->ip.proto == IPPROTO_SCTP) \{\par
 1433             struct ovs_key_sctp *sctp_key;\par
 1434 \par
 1435             nla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\par
 1436             if (!nla)\par
 1437                 goto nla_put_failure;\par
 1438             sctp_key = nla_data(nla);\par
 1439             sctp_key->sctp_src = output->tp.src;\par
 1440             sctp_key->sctp_dst = output->tp.dst;\par
 1441         \} else if (swkey->eth.type == htons(ETH_P_IP) &&\par
 1442                swkey->ip.proto == IPPROTO_ICMP) \{\par
 1443             struct ovs_key_icmp *icmp_key;\par
 1444 \par
 1445             nla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\par
 1446             if (!nla)\par
 1447                 goto nla_put_failure;\par
 1448             icmp_key = nla_data(nla);\par
 1449             icmp_key->icmp_type = ntohs(output->tp.src);\par
 1450             icmp_key->icmp_code = ntohs(output->tp.dst);\par
 1451         \} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\par
 1452                swkey->ip.proto == IPPROTO_ICMPV6) \{\par
 1453             struct ovs_key_icmpv6 *icmpv6_key;\par
 1454 \par
 1455             nla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\par
 1456                         sizeof(*icmpv6_key));\par
 1457             if (!nla)\par
 1458                 goto nla_put_failure;\par
 1459             icmpv6_key = nla_data(nla);\par
 1460             icmpv6_key->icmpv6_type = ntohs(output->tp.src);\par
 1461             icmpv6_key->icmpv6_code = ntohs(output->tp.dst);\par
 1462 \par
 1463             if (icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_SOLICITATION ||\par
 1464                 icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) \{\par
 1465                 struct ovs_key_nd *nd_key;\par
 1466 \par
 1467                 nla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\par
 1468                 if (!nla)\par
 1469                     goto nla_put_failure;\par
 1470                 nd_key = nla_data(nla);\par
 1471                 memcpy(nd_key->nd_target, &output->ipv6.nd.target,\par
 1472                             sizeof(nd_key->nd_target));\par
 1473                 ether_addr_copy(nd_key->nd_sll, output->ipv6.nd.sll);\par
 1474                 ether_addr_copy(nd_key->nd_tll, output->ipv6.nd.tll);\par
 1475             \}\par
 1476         \}\par
 1477     \}\par
 1478 \par
 1479 unencap:\par
 1480     if (encap)\par
 1481         nla_nest_end(skb, encap);\par
 1482 \par
 1483     return 0;\par
 1484 \par
 1485 nla_put_failure:\par
 1486     return -EMSGSIZE;\par
 1487 \}\par
}
}
{\xe \v __parse_flow_nlattrs\:flow_netlink.c}
{\xe \v flow_netlink.c\:__parse_flow_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __parse_flow_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}, {\b bool}  {\i nz}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   361 \{\par
  362     const struct nlattr *nla;\par
  363     u64 attrs;\par
  364     int rem;\par
  365 \par
  366     attrs = *attrsp;\par
  367     nla_for_each_nested(nla, attr, rem) \{\par
  368         u16 type = nla_type(nla);\par
  369         int expected_len;\par
  370 \par
  371         if (type > OVS_KEY_ATTR_MAX) \{\par
  372             OVS_NLERR(log, "Key type %d is out of range max %d",\par
  373                   type, OVS_KEY_ATTR_MAX);\par
  374             return -EINVAL;\par
  375         \}\par
  376 \par
  377         if (attrs & (1ULL << type)) \{\par
  378             OVS_NLERR(log, "Duplicate key (type %d).", type);\par
  379             return -EINVAL;\par
  380         \}\par
  381 \par
  382         expected_len = ovs_key_lens[type].len;\par
  383         if (nla_len(nla) != expected_len && expected_len != OVS_ATTR_NESTED) \{\par
  384             OVS_NLERR(log, "Key %d has unexpected len %d expected %d",\par
  385                   type, nla_len(nla), expected_len);\par
  386             return -EINVAL;\par
  387         \}\par
  388 \par
  389         if (!nz || !is_all_zero(nla_data(nla), expected_len)) \{\par
  390             attrs |= 1ULL << type;\par
  391             a[type] = nla;\par
  392         \}\par
  393     \}\par
  394     if (rem) \{\par
  395         OVS_NLERR(log, "Message has %d unknown bytes.", rem);\par
  396         return -EINVAL;\par
  397     \}\par
  398 \par
  399     *attrsp = attrs;\par
  400     return 0;\par
  401 \}\par
}
}
{\xe \v add_action\:flow_netlink.c}
{\xe \v flow_netlink.c\:add_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int add_action (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, void *  {\i data}, int  {\i len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1623 \{\par
 1624     struct nlattr *a;\par
 1625 \par
 1626     a = __add_action(sfa, attrtype, data, len, log);\par
 1627     if (IS_ERR(a))\par
 1628         return PTR_ERR(a);\par
 1629 \par
 1630     return 0;\par
 1631 \}\par
}
}
{\xe \v add_nested_action_end\:flow_netlink.c}
{\xe \v flow_netlink.c\:add_nested_action_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_nested_action_end (struct {\b sw_flow_actions} *  {\i sfa}, int  {\i st_offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1648 \{\par
 1649     struct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\par
 1650                                    st_offset);\par
 1651 \par
 1652     a->nla_len = sfa->actions_len - st_offset;\par
 1653 \}\par
}
}
{\xe \v add_nested_action_start\:flow_netlink.c}
{\xe \v flow_netlink.c\:add_nested_action_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int add_nested_action_start (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, {\b bool}  {\i log}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1635 \{\par
 1636     int used = (*sfa)->actions_len;\par
 1637     int err;\par
 1638 \par
 1639     err = add_action(sfa, attrtype, NULL, 0, log);\par
 1640     if (err)\par
 1641         return err;\par
 1642 \par
 1643     return used;\par
 1644 \}\par
}
}
{\xe \v copy_action\:flow_netlink.c}
{\xe \v flow_netlink.c\:copy_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int copy_action (const struct nlattr *  {\i from}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2011 \{\par
 2012     int totlen = NLA_ALIGN(from->nla_len);\par
 2013     struct nlattr *to;\par
 2014 \par
 2015     to = reserve_sfa_size(sfa, from->nla_len, log);\par
 2016     if (IS_ERR(to))\par
 2017         return PTR_ERR(to);\par
 2018 \par
 2019     memcpy(to, from, totlen);\par
 2020     return 0;\par
 2021 \}\par
}
}
{\xe \v genev_tun_opt_from_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:genev_tun_opt_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genev_tun_opt_from_nlattr (const struct nlattr *  {\i a}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   420 \{\par
  421     unsigned long opt_key_offset;\par
  422 \par
  423     if (nla_len(a) > sizeof(match->key->tun_opts)) \{\par
  424         OVS_NLERR(log, "Geneve option length err (len %d, max %zu).",\par
  425               nla_len(a), sizeof(match->key->tun_opts));\par
  426         return -EINVAL;\par
  427     \}\par
  428 \par
  429     if (nla_len(a) % 4 != 0) \{\par
  430         OVS_NLERR(log, "Geneve opt len %d is not a multiple of 4.",\par
  431               nla_len(a));\par
  432         return -EINVAL;\par
  433     \}\par
  434 \par
  435     /* We need to record the length of the options passed\par
  436      * down, otherwise packets with the same format but\par
  437      * additional options will be silently matched.\par
  438      */\par
  439     if (!is_mask) \{\par
  440         SW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),\par
  441                 false);\par
  442     \} else \{\par
  443         /* This is somewhat unusual because it looks at\par
  444          * both the key and mask while parsing the\par
  445          * attributes (and by extension assumes the key\par
  446          * is parsed first). Normally, we would verify\par
  447          * that each is the correct length and that the\par
  448          * attributes line up in the validate function.\par
  449          * However, that is difficult because this is\par
  450          * variable length and we won't have the\par
  451          * information later.\par
  452          */\par
  453         if (match->key->tun_opts_len != nla_len(a)) \{\par
  454             OVS_NLERR(log, "Geneve option len %d != mask len %d",\par
  455                   match->key->tun_opts_len, nla_len(a));\par
  456             return -EINVAL;\par
  457         \}\par
  458 \par
  459         SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\par
  460     \}\par
  461 \par
  462     opt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\par
  463     SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\par
  464                   nla_len(a), is_mask);\par
  465     return 0;\par
  466 \}\par
}
}
{\xe \v get_ufid_len\:flow_netlink.c}
{\xe \v flow_netlink.c\:get_ufid_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t get_ufid_len (const struct nlattr *  {\i attr}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1185 \{\par
 1186     size_t len;\par
 1187 \par
 1188     if (!attr)\par
 1189         return 0;\par
 1190 \par
 1191     len = nla_len(attr);\par
 1192     if (len < 1 || len > MAX_UFID_LENGTH) \{\par
 1193         OVS_NLERR(log, "ufid size %u bytes exceeds the range (1, %d)",\par
 1194               nla_len(attr), MAX_UFID_LENGTH);\par
 1195         return 0;\par
 1196     \}\par
 1197 \par
 1198     return len;\par
 1199 \}\par
}
}
{\xe \v ipv4_tun_from_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:ipv4_tun_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ipv4_tun_from_nlattr (const struct nlattr *  {\i attr}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506 \{\par
  507     struct nlattr *a;\par
  508     int rem;\par
  509     bool ttl = false;\par
  510     __be16 tun_flags = 0;\par
  511     int opts_type = 0;\par
  512 \par
  513     nla_for_each_nested(a, attr, rem) \{\par
  514         int type = nla_type(a);\par
  515         int err;\par
  516 \par
  517         if (type > OVS_TUNNEL_KEY_ATTR_MAX) \{\par
  518             OVS_NLERR(log, "Tunnel attr %d out of range max %d",\par
  519                   type, OVS_TUNNEL_KEY_ATTR_MAX);\par
  520             return -EINVAL;\par
  521         \}\par
  522 \par
  523         if (ovs_tunnel_key_lens[type].len != nla_len(a) &&\par
  524            ovs_tunnel_key_lens[type].len != OVS_ATTR_NESTED) \{\par
  525             OVS_NLERR(log, "Tunnel attr %d has unexpected len %d expected %d",\par
  526                   type, nla_len(a), ovs_tunnel_key_lens[type].len);\par
  527             return -EINVAL;\par
  528         \}\par
  529 \par
  530         switch (type) \{\par
  531         case OVS_TUNNEL_KEY_ATTR_ID:\par
  532             SW_FLOW_KEY_PUT(match, tun_key.tun_id,\par
  533                     nla_get_be64(a), is_mask);\par
  534             tun_flags |= TUNNEL_KEY;\par
  535             break;\par
  536         case OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\par
  537             SW_FLOW_KEY_PUT(match, tun_key.ipv4_src,\par
  538                     nla_get_be32(a), is_mask);\par
  539             break;\par
  540         case OVS_TUNNEL_KEY_ATTR_IPV4_DST:\par
  541             SW_FLOW_KEY_PUT(match, tun_key.ipv4_dst,\par
  542                     nla_get_be32(a), is_mask);\par
  543             break;\par
  544         case OVS_TUNNEL_KEY_ATTR_TOS:\par
  545             SW_FLOW_KEY_PUT(match, tun_key.ipv4_tos,\par
  546                     nla_get_u8(a), is_mask);\par
  547             break;\par
  548         case OVS_TUNNEL_KEY_ATTR_TTL:\par
  549             SW_FLOW_KEY_PUT(match, tun_key.ipv4_ttl,\par
  550                     nla_get_u8(a), is_mask);\par
  551             ttl = true;\par
  552             break;\par
  553         case OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\par
  554             tun_flags |= TUNNEL_DONT_FRAGMENT;\par
  555             break;\par
  556         case OVS_TUNNEL_KEY_ATTR_CSUM:\par
  557             tun_flags |= TUNNEL_CSUM;\par
  558             break;\par
  559         case OVS_TUNNEL_KEY_ATTR_TP_SRC:\par
  560             SW_FLOW_KEY_PUT(match, tun_key.tp_src,\par
  561                     nla_get_be16(a), is_mask);\par
  562             break;\par
  563         case OVS_TUNNEL_KEY_ATTR_TP_DST:\par
  564             SW_FLOW_KEY_PUT(match, tun_key.tp_dst,\par
  565                     nla_get_be16(a), is_mask);\par
  566             break;\par
  567         case OVS_TUNNEL_KEY_ATTR_OAM:\par
  568             tun_flags |= TUNNEL_OAM;\par
  569             break;\par
  570         case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\par
  571             if (opts_type) \{\par
  572                 OVS_NLERR(log, "Multiple metadata blocks provided");\par
  573                 return -EINVAL;\par
  574             \}\par
  575 \par
  576             err = genev_tun_opt_from_nlattr(a, match, is_mask, log);\par
  577             if (err)\par
  578                 return err;\par
  579 \par
  580             tun_flags |= TUNNEL_GENEVE_OPT;\par
  581             opts_type = type;\par
  582             break;\par
  583         case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\par
  584             if (opts_type) \{\par
  585                 OVS_NLERR(log, "Multiple metadata blocks provided");\par
  586                 return -EINVAL;\par
  587             \}\par
  588 \par
  589             err = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);\par
  590             if (err)\par
  591                 return err;\par
  592 \par
  593             tun_flags |= TUNNEL_VXLAN_OPT;\par
  594             opts_type = type;\par
  595             break;\par
  596         default:\par
  597             OVS_NLERR(log, "Unknown IPv4 tunnel attribute %d",\par
  598                   type);\par
  599             return -EINVAL;\par
  600         \}\par
  601     \}\par
  602 \par
  603     SW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\par
  604 \par
  605     if (rem > 0) \{\par
  606         OVS_NLERR(log, "IPv4 tunnel attribute has %d unknown bytes.",\par
  607               rem);\par
  608         return -EINVAL;\par
  609     \}\par
  610 \par
  611     if (!is_mask) \{\par
  612         if (!match->key->tun_key.ipv4_dst) \{\par
  613             OVS_NLERR(log, "IPv4 tunnel dst address is zero");\par
  614             return -EINVAL;\par
  615         \}\par
  616 \par
  617         if (!ttl) \{\par
  618             OVS_NLERR(log, "IPv4 tunnel TTL not specified.");\par
  619             return -EINVAL;\par
  620         \}\par
  621     \}\par
  622 \par
  623     return opts_type;\par
  624 \}\par
}
}
{\xe \v ipv4_tun_to_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:ipv4_tun_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ipv4_tun_to_nlattr (struct sk_buff *  {\i skb}, const struct {\b ovs_key_ipv4_tunnel} *  {\i output}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   692 \{\par
  693     struct nlattr *nla;\par
  694     int err;\par
  695 \par
  696     nla = nla_nest_start(skb, OVS_KEY_ATTR_TUNNEL);\par
  697     if (!nla)\par
  698         return -EMSGSIZE;\par
  699 \par
  700     err = __ipv4_tun_to_nlattr(skb, output, tun_opts, swkey_tun_opts_len);\par
  701     if (err)\par
  702         return err;\par
  703 \par
  704     nla_nest_end(skb, nla);\par
  705     return 0;\par
  706 \}\par
}
}
{\xe \v is_all_zero\:flow_netlink.c}
{\xe \v flow_netlink.c\:is_all_zero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_all_zero (const u8 *  {\i fp}, size_t  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   345 \{\par
  346     int i;\par
  347 \par
  348     if (!fp)\par
  349         return false;\par
  350 \par
  351     for (i = 0; i < size; i++)\par
  352         if (fp[i])\par
  353             return false;\par
  354 \par
  355     return true;\par
  356 \}\par
}
}
{\xe \v mask_set_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:mask_set_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_set_nlattr (struct nlattr *  {\i attr}, u8  {\i val}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1022 \{\par
 1023     nlattr_set(attr, val, ovs_key_lens);\par
 1024 \}\par
}
}
{\xe \v masked_set_action_to_set_action_attr\:flow_netlink.c}
{\xe \v flow_netlink.c\:masked_set_action_to_set_action_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int masked_set_action_to_set_action_attr (const struct nlattr *  {\i a}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2268 \{\par
 2269     const struct nlattr *ovs_key = nla_data(a);\par
 2270     size_t key_len = nla_len(ovs_key) / 2;\par
 2271 \par
 2272     /* Revert the conversion we did from a non-masked set action to\par
 2273      * masked set action.\par
 2274      */\par
 2275     if (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a) - key_len, ovs_key))\par
 2276         return -EMSGSIZE;\par
 2277 \par
 2278     return 0;\par
 2279 \}\par
}
}
{\xe \v match_validate\:flow_netlink.c}
{\xe \v flow_netlink.c\:match_validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} match_validate (const struct {\b sw_flow_match} *  {\i match}, u64  {\i key_attrs}, u64  {\i mask_attrs}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   123 \{\par
  124     u64 key_expected = 1ULL << OVS_KEY_ATTR_ETHERNET;\par
  125     u64 mask_allowed = key_attrs;  /* At most allow all key attributes */\par
  126 \par
  127     /* The following mask attributes allowed only if they\par
  128      * pass the validation tests.\par
  129      */\par
  130     mask_allowed &= ~((1ULL << OVS_KEY_ATTR_IPV4)\par
  131             | (1ULL << OVS_KEY_ATTR_IPV6)\par
  132             | (1ULL << OVS_KEY_ATTR_TCP)\par
  133             | (1ULL << OVS_KEY_ATTR_TCP_FLAGS)\par
  134             | (1ULL << OVS_KEY_ATTR_UDP)\par
  135             | (1ULL << OVS_KEY_ATTR_SCTP)\par
  136             | (1ULL << OVS_KEY_ATTR_ICMP)\par
  137             | (1ULL << OVS_KEY_ATTR_ICMPV6)\par
  138             | (1ULL << OVS_KEY_ATTR_ARP)\par
  139             | (1ULL << OVS_KEY_ATTR_ND)\par
  140             | (1ULL << OVS_KEY_ATTR_MPLS));\par
  141 \par
  142     /* Always allowed mask fields. */\par
  143     mask_allowed |= ((1ULL << OVS_KEY_ATTR_TUNNEL)\par
  144                | (1ULL << OVS_KEY_ATTR_IN_PORT)\par
  145                | (1ULL << OVS_KEY_ATTR_ETHERTYPE));\par
  146 \par
  147     /* Check key attributes. */\par
  148     if (match->key->eth.type == htons(ETH_P_ARP)\par
  149             || match->key->eth.type == htons(ETH_P_RARP)) \{\par
  150         key_expected |= 1ULL << OVS_KEY_ATTR_ARP;\par
  151         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  152             mask_allowed |= 1ULL << OVS_KEY_ATTR_ARP;\par
  153     \}\par
  154 \par
  155     if (eth_p_mpls(match->key->eth.type)) \{\par
  156         key_expected |= 1ULL << OVS_KEY_ATTR_MPLS;\par
  157         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  158             mask_allowed |= 1ULL << OVS_KEY_ATTR_MPLS;\par
  159     \}\par
  160 \par
  161     if (match->key->eth.type == htons(ETH_P_IP)) \{\par
  162         key_expected |= 1ULL << OVS_KEY_ATTR_IPV4;\par
  163         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  164             mask_allowed |= 1ULL << OVS_KEY_ATTR_IPV4;\par
  165 \par
  166         if (match->key->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
  167             if (match->key->ip.proto == IPPROTO_UDP) \{\par
  168                 key_expected |= 1ULL << OVS_KEY_ATTR_UDP;\par
  169                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  170                     mask_allowed |= 1ULL << OVS_KEY_ATTR_UDP;\par
  171             \}\par
  172 \par
  173             if (match->key->ip.proto == IPPROTO_SCTP) \{\par
  174                 key_expected |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  175                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  176                     mask_allowed |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  177             \}\par
  178 \par
  179             if (match->key->ip.proto == IPPROTO_TCP) \{\par
  180                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP;\par
  181                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  182                 if (match->mask && (match->mask->key.ip.proto == 0xff)) \{\par
  183                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP;\par
  184                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  185                 \}\par
  186             \}\par
  187 \par
  188             if (match->key->ip.proto == IPPROTO_ICMP) \{\par
  189                 key_expected |= 1ULL << OVS_KEY_ATTR_ICMP;\par
  190                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  191                     mask_allowed |= 1ULL << OVS_KEY_ATTR_ICMP;\par
  192             \}\par
  193         \}\par
  194     \}\par
  195 \par
  196     if (match->key->eth.type == htons(ETH_P_IPV6)) \{\par
  197         key_expected |= 1ULL << OVS_KEY_ATTR_IPV6;\par
  198         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  199             mask_allowed |= 1ULL << OVS_KEY_ATTR_IPV6;\par
  200 \par
  201         if (match->key->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
  202             if (match->key->ip.proto == IPPROTO_UDP) \{\par
  203                 key_expected |= 1ULL << OVS_KEY_ATTR_UDP;\par
  204                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  205                     mask_allowed |= 1ULL << OVS_KEY_ATTR_UDP;\par
  206             \}\par
  207 \par
  208             if (match->key->ip.proto == IPPROTO_SCTP) \{\par
  209                 key_expected |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  210                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  211                     mask_allowed |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  212             \}\par
  213 \par
  214             if (match->key->ip.proto == IPPROTO_TCP) \{\par
  215                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP;\par
  216                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  217                 if (match->mask && (match->mask->key.ip.proto == 0xff)) \{\par
  218                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP;\par
  219                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  220                 \}\par
  221             \}\par
  222 \par
  223             if (match->key->ip.proto == IPPROTO_ICMPV6) \{\par
  224                 key_expected |= 1ULL << OVS_KEY_ATTR_ICMPV6;\par
  225                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  226                     mask_allowed |= 1ULL << OVS_KEY_ATTR_ICMPV6;\par
  227 \par
  228                 if (match->key->tp.src ==\par
  229                         htons(NDISC_NEIGHBOUR_SOLICITATION) ||\par
  230                     match->key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) \{\par
  231                     key_expected |= 1ULL << OVS_KEY_ATTR_ND;\par
  232                     if (match->mask && (match->mask->key.tp.src == htons(0xff)))\par
  233                         mask_allowed |= 1ULL << OVS_KEY_ATTR_ND;\par
  234                 \}\par
  235             \}\par
  236         \}\par
  237     \}\par
  238 \par
  239     if ((key_attrs & key_expected) != key_expected) \{\par
  240         /* Key attributes check failed. */\par
  241         OVS_NLERR(log, "Missing key (keys=%llx, expected=%llx)",\par
  242               (unsigned long long)key_attrs,\par
  243               (unsigned long long)key_expected);\par
  244         return false;\par
  245     \}\par
  246 \par
  247     if ((mask_attrs & mask_allowed) != mask_attrs) \{\par
  248         /* Mask attributes check failed. */\par
  249         OVS_NLERR(log, "Unexpected mask (mask=%llx, allowed=%llx)",\par
  250               (unsigned long long)mask_attrs,\par
  251               (unsigned long long)mask_allowed);\par
  252         return false;\par
  253     \}\par
  254 \par
  255     return true;\par
  256 \}\par
}
}
{\xe \v metadata_from_nlattrs\:flow_netlink.c}
{\xe \v flow_netlink.c\:metadata_from_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int metadata_from_nlattrs (struct {\b sw_flow_match} *  {\i match}, u64 *  {\i attrs}, const struct nlattr **  {\i a}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   719 \{\par
  720     if (*attrs & (1ULL << OVS_KEY_ATTR_DP_HASH)) \{\par
  721         u32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);\par
  722 \par
  723         SW_FLOW_KEY_PUT(match, ovs_flow_hash, hash_val, is_mask);\par
  724         *attrs &= ~(1ULL << OVS_KEY_ATTR_DP_HASH);\par
  725     \}\par
  726 \par
  727     if (*attrs & (1ULL << OVS_KEY_ATTR_RECIRC_ID)) \{\par
  728         u32 recirc_id = nla_get_u32(a[OVS_KEY_ATTR_RECIRC_ID]);\par
  729 \par
  730         SW_FLOW_KEY_PUT(match, recirc_id, recirc_id, is_mask);\par
  731         *attrs &= ~(1ULL << OVS_KEY_ATTR_RECIRC_ID);\par
  732     \}\par
  733 \par
  734     if (*attrs & (1ULL << OVS_KEY_ATTR_PRIORITY)) \{\par
  735         SW_FLOW_KEY_PUT(match, phy.priority,\par
  736               nla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\par
  737         *attrs &= ~(1ULL << OVS_KEY_ATTR_PRIORITY);\par
  738     \}\par
  739 \par
  740     if (*attrs & (1ULL << OVS_KEY_ATTR_IN_PORT)) \{\par
  741         u32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\par
  742 \par
  743         if (is_mask) \{\par
  744             in_port = 0xffffffff; /* Always exact match in_port. */\par
  745         \} else if (in_port >= DP_MAX_PORTS) \{\par
  746             OVS_NLERR(log, "Port %d exceeds max allowable %d",\par
  747                   in_port, DP_MAX_PORTS);\par
  748             return -EINVAL;\par
  749         \}\par
  750 \par
  751         SW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\par
  752         *attrs &= ~(1ULL << OVS_KEY_ATTR_IN_PORT);\par
  753     \} else if (!is_mask) \{\par
  754         SW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\par
  755     \}\par
  756 \par
  757     if (*attrs & (1ULL << OVS_KEY_ATTR_SKB_MARK)) \{\par
  758         uint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\par
  759 \par
  760         SW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\par
  761         *attrs &= ~(1ULL << OVS_KEY_ATTR_SKB_MARK);\par
  762     \}\par
  763     if (*attrs & (1ULL << OVS_KEY_ATTR_TUNNEL)) \{\par
  764         if (ipv4_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\par
  765                      is_mask, log) < 0)\par
  766             return -EINVAL;\par
  767         *attrs &= ~(1ULL << OVS_KEY_ATTR_TUNNEL);\par
  768     \}\par
  769     return 0;\par
  770 \}\par
}
}
{\xe \v nla_alloc_flow_actions\:flow_netlink.c}
{\xe \v flow_netlink.c\:nla_alloc_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_actions}* nla_alloc_flow_actions (int  {\i size}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1535 \{\par
 1536     struct sw_flow_actions *sfa;\par
 1537 \par
 1538     if (size > MAX_ACTIONS_BUFSIZE) \{\par
 1539         OVS_NLERR(log, "Flow action size %u bytes exceeds max", size);\par
 1540         return ERR_PTR(-EINVAL);\par
 1541     \}\par
 1542 \par
 1543     sfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\par
 1544     if (!sfa)\par
 1545         return ERR_PTR(-ENOMEM);\par
 1546 \par
 1547     sfa->actions_len = 0;\par
 1548     return sfa;\par
 1549 \}\par
}
}
{\xe \v nlattr_set\:flow_netlink.c}
{\xe \v flow_netlink.c\:nlattr_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void nlattr_set (struct nlattr *  {\i attr}, u8  {\i val}, const struct {\b ovs_len_tbl} *  {\i tbl}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1008 \{\par
 1009     struct nlattr *nla;\par
 1010     int rem;\par
 1011 \par
 1012     /* The nlattr stream should already have been validated */\par
 1013     nla_for_each_nested(nla, attr, rem) \{\par
 1014         if (tbl && tbl[nla_type(nla)].len == OVS_ATTR_NESTED)\par
 1015             nlattr_set(nla, val, tbl[nla_type(nla)].next);\par
 1016         else\par
 1017             memset(nla_data(nla), val, nla_len(nla));\par
 1018     \}\par
 1019 \}\par
}
}
{\xe \v ovs_key_attr_size\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   280 \{\par
  281     /* Whenever adding new OVS_KEY_ FIELDS, we should consider\par
  282      * updating this function.\par
  283      */\par
  284     BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 22);\par
  285 \par
  286     return    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */\par
  287         + nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */\par
  288           + ovs_tun_key_attr_size()\par
  289         + nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */\par
  290         + nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */\par
  291         + nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */\par
  292         + nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */\par
  293         + nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */\par
  294         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  295         + nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */\par
  296         + nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */\par
  297         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  298         + nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */\par
  299         + nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */\par
  300         + nla_total_size(28); /* OVS_KEY_ATTR_ND */\par
  301 \}\par
}
}
{\xe \v ovs_key_from_nlattrs\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_key_from_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_key_from_nlattrs (struct {\b sw_flow_match} *  {\i match}, u64  {\i attrs}, const struct nlattr **  {\i a}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   775 \{\par
  776     int err;\par
  777 \par
  778     err = metadata_from_nlattrs(match, &attrs, a, is_mask, log);\par
  779     if (err)\par
  780         return err;\par
  781 \par
  782     if (attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) \{\par
  783         const struct ovs_key_ethernet *eth_key;\par
  784 \par
  785         eth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\par
  786         SW_FLOW_KEY_MEMCPY(match, eth.src,\par
  787                 eth_key->eth_src, ETH_ALEN, is_mask);\par
  788         SW_FLOW_KEY_MEMCPY(match, eth.dst,\par
  789                 eth_key->eth_dst, ETH_ALEN, is_mask);\par
  790         attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERNET);\par
  791     \}\par
  792 \par
  793     if (attrs & (1ULL << OVS_KEY_ATTR_VLAN)) \{\par
  794         __be16 tci;\par
  795 \par
  796         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
  797         if (!(tci & htons(VLAN_TAG_PRESENT))) \{\par
  798             if (is_mask)\par
  799                 OVS_NLERR(log, "VLAN TCI mask does not have exact match for VLAN_TAG_PRESENT bit.");\par
  800             else\par
  801                 OVS_NLERR(log, "VLAN TCI does not have VLAN_TAG_PRESENT bit set.");\par
  802 \par
  803             return -EINVAL;\par
  804         \}\par
  805 \par
  806         SW_FLOW_KEY_PUT(match, eth.tci, tci, is_mask);\par
  807         attrs &= ~(1ULL << OVS_KEY_ATTR_VLAN);\par
  808     \}\par
  809 \par
  810     if (attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) \{\par
  811         __be16 eth_type;\par
  812 \par
  813         eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\par
  814         if (is_mask) \{\par
  815             /* Always exact match EtherType. */\par
  816             eth_type = htons(0xffff);\par
  817         \} else if (!eth_proto_is_802_3(eth_type)) \{\par
  818             OVS_NLERR(log, "EtherType %x is less than min %x",\par
  819                   ntohs(eth_type), ETH_P_802_3_MIN);\par
  820             return -EINVAL;\par
  821         \}\par
  822 \par
  823         SW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\par
  824         attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
  825     \} else if (!is_mask) \{\par
  826         SW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\par
  827     \}\par
  828 \par
  829     if (attrs & (1ULL << OVS_KEY_ATTR_IPV4)) \{\par
  830         const struct ovs_key_ipv4 *ipv4_key;\par
  831 \par
  832         ipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\par
  833         if (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) \{\par
  834             OVS_NLERR(log, "IPv4 frag type %d is out of range max %d",\par
  835                   ipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\par
  836             return -EINVAL;\par
  837         \}\par
  838         SW_FLOW_KEY_PUT(match, ip.proto,\par
  839                 ipv4_key->ipv4_proto, is_mask);\par
  840         SW_FLOW_KEY_PUT(match, ip.tos,\par
  841                 ipv4_key->ipv4_tos, is_mask);\par
  842         SW_FLOW_KEY_PUT(match, ip.ttl,\par
  843                 ipv4_key->ipv4_ttl, is_mask);\par
  844         SW_FLOW_KEY_PUT(match, ip.frag,\par
  845                 ipv4_key->ipv4_frag, is_mask);\par
  846         SW_FLOW_KEY_PUT(match, ipv4.addr.src,\par
  847                 ipv4_key->ipv4_src, is_mask);\par
  848         SW_FLOW_KEY_PUT(match, ipv4.addr.dst,\par
  849                 ipv4_key->ipv4_dst, is_mask);\par
  850         attrs &= ~(1ULL << OVS_KEY_ATTR_IPV4);\par
  851     \}\par
  852 \par
  853     if (attrs & (1ULL << OVS_KEY_ATTR_IPV6)) \{\par
  854         const struct ovs_key_ipv6 *ipv6_key;\par
  855 \par
  856         ipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\par
  857         if (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) \{\par
  858             OVS_NLERR(log, "IPv6 frag type %d is out of range max %d",\par
  859                   ipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\par
  860             return -EINVAL;\par
  861         \}\par
  862 \par
  863         if (!is_mask && ipv6_key->ipv6_label & htonl(0xFFF00000)) \{\par
  864             OVS_NLERR(log,\par
  865                   "Invalid IPv6 flow label value (value=%x, max=%x).",\par
  866                   ntohl(ipv6_key->ipv6_label), (1 << 20) - 1);\par
  867             return -EINVAL;\par
  868         \}\par
  869 \par
  870         SW_FLOW_KEY_PUT(match, ipv6.label,\par
  871                 ipv6_key->ipv6_label, is_mask);\par
  872         SW_FLOW_KEY_PUT(match, ip.proto,\par
  873                 ipv6_key->ipv6_proto, is_mask);\par
  874         SW_FLOW_KEY_PUT(match, ip.tos,\par
  875                 ipv6_key->ipv6_tclass, is_mask);\par
  876         SW_FLOW_KEY_PUT(match, ip.ttl,\par
  877                 ipv6_key->ipv6_hlimit, is_mask);\par
  878         SW_FLOW_KEY_PUT(match, ip.frag,\par
  879                 ipv6_key->ipv6_frag, is_mask);\par
  880         SW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\par
  881                 ipv6_key->ipv6_src,\par
  882                 sizeof(match->key->ipv6.addr.src),\par
  883                 is_mask);\par
  884         SW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\par
  885                 ipv6_key->ipv6_dst,\par
  886                 sizeof(match->key->ipv6.addr.dst),\par
  887                 is_mask);\par
  888 \par
  889         attrs &= ~(1ULL << OVS_KEY_ATTR_IPV6);\par
  890     \}\par
  891 \par
  892     if (attrs & (1ULL << OVS_KEY_ATTR_ARP)) \{\par
  893         const struct ovs_key_arp *arp_key;\par
  894 \par
  895         arp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\par
  896         if (!is_mask && (arp_key->arp_op & htons(0xff00))) \{\par
  897             OVS_NLERR(log, "Unknown ARP opcode (opcode=%d).",\par
  898                   arp_key->arp_op);\par
  899             return -EINVAL;\par
  900         \}\par
  901 \par
  902         SW_FLOW_KEY_PUT(match, ipv4.addr.src,\par
  903                 arp_key->arp_sip, is_mask);\par
  904         SW_FLOW_KEY_PUT(match, ipv4.addr.dst,\par
  905             arp_key->arp_tip, is_mask);\par
  906         SW_FLOW_KEY_PUT(match, ip.proto,\par
  907                 ntohs(arp_key->arp_op), is_mask);\par
  908         SW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\par
  909                 arp_key->arp_sha, ETH_ALEN, is_mask);\par
  910         SW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\par
  911                 arp_key->arp_tha, ETH_ALEN, is_mask);\par
  912 \par
  913         attrs &= ~(1ULL << OVS_KEY_ATTR_ARP);\par
  914     \}\par
  915 \par
  916     if (attrs & (1ULL << OVS_KEY_ATTR_MPLS)) \{\par
  917         const struct ovs_key_mpls *mpls_key;\par
  918 \par
  919         mpls_key = nla_data(a[OVS_KEY_ATTR_MPLS]);\par
  920         SW_FLOW_KEY_PUT(match, mpls.top_lse,\par
  921                 mpls_key->mpls_lse, is_mask);\par
  922 \par
  923         attrs &= ~(1ULL << OVS_KEY_ATTR_MPLS);\par
  924     \}\par
  925 \par
  926     if (attrs & (1ULL << OVS_KEY_ATTR_TCP)) \{\par
  927         const struct ovs_key_tcp *tcp_key;\par
  928 \par
  929         tcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\par
  930         SW_FLOW_KEY_PUT(match, tp.src, tcp_key->tcp_src, is_mask);\par
  931         SW_FLOW_KEY_PUT(match, tp.dst, tcp_key->tcp_dst, is_mask);\par
  932         attrs &= ~(1ULL << OVS_KEY_ATTR_TCP);\par
  933     \}\par
  934 \par
  935     if (attrs & (1ULL << OVS_KEY_ATTR_TCP_FLAGS)) \{\par
  936         SW_FLOW_KEY_PUT(match, tp.flags,\par
  937                 nla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\par
  938                 is_mask);\par
  939         attrs &= ~(1ULL << OVS_KEY_ATTR_TCP_FLAGS);\par
  940     \}\par
  941 \par
  942     if (attrs & (1ULL << OVS_KEY_ATTR_UDP)) \{\par
  943         const struct ovs_key_udp *udp_key;\par
  944 \par
  945         udp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\par
  946         SW_FLOW_KEY_PUT(match, tp.src, udp_key->udp_src, is_mask);\par
  947         SW_FLOW_KEY_PUT(match, tp.dst, udp_key->udp_dst, is_mask);\par
  948         attrs &= ~(1ULL << OVS_KEY_ATTR_UDP);\par
  949     \}\par
  950 \par
  951     if (attrs & (1ULL << OVS_KEY_ATTR_SCTP)) \{\par
  952         const struct ovs_key_sctp *sctp_key;\par
  953 \par
  954         sctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\par
  955         SW_FLOW_KEY_PUT(match, tp.src, sctp_key->sctp_src, is_mask);\par
  956         SW_FLOW_KEY_PUT(match, tp.dst, sctp_key->sctp_dst, is_mask);\par
  957         attrs &= ~(1ULL << OVS_KEY_ATTR_SCTP);\par
  958     \}\par
  959 \par
  960     if (attrs & (1ULL << OVS_KEY_ATTR_ICMP)) \{\par
  961         const struct ovs_key_icmp *icmp_key;\par
  962 \par
  963         icmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\par
  964         SW_FLOW_KEY_PUT(match, tp.src,\par
  965                 htons(icmp_key->icmp_type), is_mask);\par
  966         SW_FLOW_KEY_PUT(match, tp.dst,\par
  967                 htons(icmp_key->icmp_code), is_mask);\par
  968         attrs &= ~(1ULL << OVS_KEY_ATTR_ICMP);\par
  969     \}\par
  970 \par
  971     if (attrs & (1ULL << OVS_KEY_ATTR_ICMPV6)) \{\par
  972         const struct ovs_key_icmpv6 *icmpv6_key;\par
  973 \par
  974         icmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\par
  975         SW_FLOW_KEY_PUT(match, tp.src,\par
  976                 htons(icmpv6_key->icmpv6_type), is_mask);\par
  977         SW_FLOW_KEY_PUT(match, tp.dst,\par
  978                 htons(icmpv6_key->icmpv6_code), is_mask);\par
  979         attrs &= ~(1ULL << OVS_KEY_ATTR_ICMPV6);\par
  980     \}\par
  981 \par
  982     if (attrs & (1ULL << OVS_KEY_ATTR_ND)) \{\par
  983         const struct ovs_key_nd *nd_key;\par
  984 \par
  985         nd_key = nla_data(a[OVS_KEY_ATTR_ND]);\par
  986         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\par
  987             nd_key->nd_target,\par
  988             sizeof(match->key->ipv6.nd.target),\par
  989             is_mask);\par
  990         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\par
  991             nd_key->nd_sll, ETH_ALEN, is_mask);\par
  992         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\par
  993                 nd_key->nd_tll, ETH_ALEN, is_mask);\par
  994         attrs &= ~(1ULL << OVS_KEY_ATTR_ND);\par
  995     \}\par
  996 \par
  997     if (attrs != 0) \{\par
  998         OVS_NLERR(log, "Unknown key attributes %llx",\par
  999               (unsigned long long)attrs);\par
 1000         return -EINVAL;\par
 1001     \}\par
 1002 \par
 1003     return 0;\par
 1004 \}\par
}
}
{\xe \v ovs_match_init\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_match_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_match_init (struct {\b sw_flow_match} *  {\i match}, struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1714 \{\par
 1715     memset(match, 0, sizeof(*match));\par
 1716     match->key = key;\par
 1717     match->mask = mask;\par
 1718 \par
 1719     memset(key, 0, sizeof(*key));\par
 1720 \par
 1721     if (mask) \{\par
 1722         memset(&mask->key, 0, sizeof(mask->key));\par
 1723         mask->range.start = mask->range.end = 0;\par
 1724     \}\par
 1725 \}\par
}
}
{\xe \v ovs_nla_copy_actions\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_copy_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_copy_actions (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2182 \{\par
 2183     int err;\par
 2184 \par
 2185     *sfa = nla_alloc_flow_actions(nla_len(attr), log);\par
 2186     if (IS_ERR(*sfa))\par
 2187         return PTR_ERR(*sfa);\par
 2188 \par
 2189     err = __ovs_nla_copy_actions(attr, key, 0, sfa, key->eth.type,\par
 2190                      key->eth.tci, log);\par
 2191     if (err)\par
 2192         kfree(*sfa);\par
 2193 \par
 2194     return err;\par
 2195 \}\par
}
}
{\xe \v ovs_nla_free_flow_actions\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_free_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_nla_free_flow_actions (struct {\b sw_flow_actions} *  {\i sf_acts})}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1563 \{\par
 1564     call_rcu(&sf_acts->rcu, rcu_free_acts_callback);\par
 1565 \}\par
}
}
{\xe \v ovs_nla_get_flow_metadata\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_get_flow_metadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_flow_metadata (const struct nlattr *  {\i attr}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key. : Receives extracted in_port, priority, tun_key and skb_mark. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging.\par
This parses a series of Netlink attributes that form a flow key, which must take the same form accepted by flow_from_nlattrs(), but only enough of it to get the metadata, that is, the parts of the flow key that cannot be extracted from the packet itself. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1255 \{\par
 1256     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1257     struct sw_flow_match match;\par
 1258     u64 attrs = 0;\par
 1259     int err;\par
 1260 \par
 1261     err = parse_flow_nlattrs(attr, a, &attrs, log);\par
 1262     if (err)\par
 1263         return -EINVAL;\par
 1264 \par
 1265     memset(&match, 0, sizeof(match));\par
 1266     match.key = key;\par
 1267 \par
 1268     memset(key, 0, OVS_SW_FLOW_KEY_METADATA_SIZE);\par
 1269     key->phy.in_port = DP_MAX_PORTS;\par
 1270 \par
 1271     return metadata_from_nlattrs(&match, &attrs, a, false, log);\par
 1272 \}\par
}
}
{\xe \v ovs_nla_get_identifier\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_get_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_identifier (struct {\b sw_flow_id} *  {\i sfid}, const struct nlattr *  {\i ufid}, const struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1216 \{\par
 1217     struct sw_flow_key *new_key;\par
 1218 \par
 1219     if (ovs_nla_get_ufid(sfid, ufid, log))\par
 1220         return 0;\par
 1221 \par
 1222     /* If UFID was not provided, use unmasked key. */\par
 1223     new_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\par
 1224     if (!new_key)\par
 1225         return -ENOMEM;\par
 1226     memcpy(new_key, key, sizeof(*key));\par
 1227     sfid->unmasked_key = new_key;\par
 1228 \par
 1229     return 0;\par
 1230 \}\par
}
}
{\xe \v ovs_nla_get_match\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_get_match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_match (struct {\b sw_flow_match} *  {\i match}, const struct nlattr *  {\i nla_key}, const struct nlattr *  {\i nla_mask}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_match - parses Netlink attributes into a flow key and mask. In case the 'mask' is NULL, the flow is treated as exact match flow. Otherwise, it is treated as a wildcarded flow, except the mask does not include any don't care bit. : receives the extracted flow match information. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. The fields should of the packet that triggered the creation of this flow. : Optional. Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute specifies the mask field of the wildcarded flow. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1045 \{\par
 1046     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1047     const struct nlattr *encap;\par
 1048     struct nlattr *newmask = NULL;\par
 1049     u64 key_attrs = 0;\par
 1050     u64 mask_attrs = 0;\par
 1051     bool encap_valid = false;\par
 1052     int err;\par
 1053 \par
 1054     err = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\par
 1055     if (err)\par
 1056         return err;\par
 1057 \par
 1058     if ((key_attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&\par
 1059         (key_attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) &&\par
 1060         (nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) \{\par
 1061         __be16 tci;\par
 1062 \par
 1063         if (!((key_attrs & (1ULL << OVS_KEY_ATTR_VLAN)) &&\par
 1064               (key_attrs & (1ULL << OVS_KEY_ATTR_ENCAP)))) \{\par
 1065             OVS_NLERR(log, "Invalid Vlan frame.");\par
 1066             return -EINVAL;\par
 1067         \}\par
 1068 \par
 1069         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1070         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1071         encap = a[OVS_KEY_ATTR_ENCAP];\par
 1072         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1073         encap_valid = true;\par
 1074 \par
 1075         if (tci & htons(VLAN_TAG_PRESENT)) \{\par
 1076             err = parse_flow_nlattrs(encap, a, &key_attrs, log);\par
 1077             if (err)\par
 1078                 return err;\par
 1079         \} else if (!tci) \{\par
 1080             /* Corner case for truncated 802.1Q header. */\par
 1081             if (nla_len(encap)) \{\par
 1082                 OVS_NLERR(log, "Truncated 802.1Q header has non-zero encap attribute.");\par
 1083                 return -EINVAL;\par
 1084             \}\par
 1085         \} else \{\par
 1086             OVS_NLERR(log, "Encap attr is set for non-VLAN frame");\par
 1087             return  -EINVAL;\par
 1088         \}\par
 1089     \}\par
 1090 \par
 1091     err = ovs_key_from_nlattrs(match, key_attrs, a, false, log);\par
 1092     if (err)\par
 1093         return err;\par
 1094 \par
 1095     if (match->mask) \{\par
 1096         if (!nla_mask) \{\par
 1097             /* Create an exact match mask. We need to set to 0xff\par
 1098              * all the 'match->mask' fields that have been touched\par
 1099              * in 'match->key'. We cannot simply memset\par
 1100              * 'match->mask', because padding bytes and fields not\par
 1101              * specified in 'match->key' should be left to 0.\par
 1102              * Instead, we use a stream of netlink attributes,\par
 1103              * copied from 'key' and set to 0xff.\par
 1104              * ovs_key_from_nlattrs() will take care of filling\par
 1105              * 'match->mask' appropriately.\par
 1106              */\par
 1107             newmask = kmemdup(nla_key,\par
 1108                       nla_total_size(nla_len(nla_key)),\par
 1109                       GFP_KERNEL);\par
 1110             if (!newmask)\par
 1111                 return -ENOMEM;\par
 1112 \par
 1113             mask_set_nlattr(newmask, 0xff);\par
 1114 \par
 1115             /* The userspace does not send tunnel attributes that\par
 1116              * are 0, but we should not wildcard them nonetheless.\par
 1117              */\par
 1118             if (match->key->tun_key.ipv4_dst)\par
 1119                 SW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\par
 1120                              0xff, true);\par
 1121 \par
 1122             nla_mask = newmask;\par
 1123         \}\par
 1124 \par
 1125         err = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\par
 1126         if (err)\par
 1127             goto free_newmask;\par
 1128 \par
 1129         /* Always match on tci. */\par
 1130         SW_FLOW_KEY_PUT(match, eth.tci, htons(0xffff), true);\par
 1131 \par
 1132         if (mask_attrs & 1ULL << OVS_KEY_ATTR_ENCAP) \{\par
 1133             __be16 eth_type = 0;\par
 1134             __be16 tci = 0;\par
 1135 \par
 1136             if (!encap_valid) \{\par
 1137                 OVS_NLERR(log, "Encap mask attribute is set for non-VLAN frame.");\par
 1138                 err = -EINVAL;\par
 1139                 goto free_newmask;\par
 1140             \}\par
 1141 \par
 1142             mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1143             if (a[OVS_KEY_ATTR_ETHERTYPE])\par
 1144                 eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\par
 1145 \par
 1146             if (eth_type == htons(0xffff)) \{\par
 1147                 mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1148                 encap = a[OVS_KEY_ATTR_ENCAP];\par
 1149                 err = parse_flow_mask_nlattrs(encap, a,\par
 1150                                   &mask_attrs, log);\par
 1151                 if (err)\par
 1152                     goto free_newmask;\par
 1153             \} else \{\par
 1154                 OVS_NLERR(log, "VLAN frames must have an exact match on the TPID (mask=%x).",\par
 1155                       ntohs(eth_type));\par
 1156                 err = -EINVAL;\par
 1157                 goto free_newmask;\par
 1158             \}\par
 1159 \par
 1160             if (a[OVS_KEY_ATTR_VLAN])\par
 1161                 tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1162 \par
 1163             if (!(tci & htons(VLAN_TAG_PRESENT))) \{\par
 1164                 OVS_NLERR(log, "VLAN tag present bit must have an exact match (tci_mask=%x).",\par
 1165                       ntohs(tci));\par
 1166                 err = -EINVAL;\par
 1167                 goto free_newmask;\par
 1168             \}\par
 1169         \}\par
 1170 \par
 1171         err = ovs_key_from_nlattrs(match, mask_attrs, a, true, log);\par
 1172         if (err)\par
 1173             goto free_newmask;\par
 1174     \}\par
 1175 \par
 1176     if (!match_validate(match, key_attrs, mask_attrs, log))\par
 1177         err = -EINVAL;\par
 1178 \par
 1179 free_newmask:\par
 1180     kfree(newmask);\par
 1181     return err;\par
 1182 \}\par
}
}
{\xe \v ovs_nla_get_ufid\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_get_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_nla_get_ufid (struct {\b sw_flow_id} *  {\i sfid}, const struct nlattr *  {\i attr}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1206 \{\par
 1207     sfid->ufid_len = get_ufid_len(attr, log);\par
 1208     if (sfid->ufid_len)\par
 1209         memcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\par
 1210 \par
 1211     return sfid->ufid_len;\par
 1212 \}\par
}
}
{\xe \v ovs_nla_get_ufid_flags\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_get_ufid_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_nla_get_ufid_flags (const struct nlattr *  {\i attr})}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1233 \{\par
 1234     return attr ? nla_get_u32(attr) : 0;\par
 1235 \}\par
}
}
{\xe \v ovs_nla_put_actions\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_actions (const struct nlattr *  {\i attr}, int  {\i len}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2282 \{\par
 2283     const struct nlattr *a;\par
 2284     int rem, err;\par
 2285 \par
 2286     nla_for_each_attr(a, attr, len, rem) \{\par
 2287         int type = nla_type(a);\par
 2288 \par
 2289         switch (type) \{\par
 2290         case OVS_ACTION_ATTR_SET:\par
 2291             err = set_action_to_attr(a, skb);\par
 2292             if (err)\par
 2293                 return err;\par
 2294             break;\par
 2295 \par
 2296         case OVS_ACTION_ATTR_SET_TO_MASKED:\par
 2297             err = masked_set_action_to_set_action_attr(a, skb);\par
 2298             if (err)\par
 2299                 return err;\par
 2300             break;\par
 2301 \par
 2302         case OVS_ACTION_ATTR_SAMPLE:\par
 2303             err = sample_action_to_attr(a, skb);\par
 2304             if (err)\par
 2305                 return err;\par
 2306             break;\par
 2307         default:\par
 2308             if (nla_put(skb, type, nla_len(a), nla_data(a)))\par
 2309                 return -EMSGSIZE;\par
 2310             break;\par
 2311         \}\par
 2312     \}\par
 2313 \par
 2314     return 0;\par
 2315 \}\par
}
}
{\xe \v ovs_nla_put_egress_tunnel_key\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_egress_tunnel_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_egress_tunnel_key (struct sk_buff *  {\i skb}, const struct {\b ovs_tunnel_info} *  {\i egress_tun_info})}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{\par
  711     return __ipv4_tun_to_nlattr(skb, &egress_tun_info->tunnel,\par
  712                     egress_tun_info->options,\par
  713                     egress_tun_info->options_len);\par
  714 \}\par
}
}
{\xe \v ovs_nla_put_identifier\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_identifier (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1509 \{\par
 1510     if (ovs_identifier_is_ufid(&flow->id))\par
 1511         return nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\par
 1512                    flow->id.ufid);\par
 1513 \par
 1514     return ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\par
 1515                    OVS_FLOW_ATTR_KEY, false, skb);\par
 1516 \}\par
}
}
{\xe \v ovs_nla_put_key\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_key (const struct {\b sw_flow_key} *  {\i swkey}, const struct {\b sw_flow_key} *  {\i output}, int  {\i attr}, {\b bool}  {\i is_mask}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1492 \{\par
 1493     int err;\par
 1494     struct nlattr *nla;\par
 1495 \par
 1496     nla = nla_nest_start(skb, attr);\par
 1497     if (!nla)\par
 1498         return -EMSGSIZE;\par
 1499     err = __ovs_nla_put_key(swkey, output, is_mask, skb);\par
 1500     if (err)\par
 1501         return err;\par
 1502     nla_nest_end(skb, nla);\par
 1503 \par
 1504     return 0;\par
 1505 \}\par
}
}
{\xe \v ovs_nla_put_mask\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_mask (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1527 \{\par
 1528     return ovs_nla_put_key(&flow->key, &flow->mask->key,\par
 1529                 OVS_FLOW_ATTR_MASK, true, skb);\par
 1530 \}\par
}
}
{\xe \v ovs_nla_put_masked_key\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_nla_put_masked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_masked_key (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1520 \{\par
 1521     return ovs_nla_put_key(&flow->key, &flow->key,\par
 1522                 OVS_FLOW_ATTR_KEY, false, skb);\par
 1523 \}\par
}
}
{\xe \v ovs_tun_key_attr_size\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_tun_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_tun_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259 \{\par
  260     /* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider\par
  261      * updating this function.\par
  262      */\par
  263     return    nla_total_size(8)    /* OVS_TUNNEL_KEY_ATTR_ID */\par
  264         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_SRC */\par
  265         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_DST */\par
  266         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */\par
  267         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */\par
  268         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */\par
  269         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */\par
  270         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */\par
  271         + nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */\par
  272         /* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS is mutually exclusive with\par
  273          * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it.\par
  274          */\par
  275         + nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */\par
  276         + nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */\par
  277 \}\par
}
}
{\xe \v parse_flow_mask_nlattrs\:flow_netlink.c}
{\xe \v flow_netlink.c\:parse_flow_mask_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_flow_mask_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   406 \{\par
  407     return __parse_flow_nlattrs(attr, a, attrsp, log, true);\par
  408 \}\par
}
}
{\xe \v parse_flow_nlattrs\:flow_netlink.c}
{\xe \v flow_netlink.c\:parse_flow_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_flow_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   413 \{\par
  414     return __parse_flow_nlattrs(attr, a, attrsp, log, false);\par
  415 \}\par
}
}
{\xe \v rcu_free_acts_callback\:flow_netlink.c}
{\xe \v flow_netlink.c\:rcu_free_acts_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_acts_callback (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1553 \{\par
 1554     struct sw_flow_actions *sf_acts = container_of(rcu,\par
 1555             struct sw_flow_actions, rcu);\par
 1556     kfree(sf_acts);\par
 1557 \}\par
}
}
{\xe \v reserve_sfa_size\:flow_netlink.c}
{\xe \v flow_netlink.c\:reserve_sfa_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct nlattr* reserve_sfa_size (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attr_len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1569 \{\par
 1570 \par
 1571     struct sw_flow_actions *acts;\par
 1572     int new_acts_size;\par
 1573     int req_size = NLA_ALIGN(attr_len);\par
 1574     int next_offset = offsetof(struct sw_flow_actions, actions) +\par
 1575                     (*sfa)->actions_len;\par
 1576 \par
 1577     if (req_size <= (ksize(*sfa) - next_offset))\par
 1578         goto out;\par
 1579 \par
 1580     new_acts_size = ksize(*sfa) * 2;\par
 1581 \par
 1582     if (new_acts_size > MAX_ACTIONS_BUFSIZE) \{\par
 1583         if ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size)\par
 1584             return ERR_PTR(-EMSGSIZE);\par
 1585         new_acts_size = MAX_ACTIONS_BUFSIZE;\par
 1586     \}\par
 1587 \par
 1588     acts = nla_alloc_flow_actions(new_acts_size, log);\par
 1589     if (IS_ERR(acts))\par
 1590         return (void *)acts;\par
 1591 \par
 1592     memcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\par
 1593     acts->actions_len = (*sfa)->actions_len;\par
 1594     kfree(*sfa);\par
 1595     *sfa = acts;\par
 1596 \par
 1597 out:\par
 1598     (*sfa)->actions_len += req_size;\par
 1599     return  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\par
 1600 \}\par
}
}
{\xe \v sample_action_to_attr\:flow_netlink.c}
{\xe \v flow_netlink.c\:sample_action_to_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int sample_action_to_attr (const struct nlattr *  {\i attr}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2198 \{\par
 2199     const struct nlattr *a;\par
 2200     struct nlattr *start;\par
 2201     int err = 0, rem;\par
 2202 \par
 2203     start = nla_nest_start(skb, OVS_ACTION_ATTR_SAMPLE);\par
 2204     if (!start)\par
 2205         return -EMSGSIZE;\par
 2206 \par
 2207     nla_for_each_nested(a, attr, rem) \{\par
 2208         int type = nla_type(a);\par
 2209         struct nlattr *st_sample;\par
 2210 \par
 2211         switch (type) \{\par
 2212         case OVS_SAMPLE_ATTR_PROBABILITY:\par
 2213             if (nla_put(skb, OVS_SAMPLE_ATTR_PROBABILITY,\par
 2214                     sizeof(u32), nla_data(a)))\par
 2215                 return -EMSGSIZE;\par
 2216             break;\par
 2217         case OVS_SAMPLE_ATTR_ACTIONS:\par
 2218             st_sample = nla_nest_start(skb, OVS_SAMPLE_ATTR_ACTIONS);\par
 2219             if (!st_sample)\par
 2220                 return -EMSGSIZE;\par
 2221             err = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\par
 2222             if (err)\par
 2223                 return err;\par
 2224             nla_nest_end(skb, st_sample);\par
 2225             break;\par
 2226         \}\par
 2227     \}\par
 2228 \par
 2229     nla_nest_end(skb, start);\par
 2230     return err;\par
 2231 \}\par
}
}
{\xe \v set_action_to_attr\:flow_netlink.c}
{\xe \v flow_netlink.c\:set_action_to_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_action_to_attr (const struct nlattr *  {\i a}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2234 \{\par
 2235     const struct nlattr *ovs_key = nla_data(a);\par
 2236     int key_type = nla_type(ovs_key);\par
 2237     struct nlattr *start;\par
 2238     int err;\par
 2239 \par
 2240     switch (key_type) \{\par
 2241     case OVS_KEY_ATTR_TUNNEL_INFO: \{\par
 2242         struct ovs_tunnel_info *tun_info = nla_data(ovs_key);\par
 2243 \par
 2244         start = nla_nest_start(skb, OVS_ACTION_ATTR_SET);\par
 2245         if (!start)\par
 2246             return -EMSGSIZE;\par
 2247 \par
 2248         err = ipv4_tun_to_nlattr(skb, &tun_info->tunnel,\par
 2249                      tun_info->options_len ?\par
 2250                         tun_info->options : NULL,\par
 2251                      tun_info->options_len);\par
 2252         if (err)\par
 2253             return err;\par
 2254         nla_nest_end(skb, start);\par
 2255         break;\par
 2256     \}\par
 2257     default:\par
 2258         if (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\par
 2259             return -EMSGSIZE;\par
 2260         break;\par
 2261     \}\par
 2262 \par
 2263     return 0;\par
 2264 \}\par
}
}
{\xe \v update_range\:flow_netlink.c}
{\xe \v flow_netlink.c\:update_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void update_range (struct {\b sw_flow_match} *  {\i match}, size_t  {\i offset}, size_t  {\i size}, {\b bool}  {\i is_mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    63 \{\par
   64     struct sw_flow_key_range *range;\par
   65     size_t start = rounddown(offset, sizeof(long));\par
   66     size_t end = roundup(offset + size, sizeof(long));\par
   67 \par
   68     if (!is_mask)\par
   69         range = &match->range;\par
   70     else\par
   71         range = &match->mask->range;\par
   72 \par
   73     if (range->start == range->end) \{\par
   74         range->start = start;\par
   75         range->end = end;\par
   76         return;\par
   77     \}\par
   78 \par
   79     if (range->start > start)\par
   80         range->start = start;\par
   81 \par
   82     if (range->end < end)\par
   83         range->end = end;\par
   84 \}\par
}
}
{\xe \v validate_and_copy_sample\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_and_copy_sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_and_copy_sample (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, int  {\i depth}, struct {\b sw_flow_actions} **  {\i sfa}, __be16  {\i eth_type}, __be16  {\i vlan_tci}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1664 \{\par
 1665     const struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\par
 1666     const struct nlattr *probability, *actions;\par
 1667     const struct nlattr *a;\par
 1668     int rem, start, err, st_acts;\par
 1669 \par
 1670     memset(attrs, 0, sizeof(attrs));\par
 1671     nla_for_each_nested(a, attr, rem) \{\par
 1672         int type = nla_type(a);\par
 1673         if (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\par
 1674             return -EINVAL;\par
 1675         attrs[type] = a;\par
 1676     \}\par
 1677     if (rem)\par
 1678         return -EINVAL;\par
 1679 \par
 1680     probability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\par
 1681     if (!probability || nla_len(probability) != sizeof(u32))\par
 1682         return -EINVAL;\par
 1683 \par
 1684     actions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\par
 1685     if (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\par
 1686         return -EINVAL;\par
 1687 \par
 1688     /* validation done, copy sample action. */\par
 1689     start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE, log);\par
 1690     if (start < 0)\par
 1691         return start;\par
 1692     err = add_action(sfa, OVS_SAMPLE_ATTR_PROBABILITY,\par
 1693              nla_data(probability), sizeof(u32), log);\par
 1694     if (err)\par
 1695         return err;\par
 1696     st_acts = add_nested_action_start(sfa, OVS_SAMPLE_ATTR_ACTIONS, log);\par
 1697     if (st_acts < 0)\par
 1698         return st_acts;\par
 1699 \par
 1700     err = __ovs_nla_copy_actions(actions, key, depth + 1, sfa,\par
 1701                      eth_type, vlan_tci, log);\par
 1702     if (err)\par
 1703         return err;\par
 1704 \par
 1705     add_nested_action_end(*sfa, st_acts);\par
 1706     add_nested_action_end(*sfa, start);\par
 1707 \par
 1708     return 0;\par
 1709 \}\par
}
}
{\xe \v validate_and_copy_set_tun\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_and_copy_set_tun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_and_copy_set_tun (const struct nlattr *  {\i attr}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1757 \{\par
 1758     struct sw_flow_match match;\par
 1759     struct sw_flow_key key;\par
 1760     struct ovs_tunnel_info *tun_info;\par
 1761     struct nlattr *a;\par
 1762     int start, opts_type;\par
 1763     int err = 0;\par
 1764 \par
 1765     ovs_match_init(&match, &key, NULL);\par
 1766     opts_type = ipv4_tun_from_nlattr(nla_data(attr), &match, false, log);\par
 1767     if (opts_type < 0)\par
 1768         return opts_type;\par
 1769 \par
 1770     if (key.tun_opts_len) \{\par
 1771         switch (opts_type) \{\par
 1772         case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\par
 1773             err = validate_geneve_opts(&key);\par
 1774             if (err < 0)\par
 1775                 return err;\par
 1776             break;\par
 1777         case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\par
 1778             break;\par
 1779         \}\par
 1780     \};\par
 1781 \par
 1782     start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);\par
 1783     if (start < 0)\par
 1784         return start;\par
 1785 \par
 1786     a = __add_action(sfa, OVS_KEY_ATTR_TUNNEL_INFO, NULL,\par
 1787              sizeof(*tun_info) + key.tun_opts_len, log);\par
 1788     if (IS_ERR(a))\par
 1789         return PTR_ERR(a);\par
 1790 \par
 1791     tun_info = nla_data(a);\par
 1792     tun_info->tunnel = key.tun_key;\par
 1793     tun_info->options_len = key.tun_opts_len;\par
 1794 \par
 1795     if (tun_info->options_len) \{\par
 1796         /* We need to store the options in the action itself since\par
 1797          * everything else will go away after flow setup. We can append\par
 1798          * it to tun_info and then point there.\par
 1799          */\par
 1800         memcpy((tun_info + 1),\par
 1801                TUN_METADATA_OPTS(&key, key.tun_opts_len), key.tun_opts_len);\par
 1802         tun_info->options = (tun_info + 1);\par
 1803     \} else \{\par
 1804         tun_info->options = NULL;\par
 1805     \}\par
 1806 \par
 1807     add_nested_action_end(*sfa, start);\par
 1808 \par
 1809     return err;\par
 1810 \}\par
}
}
{\xe \v validate_geneve_opts\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_geneve_opts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_geneve_opts (struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1728 \{\par
 1729     struct geneve_opt *option;\par
 1730     int opts_len = key->tun_opts_len;\par
 1731     bool crit_opt = false;\par
 1732 \par
 1733     option = (struct geneve_opt *)TUN_METADATA_OPTS(key, key->tun_opts_len);\par
 1734     while (opts_len > 0) \{\par
 1735         int len;\par
 1736 \par
 1737         if (opts_len < sizeof(*option))\par
 1738             return -EINVAL;\par
 1739 \par
 1740         len = sizeof(*option) + option->length * 4;\par
 1741         if (len > opts_len)\par
 1742             return -EINVAL;\par
 1743 \par
 1744         crit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);\par
 1745 \par
 1746         option = (struct geneve_opt *)((u8 *)option + len);\par
 1747         opts_len -= len;\par
 1748     \};\par
 1749 \par
 1750     key->tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;\par
 1751 \par
 1752     return 0;\par
 1753 \}\par
}
}
{\xe \v validate_masked\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_masked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} validate_masked (u8 *  {\i data}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1816 \{\par
 1817     u8 *mask = data + len;\par
 1818 \par
 1819     while (len--)\par
 1820         if (*data++ & ~*mask++)\par
 1821             return false;\par
 1822 \par
 1823     return true;\par
 1824 \}\par
}
}
{\xe \v validate_set\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_set (const struct nlattr *  {\i a}, const struct {\b sw_flow_key} *  {\i flow_key}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool} *  {\i skip_copy}, __be16  {\i eth_type}, {\b bool}  {\i masked}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1830 \{\par
 1831     const struct nlattr *ovs_key = nla_data(a);\par
 1832     int key_type = nla_type(ovs_key);\par
 1833     size_t key_len;\par
 1834 \par
 1835     /* There can be only one key in a action */\par
 1836     if (nla_total_size(nla_len(ovs_key)) != nla_len(a))\par
 1837         return -EINVAL;\par
 1838 \par
 1839     key_len = nla_len(ovs_key);\par
 1840     if (masked)\par
 1841         key_len /= 2;\par
 1842 \par
 1843     if (key_type > OVS_KEY_ATTR_MAX ||\par
 1844         (ovs_key_lens[key_type].len != key_len &&\par
 1845          ovs_key_lens[key_type].len != OVS_ATTR_NESTED))\par
 1846         return -EINVAL;\par
 1847 \par
 1848     if (masked && !validate_masked(nla_data(ovs_key), key_len))\par
 1849         return -EINVAL;\par
 1850 \par
 1851     switch (key_type) \{\par
 1852     const struct ovs_key_ipv4 *ipv4_key;\par
 1853     const struct ovs_key_ipv6 *ipv6_key;\par
 1854     int err;\par
 1855 \par
 1856     case OVS_KEY_ATTR_PRIORITY:\par
 1857     case OVS_KEY_ATTR_SKB_MARK:\par
 1858     case OVS_KEY_ATTR_ETHERNET:\par
 1859         break;\par
 1860 \par
 1861     case OVS_KEY_ATTR_TUNNEL:\par
 1862         if (eth_p_mpls(eth_type))\par
 1863             return -EINVAL;\par
 1864 \par
 1865         if (masked)\par
 1866             return -EINVAL; /* Masked tunnel set not supported. */\par
 1867 \par
 1868         *skip_copy = true;\par
 1869         err = validate_and_copy_set_tun(a, sfa, log);\par
 1870         if (err)\par
 1871             return err;\par
 1872         break;\par
 1873 \par
 1874     case OVS_KEY_ATTR_IPV4:\par
 1875         if (eth_type != htons(ETH_P_IP))\par
 1876             return -EINVAL;\par
 1877 \par
 1878         ipv4_key = nla_data(ovs_key);\par
 1879 \par
 1880         if (masked) \{\par
 1881             const struct ovs_key_ipv4 *mask = ipv4_key + 1;\par
 1882 \par
 1883             /* Non-writeable fields. */\par
 1884             if (mask->ipv4_proto || mask->ipv4_frag)\par
 1885                 return -EINVAL;\par
 1886         \} else \{\par
 1887             if (ipv4_key->ipv4_proto != flow_key->ip.proto)\par
 1888                 return -EINVAL;\par
 1889 \par
 1890             if (ipv4_key->ipv4_frag != flow_key->ip.frag)\par
 1891                 return -EINVAL;\par
 1892         \}\par
 1893         break;\par
 1894 \par
 1895     case OVS_KEY_ATTR_IPV6:\par
 1896         if (eth_type != htons(ETH_P_IPV6))\par
 1897             return -EINVAL;\par
 1898 \par
 1899         ipv6_key = nla_data(ovs_key);\par
 1900 \par
 1901         if (masked) \{\par
 1902             const struct ovs_key_ipv6 *mask = ipv6_key + 1;\par
 1903 \par
 1904             /* Non-writeable fields. */\par
 1905             if (mask->ipv6_proto || mask->ipv6_frag)\par
 1906                 return -EINVAL;\par
 1907 \par
 1908             /* Invalid bits in the flow label mask? */\par
 1909             if (ntohl(mask->ipv6_label) & 0xFFF00000)\par
 1910                 return -EINVAL;\par
 1911         \} else \{\par
 1912             if (ipv6_key->ipv6_proto != flow_key->ip.proto)\par
 1913                 return -EINVAL;\par
 1914 \par
 1915             if (ipv6_key->ipv6_frag != flow_key->ip.frag)\par
 1916                 return -EINVAL;\par
 1917         \}\par
 1918         if (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\par
 1919             return -EINVAL;\par
 1920 \par
 1921         break;\par
 1922 \par
 1923     case OVS_KEY_ATTR_TCP:\par
 1924         if ((eth_type != htons(ETH_P_IP) &&\par
 1925              eth_type != htons(ETH_P_IPV6)) ||\par
 1926             flow_key->ip.proto != IPPROTO_TCP)\par
 1927             return -EINVAL;\par
 1928 \par
 1929         break;\par
 1930 \par
 1931     case OVS_KEY_ATTR_UDP:\par
 1932         if ((eth_type != htons(ETH_P_IP) &&\par
 1933              eth_type != htons(ETH_P_IPV6)) ||\par
 1934             flow_key->ip.proto != IPPROTO_UDP)\par
 1935             return -EINVAL;\par
 1936 \par
 1937         break;\par
 1938 \par
 1939     case OVS_KEY_ATTR_MPLS:\par
 1940         if (!eth_p_mpls(eth_type))\par
 1941             return -EINVAL;\par
 1942         break;\par
 1943 \par
 1944     case OVS_KEY_ATTR_SCTP:\par
 1945         if ((eth_type != htons(ETH_P_IP) &&\par
 1946              eth_type != htons(ETH_P_IPV6)) ||\par
 1947             flow_key->ip.proto != IPPROTO_SCTP)\par
 1948             return -EINVAL;\par
 1949 \par
 1950         break;\par
 1951 \par
 1952     default:\par
 1953         return -EINVAL;\par
 1954     \}\par
 1955 \par
 1956     /* Convert non-masked non-tunnel set actions to masked set actions. */\par
 1957     if (!masked && key_type != OVS_KEY_ATTR_TUNNEL) \{\par
 1958         int start, len = key_len * 2;\par
 1959         struct nlattr *at;\par
 1960 \par
 1961         *skip_copy = true;\par
 1962 \par
 1963         start = add_nested_action_start(sfa,\par
 1964                         OVS_ACTION_ATTR_SET_TO_MASKED,\par
 1965                         log);\par
 1966         if (start < 0)\par
 1967             return start;\par
 1968 \par
 1969         at = __add_action(sfa, key_type, NULL, len, log);\par
 1970         if (IS_ERR(at))\par
 1971             return PTR_ERR(at);\par
 1972 \par
 1973         memcpy(nla_data(at), nla_data(ovs_key), key_len); /* Key. */\par
 1974         memset(nla_data(at) + key_len, 0xff, key_len);    /* Mask. */\par
 1975         /* Clear non-writeable bits from otherwise writeable fields. */\par
 1976         if (key_type == OVS_KEY_ATTR_IPV6) \{\par
 1977             struct ovs_key_ipv6 *mask = nla_data(at) + key_len;\par
 1978 \par
 1979             mask->ipv6_label &= htonl(0x000FFFFF);\par
 1980         \}\par
 1981         add_nested_action_end(*sfa, start);\par
 1982     \}\par
 1983 \par
 1984     return 0;\par
 1985 \}\par
}
}
{\xe \v validate_userspace\:flow_netlink.c}
{\xe \v flow_netlink.c\:validate_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_userspace (const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1988 \{\par
 1989     static const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = \{\par
 1990         [OVS_USERSPACE_ATTR_PID] = \{.type = NLA_U32 \},\par
 1991         [OVS_USERSPACE_ATTR_USERDATA] = \{.type = NLA_UNSPEC \},\par
 1992         [OVS_USERSPACE_ATTR_EGRESS_TUN_PORT] = \{.type = NLA_U32 \},\par
 1993     \};\par
 1994     struct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\par
 1995     int error;\par
 1996 \par
 1997     error = nla_parse_nested(a, OVS_USERSPACE_ATTR_MAX,\par
 1998                  attr, userspace_policy);\par
 1999     if (error)\par
 2000         return error;\par
 2001 \par
 2002     if (!a[OVS_USERSPACE_ATTR_PID] ||\par
 2003         !nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\par
 2004         return -EINVAL;\par
 2005 \par
 2006     return 0;\par
 2007 \}\par
}
}
{\xe \v vxlan_opt_to_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:vxlan_opt_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_opt_to_nlattr (struct sk_buff *  {\i skb}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628 \{\par
  629     const struct ovs_vxlan_opts *opts = tun_opts;\par
  630     struct nlattr *nla;\par
  631 \par
  632     nla = nla_nest_start(skb, OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS);\par
  633     if (!nla)\par
  634         return -EMSGSIZE;\par
  635 \par
  636     if (nla_put_u32(skb, OVS_VXLAN_EXT_GBP, opts->gbp) < 0)\par
  637         return -EMSGSIZE;\par
  638 \par
  639     nla_nest_end(skb, nla);\par
  640     return 0;\par
  641 \}\par
}
}
{\xe \v vxlan_tun_opt_from_nlattr\:flow_netlink.c}
{\xe \v flow_netlink.c\:vxlan_tun_opt_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_tun_opt_from_nlattr (const struct nlattr *  {\i a}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   475 \{\par
  476     struct nlattr *tb[OVS_VXLAN_EXT_MAX+1];\par
  477     unsigned long opt_key_offset;\par
  478     struct ovs_vxlan_opts opts;\par
  479     int err;\par
  480 \par
  481     BUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));\par
  482 \par
  483     err = nla_parse_nested(tb, OVS_VXLAN_EXT_MAX, a, vxlan_opt_policy);\par
  484     if (err < 0)\par
  485         return err;\par
  486 \par
  487     memset(&opts, 0, sizeof(opts));\par
  488 \par
  489     if (tb[OVS_VXLAN_EXT_GBP])\par
  490         opts.gbp = nla_get_u32(tb[OVS_VXLAN_EXT_GBP]);\par
  491 \par
  492     if (!is_mask)\par
  493         SW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);\par
  494     else\par
  495         SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\par
  496 \par
  497     opt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));\par
  498     SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),\par
  499                   is_mask);\par
  500     return 0;\par
  501 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_key_lens\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_key_lens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_len_tbl} ovs_key_lens[{\b OVS_KEY_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_KEY_ATTR_ENCAP]     = \{ .len = OVS_ATTR_NESTED \},\par
    [OVS_KEY_ATTR_PRIORITY]  = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_IN_PORT]   = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_SKB_MARK]  = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_ETHERNET]  = \{ .len = sizeof(struct ovs_key_ethernet) \},\par
    [OVS_KEY_ATTR_VLAN]  = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_ETHERTYPE] = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_IPV4]  = \{ .len = sizeof(struct ovs_key_ipv4) \},\par
    [OVS_KEY_ATTR_IPV6]  = \{ .len = sizeof(struct ovs_key_ipv6) \},\par
    [OVS_KEY_ATTR_TCP]   = \{ .len = sizeof(struct ovs_key_tcp) \},\par
    [OVS_KEY_ATTR_TCP_FLAGS] = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_UDP]   = \{ .len = sizeof(struct ovs_key_udp) \},\par
    [OVS_KEY_ATTR_SCTP]  = \{ .len = sizeof(struct ovs_key_sctp) \},\par
    [OVS_KEY_ATTR_ICMP]  = \{ .len = sizeof(struct ovs_key_icmp) \},\par
    [OVS_KEY_ATTR_ICMPV6]    = \{ .len = sizeof(struct ovs_key_icmpv6) \},\par
    [OVS_KEY_ATTR_ARP]   = \{ .len = sizeof(struct ovs_key_arp) \},\par
    [OVS_KEY_ATTR_ND]    = \{ .len = sizeof(struct ovs_key_nd) \},\par
    [OVS_KEY_ATTR_RECIRC_ID] = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_DP_HASH]   = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_TUNNEL]    = \{ .len = OVS_ATTR_NESTED,\par
                     .next = ovs_tunnel_key_lens, \},\par
    [OVS_KEY_ATTR_MPLS]  = \{ .len = sizeof(struct ovs_key_mpls) \},\par
\}\par
}
}
{\xe \v ovs_tunnel_key_lens\:flow_netlink.c}
{\xe \v flow_netlink.c\:ovs_tunnel_key_lens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_len_tbl} ovs_tunnel_key_lens[{\b OVS_TUNNEL_KEY_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_TUNNEL_KEY_ATTR_ID]        = \{ .len = sizeof(u64) \},\par
    [OVS_TUNNEL_KEY_ATTR_IPV4_SRC]      = \{ .len = sizeof(u32) \},\par
    [OVS_TUNNEL_KEY_ATTR_IPV4_DST]      = \{ .len = sizeof(u32) \},\par
    [OVS_TUNNEL_KEY_ATTR_TOS]       = \{ .len = 1 \},\par
    [OVS_TUNNEL_KEY_ATTR_TTL]       = \{ .len = 1 \},\par
    [OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_CSUM]      = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_TP_SRC]        = \{ .len = sizeof(u16) \},\par
    [OVS_TUNNEL_KEY_ATTR_TP_DST]        = \{ .len = sizeof(u16) \},\par
    [OVS_TUNNEL_KEY_ATTR_OAM]       = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = \{ .len = OVS_ATTR_NESTED \},\par
    [OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = \{ .len = OVS_ATTR_NESTED \},\par
\}\par
}
}
{\xe \v vxlan_opt_policy\:flow_netlink.c}
{\xe \v flow_netlink.c\:vxlan_opt_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy vxlan_opt_policy[{\b OVS_VXLAN_EXT_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VXLAN_EXT_GBP] = \{ .type = NLA_U32 \},\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/flow_netlink.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/flow_netlink.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/flow_netlink.c}
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/geneve.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "flow.h"}\par
{\f2 #include "flow_netlink.h"}\par
{\f2 #include "vport-vxlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_netlink.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2flow__netlink_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_len_tbl}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_ATTR_NESTED}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_PUT}(match,  field,  value,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMCPY_OFFSET}(match,  offset,  value_p,  len,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMCPY}(match,  field,  value_p,  len,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SW_FLOW_KEY_MEMSET_FIELD}(match,  field,  value,  is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_ACTIONS_BUFSIZE}\~ (32 * 1024)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b update_range} (struct {\b sw_flow_match} *match, size_t offset, size_t size, {\b bool} is_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b match_validate} (const struct {\b sw_flow_match} *match, u64 key_attrs, u64 mask_attrs, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_tun_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b is_all_zero} (const u8 *fp, size_t size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __parse_flow_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log, {\b bool} nz)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_flow_mask_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b parse_flow_nlattrs} (const struct nlattr *attr, const struct nlattr *a[], u64 *attrsp, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genev_tun_opt_from_nlattr} (const struct nlattr *a, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_tun_opt_from_nlattr} (const struct nlattr *a, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ipv4_tun_from_nlattr} (const struct nlattr *attr, struct {\b sw_flow_match} *match, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_opt_to_nlattr} (struct sk_buff *skb, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ipv4_tun_to_nlattr} (struct sk_buff *skb, const struct {\b ovs_key_ipv4_tunnel} *output, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ipv4_tun_to_nlattr} (struct sk_buff *skb, const struct {\b ovs_key_ipv4_tunnel} *output, const void *{\b tun_opts}, int swkey_tun_opts_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_egress_tunnel_key} (struct sk_buff *skb, const struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b metadata_from_nlattrs} (struct {\b sw_flow_match} *match, u64 *attrs, const struct nlattr **a, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_key_from_nlattrs} (struct {\b sw_flow_match} *match, u64 attrs, const struct nlattr **a, {\b bool} is_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b nlattr_set} (struct nlattr *attr, u8 val, const struct {\b ovs_len_tbl} *tbl)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_set_nlattr} (struct nlattr *attr, u8 val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_match} (struct {\b sw_flow_match} *match, const struct nlattr *nla_key, const struct nlattr *nla_mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static size_t {\b get_ufid_len} (const struct nlattr *attr, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_nla_get_ufid} (struct {\b sw_flow_id} *sfid, const struct nlattr *attr, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_identifier} (struct {\b sw_flow_id} *sfid, const struct nlattr *ufid, const struct {\b sw_flow_key} *key, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_nla_get_ufid_flags} (const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_flow_metadata} (const struct nlattr *attr, struct {\b sw_flow_key} *key, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ovs_nla_put_key} (const struct {\b sw_flow_key} *swkey, const struct {\b sw_flow_key} *output, {\b bool} is_mask, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_key} (const struct {\b sw_flow_key} *swkey, const struct {\b sw_flow_key} *output, int attr, {\b bool} is_mask, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_identifier} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_masked_key} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_mask} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_actions} * {\b nla_alloc_flow_actions} (int size, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_acts_callback} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_nla_free_flow_actions} (struct {\b sw_flow_actions} *sf_acts)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct nlattr * {\b reserve_sfa_size} (struct {\b sw_flow_actions} **sfa, int attr_len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct nlattr * {\b __add_action} (struct {\b sw_flow_actions} **sfa, int attrtype, void *data, int len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b add_action} (struct {\b sw_flow_actions} **sfa, int attrtype, void *data, int len, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b add_nested_action_start} (struct {\b sw_flow_actions} **sfa, int attrtype, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b add_nested_action_end} (struct {\b sw_flow_actions} *sfa, int st_offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __ovs_nla_copy_actions} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, int depth, struct {\b sw_flow_actions} **sfa, __be16 eth_type, __be16 vlan_tci, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_and_copy_sample} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, int depth, struct {\b sw_flow_actions} **sfa, __be16 eth_type, __be16 vlan_tci, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_match_init} (struct {\b sw_flow_match} *match, struct {\b sw_flow_key} *key, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_geneve_opts} (struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_and_copy_set_tun} (const struct nlattr *attr, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b validate_masked} (u8 *data, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_set} (const struct nlattr *a, const struct {\b sw_flow_key} *flow_key, struct {\b sw_flow_actions} **sfa, {\b bool} *skip_copy, __be16 eth_type, {\b bool} masked, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b validate_userspace} (const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b copy_action} (const struct nlattr *from, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_copy_actions} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sample_action_to_attr} (const struct nlattr *attr, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b set_action_to_attr} (const struct nlattr *a, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b masked_set_action_to_set_action_attr} (const struct nlattr *a, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_actions} (const struct nlattr *attr, int len, struct sk_buff *skb)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct {\b ovs_len_tbl} {\b ovs_tunnel_key_lens} [{\b OVS_TUNNEL_KEY_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct {\b ovs_len_tbl} {\b ovs_key_lens} [{\b OVS_KEY_ATTR_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b vxlan_opt_policy} [{\b OVS_VXLAN_EXT_MAX}+1]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_ACTIONS_BUFSIZE\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:MAX_ACTIONS_BUFSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_ACTIONS_BUFSIZE\~ (32 * 1024)}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_ATTR_NESTED\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:OVS_ATTR_NESTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_ATTR_NESTED\~ -1}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SW_FLOW_KEY_MEMCPY\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:SW_FLOW_KEY_MEMCPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMCPY( match,  field,  value_p,  len,  is_mask)}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SW_FLOW_KEY_MEMCPY_OFFSET(match, offsetof(struct sw_flow_key, field), \\\par
                  value_p, len, is_mask)\par
}
}
{\xe \v SW_FLOW_KEY_MEMCPY_OFFSET\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:SW_FLOW_KEY_MEMCPY_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMCPY_OFFSET( match,  offset,  value_p,  len,  is_mask)}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                    \\\par
        update_range(match, offset, len, is_mask);          \\\par
        if (is_mask)                            \\\par
            memcpy((u8 *)&(match)->mask->key + offset, value_p, len);\\\par
        else                                \\\par
            memcpy((u8 *)(match)->key + offset, value_p, len);  \\\par
    \} while (0)\par
}
}
{\xe \v SW_FLOW_KEY_MEMSET_FIELD\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:SW_FLOW_KEY_MEMSET_FIELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_MEMSET_FIELD( match,  field,  value,  is_mask)}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                    \\\par
        update_range(match, offsetof(struct sw_flow_key, field),    \\\par
                 sizeof((match)->key->field), is_mask);     \\\par
        if (is_mask)                            \\\par
            memset((u8 *)&(match)->mask->key.field, value,      \\\par
                   sizeof((match)->mask->key.field));       \\\par
        else                                \\\par
            memset((u8 *)&(match)->key->field, value,           \\\par
                   sizeof((match)->key->field));                \\\par
    \} while (0)\par
}
}
{\xe \v SW_FLOW_KEY_PUT\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:SW_FLOW_KEY_PUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SW_FLOW_KEY_PUT( match,  field,  value,  is_mask)}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{ \\\par
        update_range(match, offsetof(struct sw_flow_key, field),    \\\par
                 sizeof((match)->key->field), is_mask);     \\\par
        if (is_mask)                            \\\par
            (match)->mask->key.field = value;           \\\par
        else                                \\\par
            (match)->key->field = value;                    \\\par
    \} while (0)\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __add_action\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:__add_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct nlattr* __add_action (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, void *  {\i data}, int  {\i len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1604 \{\par
 1605     struct nlattr *a;\par
 1606 \par
 1607     a = reserve_sfa_size(sfa, nla_attr_size(len), log);\par
 1608     if (IS_ERR(a))\par
 1609         return a;\par
 1610 \par
 1611     a->nla_type = attrtype;\par
 1612     a->nla_len = nla_attr_size(len);\par
 1613 \par
 1614     if (data)\par
 1615         memcpy(nla_data(a), data, len);\par
 1616     memset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\par
 1617 \par
 1618     return a;\par
 1619 \}\par
}
}
{\xe \v __ipv4_tun_to_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:__ipv4_tun_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ipv4_tun_to_nlattr (struct sk_buff *  {\i skb}, const struct {\b ovs_key_ipv4_tunnel} *  {\i output}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   646 \{\par
  647     if (output->tun_flags & TUNNEL_KEY &&\par
  648         nla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id))\par
  649         return -EMSGSIZE;\par
  650     if (output->ipv4_src &&\par
  651         nla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC, output->ipv4_src))\par
  652         return -EMSGSIZE;\par
  653     if (output->ipv4_dst &&\par
  654         nla_put_be32(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST, output->ipv4_dst))\par
  655         return -EMSGSIZE;\par
  656     if (output->ipv4_tos &&\par
  657         nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->ipv4_tos))\par
  658         return -EMSGSIZE;\par
  659     if (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ipv4_ttl))\par
  660         return -EMSGSIZE;\par
  661     if ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\par
  662         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\par
  663         return -EMSGSIZE;\par
  664     if ((output->tun_flags & TUNNEL_CSUM) &&\par
  665         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\par
  666         return -EMSGSIZE;\par
  667     if (output->tp_src &&\par
  668         nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_SRC, output->tp_src))\par
  669         return -EMSGSIZE;\par
  670     if (output->tp_dst &&\par
  671         nla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_DST, output->tp_dst))\par
  672         return -EMSGSIZE;\par
  673     if ((output->tun_flags & TUNNEL_OAM) &&\par
  674         nla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_OAM))\par
  675         return -EMSGSIZE;\par
  676     if (tun_opts) \{\par
  677         if (output->tun_flags & TUNNEL_GENEVE_OPT &&\par
  678             nla_put(skb, OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,\par
  679                 swkey_tun_opts_len, tun_opts))\par
  680             return -EMSGSIZE;\par
  681                else if (output->tun_flags & TUNNEL_VXLAN_OPT &&\par
  682             vxlan_opt_to_nlattr(skb, tun_opts, swkey_tun_opts_len))\par
  683             return -EMSGSIZE;\par
  684     \}\par
  685 \par
  686     return 0;\par
  687 \}\par
}
}
{\xe \v __ovs_nla_copy_actions\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:__ovs_nla_copy_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ovs_nla_copy_actions (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, int  {\i depth}, struct {\b sw_flow_actions} **  {\i sfa}, __be16  {\i eth_type}, __be16  {\i vlan_tci}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2027 \{\par
 2028     const struct nlattr *a;\par
 2029     int rem, err;\par
 2030 \par
 2031     if (depth >= SAMPLE_ACTION_DEPTH)\par
 2032         return -EOVERFLOW;\par
 2033 \par
 2034     nla_for_each_nested(a, attr, rem) \{\par
 2035         /* Expected argument lengths, (u32)-1 for variable length. */\par
 2036         static const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = \{\par
 2037             [OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\par
 2038             [OVS_ACTION_ATTR_RECIRC] = sizeof(u32),\par
 2039             [OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\par
 2040             [OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),\par
 2041             [OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),\par
 2042             [OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\par
 2043             [OVS_ACTION_ATTR_POP_VLAN] = 0,\par
 2044             [OVS_ACTION_ATTR_SET] = (u32)-1,\par
 2045             [OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,\par
 2046             [OVS_ACTION_ATTR_SAMPLE] = (u32)-1,\par
 2047             [OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash)\par
 2048         \};\par
 2049         const struct ovs_action_push_vlan *vlan;\par
 2050         int type = nla_type(a);\par
 2051         bool skip_copy;\par
 2052 \par
 2053         if (type > OVS_ACTION_ATTR_MAX ||\par
 2054             (action_lens[type] != nla_len(a) &&\par
 2055              action_lens[type] != (u32)-1))\par
 2056             return -EINVAL;\par
 2057 \par
 2058         skip_copy = false;\par
 2059         switch (type) \{\par
 2060         case OVS_ACTION_ATTR_UNSPEC:\par
 2061             return -EINVAL;\par
 2062 \par
 2063         case OVS_ACTION_ATTR_USERSPACE:\par
 2064             err = validate_userspace(a);\par
 2065             if (err)\par
 2066                 return err;\par
 2067             break;\par
 2068 \par
 2069         case OVS_ACTION_ATTR_OUTPUT:\par
 2070             if (nla_get_u32(a) >= DP_MAX_PORTS)\par
 2071                 return -EINVAL;\par
 2072             break;\par
 2073 \par
 2074         case OVS_ACTION_ATTR_HASH: \{\par
 2075             const struct ovs_action_hash *act_hash = nla_data(a);\par
 2076 \par
 2077             switch (act_hash->hash_alg) \{\par
 2078             case OVS_HASH_ALG_L4:\par
 2079                 break;\par
 2080             default:\par
 2081                 return  -EINVAL;\par
 2082             \}\par
 2083 \par
 2084             break;\par
 2085         \}\par
 2086 \par
 2087         case OVS_ACTION_ATTR_POP_VLAN:\par
 2088             vlan_tci = htons(0);\par
 2089             break;\par
 2090 \par
 2091         case OVS_ACTION_ATTR_PUSH_VLAN:\par
 2092             vlan = nla_data(a);\par
 2093             if (vlan->vlan_tpid != htons(ETH_P_8021Q))\par
 2094                 return -EINVAL;\par
 2095             if (!(vlan->vlan_tci & htons(VLAN_TAG_PRESENT)))\par
 2096                 return -EINVAL;\par
 2097             vlan_tci = vlan->vlan_tci;\par
 2098             break;\par
 2099 \par
 2100         case OVS_ACTION_ATTR_RECIRC:\par
 2101             break;\par
 2102 \par
 2103         case OVS_ACTION_ATTR_PUSH_MPLS: \{\par
 2104             const struct ovs_action_push_mpls *mpls = nla_data(a);\par
 2105 \par
 2106             if (!eth_p_mpls(mpls->mpls_ethertype))\par
 2107                 return -EINVAL;\par
 2108             /* Prohibit push MPLS other than to a white list\par
 2109              * for packets that have a known tag order.\par
 2110              */\par
 2111             if (vlan_tci & htons(VLAN_TAG_PRESENT) ||\par
 2112                 (eth_type != htons(ETH_P_IP) &&\par
 2113                  eth_type != htons(ETH_P_IPV6) &&\par
 2114                  eth_type != htons(ETH_P_ARP) &&\par
 2115                  eth_type != htons(ETH_P_RARP) &&\par
 2116                  !eth_p_mpls(eth_type)))\par
 2117                 return -EINVAL;\par
 2118             eth_type = mpls->mpls_ethertype;\par
 2119             break;\par
 2120         \}\par
 2121 \par
 2122         case OVS_ACTION_ATTR_POP_MPLS:\par
 2123             if (vlan_tci & htons(VLAN_TAG_PRESENT) ||\par
 2124                 !eth_p_mpls(eth_type))\par
 2125                 return -EINVAL;\par
 2126 \par
 2127             /* Disallow subsequent L2.5+ set and mpls_pop actions\par
 2128              * as there is no check here to ensure that the new\par
 2129              * eth_type is valid and thus set actions could\par
 2130              * write off the end of the packet or otherwise\par
 2131              * corrupt it.\par
 2132              *\par
 2133              * Support for these actions is planned using packet\par
 2134              * recirculation.\par
 2135              */\par
 2136             eth_type = htons(0);\par
 2137             break;\par
 2138 \par
 2139         case OVS_ACTION_ATTR_SET:\par
 2140             err = validate_set(a, key, sfa,\par
 2141                        &skip_copy, eth_type, false, log);\par
 2142             if (err)\par
 2143                 return err;\par
 2144             break;\par
 2145 \par
 2146         case OVS_ACTION_ATTR_SET_MASKED:\par
 2147             err = validate_set(a, key, sfa,\par
 2148                        &skip_copy, eth_type, true, log);\par
 2149             if (err)\par
 2150                 return err;\par
 2151             break;\par
 2152 \par
 2153         case OVS_ACTION_ATTR_SAMPLE:\par
 2154             err = validate_and_copy_sample(a, key, depth, sfa,\par
 2155                                eth_type, vlan_tci, log);\par
 2156             if (err)\par
 2157                 return err;\par
 2158             skip_copy = true;\par
 2159             break;\par
 2160 \par
 2161         default:\par
 2162             OVS_NLERR(log, "Unknown Action type %d", type);\par
 2163             return -EINVAL;\par
 2164         \}\par
 2165         if (!skip_copy) \{\par
 2166             err = copy_action(a, sfa, log);\par
 2167             if (err)\par
 2168                 return err;\par
 2169         \}\par
 2170     \}\par
 2171 \par
 2172     if (rem > 0)\par
 2173         return -EINVAL;\par
 2174 \par
 2175     return 0;\par
 2176 \}\par
}
}
{\xe \v __ovs_nla_put_key\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:__ovs_nla_put_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __ovs_nla_put_key (const struct {\b sw_flow_key} *  {\i swkey}, const struct {\b sw_flow_key} *  {\i output}, {\b bool}  {\i is_mask}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1277 \{\par
 1278     struct ovs_key_ethernet *eth_key;\par
 1279     struct nlattr *nla, *encap;\par
 1280 \par
 1281     if (nla_put_u32(skb, OVS_KEY_ATTR_RECIRC_ID, output->recirc_id))\par
 1282         goto nla_put_failure;\par
 1283 \par
 1284     if (nla_put_u32(skb, OVS_KEY_ATTR_DP_HASH, output->ovs_flow_hash))\par
 1285         goto nla_put_failure;\par
 1286 \par
 1287     if (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\par
 1288         goto nla_put_failure;\par
 1289 \par
 1290     if ((swkey->tun_key.ipv4_dst || is_mask)) \{\par
 1291         const void *opts = NULL;\par
 1292 \par
 1293         if (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)\par
 1294             opts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);\par
 1295 \par
 1296         if (ipv4_tun_to_nlattr(skb, &output->tun_key, opts,\par
 1297                        swkey->tun_opts_len))\par
 1298             goto nla_put_failure;\par
 1299     \}\par
 1300 \par
 1301     if (swkey->phy.in_port == DP_MAX_PORTS) \{\par
 1302         if (is_mask && (output->phy.in_port == 0xffff))\par
 1303             if (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\par
 1304                 goto nla_put_failure;\par
 1305     \} else \{\par
 1306         u16 upper_u16;\par
 1307         upper_u16 = !is_mask ? 0 : 0xffff;\par
 1308 \par
 1309         if (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\par
 1310                 (upper_u16 << 16) | output->phy.in_port))\par
 1311             goto nla_put_failure;\par
 1312     \}\par
 1313 \par
 1314     if (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\par
 1315         goto nla_put_failure;\par
 1316 \par
 1317     nla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\par
 1318     if (!nla)\par
 1319         goto nla_put_failure;\par
 1320 \par
 1321     eth_key = nla_data(nla);\par
 1322     ether_addr_copy(eth_key->eth_src, output->eth.src);\par
 1323     ether_addr_copy(eth_key->eth_dst, output->eth.dst);\par
 1324 \par
 1325     if (swkey->eth.tci || swkey->eth.type == htons(ETH_P_8021Q)) \{\par
 1326         __be16 eth_type;\par
 1327         eth_type = !is_mask ? htons(ETH_P_8021Q) : htons(0xffff);\par
 1328         if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\par
 1329             nla_put_be16(skb, OVS_KEY_ATTR_VLAN, output->eth.tci))\par
 1330             goto nla_put_failure;\par
 1331         encap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);\par
 1332         if (!swkey->eth.tci)\par
 1333             goto unencap;\par
 1334     \} else\par
 1335         encap = NULL;\par
 1336 \par
 1337     if (swkey->eth.type == htons(ETH_P_802_2)) \{\par
 1338         /*\par
 1339          * Ethertype 802.2 is represented in the netlink with omitted\par
 1340          * OVS_KEY_ATTR_ETHERTYPE in the flow key attribute, and\par
 1341          * 0xffff in the mask attribute.  Ethertype can also\par
 1342          * be wildcarded.\par
 1343          */\par
 1344         if (is_mask && output->eth.type)\par
 1345             if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\par
 1346                         output->eth.type))\par
 1347                 goto nla_put_failure;\par
 1348         goto unencap;\par
 1349     \}\par
 1350 \par
 1351     if (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\par
 1352         goto nla_put_failure;\par
 1353 \par
 1354     if (swkey->eth.type == htons(ETH_P_IP)) \{\par
 1355         struct ovs_key_ipv4 *ipv4_key;\par
 1356 \par
 1357         nla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\par
 1358         if (!nla)\par
 1359             goto nla_put_failure;\par
 1360         ipv4_key = nla_data(nla);\par
 1361         ipv4_key->ipv4_src = output->ipv4.addr.src;\par
 1362         ipv4_key->ipv4_dst = output->ipv4.addr.dst;\par
 1363         ipv4_key->ipv4_proto = output->ip.proto;\par
 1364         ipv4_key->ipv4_tos = output->ip.tos;\par
 1365         ipv4_key->ipv4_ttl = output->ip.ttl;\par
 1366         ipv4_key->ipv4_frag = output->ip.frag;\par
 1367     \} else if (swkey->eth.type == htons(ETH_P_IPV6)) \{\par
 1368         struct ovs_key_ipv6 *ipv6_key;\par
 1369 \par
 1370         nla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\par
 1371         if (!nla)\par
 1372             goto nla_put_failure;\par
 1373         ipv6_key = nla_data(nla);\par
 1374         memcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\par
 1375                 sizeof(ipv6_key->ipv6_src));\par
 1376         memcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\par
 1377                 sizeof(ipv6_key->ipv6_dst));\par
 1378         ipv6_key->ipv6_label = output->ipv6.label;\par
 1379         ipv6_key->ipv6_proto = output->ip.proto;\par
 1380         ipv6_key->ipv6_tclass = output->ip.tos;\par
 1381         ipv6_key->ipv6_hlimit = output->ip.ttl;\par
 1382         ipv6_key->ipv6_frag = output->ip.frag;\par
 1383     \} else if (swkey->eth.type == htons(ETH_P_ARP) ||\par
 1384            swkey->eth.type == htons(ETH_P_RARP)) \{\par
 1385         struct ovs_key_arp *arp_key;\par
 1386 \par
 1387         nla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\par
 1388         if (!nla)\par
 1389             goto nla_put_failure;\par
 1390         arp_key = nla_data(nla);\par
 1391         memset(arp_key, 0, sizeof(struct ovs_key_arp));\par
 1392         arp_key->arp_sip = output->ipv4.addr.src;\par
 1393         arp_key->arp_tip = output->ipv4.addr.dst;\par
 1394         arp_key->arp_op = htons(output->ip.proto);\par
 1395         ether_addr_copy(arp_key->arp_sha, output->ipv4.arp.sha);\par
 1396         ether_addr_copy(arp_key->arp_tha, output->ipv4.arp.tha);\par
 1397     \} else if (eth_p_mpls(swkey->eth.type)) \{\par
 1398         struct ovs_key_mpls *mpls_key;\par
 1399 \par
 1400         nla = nla_reserve(skb, OVS_KEY_ATTR_MPLS, sizeof(*mpls_key));\par
 1401         if (!nla)\par
 1402             goto nla_put_failure;\par
 1403         mpls_key = nla_data(nla);\par
 1404         mpls_key->mpls_lse = output->mpls.top_lse;\par
 1405     \}\par
 1406 \par
 1407     if ((swkey->eth.type == htons(ETH_P_IP) ||\par
 1408          swkey->eth.type == htons(ETH_P_IPV6)) &&\par
 1409          swkey->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
 1410 \par
 1411         if (swkey->ip.proto == IPPROTO_TCP) \{\par
 1412             struct ovs_key_tcp *tcp_key;\par
 1413 \par
 1414             nla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\par
 1415             if (!nla)\par
 1416                 goto nla_put_failure;\par
 1417             tcp_key = nla_data(nla);\par
 1418             tcp_key->tcp_src = output->tp.src;\par
 1419             tcp_key->tcp_dst = output->tp.dst;\par
 1420             if (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\par
 1421                      output->tp.flags))\par
 1422                 goto nla_put_failure;\par
 1423         \} else if (swkey->ip.proto == IPPROTO_UDP) \{\par
 1424             struct ovs_key_udp *udp_key;\par
 1425 \par
 1426             nla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\par
 1427             if (!nla)\par
 1428                 goto nla_put_failure;\par
 1429             udp_key = nla_data(nla);\par
 1430             udp_key->udp_src = output->tp.src;\par
 1431             udp_key->udp_dst = output->tp.dst;\par
 1432         \} else if (swkey->ip.proto == IPPROTO_SCTP) \{\par
 1433             struct ovs_key_sctp *sctp_key;\par
 1434 \par
 1435             nla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\par
 1436             if (!nla)\par
 1437                 goto nla_put_failure;\par
 1438             sctp_key = nla_data(nla);\par
 1439             sctp_key->sctp_src = output->tp.src;\par
 1440             sctp_key->sctp_dst = output->tp.dst;\par
 1441         \} else if (swkey->eth.type == htons(ETH_P_IP) &&\par
 1442                swkey->ip.proto == IPPROTO_ICMP) \{\par
 1443             struct ovs_key_icmp *icmp_key;\par
 1444 \par
 1445             nla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\par
 1446             if (!nla)\par
 1447                 goto nla_put_failure;\par
 1448             icmp_key = nla_data(nla);\par
 1449             icmp_key->icmp_type = ntohs(output->tp.src);\par
 1450             icmp_key->icmp_code = ntohs(output->tp.dst);\par
 1451         \} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\par
 1452                swkey->ip.proto == IPPROTO_ICMPV6) \{\par
 1453             struct ovs_key_icmpv6 *icmpv6_key;\par
 1454 \par
 1455             nla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\par
 1456                         sizeof(*icmpv6_key));\par
 1457             if (!nla)\par
 1458                 goto nla_put_failure;\par
 1459             icmpv6_key = nla_data(nla);\par
 1460             icmpv6_key->icmpv6_type = ntohs(output->tp.src);\par
 1461             icmpv6_key->icmpv6_code = ntohs(output->tp.dst);\par
 1462 \par
 1463             if (icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_SOLICITATION ||\par
 1464                 icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) \{\par
 1465                 struct ovs_key_nd *nd_key;\par
 1466 \par
 1467                 nla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\par
 1468                 if (!nla)\par
 1469                     goto nla_put_failure;\par
 1470                 nd_key = nla_data(nla);\par
 1471                 memcpy(nd_key->nd_target, &output->ipv6.nd.target,\par
 1472                             sizeof(nd_key->nd_target));\par
 1473                 ether_addr_copy(nd_key->nd_sll, output->ipv6.nd.sll);\par
 1474                 ether_addr_copy(nd_key->nd_tll, output->ipv6.nd.tll);\par
 1475             \}\par
 1476         \}\par
 1477     \}\par
 1478 \par
 1479 unencap:\par
 1480     if (encap)\par
 1481         nla_nest_end(skb, encap);\par
 1482 \par
 1483     return 0;\par
 1484 \par
 1485 nla_put_failure:\par
 1486     return -EMSGSIZE;\par
 1487 \}\par
}
}
{\xe \v __parse_flow_nlattrs\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:__parse_flow_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __parse_flow_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}, {\b bool}  {\i nz}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   361 \{\par
  362     const struct nlattr *nla;\par
  363     u64 attrs;\par
  364     int rem;\par
  365 \par
  366     attrs = *attrsp;\par
  367     nla_for_each_nested(nla, attr, rem) \{\par
  368         u16 type = nla_type(nla);\par
  369         int expected_len;\par
  370 \par
  371         if (type > OVS_KEY_ATTR_MAX) \{\par
  372             OVS_NLERR(log, "Key type %d is out of range max %d",\par
  373                   type, OVS_KEY_ATTR_MAX);\par
  374             return -EINVAL;\par
  375         \}\par
  376 \par
  377         if (attrs & (1ULL << type)) \{\par
  378             OVS_NLERR(log, "Duplicate key (type %d).", type);\par
  379             return -EINVAL;\par
  380         \}\par
  381 \par
  382         expected_len = ovs_key_lens[type].len;\par
  383         if (nla_len(nla) != expected_len && expected_len != OVS_ATTR_NESTED) \{\par
  384             OVS_NLERR(log, "Key %d has unexpected len %d expected %d",\par
  385                   type, nla_len(nla), expected_len);\par
  386             return -EINVAL;\par
  387         \}\par
  388 \par
  389         if (!nz || !is_all_zero(nla_data(nla), expected_len)) \{\par
  390             attrs |= 1ULL << type;\par
  391             a[type] = nla;\par
  392         \}\par
  393     \}\par
  394     if (rem) \{\par
  395         OVS_NLERR(log, "Message has %d unknown bytes.", rem);\par
  396         return -EINVAL;\par
  397     \}\par
  398 \par
  399     *attrsp = attrs;\par
  400     return 0;\par
  401 \}\par
}
}
{\xe \v add_action\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:add_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int add_action (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, void *  {\i data}, int  {\i len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1623 \{\par
 1624     struct nlattr *a;\par
 1625 \par
 1626     a = __add_action(sfa, attrtype, data, len, log);\par
 1627     if (IS_ERR(a))\par
 1628         return PTR_ERR(a);\par
 1629 \par
 1630     return 0;\par
 1631 \}\par
}
}
{\xe \v add_nested_action_end\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:add_nested_action_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void add_nested_action_end (struct {\b sw_flow_actions} *  {\i sfa}, int  {\i st_offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1648 \{\par
 1649     struct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\par
 1650                                    st_offset);\par
 1651 \par
 1652     a->nla_len = sfa->actions_len - st_offset;\par
 1653 \}\par
}
}
{\xe \v add_nested_action_start\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:add_nested_action_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int add_nested_action_start (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attrtype}, {\b bool}  {\i log}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1635 \{\par
 1636     int used = (*sfa)->actions_len;\par
 1637     int err;\par
 1638 \par
 1639     err = add_action(sfa, attrtype, NULL, 0, log);\par
 1640     if (err)\par
 1641         return err;\par
 1642 \par
 1643     return used;\par
 1644 \}\par
}
}
{\xe \v copy_action\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:copy_action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int copy_action (const struct nlattr *  {\i from}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2011 \{\par
 2012     int totlen = NLA_ALIGN(from->nla_len);\par
 2013     struct nlattr *to;\par
 2014 \par
 2015     to = reserve_sfa_size(sfa, from->nla_len, log);\par
 2016     if (IS_ERR(to))\par
 2017         return PTR_ERR(to);\par
 2018 \par
 2019     memcpy(to, from, totlen);\par
 2020     return 0;\par
 2021 \}\par
}
}
{\xe \v genev_tun_opt_from_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:genev_tun_opt_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genev_tun_opt_from_nlattr (const struct nlattr *  {\i a}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   420 \{\par
  421     unsigned long opt_key_offset;\par
  422 \par
  423     if (nla_len(a) > sizeof(match->key->tun_opts)) \{\par
  424         OVS_NLERR(log, "Geneve option length err (len %d, max %zu).",\par
  425               nla_len(a), sizeof(match->key->tun_opts));\par
  426         return -EINVAL;\par
  427     \}\par
  428 \par
  429     if (nla_len(a) % 4 != 0) \{\par
  430         OVS_NLERR(log, "Geneve opt len %d is not a multiple of 4.",\par
  431               nla_len(a));\par
  432         return -EINVAL;\par
  433     \}\par
  434 \par
  435     /* We need to record the length of the options passed\par
  436      * down, otherwise packets with the same format but\par
  437      * additional options will be silently matched.\par
  438      */\par
  439     if (!is_mask) \{\par
  440         SW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),\par
  441                 false);\par
  442     \} else \{\par
  443         /* This is somewhat unusual because it looks at\par
  444          * both the key and mask while parsing the\par
  445          * attributes (and by extension assumes the key\par
  446          * is parsed first). Normally, we would verify\par
  447          * that each is the correct length and that the\par
  448          * attributes line up in the validate function.\par
  449          * However, that is difficult because this is\par
  450          * variable length and we won't have the\par
  451          * information later.\par
  452          */\par
  453         if (match->key->tun_opts_len != nla_len(a)) \{\par
  454             OVS_NLERR(log, "Geneve option len %d != mask len %d",\par
  455                   match->key->tun_opts_len, nla_len(a));\par
  456             return -EINVAL;\par
  457         \}\par
  458 \par
  459         SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\par
  460     \}\par
  461 \par
  462     opt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\par
  463     SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\par
  464                   nla_len(a), is_mask);\par
  465     return 0;\par
  466 \}\par
}
}
{\xe \v get_ufid_len\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:get_ufid_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static size_t get_ufid_len (const struct nlattr *  {\i attr}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1185 \{\par
 1186     size_t len;\par
 1187 \par
 1188     if (!attr)\par
 1189         return 0;\par
 1190 \par
 1191     len = nla_len(attr);\par
 1192     if (len < 1 || len > MAX_UFID_LENGTH) \{\par
 1193         OVS_NLERR(log, "ufid size %u bytes exceeds the range (1, %d)",\par
 1194               nla_len(attr), MAX_UFID_LENGTH);\par
 1195         return 0;\par
 1196     \}\par
 1197 \par
 1198     return len;\par
 1199 \}\par
}
}
{\xe \v ipv4_tun_from_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ipv4_tun_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ipv4_tun_from_nlattr (const struct nlattr *  {\i attr}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506 \{\par
  507     struct nlattr *a;\par
  508     int rem;\par
  509     bool ttl = false;\par
  510     __be16 tun_flags = 0;\par
  511     int opts_type = 0;\par
  512 \par
  513     nla_for_each_nested(a, attr, rem) \{\par
  514         int type = nla_type(a);\par
  515         int err;\par
  516 \par
  517         if (type > OVS_TUNNEL_KEY_ATTR_MAX) \{\par
  518             OVS_NLERR(log, "Tunnel attr %d out of range max %d",\par
  519                   type, OVS_TUNNEL_KEY_ATTR_MAX);\par
  520             return -EINVAL;\par
  521         \}\par
  522 \par
  523         if (ovs_tunnel_key_lens[type].len != nla_len(a) &&\par
  524            ovs_tunnel_key_lens[type].len != OVS_ATTR_NESTED) \{\par
  525             OVS_NLERR(log, "Tunnel attr %d has unexpected len %d expected %d",\par
  526                   type, nla_len(a), ovs_tunnel_key_lens[type].len);\par
  527             return -EINVAL;\par
  528         \}\par
  529 \par
  530         switch (type) \{\par
  531         case OVS_TUNNEL_KEY_ATTR_ID:\par
  532             SW_FLOW_KEY_PUT(match, tun_key.tun_id,\par
  533                     nla_get_be64(a), is_mask);\par
  534             tun_flags |= TUNNEL_KEY;\par
  535             break;\par
  536         case OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\par
  537             SW_FLOW_KEY_PUT(match, tun_key.ipv4_src,\par
  538                     nla_get_be32(a), is_mask);\par
  539             break;\par
  540         case OVS_TUNNEL_KEY_ATTR_IPV4_DST:\par
  541             SW_FLOW_KEY_PUT(match, tun_key.ipv4_dst,\par
  542                     nla_get_be32(a), is_mask);\par
  543             break;\par
  544         case OVS_TUNNEL_KEY_ATTR_TOS:\par
  545             SW_FLOW_KEY_PUT(match, tun_key.ipv4_tos,\par
  546                     nla_get_u8(a), is_mask);\par
  547             break;\par
  548         case OVS_TUNNEL_KEY_ATTR_TTL:\par
  549             SW_FLOW_KEY_PUT(match, tun_key.ipv4_ttl,\par
  550                     nla_get_u8(a), is_mask);\par
  551             ttl = true;\par
  552             break;\par
  553         case OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\par
  554             tun_flags |= TUNNEL_DONT_FRAGMENT;\par
  555             break;\par
  556         case OVS_TUNNEL_KEY_ATTR_CSUM:\par
  557             tun_flags |= TUNNEL_CSUM;\par
  558             break;\par
  559         case OVS_TUNNEL_KEY_ATTR_TP_SRC:\par
  560             SW_FLOW_KEY_PUT(match, tun_key.tp_src,\par
  561                     nla_get_be16(a), is_mask);\par
  562             break;\par
  563         case OVS_TUNNEL_KEY_ATTR_TP_DST:\par
  564             SW_FLOW_KEY_PUT(match, tun_key.tp_dst,\par
  565                     nla_get_be16(a), is_mask);\par
  566             break;\par
  567         case OVS_TUNNEL_KEY_ATTR_OAM:\par
  568             tun_flags |= TUNNEL_OAM;\par
  569             break;\par
  570         case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\par
  571             if (opts_type) \{\par
  572                 OVS_NLERR(log, "Multiple metadata blocks provided");\par
  573                 return -EINVAL;\par
  574             \}\par
  575 \par
  576             err = genev_tun_opt_from_nlattr(a, match, is_mask, log);\par
  577             if (err)\par
  578                 return err;\par
  579 \par
  580             tun_flags |= TUNNEL_GENEVE_OPT;\par
  581             opts_type = type;\par
  582             break;\par
  583         case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\par
  584             if (opts_type) \{\par
  585                 OVS_NLERR(log, "Multiple metadata blocks provided");\par
  586                 return -EINVAL;\par
  587             \}\par
  588 \par
  589             err = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);\par
  590             if (err)\par
  591                 return err;\par
  592 \par
  593             tun_flags |= TUNNEL_VXLAN_OPT;\par
  594             opts_type = type;\par
  595             break;\par
  596         default:\par
  597             OVS_NLERR(log, "Unknown IPv4 tunnel attribute %d",\par
  598                   type);\par
  599             return -EINVAL;\par
  600         \}\par
  601     \}\par
  602 \par
  603     SW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\par
  604 \par
  605     if (rem > 0) \{\par
  606         OVS_NLERR(log, "IPv4 tunnel attribute has %d unknown bytes.",\par
  607               rem);\par
  608         return -EINVAL;\par
  609     \}\par
  610 \par
  611     if (!is_mask) \{\par
  612         if (!match->key->tun_key.ipv4_dst) \{\par
  613             OVS_NLERR(log, "IPv4 tunnel dst address is zero");\par
  614             return -EINVAL;\par
  615         \}\par
  616 \par
  617         if (!ttl) \{\par
  618             OVS_NLERR(log, "IPv4 tunnel TTL not specified.");\par
  619             return -EINVAL;\par
  620         \}\par
  621     \}\par
  622 \par
  623     return opts_type;\par
  624 \}\par
}
}
{\xe \v ipv4_tun_to_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ipv4_tun_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ipv4_tun_to_nlattr (struct sk_buff *  {\i skb}, const struct {\b ovs_key_ipv4_tunnel} *  {\i output}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   692 \{\par
  693     struct nlattr *nla;\par
  694     int err;\par
  695 \par
  696     nla = nla_nest_start(skb, OVS_KEY_ATTR_TUNNEL);\par
  697     if (!nla)\par
  698         return -EMSGSIZE;\par
  699 \par
  700     err = __ipv4_tun_to_nlattr(skb, output, tun_opts, swkey_tun_opts_len);\par
  701     if (err)\par
  702         return err;\par
  703 \par
  704     nla_nest_end(skb, nla);\par
  705     return 0;\par
  706 \}\par
}
}
{\xe \v is_all_zero\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:is_all_zero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} is_all_zero (const u8 *  {\i fp}, size_t  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   345 \{\par
  346     int i;\par
  347 \par
  348     if (!fp)\par
  349         return false;\par
  350 \par
  351     for (i = 0; i < size; i++)\par
  352         if (fp[i])\par
  353             return false;\par
  354 \par
  355     return true;\par
  356 \}\par
}
}
{\xe \v mask_set_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:mask_set_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_set_nlattr (struct nlattr *  {\i attr}, u8  {\i val}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1022 \{\par
 1023     nlattr_set(attr, val, ovs_key_lens);\par
 1024 \}\par
}
}
{\xe \v masked_set_action_to_set_action_attr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:masked_set_action_to_set_action_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int masked_set_action_to_set_action_attr (const struct nlattr *  {\i a}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2268 \{\par
 2269     const struct nlattr *ovs_key = nla_data(a);\par
 2270     size_t key_len = nla_len(ovs_key) / 2;\par
 2271 \par
 2272     /* Revert the conversion we did from a non-masked set action to\par
 2273      * masked set action.\par
 2274      */\par
 2275     if (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a) - key_len, ovs_key))\par
 2276         return -EMSGSIZE;\par
 2277 \par
 2278     return 0;\par
 2279 \}\par
}
}
{\xe \v match_validate\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:match_validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} match_validate (const struct {\b sw_flow_match} *  {\i match}, u64  {\i key_attrs}, u64  {\i mask_attrs}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   123 \{\par
  124     u64 key_expected = 1ULL << OVS_KEY_ATTR_ETHERNET;\par
  125     u64 mask_allowed = key_attrs;  /* At most allow all key attributes */\par
  126 \par
  127     /* The following mask attributes allowed only if they\par
  128      * pass the validation tests.\par
  129      */\par
  130     mask_allowed &= ~((1ULL << OVS_KEY_ATTR_IPV4)\par
  131             | (1ULL << OVS_KEY_ATTR_IPV6)\par
  132             | (1ULL << OVS_KEY_ATTR_TCP)\par
  133             | (1ULL << OVS_KEY_ATTR_TCP_FLAGS)\par
  134             | (1ULL << OVS_KEY_ATTR_UDP)\par
  135             | (1ULL << OVS_KEY_ATTR_SCTP)\par
  136             | (1ULL << OVS_KEY_ATTR_ICMP)\par
  137             | (1ULL << OVS_KEY_ATTR_ICMPV6)\par
  138             | (1ULL << OVS_KEY_ATTR_ARP)\par
  139             | (1ULL << OVS_KEY_ATTR_ND)\par
  140             | (1ULL << OVS_KEY_ATTR_MPLS));\par
  141 \par
  142     /* Always allowed mask fields. */\par
  143     mask_allowed |= ((1ULL << OVS_KEY_ATTR_TUNNEL)\par
  144                | (1ULL << OVS_KEY_ATTR_IN_PORT)\par
  145                | (1ULL << OVS_KEY_ATTR_ETHERTYPE));\par
  146 \par
  147     /* Check key attributes. */\par
  148     if (match->key->eth.type == htons(ETH_P_ARP)\par
  149             || match->key->eth.type == htons(ETH_P_RARP)) \{\par
  150         key_expected |= 1ULL << OVS_KEY_ATTR_ARP;\par
  151         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  152             mask_allowed |= 1ULL << OVS_KEY_ATTR_ARP;\par
  153     \}\par
  154 \par
  155     if (eth_p_mpls(match->key->eth.type)) \{\par
  156         key_expected |= 1ULL << OVS_KEY_ATTR_MPLS;\par
  157         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  158             mask_allowed |= 1ULL << OVS_KEY_ATTR_MPLS;\par
  159     \}\par
  160 \par
  161     if (match->key->eth.type == htons(ETH_P_IP)) \{\par
  162         key_expected |= 1ULL << OVS_KEY_ATTR_IPV4;\par
  163         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  164             mask_allowed |= 1ULL << OVS_KEY_ATTR_IPV4;\par
  165 \par
  166         if (match->key->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
  167             if (match->key->ip.proto == IPPROTO_UDP) \{\par
  168                 key_expected |= 1ULL << OVS_KEY_ATTR_UDP;\par
  169                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  170                     mask_allowed |= 1ULL << OVS_KEY_ATTR_UDP;\par
  171             \}\par
  172 \par
  173             if (match->key->ip.proto == IPPROTO_SCTP) \{\par
  174                 key_expected |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  175                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  176                     mask_allowed |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  177             \}\par
  178 \par
  179             if (match->key->ip.proto == IPPROTO_TCP) \{\par
  180                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP;\par
  181                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  182                 if (match->mask && (match->mask->key.ip.proto == 0xff)) \{\par
  183                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP;\par
  184                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  185                 \}\par
  186             \}\par
  187 \par
  188             if (match->key->ip.proto == IPPROTO_ICMP) \{\par
  189                 key_expected |= 1ULL << OVS_KEY_ATTR_ICMP;\par
  190                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  191                     mask_allowed |= 1ULL << OVS_KEY_ATTR_ICMP;\par
  192             \}\par
  193         \}\par
  194     \}\par
  195 \par
  196     if (match->key->eth.type == htons(ETH_P_IPV6)) \{\par
  197         key_expected |= 1ULL << OVS_KEY_ATTR_IPV6;\par
  198         if (match->mask && (match->mask->key.eth.type == htons(0xffff)))\par
  199             mask_allowed |= 1ULL << OVS_KEY_ATTR_IPV6;\par
  200 \par
  201         if (match->key->ip.frag != OVS_FRAG_TYPE_LATER) \{\par
  202             if (match->key->ip.proto == IPPROTO_UDP) \{\par
  203                 key_expected |= 1ULL << OVS_KEY_ATTR_UDP;\par
  204                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  205                     mask_allowed |= 1ULL << OVS_KEY_ATTR_UDP;\par
  206             \}\par
  207 \par
  208             if (match->key->ip.proto == IPPROTO_SCTP) \{\par
  209                 key_expected |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  210                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  211                     mask_allowed |= 1ULL << OVS_KEY_ATTR_SCTP;\par
  212             \}\par
  213 \par
  214             if (match->key->ip.proto == IPPROTO_TCP) \{\par
  215                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP;\par
  216                 key_expected |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  217                 if (match->mask && (match->mask->key.ip.proto == 0xff)) \{\par
  218                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP;\par
  219                     mask_allowed |= 1ULL << OVS_KEY_ATTR_TCP_FLAGS;\par
  220                 \}\par
  221             \}\par
  222 \par
  223             if (match->key->ip.proto == IPPROTO_ICMPV6) \{\par
  224                 key_expected |= 1ULL << OVS_KEY_ATTR_ICMPV6;\par
  225                 if (match->mask && (match->mask->key.ip.proto == 0xff))\par
  226                     mask_allowed |= 1ULL << OVS_KEY_ATTR_ICMPV6;\par
  227 \par
  228                 if (match->key->tp.src ==\par
  229                         htons(NDISC_NEIGHBOUR_SOLICITATION) ||\par
  230                     match->key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) \{\par
  231                     key_expected |= 1ULL << OVS_KEY_ATTR_ND;\par
  232                     if (match->mask && (match->mask->key.tp.src == htons(0xff)))\par
  233                         mask_allowed |= 1ULL << OVS_KEY_ATTR_ND;\par
  234                 \}\par
  235             \}\par
  236         \}\par
  237     \}\par
  238 \par
  239     if ((key_attrs & key_expected) != key_expected) \{\par
  240         /* Key attributes check failed. */\par
  241         OVS_NLERR(log, "Missing key (keys=%llx, expected=%llx)",\par
  242               (unsigned long long)key_attrs,\par
  243               (unsigned long long)key_expected);\par
  244         return false;\par
  245     \}\par
  246 \par
  247     if ((mask_attrs & mask_allowed) != mask_attrs) \{\par
  248         /* Mask attributes check failed. */\par
  249         OVS_NLERR(log, "Unexpected mask (mask=%llx, allowed=%llx)",\par
  250               (unsigned long long)mask_attrs,\par
  251               (unsigned long long)mask_allowed);\par
  252         return false;\par
  253     \}\par
  254 \par
  255     return true;\par
  256 \}\par
}
}
{\xe \v metadata_from_nlattrs\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:metadata_from_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int metadata_from_nlattrs (struct {\b sw_flow_match} *  {\i match}, u64 *  {\i attrs}, const struct nlattr **  {\i a}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   719 \{\par
  720     if (*attrs & (1ULL << OVS_KEY_ATTR_DP_HASH)) \{\par
  721         u32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);\par
  722 \par
  723         SW_FLOW_KEY_PUT(match, ovs_flow_hash, hash_val, is_mask);\par
  724         *attrs &= ~(1ULL << OVS_KEY_ATTR_DP_HASH);\par
  725     \}\par
  726 \par
  727     if (*attrs & (1ULL << OVS_KEY_ATTR_RECIRC_ID)) \{\par
  728         u32 recirc_id = nla_get_u32(a[OVS_KEY_ATTR_RECIRC_ID]);\par
  729 \par
  730         SW_FLOW_KEY_PUT(match, recirc_id, recirc_id, is_mask);\par
  731         *attrs &= ~(1ULL << OVS_KEY_ATTR_RECIRC_ID);\par
  732     \}\par
  733 \par
  734     if (*attrs & (1ULL << OVS_KEY_ATTR_PRIORITY)) \{\par
  735         SW_FLOW_KEY_PUT(match, phy.priority,\par
  736               nla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\par
  737         *attrs &= ~(1ULL << OVS_KEY_ATTR_PRIORITY);\par
  738     \}\par
  739 \par
  740     if (*attrs & (1ULL << OVS_KEY_ATTR_IN_PORT)) \{\par
  741         u32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\par
  742 \par
  743         if (is_mask) \{\par
  744             in_port = 0xffffffff; /* Always exact match in_port. */\par
  745         \} else if (in_port >= DP_MAX_PORTS) \{\par
  746             OVS_NLERR(log, "Port %d exceeds max allowable %d",\par
  747                   in_port, DP_MAX_PORTS);\par
  748             return -EINVAL;\par
  749         \}\par
  750 \par
  751         SW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\par
  752         *attrs &= ~(1ULL << OVS_KEY_ATTR_IN_PORT);\par
  753     \} else if (!is_mask) \{\par
  754         SW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\par
  755     \}\par
  756 \par
  757     if (*attrs & (1ULL << OVS_KEY_ATTR_SKB_MARK)) \{\par
  758         uint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\par
  759 \par
  760         SW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\par
  761         *attrs &= ~(1ULL << OVS_KEY_ATTR_SKB_MARK);\par
  762     \}\par
  763     if (*attrs & (1ULL << OVS_KEY_ATTR_TUNNEL)) \{\par
  764         if (ipv4_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\par
  765                      is_mask, log) < 0)\par
  766             return -EINVAL;\par
  767         *attrs &= ~(1ULL << OVS_KEY_ATTR_TUNNEL);\par
  768     \}\par
  769     return 0;\par
  770 \}\par
}
}
{\xe \v nla_alloc_flow_actions\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:nla_alloc_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_actions}* nla_alloc_flow_actions (int  {\i size}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1535 \{\par
 1536     struct sw_flow_actions *sfa;\par
 1537 \par
 1538     if (size > MAX_ACTIONS_BUFSIZE) \{\par
 1539         OVS_NLERR(log, "Flow action size %u bytes exceeds max", size);\par
 1540         return ERR_PTR(-EINVAL);\par
 1541     \}\par
 1542 \par
 1543     sfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\par
 1544     if (!sfa)\par
 1545         return ERR_PTR(-ENOMEM);\par
 1546 \par
 1547     sfa->actions_len = 0;\par
 1548     return sfa;\par
 1549 \}\par
}
}
{\xe \v nlattr_set\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:nlattr_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void nlattr_set (struct nlattr *  {\i attr}, u8  {\i val}, const struct {\b ovs_len_tbl} *  {\i tbl}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1008 \{\par
 1009     struct nlattr *nla;\par
 1010     int rem;\par
 1011 \par
 1012     /* The nlattr stream should already have been validated */\par
 1013     nla_for_each_nested(nla, attr, rem) \{\par
 1014         if (tbl && tbl[nla_type(nla)].len == OVS_ATTR_NESTED)\par
 1015             nlattr_set(nla, val, tbl[nla_type(nla)].next);\par
 1016         else\par
 1017             memset(nla_data(nla), val, nla_len(nla));\par
 1018     \}\par
 1019 \}\par
}
}
{\xe \v ovs_key_attr_size\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   280 \{\par
  281     /* Whenever adding new OVS_KEY_ FIELDS, we should consider\par
  282      * updating this function.\par
  283      */\par
  284     BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 22);\par
  285 \par
  286     return    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */\par
  287         + nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */\par
  288           + ovs_tun_key_attr_size()\par
  289         + nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */\par
  290         + nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */\par
  291         + nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */\par
  292         + nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */\par
  293         + nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */\par
  294         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  295         + nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */\par
  296         + nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */\par
  297         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  298         + nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */\par
  299         + nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */\par
  300         + nla_total_size(28); /* OVS_KEY_ATTR_ND */\par
  301 \}\par
}
}
{\xe \v ovs_key_from_nlattrs\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_key_from_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_key_from_nlattrs (struct {\b sw_flow_match} *  {\i match}, u64  {\i attrs}, const struct nlattr **  {\i a}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   775 \{\par
  776     int err;\par
  777 \par
  778     err = metadata_from_nlattrs(match, &attrs, a, is_mask, log);\par
  779     if (err)\par
  780         return err;\par
  781 \par
  782     if (attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) \{\par
  783         const struct ovs_key_ethernet *eth_key;\par
  784 \par
  785         eth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\par
  786         SW_FLOW_KEY_MEMCPY(match, eth.src,\par
  787                 eth_key->eth_src, ETH_ALEN, is_mask);\par
  788         SW_FLOW_KEY_MEMCPY(match, eth.dst,\par
  789                 eth_key->eth_dst, ETH_ALEN, is_mask);\par
  790         attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERNET);\par
  791     \}\par
  792 \par
  793     if (attrs & (1ULL << OVS_KEY_ATTR_VLAN)) \{\par
  794         __be16 tci;\par
  795 \par
  796         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
  797         if (!(tci & htons(VLAN_TAG_PRESENT))) \{\par
  798             if (is_mask)\par
  799                 OVS_NLERR(log, "VLAN TCI mask does not have exact match for VLAN_TAG_PRESENT bit.");\par
  800             else\par
  801                 OVS_NLERR(log, "VLAN TCI does not have VLAN_TAG_PRESENT bit set.");\par
  802 \par
  803             return -EINVAL;\par
  804         \}\par
  805 \par
  806         SW_FLOW_KEY_PUT(match, eth.tci, tci, is_mask);\par
  807         attrs &= ~(1ULL << OVS_KEY_ATTR_VLAN);\par
  808     \}\par
  809 \par
  810     if (attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) \{\par
  811         __be16 eth_type;\par
  812 \par
  813         eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\par
  814         if (is_mask) \{\par
  815             /* Always exact match EtherType. */\par
  816             eth_type = htons(0xffff);\par
  817         \} else if (!eth_proto_is_802_3(eth_type)) \{\par
  818             OVS_NLERR(log, "EtherType %x is less than min %x",\par
  819                   ntohs(eth_type), ETH_P_802_3_MIN);\par
  820             return -EINVAL;\par
  821         \}\par
  822 \par
  823         SW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\par
  824         attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
  825     \} else if (!is_mask) \{\par
  826         SW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\par
  827     \}\par
  828 \par
  829     if (attrs & (1ULL << OVS_KEY_ATTR_IPV4)) \{\par
  830         const struct ovs_key_ipv4 *ipv4_key;\par
  831 \par
  832         ipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\par
  833         if (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) \{\par
  834             OVS_NLERR(log, "IPv4 frag type %d is out of range max %d",\par
  835                   ipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\par
  836             return -EINVAL;\par
  837         \}\par
  838         SW_FLOW_KEY_PUT(match, ip.proto,\par
  839                 ipv4_key->ipv4_proto, is_mask);\par
  840         SW_FLOW_KEY_PUT(match, ip.tos,\par
  841                 ipv4_key->ipv4_tos, is_mask);\par
  842         SW_FLOW_KEY_PUT(match, ip.ttl,\par
  843                 ipv4_key->ipv4_ttl, is_mask);\par
  844         SW_FLOW_KEY_PUT(match, ip.frag,\par
  845                 ipv4_key->ipv4_frag, is_mask);\par
  846         SW_FLOW_KEY_PUT(match, ipv4.addr.src,\par
  847                 ipv4_key->ipv4_src, is_mask);\par
  848         SW_FLOW_KEY_PUT(match, ipv4.addr.dst,\par
  849                 ipv4_key->ipv4_dst, is_mask);\par
  850         attrs &= ~(1ULL << OVS_KEY_ATTR_IPV4);\par
  851     \}\par
  852 \par
  853     if (attrs & (1ULL << OVS_KEY_ATTR_IPV6)) \{\par
  854         const struct ovs_key_ipv6 *ipv6_key;\par
  855 \par
  856         ipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\par
  857         if (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) \{\par
  858             OVS_NLERR(log, "IPv6 frag type %d is out of range max %d",\par
  859                   ipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\par
  860             return -EINVAL;\par
  861         \}\par
  862 \par
  863         if (!is_mask && ipv6_key->ipv6_label & htonl(0xFFF00000)) \{\par
  864             OVS_NLERR(log,\par
  865                   "Invalid IPv6 flow label value (value=%x, max=%x).",\par
  866                   ntohl(ipv6_key->ipv6_label), (1 << 20) - 1);\par
  867             return -EINVAL;\par
  868         \}\par
  869 \par
  870         SW_FLOW_KEY_PUT(match, ipv6.label,\par
  871                 ipv6_key->ipv6_label, is_mask);\par
  872         SW_FLOW_KEY_PUT(match, ip.proto,\par
  873                 ipv6_key->ipv6_proto, is_mask);\par
  874         SW_FLOW_KEY_PUT(match, ip.tos,\par
  875                 ipv6_key->ipv6_tclass, is_mask);\par
  876         SW_FLOW_KEY_PUT(match, ip.ttl,\par
  877                 ipv6_key->ipv6_hlimit, is_mask);\par
  878         SW_FLOW_KEY_PUT(match, ip.frag,\par
  879                 ipv6_key->ipv6_frag, is_mask);\par
  880         SW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\par
  881                 ipv6_key->ipv6_src,\par
  882                 sizeof(match->key->ipv6.addr.src),\par
  883                 is_mask);\par
  884         SW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\par
  885                 ipv6_key->ipv6_dst,\par
  886                 sizeof(match->key->ipv6.addr.dst),\par
  887                 is_mask);\par
  888 \par
  889         attrs &= ~(1ULL << OVS_KEY_ATTR_IPV6);\par
  890     \}\par
  891 \par
  892     if (attrs & (1ULL << OVS_KEY_ATTR_ARP)) \{\par
  893         const struct ovs_key_arp *arp_key;\par
  894 \par
  895         arp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\par
  896         if (!is_mask && (arp_key->arp_op & htons(0xff00))) \{\par
  897             OVS_NLERR(log, "Unknown ARP opcode (opcode=%d).",\par
  898                   arp_key->arp_op);\par
  899             return -EINVAL;\par
  900         \}\par
  901 \par
  902         SW_FLOW_KEY_PUT(match, ipv4.addr.src,\par
  903                 arp_key->arp_sip, is_mask);\par
  904         SW_FLOW_KEY_PUT(match, ipv4.addr.dst,\par
  905             arp_key->arp_tip, is_mask);\par
  906         SW_FLOW_KEY_PUT(match, ip.proto,\par
  907                 ntohs(arp_key->arp_op), is_mask);\par
  908         SW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\par
  909                 arp_key->arp_sha, ETH_ALEN, is_mask);\par
  910         SW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\par
  911                 arp_key->arp_tha, ETH_ALEN, is_mask);\par
  912 \par
  913         attrs &= ~(1ULL << OVS_KEY_ATTR_ARP);\par
  914     \}\par
  915 \par
  916     if (attrs & (1ULL << OVS_KEY_ATTR_MPLS)) \{\par
  917         const struct ovs_key_mpls *mpls_key;\par
  918 \par
  919         mpls_key = nla_data(a[OVS_KEY_ATTR_MPLS]);\par
  920         SW_FLOW_KEY_PUT(match, mpls.top_lse,\par
  921                 mpls_key->mpls_lse, is_mask);\par
  922 \par
  923         attrs &= ~(1ULL << OVS_KEY_ATTR_MPLS);\par
  924     \}\par
  925 \par
  926     if (attrs & (1ULL << OVS_KEY_ATTR_TCP)) \{\par
  927         const struct ovs_key_tcp *tcp_key;\par
  928 \par
  929         tcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\par
  930         SW_FLOW_KEY_PUT(match, tp.src, tcp_key->tcp_src, is_mask);\par
  931         SW_FLOW_KEY_PUT(match, tp.dst, tcp_key->tcp_dst, is_mask);\par
  932         attrs &= ~(1ULL << OVS_KEY_ATTR_TCP);\par
  933     \}\par
  934 \par
  935     if (attrs & (1ULL << OVS_KEY_ATTR_TCP_FLAGS)) \{\par
  936         SW_FLOW_KEY_PUT(match, tp.flags,\par
  937                 nla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\par
  938                 is_mask);\par
  939         attrs &= ~(1ULL << OVS_KEY_ATTR_TCP_FLAGS);\par
  940     \}\par
  941 \par
  942     if (attrs & (1ULL << OVS_KEY_ATTR_UDP)) \{\par
  943         const struct ovs_key_udp *udp_key;\par
  944 \par
  945         udp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\par
  946         SW_FLOW_KEY_PUT(match, tp.src, udp_key->udp_src, is_mask);\par
  947         SW_FLOW_KEY_PUT(match, tp.dst, udp_key->udp_dst, is_mask);\par
  948         attrs &= ~(1ULL << OVS_KEY_ATTR_UDP);\par
  949     \}\par
  950 \par
  951     if (attrs & (1ULL << OVS_KEY_ATTR_SCTP)) \{\par
  952         const struct ovs_key_sctp *sctp_key;\par
  953 \par
  954         sctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\par
  955         SW_FLOW_KEY_PUT(match, tp.src, sctp_key->sctp_src, is_mask);\par
  956         SW_FLOW_KEY_PUT(match, tp.dst, sctp_key->sctp_dst, is_mask);\par
  957         attrs &= ~(1ULL << OVS_KEY_ATTR_SCTP);\par
  958     \}\par
  959 \par
  960     if (attrs & (1ULL << OVS_KEY_ATTR_ICMP)) \{\par
  961         const struct ovs_key_icmp *icmp_key;\par
  962 \par
  963         icmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\par
  964         SW_FLOW_KEY_PUT(match, tp.src,\par
  965                 htons(icmp_key->icmp_type), is_mask);\par
  966         SW_FLOW_KEY_PUT(match, tp.dst,\par
  967                 htons(icmp_key->icmp_code), is_mask);\par
  968         attrs &= ~(1ULL << OVS_KEY_ATTR_ICMP);\par
  969     \}\par
  970 \par
  971     if (attrs & (1ULL << OVS_KEY_ATTR_ICMPV6)) \{\par
  972         const struct ovs_key_icmpv6 *icmpv6_key;\par
  973 \par
  974         icmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\par
  975         SW_FLOW_KEY_PUT(match, tp.src,\par
  976                 htons(icmpv6_key->icmpv6_type), is_mask);\par
  977         SW_FLOW_KEY_PUT(match, tp.dst,\par
  978                 htons(icmpv6_key->icmpv6_code), is_mask);\par
  979         attrs &= ~(1ULL << OVS_KEY_ATTR_ICMPV6);\par
  980     \}\par
  981 \par
  982     if (attrs & (1ULL << OVS_KEY_ATTR_ND)) \{\par
  983         const struct ovs_key_nd *nd_key;\par
  984 \par
  985         nd_key = nla_data(a[OVS_KEY_ATTR_ND]);\par
  986         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\par
  987             nd_key->nd_target,\par
  988             sizeof(match->key->ipv6.nd.target),\par
  989             is_mask);\par
  990         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\par
  991             nd_key->nd_sll, ETH_ALEN, is_mask);\par
  992         SW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\par
  993                 nd_key->nd_tll, ETH_ALEN, is_mask);\par
  994         attrs &= ~(1ULL << OVS_KEY_ATTR_ND);\par
  995     \}\par
  996 \par
  997     if (attrs != 0) \{\par
  998         OVS_NLERR(log, "Unknown key attributes %llx",\par
  999               (unsigned long long)attrs);\par
 1000         return -EINVAL;\par
 1001     \}\par
 1002 \par
 1003     return 0;\par
 1004 \}\par
}
}
{\xe \v ovs_match_init\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_match_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_match_init (struct {\b sw_flow_match} *  {\i match}, struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1714 \{\par
 1715     memset(match, 0, sizeof(*match));\par
 1716     match->key = key;\par
 1717     match->mask = mask;\par
 1718 \par
 1719     memset(key, 0, sizeof(*key));\par
 1720 \par
 1721     if (mask) \{\par
 1722         memset(&mask->key, 0, sizeof(mask->key));\par
 1723         mask->range.start = mask->range.end = 0;\par
 1724     \}\par
 1725 \}\par
}
}
{\xe \v ovs_nla_copy_actions\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_copy_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_copy_actions (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2182 \{\par
 2183     int err;\par
 2184 \par
 2185     *sfa = nla_alloc_flow_actions(nla_len(attr), log);\par
 2186     if (IS_ERR(*sfa))\par
 2187         return PTR_ERR(*sfa);\par
 2188 \par
 2189     err = __ovs_nla_copy_actions(attr, key, 0, sfa, key->eth.type,\par
 2190                      key->eth.tci, log);\par
 2191     if (err)\par
 2192         kfree(*sfa);\par
 2193 \par
 2194     return err;\par
 2195 \}\par
}
}
{\xe \v ovs_nla_free_flow_actions\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_free_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_nla_free_flow_actions (struct {\b sw_flow_actions} *  {\i sf_acts})}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1563 \{\par
 1564     call_rcu(&sf_acts->rcu, rcu_free_acts_callback);\par
 1565 \}\par
}
}
{\xe \v ovs_nla_get_flow_metadata\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_get_flow_metadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_flow_metadata (const struct nlattr *  {\i attr}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key. : Receives extracted in_port, priority, tun_key and skb_mark. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging.\par
This parses a series of Netlink attributes that form a flow key, which must take the same form accepted by flow_from_nlattrs(), but only enough of it to get the metadata, that is, the parts of the flow key that cannot be extracted from the packet itself. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1255 \{\par
 1256     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1257     struct sw_flow_match match;\par
 1258     u64 attrs = 0;\par
 1259     int err;\par
 1260 \par
 1261     err = parse_flow_nlattrs(attr, a, &attrs, log);\par
 1262     if (err)\par
 1263         return -EINVAL;\par
 1264 \par
 1265     memset(&match, 0, sizeof(match));\par
 1266     match.key = key;\par
 1267 \par
 1268     memset(key, 0, OVS_SW_FLOW_KEY_METADATA_SIZE);\par
 1269     key->phy.in_port = DP_MAX_PORTS;\par
 1270 \par
 1271     return metadata_from_nlattrs(&match, &attrs, a, false, log);\par
 1272 \}\par
}
}
{\xe \v ovs_nla_get_identifier\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_get_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_identifier (struct {\b sw_flow_id} *  {\i sfid}, const struct nlattr *  {\i ufid}, const struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1216 \{\par
 1217     struct sw_flow_key *new_key;\par
 1218 \par
 1219     if (ovs_nla_get_ufid(sfid, ufid, log))\par
 1220         return 0;\par
 1221 \par
 1222     /* If UFID was not provided, use unmasked key. */\par
 1223     new_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\par
 1224     if (!new_key)\par
 1225         return -ENOMEM;\par
 1226     memcpy(new_key, key, sizeof(*key));\par
 1227     sfid->unmasked_key = new_key;\par
 1228 \par
 1229     return 0;\par
 1230 \}\par
}
}
{\xe \v ovs_nla_get_match\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_get_match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_match (struct {\b sw_flow_match} *  {\i match}, const struct nlattr *  {\i nla_key}, const struct nlattr *  {\i nla_mask}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_match - parses Netlink attributes into a flow key and mask. In case the 'mask' is NULL, the flow is treated as exact match flow. Otherwise, it is treated as a wildcarded flow, except the mask does not include any don't care bit. : receives the extracted flow match information. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. The fields should of the packet that triggered the creation of this flow. : Optional. Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute specifies the mask field of the wildcarded flow. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1045 \{\par
 1046     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1047     const struct nlattr *encap;\par
 1048     struct nlattr *newmask = NULL;\par
 1049     u64 key_attrs = 0;\par
 1050     u64 mask_attrs = 0;\par
 1051     bool encap_valid = false;\par
 1052     int err;\par
 1053 \par
 1054     err = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\par
 1055     if (err)\par
 1056         return err;\par
 1057 \par
 1058     if ((key_attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&\par
 1059         (key_attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) &&\par
 1060         (nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) \{\par
 1061         __be16 tci;\par
 1062 \par
 1063         if (!((key_attrs & (1ULL << OVS_KEY_ATTR_VLAN)) &&\par
 1064               (key_attrs & (1ULL << OVS_KEY_ATTR_ENCAP)))) \{\par
 1065             OVS_NLERR(log, "Invalid Vlan frame.");\par
 1066             return -EINVAL;\par
 1067         \}\par
 1068 \par
 1069         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1070         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1071         encap = a[OVS_KEY_ATTR_ENCAP];\par
 1072         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1073         encap_valid = true;\par
 1074 \par
 1075         if (tci & htons(VLAN_TAG_PRESENT)) \{\par
 1076             err = parse_flow_nlattrs(encap, a, &key_attrs, log);\par
 1077             if (err)\par
 1078                 return err;\par
 1079         \} else if (!tci) \{\par
 1080             /* Corner case for truncated 802.1Q header. */\par
 1081             if (nla_len(encap)) \{\par
 1082                 OVS_NLERR(log, "Truncated 802.1Q header has non-zero encap attribute.");\par
 1083                 return -EINVAL;\par
 1084             \}\par
 1085         \} else \{\par
 1086             OVS_NLERR(log, "Encap attr is set for non-VLAN frame");\par
 1087             return  -EINVAL;\par
 1088         \}\par
 1089     \}\par
 1090 \par
 1091     err = ovs_key_from_nlattrs(match, key_attrs, a, false, log);\par
 1092     if (err)\par
 1093         return err;\par
 1094 \par
 1095     if (match->mask) \{\par
 1096         if (!nla_mask) \{\par
 1097             /* Create an exact match mask. We need to set to 0xff\par
 1098              * all the 'match->mask' fields that have been touched\par
 1099              * in 'match->key'. We cannot simply memset\par
 1100              * 'match->mask', because padding bytes and fields not\par
 1101              * specified in 'match->key' should be left to 0.\par
 1102              * Instead, we use a stream of netlink attributes,\par
 1103              * copied from 'key' and set to 0xff.\par
 1104              * ovs_key_from_nlattrs() will take care of filling\par
 1105              * 'match->mask' appropriately.\par
 1106              */\par
 1107             newmask = kmemdup(nla_key,\par
 1108                       nla_total_size(nla_len(nla_key)),\par
 1109                       GFP_KERNEL);\par
 1110             if (!newmask)\par
 1111                 return -ENOMEM;\par
 1112 \par
 1113             mask_set_nlattr(newmask, 0xff);\par
 1114 \par
 1115             /* The userspace does not send tunnel attributes that\par
 1116              * are 0, but we should not wildcard them nonetheless.\par
 1117              */\par
 1118             if (match->key->tun_key.ipv4_dst)\par
 1119                 SW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\par
 1120                              0xff, true);\par
 1121 \par
 1122             nla_mask = newmask;\par
 1123         \}\par
 1124 \par
 1125         err = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\par
 1126         if (err)\par
 1127             goto free_newmask;\par
 1128 \par
 1129         /* Always match on tci. */\par
 1130         SW_FLOW_KEY_PUT(match, eth.tci, htons(0xffff), true);\par
 1131 \par
 1132         if (mask_attrs & 1ULL << OVS_KEY_ATTR_ENCAP) \{\par
 1133             __be16 eth_type = 0;\par
 1134             __be16 tci = 0;\par
 1135 \par
 1136             if (!encap_valid) \{\par
 1137                 OVS_NLERR(log, "Encap mask attribute is set for non-VLAN frame.");\par
 1138                 err = -EINVAL;\par
 1139                 goto free_newmask;\par
 1140             \}\par
 1141 \par
 1142             mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1143             if (a[OVS_KEY_ATTR_ETHERTYPE])\par
 1144                 eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\par
 1145 \par
 1146             if (eth_type == htons(0xffff)) \{\par
 1147                 mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1148                 encap = a[OVS_KEY_ATTR_ENCAP];\par
 1149                 err = parse_flow_mask_nlattrs(encap, a,\par
 1150                                   &mask_attrs, log);\par
 1151                 if (err)\par
 1152                     goto free_newmask;\par
 1153             \} else \{\par
 1154                 OVS_NLERR(log, "VLAN frames must have an exact match on the TPID (mask=%x).",\par
 1155                       ntohs(eth_type));\par
 1156                 err = -EINVAL;\par
 1157                 goto free_newmask;\par
 1158             \}\par
 1159 \par
 1160             if (a[OVS_KEY_ATTR_VLAN])\par
 1161                 tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1162 \par
 1163             if (!(tci & htons(VLAN_TAG_PRESENT))) \{\par
 1164                 OVS_NLERR(log, "VLAN tag present bit must have an exact match (tci_mask=%x).",\par
 1165                       ntohs(tci));\par
 1166                 err = -EINVAL;\par
 1167                 goto free_newmask;\par
 1168             \}\par
 1169         \}\par
 1170 \par
 1171         err = ovs_key_from_nlattrs(match, mask_attrs, a, true, log);\par
 1172         if (err)\par
 1173             goto free_newmask;\par
 1174     \}\par
 1175 \par
 1176     if (!match_validate(match, key_attrs, mask_attrs, log))\par
 1177         err = -EINVAL;\par
 1178 \par
 1179 free_newmask:\par
 1180     kfree(newmask);\par
 1181     return err;\par
 1182 \}\par
}
}
{\xe \v ovs_nla_get_ufid\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_get_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_nla_get_ufid (struct {\b sw_flow_id} *  {\i sfid}, const struct nlattr *  {\i attr}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1206 \{\par
 1207     sfid->ufid_len = get_ufid_len(attr, log);\par
 1208     if (sfid->ufid_len)\par
 1209         memcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\par
 1210 \par
 1211     return sfid->ufid_len;\par
 1212 \}\par
}
}
{\xe \v ovs_nla_get_ufid_flags\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_get_ufid_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_nla_get_ufid_flags (const struct nlattr *  {\i attr})}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1233 \{\par
 1234     return attr ? nla_get_u32(attr) : 0;\par
 1235 \}\par
}
}
{\xe \v ovs_nla_put_actions\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_actions (const struct nlattr *  {\i attr}, int  {\i len}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2282 \{\par
 2283     const struct nlattr *a;\par
 2284     int rem, err;\par
 2285 \par
 2286     nla_for_each_attr(a, attr, len, rem) \{\par
 2287         int type = nla_type(a);\par
 2288 \par
 2289         switch (type) \{\par
 2290         case OVS_ACTION_ATTR_SET:\par
 2291             err = set_action_to_attr(a, skb);\par
 2292             if (err)\par
 2293                 return err;\par
 2294             break;\par
 2295 \par
 2296         case OVS_ACTION_ATTR_SET_TO_MASKED:\par
 2297             err = masked_set_action_to_set_action_attr(a, skb);\par
 2298             if (err)\par
 2299                 return err;\par
 2300             break;\par
 2301 \par
 2302         case OVS_ACTION_ATTR_SAMPLE:\par
 2303             err = sample_action_to_attr(a, skb);\par
 2304             if (err)\par
 2305                 return err;\par
 2306             break;\par
 2307         default:\par
 2308             if (nla_put(skb, type, nla_len(a), nla_data(a)))\par
 2309                 return -EMSGSIZE;\par
 2310             break;\par
 2311         \}\par
 2312     \}\par
 2313 \par
 2314     return 0;\par
 2315 \}\par
}
}
{\xe \v ovs_nla_put_egress_tunnel_key\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_egress_tunnel_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_egress_tunnel_key (struct sk_buff *  {\i skb}, const struct {\b ovs_tunnel_info} *  {\i egress_tun_info})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{\par
  711     return __ipv4_tun_to_nlattr(skb, &egress_tun_info->tunnel,\par
  712                     egress_tun_info->options,\par
  713                     egress_tun_info->options_len);\par
  714 \}\par
}
}
{\xe \v ovs_nla_put_identifier\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_identifier (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1509 \{\par
 1510     if (ovs_identifier_is_ufid(&flow->id))\par
 1511         return nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\par
 1512                    flow->id.ufid);\par
 1513 \par
 1514     return ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\par
 1515                    OVS_FLOW_ATTR_KEY, false, skb);\par
 1516 \}\par
}
}
{\xe \v ovs_nla_put_key\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_key (const struct {\b sw_flow_key} *  {\i swkey}, const struct {\b sw_flow_key} *  {\i output}, int  {\i attr}, {\b bool}  {\i is_mask}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1492 \{\par
 1493     int err;\par
 1494     struct nlattr *nla;\par
 1495 \par
 1496     nla = nla_nest_start(skb, attr);\par
 1497     if (!nla)\par
 1498         return -EMSGSIZE;\par
 1499     err = __ovs_nla_put_key(swkey, output, is_mask, skb);\par
 1500     if (err)\par
 1501         return err;\par
 1502     nla_nest_end(skb, nla);\par
 1503 \par
 1504     return 0;\par
 1505 \}\par
}
}
{\xe \v ovs_nla_put_mask\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_mask (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1527 \{\par
 1528     return ovs_nla_put_key(&flow->key, &flow->mask->key,\par
 1529                 OVS_FLOW_ATTR_MASK, true, skb);\par
 1530 \}\par
}
}
{\xe \v ovs_nla_put_masked_key\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_nla_put_masked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_masked_key (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1520 \{\par
 1521     return ovs_nla_put_key(&flow->key, &flow->key,\par
 1522                 OVS_FLOW_ATTR_KEY, false, skb);\par
 1523 \}\par
}
}
{\xe \v ovs_tun_key_attr_size\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_tun_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_tun_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259 \{\par
  260     /* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider\par
  261      * updating this function.\par
  262      */\par
  263     return    nla_total_size(8)    /* OVS_TUNNEL_KEY_ATTR_ID */\par
  264         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_SRC */\par
  265         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_DST */\par
  266         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */\par
  267         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */\par
  268         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */\par
  269         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */\par
  270         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */\par
  271         + nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */\par
  272         /* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS is mutually exclusive with\par
  273          * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it.\par
  274          */\par
  275         + nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */\par
  276         + nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */\par
  277 \}\par
}
}
{\xe \v parse_flow_mask_nlattrs\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:parse_flow_mask_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_flow_mask_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   406 \{\par
  407     return __parse_flow_nlattrs(attr, a, attrsp, log, true);\par
  408 \}\par
}
}
{\xe \v parse_flow_nlattrs\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:parse_flow_nlattrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int parse_flow_nlattrs (const struct nlattr *  {\i attr}, const struct nlattr *  {\i a}[], u64 *  {\i attrsp}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   413 \{\par
  414     return __parse_flow_nlattrs(attr, a, attrsp, log, false);\par
  415 \}\par
}
}
{\xe \v rcu_free_acts_callback\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:rcu_free_acts_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_acts_callback (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1553 \{\par
 1554     struct sw_flow_actions *sf_acts = container_of(rcu,\par
 1555             struct sw_flow_actions, rcu);\par
 1556     kfree(sf_acts);\par
 1557 \}\par
}
}
{\xe \v reserve_sfa_size\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:reserve_sfa_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct nlattr* reserve_sfa_size (struct {\b sw_flow_actions} **  {\i sfa}, int  {\i attr_len}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1569 \{\par
 1570 \par
 1571     struct sw_flow_actions *acts;\par
 1572     int new_acts_size;\par
 1573     int req_size = NLA_ALIGN(attr_len);\par
 1574     int next_offset = offsetof(struct sw_flow_actions, actions) +\par
 1575                     (*sfa)->actions_len;\par
 1576 \par
 1577     if (req_size <= (ksize(*sfa) - next_offset))\par
 1578         goto out;\par
 1579 \par
 1580     new_acts_size = ksize(*sfa) * 2;\par
 1581 \par
 1582     if (new_acts_size > MAX_ACTIONS_BUFSIZE) \{\par
 1583         if ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size)\par
 1584             return ERR_PTR(-EMSGSIZE);\par
 1585         new_acts_size = MAX_ACTIONS_BUFSIZE;\par
 1586     \}\par
 1587 \par
 1588     acts = nla_alloc_flow_actions(new_acts_size, log);\par
 1589     if (IS_ERR(acts))\par
 1590         return (void *)acts;\par
 1591 \par
 1592     memcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\par
 1593     acts->actions_len = (*sfa)->actions_len;\par
 1594     kfree(*sfa);\par
 1595     *sfa = acts;\par
 1596 \par
 1597 out:\par
 1598     (*sfa)->actions_len += req_size;\par
 1599     return  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\par
 1600 \}\par
}
}
{\xe \v sample_action_to_attr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:sample_action_to_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int sample_action_to_attr (const struct nlattr *  {\i attr}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2198 \{\par
 2199     const struct nlattr *a;\par
 2200     struct nlattr *start;\par
 2201     int err = 0, rem;\par
 2202 \par
 2203     start = nla_nest_start(skb, OVS_ACTION_ATTR_SAMPLE);\par
 2204     if (!start)\par
 2205         return -EMSGSIZE;\par
 2206 \par
 2207     nla_for_each_nested(a, attr, rem) \{\par
 2208         int type = nla_type(a);\par
 2209         struct nlattr *st_sample;\par
 2210 \par
 2211         switch (type) \{\par
 2212         case OVS_SAMPLE_ATTR_PROBABILITY:\par
 2213             if (nla_put(skb, OVS_SAMPLE_ATTR_PROBABILITY,\par
 2214                     sizeof(u32), nla_data(a)))\par
 2215                 return -EMSGSIZE;\par
 2216             break;\par
 2217         case OVS_SAMPLE_ATTR_ACTIONS:\par
 2218             st_sample = nla_nest_start(skb, OVS_SAMPLE_ATTR_ACTIONS);\par
 2219             if (!st_sample)\par
 2220                 return -EMSGSIZE;\par
 2221             err = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\par
 2222             if (err)\par
 2223                 return err;\par
 2224             nla_nest_end(skb, st_sample);\par
 2225             break;\par
 2226         \}\par
 2227     \}\par
 2228 \par
 2229     nla_nest_end(skb, start);\par
 2230     return err;\par
 2231 \}\par
}
}
{\xe \v set_action_to_attr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:set_action_to_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int set_action_to_attr (const struct nlattr *  {\i a}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2234 \{\par
 2235     const struct nlattr *ovs_key = nla_data(a);\par
 2236     int key_type = nla_type(ovs_key);\par
 2237     struct nlattr *start;\par
 2238     int err;\par
 2239 \par
 2240     switch (key_type) \{\par
 2241     case OVS_KEY_ATTR_TUNNEL_INFO: \{\par
 2242         struct ovs_tunnel_info *tun_info = nla_data(ovs_key);\par
 2243 \par
 2244         start = nla_nest_start(skb, OVS_ACTION_ATTR_SET);\par
 2245         if (!start)\par
 2246             return -EMSGSIZE;\par
 2247 \par
 2248         err = ipv4_tun_to_nlattr(skb, &tun_info->tunnel,\par
 2249                      tun_info->options_len ?\par
 2250                         tun_info->options : NULL,\par
 2251                      tun_info->options_len);\par
 2252         if (err)\par
 2253             return err;\par
 2254         nla_nest_end(skb, start);\par
 2255         break;\par
 2256     \}\par
 2257     default:\par
 2258         if (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\par
 2259             return -EMSGSIZE;\par
 2260         break;\par
 2261     \}\par
 2262 \par
 2263     return 0;\par
 2264 \}\par
}
}
{\xe \v update_range\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:update_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void update_range (struct {\b sw_flow_match} *  {\i match}, size_t  {\i offset}, size_t  {\i size}, {\b bool}  {\i is_mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    63 \{\par
   64     struct sw_flow_key_range *range;\par
   65     size_t start = rounddown(offset, sizeof(long));\par
   66     size_t end = roundup(offset + size, sizeof(long));\par
   67 \par
   68     if (!is_mask)\par
   69         range = &match->range;\par
   70     else\par
   71         range = &match->mask->range;\par
   72 \par
   73     if (range->start == range->end) \{\par
   74         range->start = start;\par
   75         range->end = end;\par
   76         return;\par
   77     \}\par
   78 \par
   79     if (range->start > start)\par
   80         range->start = start;\par
   81 \par
   82     if (range->end < end)\par
   83         range->end = end;\par
   84 \}\par
}
}
{\xe \v validate_and_copy_sample\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_and_copy_sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_and_copy_sample (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, int  {\i depth}, struct {\b sw_flow_actions} **  {\i sfa}, __be16  {\i eth_type}, __be16  {\i vlan_tci}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1664 \{\par
 1665     const struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\par
 1666     const struct nlattr *probability, *actions;\par
 1667     const struct nlattr *a;\par
 1668     int rem, start, err, st_acts;\par
 1669 \par
 1670     memset(attrs, 0, sizeof(attrs));\par
 1671     nla_for_each_nested(a, attr, rem) \{\par
 1672         int type = nla_type(a);\par
 1673         if (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\par
 1674             return -EINVAL;\par
 1675         attrs[type] = a;\par
 1676     \}\par
 1677     if (rem)\par
 1678         return -EINVAL;\par
 1679 \par
 1680     probability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\par
 1681     if (!probability || nla_len(probability) != sizeof(u32))\par
 1682         return -EINVAL;\par
 1683 \par
 1684     actions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\par
 1685     if (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\par
 1686         return -EINVAL;\par
 1687 \par
 1688     /* validation done, copy sample action. */\par
 1689     start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE, log);\par
 1690     if (start < 0)\par
 1691         return start;\par
 1692     err = add_action(sfa, OVS_SAMPLE_ATTR_PROBABILITY,\par
 1693              nla_data(probability), sizeof(u32), log);\par
 1694     if (err)\par
 1695         return err;\par
 1696     st_acts = add_nested_action_start(sfa, OVS_SAMPLE_ATTR_ACTIONS, log);\par
 1697     if (st_acts < 0)\par
 1698         return st_acts;\par
 1699 \par
 1700     err = __ovs_nla_copy_actions(actions, key, depth + 1, sfa,\par
 1701                      eth_type, vlan_tci, log);\par
 1702     if (err)\par
 1703         return err;\par
 1704 \par
 1705     add_nested_action_end(*sfa, st_acts);\par
 1706     add_nested_action_end(*sfa, start);\par
 1707 \par
 1708     return 0;\par
 1709 \}\par
}
}
{\xe \v validate_and_copy_set_tun\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_and_copy_set_tun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_and_copy_set_tun (const struct nlattr *  {\i attr}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1757 \{\par
 1758     struct sw_flow_match match;\par
 1759     struct sw_flow_key key;\par
 1760     struct ovs_tunnel_info *tun_info;\par
 1761     struct nlattr *a;\par
 1762     int start, opts_type;\par
 1763     int err = 0;\par
 1764 \par
 1765     ovs_match_init(&match, &key, NULL);\par
 1766     opts_type = ipv4_tun_from_nlattr(nla_data(attr), &match, false, log);\par
 1767     if (opts_type < 0)\par
 1768         return opts_type;\par
 1769 \par
 1770     if (key.tun_opts_len) \{\par
 1771         switch (opts_type) \{\par
 1772         case OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\par
 1773             err = validate_geneve_opts(&key);\par
 1774             if (err < 0)\par
 1775                 return err;\par
 1776             break;\par
 1777         case OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\par
 1778             break;\par
 1779         \}\par
 1780     \};\par
 1781 \par
 1782     start = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);\par
 1783     if (start < 0)\par
 1784         return start;\par
 1785 \par
 1786     a = __add_action(sfa, OVS_KEY_ATTR_TUNNEL_INFO, NULL,\par
 1787              sizeof(*tun_info) + key.tun_opts_len, log);\par
 1788     if (IS_ERR(a))\par
 1789         return PTR_ERR(a);\par
 1790 \par
 1791     tun_info = nla_data(a);\par
 1792     tun_info->tunnel = key.tun_key;\par
 1793     tun_info->options_len = key.tun_opts_len;\par
 1794 \par
 1795     if (tun_info->options_len) \{\par
 1796         /* We need to store the options in the action itself since\par
 1797          * everything else will go away after flow setup. We can append\par
 1798          * it to tun_info and then point there.\par
 1799          */\par
 1800         memcpy((tun_info + 1),\par
 1801                TUN_METADATA_OPTS(&key, key.tun_opts_len), key.tun_opts_len);\par
 1802         tun_info->options = (tun_info + 1);\par
 1803     \} else \{\par
 1804         tun_info->options = NULL;\par
 1805     \}\par
 1806 \par
 1807     add_nested_action_end(*sfa, start);\par
 1808 \par
 1809     return err;\par
 1810 \}\par
}
}
{\xe \v validate_geneve_opts\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_geneve_opts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_geneve_opts (struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1728 \{\par
 1729     struct geneve_opt *option;\par
 1730     int opts_len = key->tun_opts_len;\par
 1731     bool crit_opt = false;\par
 1732 \par
 1733     option = (struct geneve_opt *)TUN_METADATA_OPTS(key, key->tun_opts_len);\par
 1734     while (opts_len > 0) \{\par
 1735         int len;\par
 1736 \par
 1737         if (opts_len < sizeof(*option))\par
 1738             return -EINVAL;\par
 1739 \par
 1740         len = sizeof(*option) + option->length * 4;\par
 1741         if (len > opts_len)\par
 1742             return -EINVAL;\par
 1743 \par
 1744         crit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);\par
 1745 \par
 1746         option = (struct geneve_opt *)((u8 *)option + len);\par
 1747         opts_len -= len;\par
 1748     \};\par
 1749 \par
 1750     key->tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;\par
 1751 \par
 1752     return 0;\par
 1753 \}\par
}
}
{\xe \v validate_masked\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_masked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} validate_masked (u8 *  {\i data}, int  {\i len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1816 \{\par
 1817     u8 *mask = data + len;\par
 1818 \par
 1819     while (len--)\par
 1820         if (*data++ & ~*mask++)\par
 1821             return false;\par
 1822 \par
 1823     return true;\par
 1824 \}\par
}
}
{\xe \v validate_set\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_set (const struct nlattr *  {\i a}, const struct {\b sw_flow_key} *  {\i flow_key}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool} *  {\i skip_copy}, __be16  {\i eth_type}, {\b bool}  {\i masked}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1830 \{\par
 1831     const struct nlattr *ovs_key = nla_data(a);\par
 1832     int key_type = nla_type(ovs_key);\par
 1833     size_t key_len;\par
 1834 \par
 1835     /* There can be only one key in a action */\par
 1836     if (nla_total_size(nla_len(ovs_key)) != nla_len(a))\par
 1837         return -EINVAL;\par
 1838 \par
 1839     key_len = nla_len(ovs_key);\par
 1840     if (masked)\par
 1841         key_len /= 2;\par
 1842 \par
 1843     if (key_type > OVS_KEY_ATTR_MAX ||\par
 1844         (ovs_key_lens[key_type].len != key_len &&\par
 1845          ovs_key_lens[key_type].len != OVS_ATTR_NESTED))\par
 1846         return -EINVAL;\par
 1847 \par
 1848     if (masked && !validate_masked(nla_data(ovs_key), key_len))\par
 1849         return -EINVAL;\par
 1850 \par
 1851     switch (key_type) \{\par
 1852     const struct ovs_key_ipv4 *ipv4_key;\par
 1853     const struct ovs_key_ipv6 *ipv6_key;\par
 1854     int err;\par
 1855 \par
 1856     case OVS_KEY_ATTR_PRIORITY:\par
 1857     case OVS_KEY_ATTR_SKB_MARK:\par
 1858     case OVS_KEY_ATTR_ETHERNET:\par
 1859         break;\par
 1860 \par
 1861     case OVS_KEY_ATTR_TUNNEL:\par
 1862         if (eth_p_mpls(eth_type))\par
 1863             return -EINVAL;\par
 1864 \par
 1865         if (masked)\par
 1866             return -EINVAL; /* Masked tunnel set not supported. */\par
 1867 \par
 1868         *skip_copy = true;\par
 1869         err = validate_and_copy_set_tun(a, sfa, log);\par
 1870         if (err)\par
 1871             return err;\par
 1872         break;\par
 1873 \par
 1874     case OVS_KEY_ATTR_IPV4:\par
 1875         if (eth_type != htons(ETH_P_IP))\par
 1876             return -EINVAL;\par
 1877 \par
 1878         ipv4_key = nla_data(ovs_key);\par
 1879 \par
 1880         if (masked) \{\par
 1881             const struct ovs_key_ipv4 *mask = ipv4_key + 1;\par
 1882 \par
 1883             /* Non-writeable fields. */\par
 1884             if (mask->ipv4_proto || mask->ipv4_frag)\par
 1885                 return -EINVAL;\par
 1886         \} else \{\par
 1887             if (ipv4_key->ipv4_proto != flow_key->ip.proto)\par
 1888                 return -EINVAL;\par
 1889 \par
 1890             if (ipv4_key->ipv4_frag != flow_key->ip.frag)\par
 1891                 return -EINVAL;\par
 1892         \}\par
 1893         break;\par
 1894 \par
 1895     case OVS_KEY_ATTR_IPV6:\par
 1896         if (eth_type != htons(ETH_P_IPV6))\par
 1897             return -EINVAL;\par
 1898 \par
 1899         ipv6_key = nla_data(ovs_key);\par
 1900 \par
 1901         if (masked) \{\par
 1902             const struct ovs_key_ipv6 *mask = ipv6_key + 1;\par
 1903 \par
 1904             /* Non-writeable fields. */\par
 1905             if (mask->ipv6_proto || mask->ipv6_frag)\par
 1906                 return -EINVAL;\par
 1907 \par
 1908             /* Invalid bits in the flow label mask? */\par
 1909             if (ntohl(mask->ipv6_label) & 0xFFF00000)\par
 1910                 return -EINVAL;\par
 1911         \} else \{\par
 1912             if (ipv6_key->ipv6_proto != flow_key->ip.proto)\par
 1913                 return -EINVAL;\par
 1914 \par
 1915             if (ipv6_key->ipv6_frag != flow_key->ip.frag)\par
 1916                 return -EINVAL;\par
 1917         \}\par
 1918         if (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\par
 1919             return -EINVAL;\par
 1920 \par
 1921         break;\par
 1922 \par
 1923     case OVS_KEY_ATTR_TCP:\par
 1924         if ((eth_type != htons(ETH_P_IP) &&\par
 1925              eth_type != htons(ETH_P_IPV6)) ||\par
 1926             flow_key->ip.proto != IPPROTO_TCP)\par
 1927             return -EINVAL;\par
 1928 \par
 1929         break;\par
 1930 \par
 1931     case OVS_KEY_ATTR_UDP:\par
 1932         if ((eth_type != htons(ETH_P_IP) &&\par
 1933              eth_type != htons(ETH_P_IPV6)) ||\par
 1934             flow_key->ip.proto != IPPROTO_UDP)\par
 1935             return -EINVAL;\par
 1936 \par
 1937         break;\par
 1938 \par
 1939     case OVS_KEY_ATTR_MPLS:\par
 1940         if (!eth_p_mpls(eth_type))\par
 1941             return -EINVAL;\par
 1942         break;\par
 1943 \par
 1944     case OVS_KEY_ATTR_SCTP:\par
 1945         if ((eth_type != htons(ETH_P_IP) &&\par
 1946              eth_type != htons(ETH_P_IPV6)) ||\par
 1947             flow_key->ip.proto != IPPROTO_SCTP)\par
 1948             return -EINVAL;\par
 1949 \par
 1950         break;\par
 1951 \par
 1952     default:\par
 1953         return -EINVAL;\par
 1954     \}\par
 1955 \par
 1956     /* Convert non-masked non-tunnel set actions to masked set actions. */\par
 1957     if (!masked && key_type != OVS_KEY_ATTR_TUNNEL) \{\par
 1958         int start, len = key_len * 2;\par
 1959         struct nlattr *at;\par
 1960 \par
 1961         *skip_copy = true;\par
 1962 \par
 1963         start = add_nested_action_start(sfa,\par
 1964                         OVS_ACTION_ATTR_SET_TO_MASKED,\par
 1965                         log);\par
 1966         if (start < 0)\par
 1967             return start;\par
 1968 \par
 1969         at = __add_action(sfa, key_type, NULL, len, log);\par
 1970         if (IS_ERR(at))\par
 1971             return PTR_ERR(at);\par
 1972 \par
 1973         memcpy(nla_data(at), nla_data(ovs_key), key_len); /* Key. */\par
 1974         memset(nla_data(at) + key_len, 0xff, key_len);    /* Mask. */\par
 1975         /* Clear non-writeable bits from otherwise writeable fields. */\par
 1976         if (key_type == OVS_KEY_ATTR_IPV6) \{\par
 1977             struct ovs_key_ipv6 *mask = nla_data(at) + key_len;\par
 1978 \par
 1979             mask->ipv6_label &= htonl(0x000FFFFF);\par
 1980         \}\par
 1981         add_nested_action_end(*sfa, start);\par
 1982     \}\par
 1983 \par
 1984     return 0;\par
 1985 \}\par
}
}
{\xe \v validate_userspace\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:validate_userspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int validate_userspace (const struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1988 \{\par
 1989     static const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = \{\par
 1990         [OVS_USERSPACE_ATTR_PID] = \{.type = NLA_U32 \},\par
 1991         [OVS_USERSPACE_ATTR_USERDATA] = \{.type = NLA_UNSPEC \},\par
 1992         [OVS_USERSPACE_ATTR_EGRESS_TUN_PORT] = \{.type = NLA_U32 \},\par
 1993     \};\par
 1994     struct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\par
 1995     int error;\par
 1996 \par
 1997     error = nla_parse_nested(a, OVS_USERSPACE_ATTR_MAX,\par
 1998                  attr, userspace_policy);\par
 1999     if (error)\par
 2000         return error;\par
 2001 \par
 2002     if (!a[OVS_USERSPACE_ATTR_PID] ||\par
 2003         !nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\par
 2004         return -EINVAL;\par
 2005 \par
 2006     return 0;\par
 2007 \}\par
}
}
{\xe \v vxlan_opt_to_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:vxlan_opt_to_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_opt_to_nlattr (struct sk_buff *  {\i skb}, const void *  {\i tun_opts}, int  {\i swkey_tun_opts_len}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   628 \{\par
  629     const struct ovs_vxlan_opts *opts = tun_opts;\par
  630     struct nlattr *nla;\par
  631 \par
  632     nla = nla_nest_start(skb, OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS);\par
  633     if (!nla)\par
  634         return -EMSGSIZE;\par
  635 \par
  636     if (nla_put_u32(skb, OVS_VXLAN_EXT_GBP, opts->gbp) < 0)\par
  637         return -EMSGSIZE;\par
  638 \par
  639     nla_nest_end(skb, nla);\par
  640     return 0;\par
  641 \}\par
}
}
{\xe \v vxlan_tun_opt_from_nlattr\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:vxlan_tun_opt_from_nlattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_tun_opt_from_nlattr (const struct nlattr *  {\i a}, struct {\b sw_flow_match} *  {\i match}, {\b bool}  {\i is_mask}, {\b bool}  {\i log}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   475 \{\par
  476     struct nlattr *tb[OVS_VXLAN_EXT_MAX+1];\par
  477     unsigned long opt_key_offset;\par
  478     struct ovs_vxlan_opts opts;\par
  479     int err;\par
  480 \par
  481     BUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));\par
  482 \par
  483     err = nla_parse_nested(tb, OVS_VXLAN_EXT_MAX, a, vxlan_opt_policy);\par
  484     if (err < 0)\par
  485         return err;\par
  486 \par
  487     memset(&opts, 0, sizeof(opts));\par
  488 \par
  489     if (tb[OVS_VXLAN_EXT_GBP])\par
  490         opts.gbp = nla_get_u32(tb[OVS_VXLAN_EXT_GBP]);\par
  491 \par
  492     if (!is_mask)\par
  493         SW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);\par
  494     else\par
  495         SW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\par
  496 \par
  497     opt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));\par
  498     SW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),\par
  499                   is_mask);\par
  500     return 0;\par
  501 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_key_lens\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_key_lens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_len_tbl} ovs_key_lens[{\b OVS_KEY_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_KEY_ATTR_ENCAP]     = \{ .len = OVS_ATTR_NESTED \},\par
    [OVS_KEY_ATTR_PRIORITY]  = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_IN_PORT]   = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_SKB_MARK]  = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_ETHERNET]  = \{ .len = sizeof(struct ovs_key_ethernet) \},\par
    [OVS_KEY_ATTR_VLAN]  = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_ETHERTYPE] = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_IPV4]  = \{ .len = sizeof(struct ovs_key_ipv4) \},\par
    [OVS_KEY_ATTR_IPV6]  = \{ .len = sizeof(struct ovs_key_ipv6) \},\par
    [OVS_KEY_ATTR_TCP]   = \{ .len = sizeof(struct ovs_key_tcp) \},\par
    [OVS_KEY_ATTR_TCP_FLAGS] = \{ .len = sizeof(__be16) \},\par
    [OVS_KEY_ATTR_UDP]   = \{ .len = sizeof(struct ovs_key_udp) \},\par
    [OVS_KEY_ATTR_SCTP]  = \{ .len = sizeof(struct ovs_key_sctp) \},\par
    [OVS_KEY_ATTR_ICMP]  = \{ .len = sizeof(struct ovs_key_icmp) \},\par
    [OVS_KEY_ATTR_ICMPV6]    = \{ .len = sizeof(struct ovs_key_icmpv6) \},\par
    [OVS_KEY_ATTR_ARP]   = \{ .len = sizeof(struct ovs_key_arp) \},\par
    [OVS_KEY_ATTR_ND]    = \{ .len = sizeof(struct ovs_key_nd) \},\par
    [OVS_KEY_ATTR_RECIRC_ID] = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_DP_HASH]   = \{ .len = sizeof(u32) \},\par
    [OVS_KEY_ATTR_TUNNEL]    = \{ .len = OVS_ATTR_NESTED,\par
                     .next = ovs_tunnel_key_lens, \},\par
    [OVS_KEY_ATTR_MPLS]  = \{ .len = sizeof(struct ovs_key_mpls) \},\par
\}\par
}
}
{\xe \v ovs_tunnel_key_lens\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:ovs_tunnel_key_lens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct {\b ovs_len_tbl} ovs_tunnel_key_lens[{\b OVS_TUNNEL_KEY_ATTR_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_TUNNEL_KEY_ATTR_ID]        = \{ .len = sizeof(u64) \},\par
    [OVS_TUNNEL_KEY_ATTR_IPV4_SRC]      = \{ .len = sizeof(u32) \},\par
    [OVS_TUNNEL_KEY_ATTR_IPV4_DST]      = \{ .len = sizeof(u32) \},\par
    [OVS_TUNNEL_KEY_ATTR_TOS]       = \{ .len = 1 \},\par
    [OVS_TUNNEL_KEY_ATTR_TTL]       = \{ .len = 1 \},\par
    [OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT] = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_CSUM]      = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_TP_SRC]        = \{ .len = sizeof(u16) \},\par
    [OVS_TUNNEL_KEY_ATTR_TP_DST]        = \{ .len = sizeof(u16) \},\par
    [OVS_TUNNEL_KEY_ATTR_OAM]       = \{ .len = 0 \},\par
    [OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS]   = \{ .len = OVS_ATTR_NESTED \},\par
    [OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS]    = \{ .len = OVS_ATTR_NESTED \},\par
\}\par
}
}
{\xe \v vxlan_opt_policy\:linux/flow_netlink.c}
{\xe \v linux/flow_netlink.c\:vxlan_opt_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy vxlan_opt_policy[{\b OVS_VXLAN_EXT_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VXLAN_EXT_GBP] = \{ .type = NLA_U32 \},\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow_netlink.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow_netlink.h}
{\xe \v /home/vladn/git/ovs/datapath/flow_netlink.h}
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/in6.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/time.h>}\par
{\f2 #include <linux/flex_array.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include "flow.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_netlink.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__netlink_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__netlink_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_tun_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ovs_key_attr_size} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_match_init} (struct {\b sw_flow_match} *match, struct {\b sw_flow_key} *key, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_key} (const struct {\b sw_flow_key} *, const struct {\b sw_flow_key} *, int attr, {\b bool} is_mask, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_flow_metadata} (const struct nlattr *, struct {\b sw_flow_key} *, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_identifier} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_masked_key} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_mask} (const struct {\b sw_flow} *flow, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_match} (struct {\b sw_flow_match} *, const struct nlattr *key, const struct nlattr *mask, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_egress_tunnel_key} (struct sk_buff *, const struct {\b ovs_tunnel_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_nla_get_ufid} (struct {\b sw_flow_id} *, const struct nlattr *, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_get_identifier} (struct {\b sw_flow_id} *sfid, const struct nlattr *ufid, const struct {\b sw_flow_key} *key, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_nla_get_ufid_flags} (const struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_copy_actions} (const struct nlattr *attr, const struct {\b sw_flow_key} *key, struct {\b sw_flow_actions} **sfa, {\b bool} log)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_nla_put_actions} (const struct nlattr *attr, int len, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_nla_free_flow_actions} (struct {\b sw_flow_actions} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_key_attr_size\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   280 \{\par
  281     /* Whenever adding new OVS_KEY_ FIELDS, we should consider\par
  282      * updating this function.\par
  283      */\par
  284     BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 22);\par
  285 \par
  286     return    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */\par
  287         + nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */\par
  288           + ovs_tun_key_attr_size()\par
  289         + nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */\par
  290         + nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */\par
  291         + nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */\par
  292         + nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */\par
  293         + nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */\par
  294         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  295         + nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */\par
  296         + nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */\par
  297         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */\par
  298         + nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */\par
  299         + nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */\par
  300         + nla_total_size(28); /* OVS_KEY_ATTR_ND */\par
  301 \}\par
}
}
{\xe \v ovs_match_init\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_match_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_match_init (struct {\b sw_flow_match} *  {\i match}, struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1714 \{\par
 1715     memset(match, 0, sizeof(*match));\par
 1716     match->key = key;\par
 1717     match->mask = mask;\par
 1718 \par
 1719     memset(key, 0, sizeof(*key));\par
 1720 \par
 1721     if (mask) \{\par
 1722         memset(&mask->key, 0, sizeof(mask->key));\par
 1723         mask->range.start = mask->range.end = 0;\par
 1724     \}\par
 1725 \}\par
}
}
{\xe \v ovs_nla_copy_actions\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_copy_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_copy_actions (const struct nlattr *  {\i attr}, const struct {\b sw_flow_key} *  {\i key}, struct {\b sw_flow_actions} **  {\i sfa}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2182 \{\par
 2183     int err;\par
 2184 \par
 2185     *sfa = nla_alloc_flow_actions(nla_len(attr), log);\par
 2186     if (IS_ERR(*sfa))\par
 2187         return PTR_ERR(*sfa);\par
 2188 \par
 2189     err = __ovs_nla_copy_actions(attr, key, 0, sfa, key->eth.type,\par
 2190                      key->eth.tci, log);\par
 2191     if (err)\par
 2192         kfree(*sfa);\par
 2193 \par
 2194     return err;\par
 2195 \}\par
}
}
{\xe \v ovs_nla_free_flow_actions\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_free_flow_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_nla_free_flow_actions (struct {\b sw_flow_actions} * )}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1563 \{\par
 1564     call_rcu(&sf_acts->rcu, rcu_free_acts_callback);\par
 1565 \}\par
}
}
{\xe \v ovs_nla_get_flow_metadata\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_get_flow_metadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_flow_metadata (const struct nlattr *  {\i attr}, struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key. : Receives extracted in_port, priority, tun_key and skb_mark. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging.\par
This parses a series of Netlink attributes that form a flow key, which must take the same form accepted by flow_from_nlattrs(), but only enough of it to get the metadata, that is, the parts of the flow key that cannot be extracted from the packet itself. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1255 \{\par
 1256     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1257     struct sw_flow_match match;\par
 1258     u64 attrs = 0;\par
 1259     int err;\par
 1260 \par
 1261     err = parse_flow_nlattrs(attr, a, &attrs, log);\par
 1262     if (err)\par
 1263         return -EINVAL;\par
 1264 \par
 1265     memset(&match, 0, sizeof(match));\par
 1266     match.key = key;\par
 1267 \par
 1268     memset(key, 0, OVS_SW_FLOW_KEY_METADATA_SIZE);\par
 1269     key->phy.in_port = DP_MAX_PORTS;\par
 1270 \par
 1271     return metadata_from_nlattrs(&match, &attrs, a, false, log);\par
 1272 \}\par
}
}
{\xe \v ovs_nla_get_identifier\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_get_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_identifier (struct {\b sw_flow_id} *  {\i sfid}, const struct nlattr *  {\i ufid}, const struct {\b sw_flow_key} *  {\i key}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1216 \{\par
 1217     struct sw_flow_key *new_key;\par
 1218 \par
 1219     if (ovs_nla_get_ufid(sfid, ufid, log))\par
 1220         return 0;\par
 1221 \par
 1222     /* If UFID was not provided, use unmasked key. */\par
 1223     new_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\par
 1224     if (!new_key)\par
 1225         return -ENOMEM;\par
 1226     memcpy(new_key, key, sizeof(*key));\par
 1227     sfid->unmasked_key = new_key;\par
 1228 \par
 1229     return 0;\par
 1230 \}\par
}
}
{\xe \v ovs_nla_get_match\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_get_match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_get_match (struct {\b sw_flow_match} *  {\i match}, const struct nlattr *  {\i nla_key}, const struct nlattr *  {\i nla_mask}, {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_nla_get_match - parses Netlink attributes into a flow key and mask. In case the 'mask' is NULL, the flow is treated as exact match flow. Otherwise, it is treated as a wildcarded flow, except the mask does not include any don't care bit. : receives the extracted flow match information. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence. The fields should of the packet that triggered the creation of this flow. : Optional. Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute specifies the mask field of the wildcarded flow. : Boolean to allow kernel error logging. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1045 \{\par
 1046     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\par
 1047     const struct nlattr *encap;\par
 1048     struct nlattr *newmask = NULL;\par
 1049     u64 key_attrs = 0;\par
 1050     u64 mask_attrs = 0;\par
 1051     bool encap_valid = false;\par
 1052     int err;\par
 1053 \par
 1054     err = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\par
 1055     if (err)\par
 1056         return err;\par
 1057 \par
 1058     if ((key_attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&\par
 1059         (key_attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) &&\par
 1060         (nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) \{\par
 1061         __be16 tci;\par
 1062 \par
 1063         if (!((key_attrs & (1ULL << OVS_KEY_ATTR_VLAN)) &&\par
 1064               (key_attrs & (1ULL << OVS_KEY_ATTR_ENCAP)))) \{\par
 1065             OVS_NLERR(log, "Invalid Vlan frame.");\par
 1066             return -EINVAL;\par
 1067         \}\par
 1068 \par
 1069         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1070         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1071         encap = a[OVS_KEY_ATTR_ENCAP];\par
 1072         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1073         encap_valid = true;\par
 1074 \par
 1075         if (tci & htons(VLAN_TAG_PRESENT)) \{\par
 1076             err = parse_flow_nlattrs(encap, a, &key_attrs, log);\par
 1077             if (err)\par
 1078                 return err;\par
 1079         \} else if (!tci) \{\par
 1080             /* Corner case for truncated 802.1Q header. */\par
 1081             if (nla_len(encap)) \{\par
 1082                 OVS_NLERR(log, "Truncated 802.1Q header has non-zero encap attribute.");\par
 1083                 return -EINVAL;\par
 1084             \}\par
 1085         \} else \{\par
 1086             OVS_NLERR(log, "Encap attr is set for non-VLAN frame");\par
 1087             return  -EINVAL;\par
 1088         \}\par
 1089     \}\par
 1090 \par
 1091     err = ovs_key_from_nlattrs(match, key_attrs, a, false, log);\par
 1092     if (err)\par
 1093         return err;\par
 1094 \par
 1095     if (match->mask) \{\par
 1096         if (!nla_mask) \{\par
 1097             /* Create an exact match mask. We need to set to 0xff\par
 1098              * all the 'match->mask' fields that have been touched\par
 1099              * in 'match->key'. We cannot simply memset\par
 1100              * 'match->mask', because padding bytes and fields not\par
 1101              * specified in 'match->key' should be left to 0.\par
 1102              * Instead, we use a stream of netlink attributes,\par
 1103              * copied from 'key' and set to 0xff.\par
 1104              * ovs_key_from_nlattrs() will take care of filling\par
 1105              * 'match->mask' appropriately.\par
 1106              */\par
 1107             newmask = kmemdup(nla_key,\par
 1108                       nla_total_size(nla_len(nla_key)),\par
 1109                       GFP_KERNEL);\par
 1110             if (!newmask)\par
 1111                 return -ENOMEM;\par
 1112 \par
 1113             mask_set_nlattr(newmask, 0xff);\par
 1114 \par
 1115             /* The userspace does not send tunnel attributes that\par
 1116              * are 0, but we should not wildcard them nonetheless.\par
 1117              */\par
 1118             if (match->key->tun_key.ipv4_dst)\par
 1119                 SW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\par
 1120                              0xff, true);\par
 1121 \par
 1122             nla_mask = newmask;\par
 1123         \}\par
 1124 \par
 1125         err = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\par
 1126         if (err)\par
 1127             goto free_newmask;\par
 1128 \par
 1129         /* Always match on tci. */\par
 1130         SW_FLOW_KEY_PUT(match, eth.tci, htons(0xffff), true);\par
 1131 \par
 1132         if (mask_attrs & 1ULL << OVS_KEY_ATTR_ENCAP) \{\par
 1133             __be16 eth_type = 0;\par
 1134             __be16 tci = 0;\par
 1135 \par
 1136             if (!encap_valid) \{\par
 1137                 OVS_NLERR(log, "Encap mask attribute is set for non-VLAN frame.");\par
 1138                 err = -EINVAL;\par
 1139                 goto free_newmask;\par
 1140             \}\par
 1141 \par
 1142             mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);\par
 1143             if (a[OVS_KEY_ATTR_ETHERTYPE])\par
 1144                 eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\par
 1145 \par
 1146             if (eth_type == htons(0xffff)) \{\par
 1147                 mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);\par
 1148                 encap = a[OVS_KEY_ATTR_ENCAP];\par
 1149                 err = parse_flow_mask_nlattrs(encap, a,\par
 1150                                   &mask_attrs, log);\par
 1151                 if (err)\par
 1152                     goto free_newmask;\par
 1153             \} else \{\par
 1154                 OVS_NLERR(log, "VLAN frames must have an exact match on the TPID (mask=%x).",\par
 1155                       ntohs(eth_type));\par
 1156                 err = -EINVAL;\par
 1157                 goto free_newmask;\par
 1158             \}\par
 1159 \par
 1160             if (a[OVS_KEY_ATTR_VLAN])\par
 1161                 tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\par
 1162 \par
 1163             if (!(tci & htons(VLAN_TAG_PRESENT))) \{\par
 1164                 OVS_NLERR(log, "VLAN tag present bit must have an exact match (tci_mask=%x).",\par
 1165                       ntohs(tci));\par
 1166                 err = -EINVAL;\par
 1167                 goto free_newmask;\par
 1168             \}\par
 1169         \}\par
 1170 \par
 1171         err = ovs_key_from_nlattrs(match, mask_attrs, a, true, log);\par
 1172         if (err)\par
 1173             goto free_newmask;\par
 1174     \}\par
 1175 \par
 1176     if (!match_validate(match, key_attrs, mask_attrs, log))\par
 1177         err = -EINVAL;\par
 1178 \par
 1179 free_newmask:\par
 1180     kfree(newmask);\par
 1181     return err;\par
 1182 \}\par
}
}
{\xe \v ovs_nla_get_ufid\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_get_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_nla_get_ufid (struct {\b sw_flow_id} * , const struct nlattr * , {\b bool}  {\i log})}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1206 \{\par
 1207     sfid->ufid_len = get_ufid_len(attr, log);\par
 1208     if (sfid->ufid_len)\par
 1209         memcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\par
 1210 \par
 1211     return sfid->ufid_len;\par
 1212 \}\par
}
}
{\xe \v ovs_nla_get_ufid_flags\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_get_ufid_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_nla_get_ufid_flags (const struct nlattr *  {\i attr})}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1233 \{\par
 1234     return attr ? nla_get_u32(attr) : 0;\par
 1235 \}\par
}
}
{\xe \v ovs_nla_put_actions\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_actions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_actions (const struct nlattr *  {\i attr}, int  {\i len}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2282 \{\par
 2283     const struct nlattr *a;\par
 2284     int rem, err;\par
 2285 \par
 2286     nla_for_each_attr(a, attr, len, rem) \{\par
 2287         int type = nla_type(a);\par
 2288 \par
 2289         switch (type) \{\par
 2290         case OVS_ACTION_ATTR_SET:\par
 2291             err = set_action_to_attr(a, skb);\par
 2292             if (err)\par
 2293                 return err;\par
 2294             break;\par
 2295 \par
 2296         case OVS_ACTION_ATTR_SET_TO_MASKED:\par
 2297             err = masked_set_action_to_set_action_attr(a, skb);\par
 2298             if (err)\par
 2299                 return err;\par
 2300             break;\par
 2301 \par
 2302         case OVS_ACTION_ATTR_SAMPLE:\par
 2303             err = sample_action_to_attr(a, skb);\par
 2304             if (err)\par
 2305                 return err;\par
 2306             break;\par
 2307         default:\par
 2308             if (nla_put(skb, type, nla_len(a), nla_data(a)))\par
 2309                 return -EMSGSIZE;\par
 2310             break;\par
 2311         \}\par
 2312     \}\par
 2313 \par
 2314     return 0;\par
 2315 \}\par
}
}
{\xe \v ovs_nla_put_egress_tunnel_key\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_egress_tunnel_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_egress_tunnel_key (struct sk_buff * , const struct {\b ovs_tunnel_info} * )}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   710 \{\par
  711     return __ipv4_tun_to_nlattr(skb, &egress_tun_info->tunnel,\par
  712                     egress_tun_info->options,\par
  713                     egress_tun_info->options_len);\par
  714 \}\par
}
}
{\xe \v ovs_nla_put_identifier\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_identifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_identifier (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1509 \{\par
 1510     if (ovs_identifier_is_ufid(&flow->id))\par
 1511         return nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\par
 1512                    flow->id.ufid);\par
 1513 \par
 1514     return ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\par
 1515                    OVS_FLOW_ATTR_KEY, false, skb);\par
 1516 \}\par
}
}
{\xe \v ovs_nla_put_key\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_key (const struct {\b sw_flow_key} * , const struct {\b sw_flow_key} * , int  {\i attr}, {\b bool}  {\i is_mask}, struct sk_buff * )}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1492 \{\par
 1493     int err;\par
 1494     struct nlattr *nla;\par
 1495 \par
 1496     nla = nla_nest_start(skb, attr);\par
 1497     if (!nla)\par
 1498         return -EMSGSIZE;\par
 1499     err = __ovs_nla_put_key(swkey, output, is_mask, skb);\par
 1500     if (err)\par
 1501         return err;\par
 1502     nla_nest_end(skb, nla);\par
 1503 \par
 1504     return 0;\par
 1505 \}\par
}
}
{\xe \v ovs_nla_put_mask\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_mask (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1527 \{\par
 1528     return ovs_nla_put_key(&flow->key, &flow->mask->key,\par
 1529                 OVS_FLOW_ATTR_MASK, true, skb);\par
 1530 \}\par
}
}
{\xe \v ovs_nla_put_masked_key\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_nla_put_masked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_nla_put_masked_key (const struct {\b sw_flow} *  {\i flow}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1520 \{\par
 1521     return ovs_nla_put_key(&flow->key, &flow->key,\par
 1522                 OVS_FLOW_ATTR_KEY, false, skb);\par
 1523 \}\par
}
}
{\xe \v ovs_tun_key_attr_size\:flow_netlink.h}
{\xe \v flow_netlink.h\:ovs_tun_key_attr_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t ovs_tun_key_attr_size (void )}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   259 \{\par
  260     /* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider\par
  261      * updating this function.\par
  262      */\par
  263     return    nla_total_size(8)    /* OVS_TUNNEL_KEY_ATTR_ID */\par
  264         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_SRC */\par
  265         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_DST */\par
  266         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */\par
  267         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */\par
  268         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */\par
  269         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */\par
  270         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */\par
  271         + nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */\par
  272         /* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS is mutually exclusive with\par
  273          * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it.\par
  274          */\par
  275         + nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */\par
  276         + nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */\par
  277 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow_table.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow_table.c}
{\xe \v /home/vladn/git/ovs/datapath/flow_table.c}
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "flow.h"}\par
{\f2 #include "datapath.h"}\par
{\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_table.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__table_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TBL_MIN_BUCKETS}\~ 1024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MASK_ARRAY_SIZE_MIN}\~ 16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REHASH_INTERVAL}\~ (10 * 60 * HZ)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_SHIFT}\~ 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_ENTRIES}\~ (1u << MC_HASH_SHIFT)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_SEGS}\~ ((sizeof(uint32_t) * 8) / {\b MC_HASH_SHIFT})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u16 {\b range_n_bytes} (const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_mask_key} (struct {\b sw_flow_key} *{\b dst}, const struct {\b sw_flow_key} *{\b src}, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_alloc} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_count} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct flex_array * {\b alloc_buckets} (unsigned int n_buckets)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_free} (struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_flow_callback} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_sw_flow_mask_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_free} (struct {\b sw_flow} *flow, {\b bool} deferred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_buckets} (struct flex_array *buckets)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __table_instance_destroy} (struct {\b table_instance} *ti)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_alloc} (int new_size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_array_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b mask_array} * {\b tbl_mask_array_alloc} (int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b tbl_mask_array_realloc} (struct {\b flow_table} *tbl, int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_init} (struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_tbl_destroy_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b table_instance_destroy} (struct {\b table_instance} *ti, struct {\b table_instance} *ufid_ti, {\b bool} deferred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_destroy} (struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_dump_next} (struct {\b table_instance} *ti, u32 *bucket, u32 *last)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b find_bucket} (struct {\b table_instance} *ti, u32 hash)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b table_instance_insert} (struct {\b table_instance} *ti, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ufid_table_instance_insert} (struct {\b table_instance} *ti, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_table_copy_flows} (struct {\b table_instance} *old, struct {\b table_instance} *new, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_rehash} (struct {\b table_instance} *ti, int n_buckets, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_flush} (struct {\b flow_table} *{\b flow_table})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u32 {\b flow_hash} (const struct {\b sw_flow_key} *key, const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b flow_key_start} (const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b cmp_key} (const struct {\b sw_flow_key} *key1, const struct {\b sw_flow_key} *key2, int key_start, int key_end)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b flow_cmp_masked_key} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_key} *key, const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_flow_cmp_unmasked_key} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow} * {\b masked_flow_lookup} (struct {\b table_instance} *ti, const struct {\b sw_flow_key} *unmasked, const struct {\b sw_flow_mask} *mask, u32 *n_mask_hit)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow} * {\b flow_lookup} (struct {\b flow_table} *tbl, struct {\b table_instance} *ti, const struct {\b mask_array} *ma, const struct {\b sw_flow_key} *key, u32 *n_mask_hit, u32 *index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_stats} (struct {\b flow_table} *tbl, const struct {\b sw_flow_key} *key, u32 skb_hash, u32 *n_mask_hit)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup} (struct {\b flow_table} *tbl, const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_exact} (struct {\b flow_table} *tbl, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u32 {\b ufid_hash} (const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_flow_cmp_ufid} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_flow_cmp} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_ufid} (struct {\b flow_table} *tbl, const struct {\b sw_flow_id} *ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_num_masks} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_expand} (struct {\b table_instance} *ti, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tbl_mask_array_delete_mask} (struct {\b mask_array} *ma, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_mask_remove} (struct {\b flow_table} *tbl, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_remove} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_mask} * {\b mask_alloc} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b mask_equal} (const struct {\b sw_flow_mask} *a, const struct {\b sw_flow_mask} *b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_mask} * {\b flow_mask_find} (const struct {\b flow_table} *tbl, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b flow_mask_insert} (struct {\b flow_table} *tbl, struct {\b sw_flow} *flow, const struct {\b sw_flow_mask} *new)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_key_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_ufid_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct kmem_cache * {\b flow_cache}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct kmem_cache *{\b flow_stats_cache} {\b __read_mostly}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MASK_ARRAY_SIZE_MIN\:flow_table.c}
{\xe \v flow_table.c\:MASK_ARRAY_SIZE_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MASK_ARRAY_SIZE_MIN\~ 16}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_ENTRIES\:flow_table.c}
{\xe \v flow_table.c\:MC_HASH_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_ENTRIES\~ (1u << MC_HASH_SHIFT)}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_SEGS\:flow_table.c}
{\xe \v flow_table.c\:MC_HASH_SEGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_SEGS\~ ((sizeof(uint32_t) * 8) / {\b MC_HASH_SHIFT})}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_SHIFT\:flow_table.c}
{\xe \v flow_table.c\:MC_HASH_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_SHIFT\~ 8}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REHASH_INTERVAL\:flow_table.c}
{\xe \v flow_table.c\:REHASH_INTERVAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REHASH_INTERVAL\~ (10 * 60 * HZ)}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TBL_MIN_BUCKETS\:flow_table.c}
{\xe \v flow_table.c\:TBL_MIN_BUCKETS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TBL_MIN_BUCKETS\~ 1024}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __table_instance_destroy\:flow_table.c}
{\xe \v flow_table.c\:__table_instance_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __table_instance_destroy (struct {\b table_instance} *  {\i ti}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194     free_buckets(ti->buckets);\par
  195     kfree(ti);\par
  196 \}\par
}
}
{\xe \v alloc_buckets\:flow_table.c}
{\xe \v flow_table.c\:alloc_buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct flex_array* alloc_buckets (unsigned int  {\i n_buckets}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   125 \{\par
  126     struct flex_array *buckets;\par
  127     int i, err;\par
  128 \par
  129     buckets = flex_array_alloc(sizeof(struct hlist_head),\par
  130                    n_buckets, GFP_KERNEL);\par
  131     if (!buckets)\par
  132         return NULL;\par
  133 \par
  134     err = flex_array_prealloc(buckets, 0, n_buckets, GFP_KERNEL);\par
  135     if (err) \{\par
  136         flex_array_free(buckets);\par
  137         return NULL;\par
  138     \}\par
  139 \par
  140     for (i = 0; i < n_buckets; i++)\par
  141         INIT_HLIST_HEAD((struct hlist_head *)\par
  142                     flex_array_get(buckets, i));\par
  143 \par
  144     return buckets;\par
  145 \}\par
}
}
{\xe \v cmp_key\:flow_table.c}
{\xe \v flow_table.c\:cmp_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} cmp_key (const struct {\b sw_flow_key} *  {\i key1}, const struct {\b sw_flow_key} *  {\i key2}, int  {\i key_start}, int  {\i key_end}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   517 \{\par
  518     const long *cp1 = (const long *)((const u8 *)key1 + key_start);\par
  519     const long *cp2 = (const long *)((const u8 *)key2 + key_start);\par
  520     long diffs = 0;\par
  521     int i;\par
  522 \par
  523     for (i = key_start; i < key_end;  i += sizeof(long))\par
  524         diffs |= *cp1++ ^ *cp2++;\par
  525 \par
  526     return diffs == 0;\par
  527 \}\par
}
}
{\xe \v find_bucket\:flow_table.c}
{\xe \v flow_table.c\:find_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* find_bucket (struct {\b table_instance} *  {\i ti}, u32  {\i hash}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   395 \{\par
  396     hash = jhash_1word(hash, ti->hash_seed);\par
  397     return flex_array_get(ti->buckets,\par
  398                 (hash & (ti->n_buckets - 1)));\par
  399 \}\par
}
}
{\xe \v flow_cmp_masked_key\:flow_table.c}
{\xe \v flow_table.c\:flow_cmp_masked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} flow_cmp_masked_key (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   532 \{\par
  533     return cmp_key(&flow->key, key, range->start, range->end);\par
  534 \}\par
}
}
{\xe \v flow_free\:flow_table.c}
{\xe \v flow_table.c\:flow_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_free (struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   148 \{\par
  149     int node;\par
  150 \par
  151     if (ovs_identifier_is_key(&flow->id))\par
  152         kfree(flow->id.unmasked_key);\par
  153     kfree(rcu_dereference_raw(flow->sf_acts));\par
  154     for_each_node(node)\par
  155         if (flow->stats[node])\par
  156             kmem_cache_free(flow_stats_cache,\par
  157                     rcu_dereference_raw(flow->stats[node]));\par
  158     kmem_cache_free(flow_cache, flow);\par
  159 \}\par
}
}
{\xe \v flow_hash\:flow_table.c}
{\xe \v flow_table.c\:flow_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u32 flow_hash (const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   493 \{\par
  494     int key_start = range->start;\par
  495     int key_end = range->end;\par
  496     const u32 *hash_key = (const u32 *)((const u8 *)key + key_start);\par
  497     int hash_u32s = (key_end - key_start) >> 2;\par
  498 \par
  499     /* Make sure number of hash bytes are multiple of u32. */\par
  500     BUILD_BUG_ON(sizeof(long) % sizeof(u32));\par
  501 \par
  502     return jhash2(hash_key, hash_u32s, 0);\par
  503 \}\par
}
}
{\xe \v flow_key_insert\:flow_table.c}
{\xe \v flow_table.c\:flow_key_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_key_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   922 \{\par
  923     struct table_instance *new_ti = NULL;\par
  924     struct table_instance *ti;\par
  925 \par
  926     flow->flow_table.hash = flow_hash(&flow->key, &flow->mask->range);\par
  927     ti = ovsl_dereference(table->ti);\par
  928     table_instance_insert(ti, flow);\par
  929     table->count++;\par
  930 \par
  931     /* Expand table, if necessary, to make room. */\par
  932     if (table->count > ti->n_buckets)\par
  933         new_ti = table_instance_expand(ti, false);\par
  934     else if (time_after(jiffies, table->last_rehash + REHASH_INTERVAL))\par
  935         new_ti = table_instance_rehash(ti, ti->n_buckets, false);\par
  936 \par
  937     if (new_ti) \{\par
  938         rcu_assign_pointer(table->ti, new_ti);\par
  939         call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  940         table->last_rehash = jiffies;\par
  941     \}\par
  942 \}\par
}
}
{\xe \v flow_key_start\:flow_table.c}
{\xe \v flow_table.c\:flow_key_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int flow_key_start (const struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506 \{\par
  507     if (key->tun_key.ipv4_dst)\par
  508         return 0;\par
  509     else\par
  510         return rounddown(offsetof(struct sw_flow_key, phy),\par
  511                       sizeof(long));\par
  512 \}\par
}
}
{\xe \v flow_lookup\:flow_table.c}
{\xe \v flow_table.c\:flow_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow}* flow_lookup (struct {\b flow_table} *  {\i tbl}, struct {\b table_instance} *  {\i ti}, const struct {\b mask_array} *  {\i ma}, const struct {\b sw_flow_key} *  {\i key}, u32 *  {\i n_mask_hit}, u32 *  {\i index}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579     struct sw_flow_mask *mask;\par
  580     struct sw_flow *flow;\par
  581     int i;\par
  582 \par
  583     if (*index < ma->max) \{\par
  584         mask = rcu_dereference_ovsl(ma->masks[*index]);\par
  585         if (mask) \{\par
  586             flow = masked_flow_lookup(ti, key, mask, n_mask_hit);\par
  587             if (flow)\par
  588                 return flow;\par
  589         \}\par
  590     \}\par
  591 \par
  592     for (i = 0; i < ma->max; i++)  \{\par
  593 \par
  594         if (i == *index)\par
  595             continue;\par
  596 \par
  597         mask = rcu_dereference_ovsl(ma->masks[i]);\par
  598         if (!mask)\par
  599             continue;\par
  600 \par
  601         flow = masked_flow_lookup(ti, key, mask, n_mask_hit);\par
  602         if (flow) \{ /* Found */\par
  603             *index = i;\par
  604             return flow;\par
  605         \}\par
  606     \}\par
  607 \par
  608     return NULL;\par
  609 \}\par
}
}
{\xe \v flow_mask_find\:flow_table.c}
{\xe \v flow_table.c\:flow_mask_find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_mask}* flow_mask_find (const struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   851 \{\par
  852     struct mask_array *ma;\par
  853     int i;\par
  854 \par
  855     ma = ovsl_dereference(tbl->mask_array);\par
  856     for (i = 0; i < ma->max; i++) \{\par
  857         struct sw_flow_mask *t;\par
  858 \par
  859         t = ovsl_dereference(ma->masks[i]);\par
  860         if (t && mask_equal(mask, t))\par
  861             return t;\par
  862     \}\par
  863 \par
  864     return NULL;\par
  865 \}\par
}
}
{\xe \v flow_mask_insert\:flow_table.c}
{\xe \v flow_table.c\:flow_mask_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int flow_mask_insert (struct {\b flow_table} *  {\i tbl}, struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_mask} *  {\i new}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   870 \{\par
  871     struct sw_flow_mask *mask;\par
  872 \par
  873     mask = flow_mask_find(tbl, new);\par
  874     if (!mask) \{\par
  875         struct mask_array *ma;\par
  876         int i;\par
  877 \par
  878         /* Allocate a new mask if none exsits. */\par
  879         mask = mask_alloc();\par
  880         if (!mask)\par
  881             return -ENOMEM;\par
  882 \par
  883         mask->key = new->key;\par
  884         mask->range = new->range;\par
  885 \par
  886         /* Add mask to mask-list. */\par
  887         ma = ovsl_dereference(tbl->mask_array);\par
  888         if (ma->count >= ma->max) \{\par
  889             int err;\par
  890 \par
  891             err = tbl_mask_array_realloc(tbl, ma->max +\par
  892                               MASK_ARRAY_SIZE_MIN);\par
  893             if (err) \{\par
  894                 kfree(mask);\par
  895                 return err;\par
  896             \}\par
  897             ma = ovsl_dereference(tbl->mask_array);\par
  898         \}\par
  899 \par
  900         for (i = 0; i < ma->max; i++) \{\par
  901             struct sw_flow_mask *t;\par
  902 \par
  903             t = ovsl_dereference(ma->masks[i]);\par
  904             if (!t) \{\par
  905                 rcu_assign_pointer(ma->masks[i], mask);\par
  906                 ma->count++;\par
  907                 break;\par
  908             \}\par
  909         \}\par
  910 \par
  911     \} else \{\par
  912         BUG_ON(!mask->ref_count);\par
  913         mask->ref_count++;\par
  914     \}\par
  915 \par
  916     flow->mask = mask;\par
  917     return 0;\par
  918 \}\par
}
}
{\xe \v flow_mask_remove\:flow_table.c}
{\xe \v flow_table.c\:flow_mask_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_mask_remove (struct {\b flow_table} *  {\i tbl}, struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   783 \{\par
  784     if (mask) \{\par
  785         /* ovs-lock is required to protect mask-refcount and\par
  786          * mask list.\par
  787          */\par
  788         ASSERT_OVSL();\par
  789         BUG_ON(!mask->ref_count);\par
  790         mask->ref_count--;\par
  791 \par
  792         if (!mask->ref_count) \{\par
  793             struct mask_array *ma;\par
  794 \par
  795             ma = ovsl_dereference(tbl->mask_array);\par
  796             tbl_mask_array_delete_mask(ma, mask);\par
  797 \par
  798             /* Shrink the mask array if necessary. */\par
  799             if (ma->max >= (MASK_ARRAY_SIZE_MIN * 2) &&\par
  800                 ma->count <= (ma->max / 3))\par
  801                 tbl_mask_array_realloc(tbl, ma->max / 2);\par
  802 \par
  803         \}\par
  804     \}\par
  805 \}\par
}
}
{\xe \v flow_table_copy_flows\:flow_table.c}
{\xe \v flow_table.c\:flow_table_copy_flows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_table_copy_flows (struct {\b table_instance} *  {\i old}, struct {\b table_instance} *  {\i new}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   421 \{\par
  422     int old_ver;\par
  423     int i;\par
  424 \par
  425     old_ver = old->node_ver;\par
  426     new->node_ver = !old_ver;\par
  427 \par
  428     /* Insert in new table. */\par
  429     for (i = 0; i < old->n_buckets; i++) \{\par
  430         struct sw_flow *flow;\par
  431         struct hlist_head *head;\par
  432 \par
  433         head = flex_array_get(old->buckets, i);\par
  434 \par
  435         if (ufid)\par
  436             hlist_for_each_entry(flow, head,\par
  437                          ufid_table.node[old_ver])\par
  438                 ufid_table_instance_insert(new, flow);\par
  439         else\par
  440             hlist_for_each_entry(flow, head,\par
  441                          flow_table.node[old_ver])\par
  442                 table_instance_insert(new, flow);\par
  443     \}\par
  444 \par
  445     old->keep_flows = true;\par
  446 \}\par
}
}
{\xe \v flow_tbl_destroy_rcu_cb\:flow_table.c}
{\xe \v flow_table.c\:flow_tbl_destroy_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_tbl_destroy_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   310 \{\par
  311     struct table_instance *ti = container_of(rcu, struct table_instance, rcu);\par
  312 \par
  313     __table_instance_destroy(ti);\par
  314 \}\par
}
}
{\xe \v flow_ufid_insert\:flow_table.c}
{\xe \v flow_table.c\:flow_ufid_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_ufid_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   946 \{\par
  947     struct table_instance *ti;\par
  948 \par
  949     flow->ufid_table.hash = ufid_hash(&flow->id);\par
  950     ti = ovsl_dereference(table->ufid_ti);\par
  951     ufid_table_instance_insert(ti, flow);\par
  952     table->ufid_count++;\par
  953 \par
  954     /* Expand table, if necessary, to make room. */\par
  955     if (table->ufid_count > ti->n_buckets) \{\par
  956         struct table_instance *new_ti;\par
  957 \par
  958         new_ti = table_instance_expand(ti, true);\par
  959         if (new_ti) \{\par
  960             rcu_assign_pointer(table->ufid_ti, new_ti);\par
  961             call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  962         \}\par
  963     \}\par
  964 \}\par
}
}
{\xe \v free_buckets\:flow_table.c}
{\xe \v flow_table.c\:free_buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_buckets (struct flex_array *  {\i buckets}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   187 \{\par
  188     flex_array_free(buckets);\par
  189 \}\par
}
}
{\xe \v mask_alloc\:flow_table.c}
{\xe \v flow_table.c\:mask_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_mask}* mask_alloc (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   828 \{\par
  829     struct sw_flow_mask *mask;\par
  830 \par
  831     mask = kmalloc(sizeof(*mask), GFP_KERNEL);\par
  832     if (mask)\par
  833         mask->ref_count = 1;\par
  834 \par
  835     return mask;\par
  836 \}\par
}
}
{\xe \v mask_array_rcu_cb\:flow_table.c}
{\xe \v flow_table.c\:mask_array_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_array_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   220 \{\par
  221     struct mask_array *ma = container_of(rcu, struct mask_array, rcu);\par
  222 \par
  223     kfree(ma);\par
  224 \}\par
}
}
{\xe \v mask_equal\:flow_table.c}
{\xe \v flow_table.c\:mask_equal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} mask_equal (const struct {\b sw_flow_mask} *  {\i a}, const struct {\b sw_flow_mask} *  {\i b}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   840 \{\par
  841     const u8 *a_ = (const u8 *)&a->key + a->range.start;\par
  842     const u8 *b_ = (const u8 *)&b->key + b->range.start;\par
  843 \par
  844     return  (a->range.end == b->range.end)\par
  845         && (a->range.start == b->range.start)\par
  846         && (memcmp(a_, b_, range_n_bytes(&a->range)) == 0);\par
  847 \}\par
}
}
{\xe \v masked_flow_lookup\:flow_table.c}
{\xe \v flow_table.c\:masked_flow_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow}* masked_flow_lookup (struct {\b table_instance} *  {\i ti}, const struct {\b sw_flow_key} *  {\i unmasked}, const struct {\b sw_flow_mask} *  {\i mask}, u32 *  {\i n_mask_hit}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   551 \{\par
  552     struct sw_flow *flow;\par
  553     struct hlist_head *head;\par
  554     u32 hash;\par
  555     struct sw_flow_key masked_key;\par
  556 \par
  557     ovs_flow_mask_key(&masked_key, unmasked, mask);\par
  558     hash = flow_hash(&masked_key, &mask->range);\par
  559     head = find_bucket(ti, hash);\par
  560     (*n_mask_hit)++;\par
  561     hlist_for_each_entry_rcu(flow, head, flow_table.node[ti->node_ver]) \{\par
  562         if (flow->mask == mask && flow->flow_table.hash == hash &&\par
  563             flow_cmp_masked_key(flow, &masked_key, &mask->range))\par
  564             return flow;\par
  565     \}\par
  566     return NULL;\par
  567 \}\par
}
}
{\xe \v ovs_flow_alloc\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_alloc (void )}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    84 \{\par
   85     struct sw_flow *flow;\par
   86     struct flow_stats *stats;\par
   87     int node;\par
   88 \par
   89     flow = kmem_cache_alloc(flow_cache, GFP_KERNEL);\par
   90     if (!flow)\par
   91         return ERR_PTR(-ENOMEM);\par
   92 \par
   93     flow->sf_acts = NULL;\par
   94     flow->mask = NULL;\par
   95     flow->id.ufid_len = 0;\par
   96     flow->id.unmasked_key = NULL;\par
   97     flow->stats_last_writer = NUMA_NO_NODE;\par
   98 \par
   99     /* Initialize the default stat node. */\par
  100     stats = kmem_cache_alloc_node(flow_stats_cache,\par
  101                       GFP_KERNEL | __GFP_ZERO, 0);\par
  102     if (!stats)\par
  103         goto err;\par
  104 \par
  105     spin_lock_init(&stats->lock);\par
  106 \par
  107     RCU_INIT_POINTER(flow->stats[0], stats);\par
  108 \par
  109     for_each_node(node)\par
  110         if (node != 0)\par
  111             RCU_INIT_POINTER(flow->stats[node], NULL);\par
  112 \par
  113     return flow;\par
  114 err:\par
  115     kmem_cache_free(flow_cache, flow);\par
  116     return ERR_PTR(-ENOMEM);\par
  117 \}\par
}
}
{\xe \v ovs_flow_cmp\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_flow_cmp (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_match} *  {\i match})}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   725 \{\par
  726     if (ovs_identifier_is_ufid(&flow->id))\par
  727         return flow_cmp_masked_key(flow, match->key, &match->range);\par
  728 \par
  729     return ovs_flow_cmp_unmasked_key(flow, match);\par
  730 \}\par
}
}
{\xe \v ovs_flow_cmp_ufid\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_cmp_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_flow_cmp_ufid (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_id} *  {\i sfid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   717 \{\par
  718     if (flow->id.ufid_len != sfid->ufid_len)\par
  719         return false;\par
  720 \par
  721     return !memcmp(flow->id.ufid, sfid->ufid, sfid->ufid_len);\par
  722 \}\par
}
}
{\xe \v ovs_flow_cmp_unmasked_key\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_cmp_unmasked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_flow_cmp_unmasked_key (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_match} *  {\i match}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   538 \{\par
  539     struct sw_flow_key *key = match->key;\par
  540     int key_start = flow_key_start(key);\par
  541     int key_end = match->range.end;\par
  542 \par
  543     BUG_ON(ovs_identifier_is_ufid(&flow->id));\par
  544     return cmp_key(flow->id.unmasked_key, key, key_start, key_end);\par
  545 \}\par
}
}
{\xe \v ovs_flow_exit\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_exit (void )}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1011 \{\par
 1012     kmem_cache_destroy(flow_stats_cache);\par
 1013     kmem_cache_destroy(flow_cache);\par
 1014 \}\par
}
}
{\xe \v ovs_flow_free\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_free (struct {\b sw_flow} *  {\i flow}, {\b bool}  {\i deferred})}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     if (!flow)\par
  178         return;\par
  179 \par
  180     if (deferred)\par
  181         call_rcu(&flow->rcu, rcu_free_flow_callback);\par
  182     else\par
  183         flow_free(flow);\par
  184 \}\par
}
}
{\xe \v ovs_flow_init\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_init (void )}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   986 \{\par
  987     BUILD_BUG_ON(__alignof__(struct sw_flow_key) % __alignof__(long));\par
  988     BUILD_BUG_ON(sizeof(struct sw_flow_key) % sizeof(long));\par
  989 \par
  990     flow_cache = kmem_cache_create("sw_flow", sizeof(struct sw_flow)\par
  991                        + (nr_node_ids\par
  992                       * sizeof(struct flow_stats *)),\par
  993                        0, 0, NULL);\par
  994     if (flow_cache == NULL)\par
  995         return -ENOMEM;\par
  996 \par
  997     flow_stats_cache\par
  998         = kmem_cache_create("sw_flow_stats", sizeof(struct flow_stats),\par
  999                     0, SLAB_HWCACHE_ALIGN, NULL);\par
 1000     if (flow_stats_cache == NULL) \{\par
 1001         kmem_cache_destroy(flow_cache);\par
 1002         flow_cache = NULL;\par
 1003         return -ENOMEM;\par
 1004     \}\par
 1005 \par
 1006     return 0;\par
 1007 \}\par
}
}
{\xe \v ovs_flow_mask_key\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_mask_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_mask_key (struct {\b sw_flow_key} *  {\i dst}, const struct {\b sw_flow_key} *  {\i src}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    67 \{\par
   68     const long *m = (const long *)((const u8 *)&mask->key +\par
   69                 mask->range.start);\par
   70     const long *s = (const long *)((const u8 *)src +\par
   71                 mask->range.start);\par
   72     long *d = (long *)((u8 *)dst + mask->range.start);\par
   73     int i;\par
   74 \par
   75     /* The memory outside of the 'mask->range' are not set since\par
   76      * further operations on 'dst' only uses contents within\par
   77      * 'mask->range'.\par
   78      */\par
   79     for (i = 0; i < range_n_bytes(&mask->range); i += sizeof(long))\par
   80         *d++ = *s++ & *m++;\par
   81 \}\par
}
}
{\xe \v ovs_flow_tbl_count\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_count (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   120 \{\par
  121     return table->count;\par
  122 \}\par
}
}
{\xe \v ovs_flow_tbl_destroy\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_destroy (struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   358 \{\par
  359     struct table_instance *ti = rcu_dereference_raw(table->ti);\par
  360     struct table_instance *ufid_ti = rcu_dereference_raw(table->ufid_ti);\par
  361 \par
  362     free_percpu(table->mask_cache);\par
  363     kfree(rcu_dereference_raw(table->mask_array));\par
  364     table_instance_destroy(ti, ufid_ti, false);\par
  365 \}\par
}
}
{\xe \v ovs_flow_tbl_dump_next\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_dump_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_dump_next (struct {\b table_instance} *  {\i ti}, u32 *  {\i bucket}, u32 *  {\i last})}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   369 \{\par
  370     struct sw_flow *flow;\par
  371     struct hlist_head *head;\par
  372     int ver;\par
  373     int i;\par
  374 \par
  375     ver = ti->node_ver;\par
  376     while (*bucket < ti->n_buckets) \{\par
  377         i = 0;\par
  378         head = flex_array_get(ti->buckets, *bucket);\par
  379         hlist_for_each_entry_rcu(flow, head, flow_table.node[ver]) \{\par
  380             if (i < *last) \{\par
  381                 i++;\par
  382                 continue;\par
  383             \}\par
  384             *last = i + 1;\par
  385             return flow;\par
  386         \}\par
  387         (*bucket)++;\par
  388         *last = 0;\par
  389     \}\par
  390 \par
  391     return NULL;\par
  392 \}\par
}
}
{\xe \v ovs_flow_tbl_flush\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_flush (struct {\b flow_table} *  {\i flow_table})}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   463 \{\par
  464     struct table_instance *old_ti, *new_ti;\par
  465     struct table_instance *old_ufid_ti, *new_ufid_ti;\par
  466 \par
  467     new_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  468     if (!new_ti)\par
  469         return -ENOMEM;\par
  470     new_ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  471     if (!new_ufid_ti)\par
  472         goto err_free_ti;\par
  473 \par
  474     old_ti = ovsl_dereference(flow_table->ti);\par
  475     old_ufid_ti = ovsl_dereference(flow_table->ufid_ti);\par
  476 \par
  477     rcu_assign_pointer(flow_table->ti, new_ti);\par
  478     rcu_assign_pointer(flow_table->ufid_ti, new_ufid_ti);\par
  479     flow_table->last_rehash = jiffies;\par
  480     flow_table->count = 0;\par
  481     flow_table->ufid_count = 0;\par
  482 \par
  483     table_instance_destroy(old_ti, old_ufid_ti, true);\par
  484     return 0;\par
  485 \par
  486 err_free_ti:\par
  487     __table_instance_destroy(new_ti);\par
  488     return -ENOMEM;\par
  489 \}\par
}
}
{\xe \v ovs_flow_tbl_init\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_init (struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271 \{\par
  272     struct table_instance *ti, *ufid_ti;\par
  273     struct mask_array *ma;\par
  274 \par
  275     table->mask_cache = __alloc_percpu(sizeof(struct mask_cache_entry) *\par
  276                       MC_HASH_ENTRIES, __alignof__(struct mask_cache_entry));\par
  277     if (!table->mask_cache)\par
  278         return -ENOMEM;\par
  279 \par
  280     ma = tbl_mask_array_alloc(MASK_ARRAY_SIZE_MIN);\par
  281     if (!ma)\par
  282         goto free_mask_cache;\par
  283 \par
  284     ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  285     if (!ti)\par
  286         goto free_mask_array;\par
  287 \par
  288     ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  289     if (!ufid_ti)\par
  290         goto free_ti;\par
  291 \par
  292     rcu_assign_pointer(table->ti, ti);\par
  293     rcu_assign_pointer(table->ufid_ti, ufid_ti);\par
  294     rcu_assign_pointer(table->mask_array, ma);\par
  295     table->last_rehash = jiffies;\par
  296     table->count = 0;\par
  297     table->ufid_count = 0;\par
  298     return 0;\par
  299 \par
  300 free_ti:\par
  301     __table_instance_destroy(ti);\par
  302 free_mask_array:\par
  303     kfree(ma);\par
  304 free_mask_cache:\par
  305     free_percpu(table->mask_cache);\par
  306     return -ENOMEM;\par
  307 \}\par
}
}
{\xe \v ovs_flow_tbl_insert\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   969 \{\par
  970     int err;\par
  971 \par
  972     err = flow_mask_insert(table, flow, mask);\par
  973     if (err)\par
  974         return err;\par
  975     flow_key_insert(table, flow);\par
  976     if (ovs_identifier_is_ufid(&flow->id))\par
  977         flow_ufid_insert(table, flow);\par
  978 \par
  979     return 0;\par
  980 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   677 \{\par
  678     struct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\par
  679     struct mask_array *ma = rcu_dereference_ovsl(tbl->mask_array);\par
  680     u32 __always_unused n_mask_hit;\par
  681     u32 index = 0;\par
  682 \par
  683     return flow_lookup(tbl, ti, ma, key, &n_mask_hit, &index);\par
  684 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_exact\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_lookup_exact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_exact (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_match} *  {\i match})}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   688 \{\par
  689     struct mask_array *ma = ovsl_dereference(tbl->mask_array);\par
  690     int i;\par
  691 \par
  692     /* Always called under ovs-mutex. */\par
  693     for (i = 0; i < ma->max; i++) \{\par
  694         struct table_instance *ti = ovsl_dereference(tbl->ti);\par
  695         u32 __always_unused n_mask_hit;\par
  696         struct sw_flow_mask *mask;\par
  697         struct sw_flow *flow;\par
  698 \par
  699         mask = ovsl_dereference(ma->masks[i]);\par
  700         if (!mask)\par
  701             continue;\par
  702         flow = masked_flow_lookup(ti, match->key, mask, &n_mask_hit);\par
  703         if (flow && ovs_identifier_is_key(&flow->id) &&\par
  704             ovs_flow_cmp_unmasked_key(flow, match))\par
  705             return flow;\par
  706     \}\par
  707     return NULL;\par
  708 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_stats\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_lookup_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_stats (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_key} *  {\i key}, u32  {\i skb_hash}, u32 *  {\i n_mask_hit})}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   622 \{\par
  623     struct mask_array *ma = rcu_dereference(tbl->mask_array);\par
  624     struct table_instance *ti = rcu_dereference(tbl->ti);\par
  625     struct mask_cache_entry *entries, *ce;\par
  626     struct sw_flow *flow;\par
  627     u32 hash;\par
  628     int seg;\par
  629 \par
  630     *n_mask_hit = 0;\par
  631     if (unlikely(!skb_hash)) \{\par
  632         u32 mask_index = 0;\par
  633 \par
  634         return flow_lookup(tbl, ti, ma, key, n_mask_hit, &mask_index);\par
  635     \}\par
  636 \par
  637     /* Pre and post recirulation flows usually have the same skb_hash\par
  638      * value. To avoid hash collisions, rehash the 'skb_hash' with\par
  639      * 'recirc_id'.  */\par
  640     if (key->recirc_id)\par
  641         skb_hash = jhash_1word(skb_hash, key->recirc_id);\par
  642 \par
  643     ce = NULL;\par
  644     hash = skb_hash;\par
  645     entries = this_cpu_ptr(tbl->mask_cache);\par
  646 \par
  647     /* Find the cache entry 'ce' to operate on. */\par
  648     for (seg = 0; seg < MC_HASH_SEGS; seg++) \{\par
  649         int index = hash & (MC_HASH_ENTRIES - 1);\par
  650         struct mask_cache_entry *e;\par
  651 \par
  652         e = &entries[index];\par
  653         if (e->skb_hash == skb_hash) \{\par
  654             flow = flow_lookup(tbl, ti, ma, key, n_mask_hit,\par
  655                        &e->mask_index);\par
  656             if (!flow)\par
  657                 e->skb_hash = 0;\par
  658             return flow;\par
  659         \}\par
  660 \par
  661         if (!ce || e->skb_hash < ce->skb_hash)\par
  662             ce = e;  /* A better replacement cache candidate. */\par
  663 \par
  664         hash >>= MC_HASH_SHIFT;\par
  665     \}\par
  666 \par
  667     /* Cache miss, do full lookup. */\par
  668     flow = flow_lookup(tbl, ti, ma, key, n_mask_hit, &ce->mask_index);\par
  669     if (flow)\par
  670         ce->skb_hash = skb_hash;\par
  671 \par
  672     return flow;\par
  673 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_ufid\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_lookup_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_ufid (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_id} *  {\i ufid})}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   734 \{\par
  735     struct table_instance *ti = rcu_dereference_ovsl(tbl->ufid_ti);\par
  736     struct sw_flow *flow;\par
  737     struct hlist_head *head;\par
  738     u32 hash;\par
  739 \par
  740     hash = ufid_hash(ufid);\par
  741     head = find_bucket(ti, hash);\par
  742     hlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver]) \{\par
  743         if (flow->ufid_table.hash == hash &&\par
  744             ovs_flow_cmp_ufid(flow, ufid))\par
  745             return flow;\par
  746     \}\par
  747     return NULL;\par
  748 \}\par
}
}
{\xe \v ovs_flow_tbl_num_masks\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_num_masks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_num_masks (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   751 \{\par
  752     struct mask_array *ma;\par
  753 \par
  754     ma = rcu_dereference_ovsl(table->mask_array);\par
  755     return ma->count;\par
  756 \}\par
}
}
{\xe \v ovs_flow_tbl_remove\:flow_table.c}
{\xe \v flow_table.c\:ovs_flow_tbl_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_remove (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   809 \{\par
  810     struct table_instance *ti = ovsl_dereference(table->ti);\par
  811     struct table_instance *ufid_ti = ovsl_dereference(table->ufid_ti);\par
  812 \par
  813     BUG_ON(table->count == 0);\par
  814     hlist_del_rcu(&flow->flow_table.node[ti->node_ver]);\par
  815     table->count--;\par
  816     if (ovs_identifier_is_ufid(&flow->id)) \{\par
  817         hlist_del_rcu(&flow->ufid_table.node[ufid_ti->node_ver]);\par
  818         table->ufid_count--;\par
  819     \}\par
  820 \par
  821     /* RCU delete the mask. 'flow->mask' is not NULLed, as it should be\par
  822      * accessible as long as the RCU read lock is held.\par
  823      */\par
  824     flow_mask_remove(table, flow->mask);\par
  825 \}\par
}
}
{\xe \v range_n_bytes\:flow_table.c}
{\xe \v flow_table.c\:range_n_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u16 range_n_bytes (const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return range->end - range->start;\par
   63 \}\par
}
}
{\xe \v rcu_free_flow_callback\:flow_table.c}
{\xe \v flow_table.c\:rcu_free_flow_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_flow_callback (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163     struct sw_flow *flow = container_of(rcu, struct sw_flow, rcu);\par
  164 \par
  165     flow_free(flow);\par
  166 \}\par
}
}
{\xe \v rcu_free_sw_flow_mask_cb\:flow_table.c}
{\xe \v flow_table.c\:rcu_free_sw_flow_mask_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_sw_flow_mask_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   169 \{\par
  170     struct sw_flow_mask *mask = container_of(rcu, struct sw_flow_mask, rcu);\par
  171 \par
  172     kfree(mask);\par
  173 \}\par
}
}
{\xe \v table_instance_alloc\:flow_table.c}
{\xe \v flow_table.c\:table_instance_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_alloc (int  {\i new_size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199 \{\par
  200     struct table_instance *ti = kmalloc(sizeof(*ti), GFP_KERNEL);\par
  201 \par
  202     if (!ti)\par
  203         return NULL;\par
  204 \par
  205     ti->buckets = alloc_buckets(new_size);\par
  206 \par
  207     if (!ti->buckets) \{\par
  208         kfree(ti);\par
  209         return NULL;\par
  210     \}\par
  211     ti->n_buckets = new_size;\par
  212     ti->node_ver = 0;\par
  213     ti->keep_flows = false;\par
  214     get_random_bytes(&ti->hash_seed, sizeof(u32));\par
  215 \par
  216     return ti;\par
  217 \}\par
}
}
{\xe \v table_instance_destroy\:flow_table.c}
{\xe \v flow_table.c\:table_instance_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void table_instance_destroy (struct {\b table_instance} *  {\i ti}, struct {\b table_instance} *  {\i ufid_ti}, {\b bool}  {\i deferred}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   319 \{\par
  320     int i;\par
  321 \par
  322     if (!ti)\par
  323         return;\par
  324 \par
  325     BUG_ON(!ufid_ti);\par
  326     if (ti->keep_flows)\par
  327         goto skip_flows;\par
  328 \par
  329     for (i = 0; i < ti->n_buckets; i++) \{\par
  330         struct sw_flow *flow;\par
  331         struct hlist_head *head = flex_array_get(ti->buckets, i);\par
  332         struct hlist_node *n;\par
  333         int ver = ti->node_ver;\par
  334         int ufid_ver = ufid_ti->node_ver;\par
  335 \par
  336         hlist_for_each_entry_safe(flow, n, head, flow_table.node[ver]) \{\par
  337             hlist_del_rcu(&flow->flow_table.node[ver]);\par
  338             if (ovs_identifier_is_ufid(&flow->id))\par
  339                 hlist_del_rcu(&flow->ufid_table.node[ufid_ver]);\par
  340             ovs_flow_free(flow, deferred);\par
  341         \}\par
  342     \}\par
  343 \par
  344 skip_flows:\par
  345     if (deferred) \{\par
  346         call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  347         call_rcu(&ufid_ti->rcu, flow_tbl_destroy_rcu_cb);\par
  348     \} else \{\par
  349         __table_instance_destroy(ti);\par
  350         __table_instance_destroy(ufid_ti);\par
  351     \}\par
  352 \}\par
}
}
{\xe \v table_instance_expand\:flow_table.c}
{\xe \v flow_table.c\:table_instance_expand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_expand (struct {\b table_instance} *  {\i ti}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   760 \{\par
  761     return table_instance_rehash(ti, ti->n_buckets * 2, ufid);\par
  762 \}\par
}
}
{\xe \v table_instance_insert\:flow_table.c}
{\xe \v flow_table.c\:table_instance_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void table_instance_insert (struct {\b table_instance} *  {\i ti}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   403 \{\par
  404     struct hlist_head *head;\par
  405 \par
  406     head = find_bucket(ti, flow->flow_table.hash);\par
  407     hlist_add_head_rcu(&flow->flow_table.node[ti->node_ver], head);\par
  408 \}\par
}
}
{\xe \v table_instance_rehash\:flow_table.c}
{\xe \v flow_table.c\:table_instance_rehash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_rehash (struct {\b table_instance} *  {\i ti}, int  {\i n_buckets}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   450 \{\par
  451     struct table_instance *new_ti;\par
  452 \par
  453     new_ti = table_instance_alloc(n_buckets);\par
  454     if (!new_ti)\par
  455         return NULL;\par
  456 \par
  457     flow_table_copy_flows(ti, new_ti, ufid);\par
  458 \par
  459     return new_ti;\par
  460 \}\par
}
}
{\xe \v tbl_mask_array_alloc\:flow_table.c}
{\xe \v flow_table.c\:tbl_mask_array_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b mask_array}* tbl_mask_array_alloc (int  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227 \{\par
  228     struct mask_array *new;\par
  229 \par
  230     size = max(MASK_ARRAY_SIZE_MIN, size);\par
  231     new = kzalloc(sizeof(struct mask_array) +\par
  232               sizeof(struct sw_flow_mask *) * size, GFP_KERNEL);\par
  233     if (!new)\par
  234         return NULL;\par
  235 \par
  236     new->count = 0;\par
  237     new->max = size;\par
  238 \par
  239     return new;\par
  240 \}\par
}
}
{\xe \v tbl_mask_array_delete_mask\:flow_table.c}
{\xe \v flow_table.c\:tbl_mask_array_delete_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tbl_mask_array_delete_mask (struct {\b mask_array} *  {\i ma}, struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   766 \{\par
  767     int i;\par
  768 \par
  769     /* Remove the deleted mask pointers from the array */\par
  770     for (i = 0; i < ma->max; i++) \{\par
  771         if (mask == ovsl_dereference(ma->masks[i])) \{\par
  772             RCU_INIT_POINTER(ma->masks[i], NULL);\par
  773             ma->count--;\par
  774             call_rcu(&mask->rcu, rcu_free_sw_flow_mask_cb);\par
  775             return;\par
  776         \}\par
  777     \}\par
  778     BUG();\par
  779 \}\par
}
}
{\xe \v tbl_mask_array_realloc\:flow_table.c}
{\xe \v flow_table.c\:tbl_mask_array_realloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int tbl_mask_array_realloc (struct {\b flow_table} *  {\i tbl}, int  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   243 \{\par
  244     struct mask_array *old;\par
  245     struct mask_array *new;\par
  246 \par
  247     new = tbl_mask_array_alloc(size);\par
  248     if (!new)\par
  249         return -ENOMEM;\par
  250 \par
  251     old = ovsl_dereference(tbl->mask_array);\par
  252     if (old) \{\par
  253         int i, count = 0;\par
  254 \par
  255         for (i = 0; i < old->max; i++) \{\par
  256             if (ovsl_dereference(old->masks[i]))\par
  257                 new->masks[count++] = old->masks[i];\par
  258         \}\par
  259 \par
  260         new->count = count;\par
  261     \}\par
  262     rcu_assign_pointer(tbl->mask_array, new);\par
  263 \par
  264     if (old)\par
  265         call_rcu(&old->rcu, mask_array_rcu_cb);\par
  266 \par
  267     return 0;\par
  268 \}\par
}
}
{\xe \v ufid_hash\:flow_table.c}
{\xe \v flow_table.c\:ufid_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u32 ufid_hash (const struct {\b sw_flow_id} *  {\i sfid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{\par
  712     return jhash(sfid->ufid, sfid->ufid_len, 0);\par
  713 \}\par
}
}
{\xe \v ufid_table_instance_insert\:flow_table.c}
{\xe \v flow_table.c\:ufid_table_instance_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ufid_table_instance_insert (struct {\b table_instance} *  {\i ti}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   412 \{\par
  413     struct hlist_head *head;\par
  414 \par
  415     head = find_bucket(ti, flow->ufid_table.hash);\par
  416     hlist_add_head_rcu(&flow->ufid_table.node[ti->node_ver], head);\par
  417 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:flow_table.c}
{\xe \v flow_table.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct kmem_cache* {\b flow_stats_cache} __read_mostly}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flow_cache\:flow_table.c}
{\xe \v flow_table.c\:flow_cache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct kmem_cache* flow_cache{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/flow_table.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/flow_table.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/flow_table.c}
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "flow.h"}\par
{\f2 #include "datapath.h"}\par
{\f2 #include <linux/uaccess.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/llc_pdu.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/sctp.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/icmpv6.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/ipv6.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_table.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2flow__table_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TBL_MIN_BUCKETS}\~ 1024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MASK_ARRAY_SIZE_MIN}\~ 16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REHASH_INTERVAL}\~ (10 * 60 * HZ)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_SHIFT}\~ 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_ENTRIES}\~ (1u << MC_HASH_SHIFT)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MC_HASH_SEGS}\~ ((sizeof(uint32_t) * 8) / {\b MC_HASH_SHIFT})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u16 {\b range_n_bytes} (const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_mask_key} (struct {\b sw_flow_key} *{\b dst}, const struct {\b sw_flow_key} *{\b src}, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_alloc} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_count} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct flex_array * {\b alloc_buckets} (unsigned int n_buckets)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_free} (struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_flow_callback} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_sw_flow_mask_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_free} (struct {\b sw_flow} *flow, {\b bool} deferred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_buckets} (struct flex_array *buckets)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __table_instance_destroy} (struct {\b table_instance} *ti)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_alloc} (int new_size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b mask_array_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b mask_array} * {\b tbl_mask_array_alloc} (int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b tbl_mask_array_realloc} (struct {\b flow_table} *tbl, int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_init} (struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_tbl_destroy_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b table_instance_destroy} (struct {\b table_instance} *ti, struct {\b table_instance} *ufid_ti, {\b bool} deferred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_destroy} (struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_dump_next} (struct {\b table_instance} *ti, u32 *bucket, u32 *last)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b find_bucket} (struct {\b table_instance} *ti, u32 hash)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b table_instance_insert} (struct {\b table_instance} *ti, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ufid_table_instance_insert} (struct {\b table_instance} *ti, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_table_copy_flows} (struct {\b table_instance} *old, struct {\b table_instance} *new, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_rehash} (struct {\b table_instance} *ti, int n_buckets, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_flush} (struct {\b flow_table} *{\b flow_table})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u32 {\b flow_hash} (const struct {\b sw_flow_key} *key, const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b flow_key_start} (const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b cmp_key} (const struct {\b sw_flow_key} *key1, const struct {\b sw_flow_key} *key2, int key_start, int key_end)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b flow_cmp_masked_key} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_key} *key, const struct {\b sw_flow_key_range} *range)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_flow_cmp_unmasked_key} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow} * {\b masked_flow_lookup} (struct {\b table_instance} *ti, const struct {\b sw_flow_key} *unmasked, const struct {\b sw_flow_mask} *mask, u32 *n_mask_hit)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow} * {\b flow_lookup} (struct {\b flow_table} *tbl, struct {\b table_instance} *ti, const struct {\b mask_array} *ma, const struct {\b sw_flow_key} *key, u32 *n_mask_hit, u32 *index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_stats} (struct {\b flow_table} *tbl, const struct {\b sw_flow_key} *key, u32 skb_hash, u32 *n_mask_hit)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup} (struct {\b flow_table} *tbl, const struct {\b sw_flow_key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_exact} (struct {\b flow_table} *tbl, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u32 {\b ufid_hash} (const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ovs_flow_cmp_ufid} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_id} *sfid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_flow_cmp} (const struct {\b sw_flow} *flow, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_ufid} (struct {\b flow_table} *tbl, const struct {\b sw_flow_id} *ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_num_masks} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b table_instance} * {\b table_instance_expand} (struct {\b table_instance} *ti, {\b bool} ufid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tbl_mask_array_delete_mask} (struct {\b mask_array} *ma, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_mask_remove} (struct {\b flow_table} *tbl, struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_remove} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_mask} * {\b mask_alloc} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b mask_equal} (const struct {\b sw_flow_mask} *a, const struct {\b sw_flow_mask} *b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b sw_flow_mask} * {\b flow_mask_find} (const struct {\b flow_table} *tbl, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b flow_mask_insert} (struct {\b flow_table} *tbl, struct {\b sw_flow} *flow, const struct {\b sw_flow_mask} *new)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_key_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b flow_ufid_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct kmem_cache * {\b flow_cache}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct kmem_cache *{\b flow_stats_cache} {\b __read_mostly}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MASK_ARRAY_SIZE_MIN\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:MASK_ARRAY_SIZE_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MASK_ARRAY_SIZE_MIN\~ 16}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_ENTRIES\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:MC_HASH_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_ENTRIES\~ (1u << MC_HASH_SHIFT)}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_SEGS\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:MC_HASH_SEGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_SEGS\~ ((sizeof(uint32_t) * 8) / {\b MC_HASH_SHIFT})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MC_HASH_SHIFT\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:MC_HASH_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MC_HASH_SHIFT\~ 8}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REHASH_INTERVAL\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:REHASH_INTERVAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REHASH_INTERVAL\~ (10 * 60 * HZ)}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TBL_MIN_BUCKETS\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:TBL_MIN_BUCKETS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TBL_MIN_BUCKETS\~ 1024}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __table_instance_destroy\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:__table_instance_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __table_instance_destroy (struct {\b table_instance} *  {\i ti}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194     free_buckets(ti->buckets);\par
  195     kfree(ti);\par
  196 \}\par
}
}
{\xe \v alloc_buckets\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:alloc_buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct flex_array* alloc_buckets (unsigned int  {\i n_buckets}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   125 \{\par
  126     struct flex_array *buckets;\par
  127     int i, err;\par
  128 \par
  129     buckets = flex_array_alloc(sizeof(struct hlist_head),\par
  130                    n_buckets, GFP_KERNEL);\par
  131     if (!buckets)\par
  132         return NULL;\par
  133 \par
  134     err = flex_array_prealloc(buckets, 0, n_buckets, GFP_KERNEL);\par
  135     if (err) \{\par
  136         flex_array_free(buckets);\par
  137         return NULL;\par
  138     \}\par
  139 \par
  140     for (i = 0; i < n_buckets; i++)\par
  141         INIT_HLIST_HEAD((struct hlist_head *)\par
  142                     flex_array_get(buckets, i));\par
  143 \par
  144     return buckets;\par
  145 \}\par
}
}
{\xe \v cmp_key\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:cmp_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} cmp_key (const struct {\b sw_flow_key} *  {\i key1}, const struct {\b sw_flow_key} *  {\i key2}, int  {\i key_start}, int  {\i key_end}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   517 \{\par
  518     const long *cp1 = (const long *)((const u8 *)key1 + key_start);\par
  519     const long *cp2 = (const long *)((const u8 *)key2 + key_start);\par
  520     long diffs = 0;\par
  521     int i;\par
  522 \par
  523     for (i = key_start; i < key_end;  i += sizeof(long))\par
  524         diffs |= *cp1++ ^ *cp2++;\par
  525 \par
  526     return diffs == 0;\par
  527 \}\par
}
}
{\xe \v find_bucket\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:find_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* find_bucket (struct {\b table_instance} *  {\i ti}, u32  {\i hash}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   395 \{\par
  396     hash = jhash_1word(hash, ti->hash_seed);\par
  397     return flex_array_get(ti->buckets,\par
  398                 (hash & (ti->n_buckets - 1)));\par
  399 \}\par
}
}
{\xe \v flow_cmp_masked_key\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_cmp_masked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} flow_cmp_masked_key (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   532 \{\par
  533     return cmp_key(&flow->key, key, range->start, range->end);\par
  534 \}\par
}
}
{\xe \v flow_free\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_free (struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   148 \{\par
  149     int node;\par
  150 \par
  151     if (ovs_identifier_is_key(&flow->id))\par
  152         kfree(flow->id.unmasked_key);\par
  153     kfree(rcu_dereference_raw(flow->sf_acts));\par
  154     for_each_node(node)\par
  155         if (flow->stats[node])\par
  156             kmem_cache_free(flow_stats_cache,\par
  157                     rcu_dereference_raw(flow->stats[node]));\par
  158     kmem_cache_free(flow_cache, flow);\par
  159 \}\par
}
}
{\xe \v flow_hash\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u32 flow_hash (const struct {\b sw_flow_key} *  {\i key}, const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   493 \{\par
  494     int key_start = range->start;\par
  495     int key_end = range->end;\par
  496     const u32 *hash_key = (const u32 *)((const u8 *)key + key_start);\par
  497     int hash_u32s = (key_end - key_start) >> 2;\par
  498 \par
  499     /* Make sure number of hash bytes are multiple of u32. */\par
  500     BUILD_BUG_ON(sizeof(long) % sizeof(u32));\par
  501 \par
  502     return jhash2(hash_key, hash_u32s, 0);\par
  503 \}\par
}
}
{\xe \v flow_key_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_key_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_key_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   922 \{\par
  923     struct table_instance *new_ti = NULL;\par
  924     struct table_instance *ti;\par
  925 \par
  926     flow->flow_table.hash = flow_hash(&flow->key, &flow->mask->range);\par
  927     ti = ovsl_dereference(table->ti);\par
  928     table_instance_insert(ti, flow);\par
  929     table->count++;\par
  930 \par
  931     /* Expand table, if necessary, to make room. */\par
  932     if (table->count > ti->n_buckets)\par
  933         new_ti = table_instance_expand(ti, false);\par
  934     else if (time_after(jiffies, table->last_rehash + REHASH_INTERVAL))\par
  935         new_ti = table_instance_rehash(ti, ti->n_buckets, false);\par
  936 \par
  937     if (new_ti) \{\par
  938         rcu_assign_pointer(table->ti, new_ti);\par
  939         call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  940         table->last_rehash = jiffies;\par
  941     \}\par
  942 \}\par
}
}
{\xe \v flow_key_start\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_key_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int flow_key_start (const struct {\b sw_flow_key} *  {\i key}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506 \{\par
  507     if (key->tun_key.ipv4_dst)\par
  508         return 0;\par
  509     else\par
  510         return rounddown(offsetof(struct sw_flow_key, phy),\par
  511                       sizeof(long));\par
  512 \}\par
}
}
{\xe \v flow_lookup\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow}* flow_lookup (struct {\b flow_table} *  {\i tbl}, struct {\b table_instance} *  {\i ti}, const struct {\b mask_array} *  {\i ma}, const struct {\b sw_flow_key} *  {\i key}, u32 *  {\i n_mask_hit}, u32 *  {\i index}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579     struct sw_flow_mask *mask;\par
  580     struct sw_flow *flow;\par
  581     int i;\par
  582 \par
  583     if (*index < ma->max) \{\par
  584         mask = rcu_dereference_ovsl(ma->masks[*index]);\par
  585         if (mask) \{\par
  586             flow = masked_flow_lookup(ti, key, mask, n_mask_hit);\par
  587             if (flow)\par
  588                 return flow;\par
  589         \}\par
  590     \}\par
  591 \par
  592     for (i = 0; i < ma->max; i++)  \{\par
  593 \par
  594         if (i == *index)\par
  595             continue;\par
  596 \par
  597         mask = rcu_dereference_ovsl(ma->masks[i]);\par
  598         if (!mask)\par
  599             continue;\par
  600 \par
  601         flow = masked_flow_lookup(ti, key, mask, n_mask_hit);\par
  602         if (flow) \{ /* Found */\par
  603             *index = i;\par
  604             return flow;\par
  605         \}\par
  606     \}\par
  607 \par
  608     return NULL;\par
  609 \}\par
}
}
{\xe \v flow_mask_find\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_mask_find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_mask}* flow_mask_find (const struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   851 \{\par
  852     struct mask_array *ma;\par
  853     int i;\par
  854 \par
  855     ma = ovsl_dereference(tbl->mask_array);\par
  856     for (i = 0; i < ma->max; i++) \{\par
  857         struct sw_flow_mask *t;\par
  858 \par
  859         t = ovsl_dereference(ma->masks[i]);\par
  860         if (t && mask_equal(mask, t))\par
  861             return t;\par
  862     \}\par
  863 \par
  864     return NULL;\par
  865 \}\par
}
}
{\xe \v flow_mask_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_mask_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int flow_mask_insert (struct {\b flow_table} *  {\i tbl}, struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_mask} *  {\i new}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   870 \{\par
  871     struct sw_flow_mask *mask;\par
  872 \par
  873     mask = flow_mask_find(tbl, new);\par
  874     if (!mask) \{\par
  875         struct mask_array *ma;\par
  876         int i;\par
  877 \par
  878         /* Allocate a new mask if none exsits. */\par
  879         mask = mask_alloc();\par
  880         if (!mask)\par
  881             return -ENOMEM;\par
  882 \par
  883         mask->key = new->key;\par
  884         mask->range = new->range;\par
  885 \par
  886         /* Add mask to mask-list. */\par
  887         ma = ovsl_dereference(tbl->mask_array);\par
  888         if (ma->count >= ma->max) \{\par
  889             int err;\par
  890 \par
  891             err = tbl_mask_array_realloc(tbl, ma->max +\par
  892                               MASK_ARRAY_SIZE_MIN);\par
  893             if (err) \{\par
  894                 kfree(mask);\par
  895                 return err;\par
  896             \}\par
  897             ma = ovsl_dereference(tbl->mask_array);\par
  898         \}\par
  899 \par
  900         for (i = 0; i < ma->max; i++) \{\par
  901             struct sw_flow_mask *t;\par
  902 \par
  903             t = ovsl_dereference(ma->masks[i]);\par
  904             if (!t) \{\par
  905                 rcu_assign_pointer(ma->masks[i], mask);\par
  906                 ma->count++;\par
  907                 break;\par
  908             \}\par
  909         \}\par
  910 \par
  911     \} else \{\par
  912         BUG_ON(!mask->ref_count);\par
  913         mask->ref_count++;\par
  914     \}\par
  915 \par
  916     flow->mask = mask;\par
  917     return 0;\par
  918 \}\par
}
}
{\xe \v flow_mask_remove\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_mask_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_mask_remove (struct {\b flow_table} *  {\i tbl}, struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   783 \{\par
  784     if (mask) \{\par
  785         /* ovs-lock is required to protect mask-refcount and\par
  786          * mask list.\par
  787          */\par
  788         ASSERT_OVSL();\par
  789         BUG_ON(!mask->ref_count);\par
  790         mask->ref_count--;\par
  791 \par
  792         if (!mask->ref_count) \{\par
  793             struct mask_array *ma;\par
  794 \par
  795             ma = ovsl_dereference(tbl->mask_array);\par
  796             tbl_mask_array_delete_mask(ma, mask);\par
  797 \par
  798             /* Shrink the mask array if necessary. */\par
  799             if (ma->max >= (MASK_ARRAY_SIZE_MIN * 2) &&\par
  800                 ma->count <= (ma->max / 3))\par
  801                 tbl_mask_array_realloc(tbl, ma->max / 2);\par
  802 \par
  803         \}\par
  804     \}\par
  805 \}\par
}
}
{\xe \v flow_table_copy_flows\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_table_copy_flows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_table_copy_flows (struct {\b table_instance} *  {\i old}, struct {\b table_instance} *  {\i new}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   421 \{\par
  422     int old_ver;\par
  423     int i;\par
  424 \par
  425     old_ver = old->node_ver;\par
  426     new->node_ver = !old_ver;\par
  427 \par
  428     /* Insert in new table. */\par
  429     for (i = 0; i < old->n_buckets; i++) \{\par
  430         struct sw_flow *flow;\par
  431         struct hlist_head *head;\par
  432 \par
  433         head = flex_array_get(old->buckets, i);\par
  434 \par
  435         if (ufid)\par
  436             hlist_for_each_entry(flow, head,\par
  437                          ufid_table.node[old_ver])\par
  438                 ufid_table_instance_insert(new, flow);\par
  439         else\par
  440             hlist_for_each_entry(flow, head,\par
  441                          flow_table.node[old_ver])\par
  442                 table_instance_insert(new, flow);\par
  443     \}\par
  444 \par
  445     old->keep_flows = true;\par
  446 \}\par
}
}
{\xe \v flow_tbl_destroy_rcu_cb\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_tbl_destroy_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_tbl_destroy_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   310 \{\par
  311     struct table_instance *ti = container_of(rcu, struct table_instance, rcu);\par
  312 \par
  313     __table_instance_destroy(ti);\par
  314 \}\par
}
}
{\xe \v flow_ufid_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_ufid_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void flow_ufid_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   946 \{\par
  947     struct table_instance *ti;\par
  948 \par
  949     flow->ufid_table.hash = ufid_hash(&flow->id);\par
  950     ti = ovsl_dereference(table->ufid_ti);\par
  951     ufid_table_instance_insert(ti, flow);\par
  952     table->ufid_count++;\par
  953 \par
  954     /* Expand table, if necessary, to make room. */\par
  955     if (table->ufid_count > ti->n_buckets) \{\par
  956         struct table_instance *new_ti;\par
  957 \par
  958         new_ti = table_instance_expand(ti, true);\par
  959         if (new_ti) \{\par
  960             rcu_assign_pointer(table->ufid_ti, new_ti);\par
  961             call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  962         \}\par
  963     \}\par
  964 \}\par
}
}
{\xe \v free_buckets\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:free_buckets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_buckets (struct flex_array *  {\i buckets}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   187 \{\par
  188     flex_array_free(buckets);\par
  189 \}\par
}
}
{\xe \v mask_alloc\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:mask_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow_mask}* mask_alloc (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   828 \{\par
  829     struct sw_flow_mask *mask;\par
  830 \par
  831     mask = kmalloc(sizeof(*mask), GFP_KERNEL);\par
  832     if (mask)\par
  833         mask->ref_count = 1;\par
  834 \par
  835     return mask;\par
  836 \}\par
}
}
{\xe \v mask_array_rcu_cb\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:mask_array_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void mask_array_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   220 \{\par
  221     struct mask_array *ma = container_of(rcu, struct mask_array, rcu);\par
  222 \par
  223     kfree(ma);\par
  224 \}\par
}
}
{\xe \v mask_equal\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:mask_equal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} mask_equal (const struct {\b sw_flow_mask} *  {\i a}, const struct {\b sw_flow_mask} *  {\i b}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   840 \{\par
  841     const u8 *a_ = (const u8 *)&a->key + a->range.start;\par
  842     const u8 *b_ = (const u8 *)&b->key + b->range.start;\par
  843 \par
  844     return  (a->range.end == b->range.end)\par
  845         && (a->range.start == b->range.start)\par
  846         && (memcmp(a_, b_, range_n_bytes(&a->range)) == 0);\par
  847 \}\par
}
}
{\xe \v masked_flow_lookup\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:masked_flow_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b sw_flow}* masked_flow_lookup (struct {\b table_instance} *  {\i ti}, const struct {\b sw_flow_key} *  {\i unmasked}, const struct {\b sw_flow_mask} *  {\i mask}, u32 *  {\i n_mask_hit}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   551 \{\par
  552     struct sw_flow *flow;\par
  553     struct hlist_head *head;\par
  554     u32 hash;\par
  555     struct sw_flow_key masked_key;\par
  556 \par
  557     ovs_flow_mask_key(&masked_key, unmasked, mask);\par
  558     hash = flow_hash(&masked_key, &mask->range);\par
  559     head = find_bucket(ti, hash);\par
  560     (*n_mask_hit)++;\par
  561     hlist_for_each_entry_rcu(flow, head, flow_table.node[ti->node_ver]) \{\par
  562         if (flow->mask == mask && flow->flow_table.hash == hash &&\par
  563             flow_cmp_masked_key(flow, &masked_key, &mask->range))\par
  564             return flow;\par
  565     \}\par
  566     return NULL;\par
  567 \}\par
}
}
{\xe \v ovs_flow_alloc\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_alloc (void )}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    84 \{\par
   85     struct sw_flow *flow;\par
   86     struct flow_stats *stats;\par
   87     int node;\par
   88 \par
   89     flow = kmem_cache_alloc(flow_cache, GFP_KERNEL);\par
   90     if (!flow)\par
   91         return ERR_PTR(-ENOMEM);\par
   92 \par
   93     flow->sf_acts = NULL;\par
   94     flow->mask = NULL;\par
   95     flow->id.ufid_len = 0;\par
   96     flow->id.unmasked_key = NULL;\par
   97     flow->stats_last_writer = NUMA_NO_NODE;\par
   98 \par
   99     /* Initialize the default stat node. */\par
  100     stats = kmem_cache_alloc_node(flow_stats_cache,\par
  101                       GFP_KERNEL | __GFP_ZERO, 0);\par
  102     if (!stats)\par
  103         goto err;\par
  104 \par
  105     spin_lock_init(&stats->lock);\par
  106 \par
  107     RCU_INIT_POINTER(flow->stats[0], stats);\par
  108 \par
  109     for_each_node(node)\par
  110         if (node != 0)\par
  111             RCU_INIT_POINTER(flow->stats[node], NULL);\par
  112 \par
  113     return flow;\par
  114 err:\par
  115     kmem_cache_free(flow_cache, flow);\par
  116     return ERR_PTR(-ENOMEM);\par
  117 \}\par
}
}
{\xe \v ovs_flow_cmp\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_flow_cmp (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_match} *  {\i match})}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   725 \{\par
  726     if (ovs_identifier_is_ufid(&flow->id))\par
  727         return flow_cmp_masked_key(flow, match->key, &match->range);\par
  728 \par
  729     return ovs_flow_cmp_unmasked_key(flow, match);\par
  730 \}\par
}
}
{\xe \v ovs_flow_cmp_ufid\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_cmp_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_flow_cmp_ufid (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_id} *  {\i sfid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   717 \{\par
  718     if (flow->id.ufid_len != sfid->ufid_len)\par
  719         return false;\par
  720 \par
  721     return !memcmp(flow->id.ufid, sfid->ufid, sfid->ufid_len);\par
  722 \}\par
}
}
{\xe \v ovs_flow_cmp_unmasked_key\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_cmp_unmasked_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ovs_flow_cmp_unmasked_key (const struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_match} *  {\i match}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   538 \{\par
  539     struct sw_flow_key *key = match->key;\par
  540     int key_start = flow_key_start(key);\par
  541     int key_end = match->range.end;\par
  542 \par
  543     BUG_ON(ovs_identifier_is_ufid(&flow->id));\par
  544     return cmp_key(flow->id.unmasked_key, key, key_start, key_end);\par
  545 \}\par
}
}
{\xe \v ovs_flow_exit\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_exit (void )}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1011 \{\par
 1012     kmem_cache_destroy(flow_stats_cache);\par
 1013     kmem_cache_destroy(flow_cache);\par
 1014 \}\par
}
}
{\xe \v ovs_flow_free\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_free (struct {\b sw_flow} *  {\i flow}, {\b bool}  {\i deferred})}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     if (!flow)\par
  178         return;\par
  179 \par
  180     if (deferred)\par
  181         call_rcu(&flow->rcu, rcu_free_flow_callback);\par
  182     else\par
  183         flow_free(flow);\par
  184 \}\par
}
}
{\xe \v ovs_flow_init\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_init (void )}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   986 \{\par
  987     BUILD_BUG_ON(__alignof__(struct sw_flow_key) % __alignof__(long));\par
  988     BUILD_BUG_ON(sizeof(struct sw_flow_key) % sizeof(long));\par
  989 \par
  990     flow_cache = kmem_cache_create("sw_flow", sizeof(struct sw_flow)\par
  991                        + (nr_node_ids\par
  992                       * sizeof(struct flow_stats *)),\par
  993                        0, 0, NULL);\par
  994     if (flow_cache == NULL)\par
  995         return -ENOMEM;\par
  996 \par
  997     flow_stats_cache\par
  998         = kmem_cache_create("sw_flow_stats", sizeof(struct flow_stats),\par
  999                     0, SLAB_HWCACHE_ALIGN, NULL);\par
 1000     if (flow_stats_cache == NULL) \{\par
 1001         kmem_cache_destroy(flow_cache);\par
 1002         flow_cache = NULL;\par
 1003         return -ENOMEM;\par
 1004     \}\par
 1005 \par
 1006     return 0;\par
 1007 \}\par
}
}
{\xe \v ovs_flow_mask_key\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_mask_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_mask_key (struct {\b sw_flow_key} *  {\i dst}, const struct {\b sw_flow_key} *  {\i src}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    67 \{\par
   68     const long *m = (const long *)((const u8 *)&mask->key +\par
   69                 mask->range.start);\par
   70     const long *s = (const long *)((const u8 *)src +\par
   71                 mask->range.start);\par
   72     long *d = (long *)((u8 *)dst + mask->range.start);\par
   73     int i;\par
   74 \par
   75     /* The memory outside of the 'mask->range' are not set since\par
   76      * further operations on 'dst' only uses contents within\par
   77      * 'mask->range'.\par
   78      */\par
   79     for (i = 0; i < range_n_bytes(&mask->range); i += sizeof(long))\par
   80         *d++ = *s++ & *m++;\par
   81 \}\par
}
}
{\xe \v ovs_flow_tbl_count\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_count (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   120 \{\par
  121     return table->count;\par
  122 \}\par
}
}
{\xe \v ovs_flow_tbl_destroy\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_destroy (struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   358 \{\par
  359     struct table_instance *ti = rcu_dereference_raw(table->ti);\par
  360     struct table_instance *ufid_ti = rcu_dereference_raw(table->ufid_ti);\par
  361 \par
  362     free_percpu(table->mask_cache);\par
  363     kfree(rcu_dereference_raw(table->mask_array));\par
  364     table_instance_destroy(ti, ufid_ti, false);\par
  365 \}\par
}
}
{\xe \v ovs_flow_tbl_dump_next\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_dump_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_dump_next (struct {\b table_instance} *  {\i ti}, u32 *  {\i bucket}, u32 *  {\i last})}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   369 \{\par
  370     struct sw_flow *flow;\par
  371     struct hlist_head *head;\par
  372     int ver;\par
  373     int i;\par
  374 \par
  375     ver = ti->node_ver;\par
  376     while (*bucket < ti->n_buckets) \{\par
  377         i = 0;\par
  378         head = flex_array_get(ti->buckets, *bucket);\par
  379         hlist_for_each_entry_rcu(flow, head, flow_table.node[ver]) \{\par
  380             if (i < *last) \{\par
  381                 i++;\par
  382                 continue;\par
  383             \}\par
  384             *last = i + 1;\par
  385             return flow;\par
  386         \}\par
  387         (*bucket)++;\par
  388         *last = 0;\par
  389     \}\par
  390 \par
  391     return NULL;\par
  392 \}\par
}
}
{\xe \v ovs_flow_tbl_flush\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_flush (struct {\b flow_table} *  {\i flow_table})}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   463 \{\par
  464     struct table_instance *old_ti, *new_ti;\par
  465     struct table_instance *old_ufid_ti, *new_ufid_ti;\par
  466 \par
  467     new_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  468     if (!new_ti)\par
  469         return -ENOMEM;\par
  470     new_ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  471     if (!new_ufid_ti)\par
  472         goto err_free_ti;\par
  473 \par
  474     old_ti = ovsl_dereference(flow_table->ti);\par
  475     old_ufid_ti = ovsl_dereference(flow_table->ufid_ti);\par
  476 \par
  477     rcu_assign_pointer(flow_table->ti, new_ti);\par
  478     rcu_assign_pointer(flow_table->ufid_ti, new_ufid_ti);\par
  479     flow_table->last_rehash = jiffies;\par
  480     flow_table->count = 0;\par
  481     flow_table->ufid_count = 0;\par
  482 \par
  483     table_instance_destroy(old_ti, old_ufid_ti, true);\par
  484     return 0;\par
  485 \par
  486 err_free_ti:\par
  487     __table_instance_destroy(new_ti);\par
  488     return -ENOMEM;\par
  489 \}\par
}
}
{\xe \v ovs_flow_tbl_init\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_init (struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271 \{\par
  272     struct table_instance *ti, *ufid_ti;\par
  273     struct mask_array *ma;\par
  274 \par
  275     table->mask_cache = __alloc_percpu(sizeof(struct mask_cache_entry) *\par
  276                       MC_HASH_ENTRIES, __alignof__(struct mask_cache_entry));\par
  277     if (!table->mask_cache)\par
  278         return -ENOMEM;\par
  279 \par
  280     ma = tbl_mask_array_alloc(MASK_ARRAY_SIZE_MIN);\par
  281     if (!ma)\par
  282         goto free_mask_cache;\par
  283 \par
  284     ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  285     if (!ti)\par
  286         goto free_mask_array;\par
  287 \par
  288     ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  289     if (!ufid_ti)\par
  290         goto free_ti;\par
  291 \par
  292     rcu_assign_pointer(table->ti, ti);\par
  293     rcu_assign_pointer(table->ufid_ti, ufid_ti);\par
  294     rcu_assign_pointer(table->mask_array, ma);\par
  295     table->last_rehash = jiffies;\par
  296     table->count = 0;\par
  297     table->ufid_count = 0;\par
  298     return 0;\par
  299 \par
  300 free_ti:\par
  301     __table_instance_destroy(ti);\par
  302 free_mask_array:\par
  303     kfree(ma);\par
  304 free_mask_cache:\par
  305     free_percpu(table->mask_cache);\par
  306     return -ENOMEM;\par
  307 \}\par
}
}
{\xe \v ovs_flow_tbl_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   969 \{\par
  970     int err;\par
  971 \par
  972     err = flow_mask_insert(table, flow, mask);\par
  973     if (err)\par
  974         return err;\par
  975     flow_key_insert(table, flow);\par
  976     if (ovs_identifier_is_ufid(&flow->id))\par
  977         flow_ufid_insert(table, flow);\par
  978 \par
  979     return 0;\par
  980 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_key} *  {\i key})}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   677 \{\par
  678     struct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\par
  679     struct mask_array *ma = rcu_dereference_ovsl(tbl->mask_array);\par
  680     u32 __always_unused n_mask_hit;\par
  681     u32 index = 0;\par
  682 \par
  683     return flow_lookup(tbl, ti, ma, key, &n_mask_hit, &index);\par
  684 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_exact\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_lookup_exact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_exact (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_match} *  {\i match})}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   688 \{\par
  689     struct mask_array *ma = ovsl_dereference(tbl->mask_array);\par
  690     int i;\par
  691 \par
  692     /* Always called under ovs-mutex. */\par
  693     for (i = 0; i < ma->max; i++) \{\par
  694         struct table_instance *ti = ovsl_dereference(tbl->ti);\par
  695         u32 __always_unused n_mask_hit;\par
  696         struct sw_flow_mask *mask;\par
  697         struct sw_flow *flow;\par
  698 \par
  699         mask = ovsl_dereference(ma->masks[i]);\par
  700         if (!mask)\par
  701             continue;\par
  702         flow = masked_flow_lookup(ti, match->key, mask, &n_mask_hit);\par
  703         if (flow && ovs_identifier_is_key(&flow->id) &&\par
  704             ovs_flow_cmp_unmasked_key(flow, match))\par
  705             return flow;\par
  706     \}\par
  707     return NULL;\par
  708 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_stats\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_lookup_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_stats (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_key} *  {\i key}, u32  {\i skb_hash}, u32 *  {\i n_mask_hit})}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   622 \{\par
  623     struct mask_array *ma = rcu_dereference(tbl->mask_array);\par
  624     struct table_instance *ti = rcu_dereference(tbl->ti);\par
  625     struct mask_cache_entry *entries, *ce;\par
  626     struct sw_flow *flow;\par
  627     u32 hash;\par
  628     int seg;\par
  629 \par
  630     *n_mask_hit = 0;\par
  631     if (unlikely(!skb_hash)) \{\par
  632         u32 mask_index = 0;\par
  633 \par
  634         return flow_lookup(tbl, ti, ma, key, n_mask_hit, &mask_index);\par
  635     \}\par
  636 \par
  637     /* Pre and post recirulation flows usually have the same skb_hash\par
  638      * value. To avoid hash collisions, rehash the 'skb_hash' with\par
  639      * 'recirc_id'.  */\par
  640     if (key->recirc_id)\par
  641         skb_hash = jhash_1word(skb_hash, key->recirc_id);\par
  642 \par
  643     ce = NULL;\par
  644     hash = skb_hash;\par
  645     entries = this_cpu_ptr(tbl->mask_cache);\par
  646 \par
  647     /* Find the cache entry 'ce' to operate on. */\par
  648     for (seg = 0; seg < MC_HASH_SEGS; seg++) \{\par
  649         int index = hash & (MC_HASH_ENTRIES - 1);\par
  650         struct mask_cache_entry *e;\par
  651 \par
  652         e = &entries[index];\par
  653         if (e->skb_hash == skb_hash) \{\par
  654             flow = flow_lookup(tbl, ti, ma, key, n_mask_hit,\par
  655                        &e->mask_index);\par
  656             if (!flow)\par
  657                 e->skb_hash = 0;\par
  658             return flow;\par
  659         \}\par
  660 \par
  661         if (!ce || e->skb_hash < ce->skb_hash)\par
  662             ce = e;  /* A better replacement cache candidate. */\par
  663 \par
  664         hash >>= MC_HASH_SHIFT;\par
  665     \}\par
  666 \par
  667     /* Cache miss, do full lookup. */\par
  668     flow = flow_lookup(tbl, ti, ma, key, n_mask_hit, &ce->mask_index);\par
  669     if (flow)\par
  670         ce->skb_hash = skb_hash;\par
  671 \par
  672     return flow;\par
  673 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_ufid\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_lookup_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_ufid (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_id} *  {\i ufid})}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   734 \{\par
  735     struct table_instance *ti = rcu_dereference_ovsl(tbl->ufid_ti);\par
  736     struct sw_flow *flow;\par
  737     struct hlist_head *head;\par
  738     u32 hash;\par
  739 \par
  740     hash = ufid_hash(ufid);\par
  741     head = find_bucket(ti, hash);\par
  742     hlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver]) \{\par
  743         if (flow->ufid_table.hash == hash &&\par
  744             ovs_flow_cmp_ufid(flow, ufid))\par
  745             return flow;\par
  746     \}\par
  747     return NULL;\par
  748 \}\par
}
}
{\xe \v ovs_flow_tbl_num_masks\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_num_masks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_num_masks (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   751 \{\par
  752     struct mask_array *ma;\par
  753 \par
  754     ma = rcu_dereference_ovsl(table->mask_array);\par
  755     return ma->count;\par
  756 \}\par
}
}
{\xe \v ovs_flow_tbl_remove\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ovs_flow_tbl_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_remove (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow})}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   809 \{\par
  810     struct table_instance *ti = ovsl_dereference(table->ti);\par
  811     struct table_instance *ufid_ti = ovsl_dereference(table->ufid_ti);\par
  812 \par
  813     BUG_ON(table->count == 0);\par
  814     hlist_del_rcu(&flow->flow_table.node[ti->node_ver]);\par
  815     table->count--;\par
  816     if (ovs_identifier_is_ufid(&flow->id)) \{\par
  817         hlist_del_rcu(&flow->ufid_table.node[ufid_ti->node_ver]);\par
  818         table->ufid_count--;\par
  819     \}\par
  820 \par
  821     /* RCU delete the mask. 'flow->mask' is not NULLed, as it should be\par
  822      * accessible as long as the RCU read lock is held.\par
  823      */\par
  824     flow_mask_remove(table, flow->mask);\par
  825 \}\par
}
}
{\xe \v range_n_bytes\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:range_n_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u16 range_n_bytes (const struct {\b sw_flow_key_range} *  {\i range}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return range->end - range->start;\par
   63 \}\par
}
}
{\xe \v rcu_free_flow_callback\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:rcu_free_flow_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_flow_callback (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   162 \{\par
  163     struct sw_flow *flow = container_of(rcu, struct sw_flow, rcu);\par
  164 \par
  165     flow_free(flow);\par
  166 \}\par
}
}
{\xe \v rcu_free_sw_flow_mask_cb\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:rcu_free_sw_flow_mask_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_sw_flow_mask_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   169 \{\par
  170     struct sw_flow_mask *mask = container_of(rcu, struct sw_flow_mask, rcu);\par
  171 \par
  172     kfree(mask);\par
  173 \}\par
}
}
{\xe \v table_instance_alloc\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:table_instance_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_alloc (int  {\i new_size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199 \{\par
  200     struct table_instance *ti = kmalloc(sizeof(*ti), GFP_KERNEL);\par
  201 \par
  202     if (!ti)\par
  203         return NULL;\par
  204 \par
  205     ti->buckets = alloc_buckets(new_size);\par
  206 \par
  207     if (!ti->buckets) \{\par
  208         kfree(ti);\par
  209         return NULL;\par
  210     \}\par
  211     ti->n_buckets = new_size;\par
  212     ti->node_ver = 0;\par
  213     ti->keep_flows = false;\par
  214     get_random_bytes(&ti->hash_seed, sizeof(u32));\par
  215 \par
  216     return ti;\par
  217 \}\par
}
}
{\xe \v table_instance_destroy\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:table_instance_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void table_instance_destroy (struct {\b table_instance} *  {\i ti}, struct {\b table_instance} *  {\i ufid_ti}, {\b bool}  {\i deferred}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   319 \{\par
  320     int i;\par
  321 \par
  322     if (!ti)\par
  323         return;\par
  324 \par
  325     BUG_ON(!ufid_ti);\par
  326     if (ti->keep_flows)\par
  327         goto skip_flows;\par
  328 \par
  329     for (i = 0; i < ti->n_buckets; i++) \{\par
  330         struct sw_flow *flow;\par
  331         struct hlist_head *head = flex_array_get(ti->buckets, i);\par
  332         struct hlist_node *n;\par
  333         int ver = ti->node_ver;\par
  334         int ufid_ver = ufid_ti->node_ver;\par
  335 \par
  336         hlist_for_each_entry_safe(flow, n, head, flow_table.node[ver]) \{\par
  337             hlist_del_rcu(&flow->flow_table.node[ver]);\par
  338             if (ovs_identifier_is_ufid(&flow->id))\par
  339                 hlist_del_rcu(&flow->ufid_table.node[ufid_ver]);\par
  340             ovs_flow_free(flow, deferred);\par
  341         \}\par
  342     \}\par
  343 \par
  344 skip_flows:\par
  345     if (deferred) \{\par
  346         call_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\par
  347         call_rcu(&ufid_ti->rcu, flow_tbl_destroy_rcu_cb);\par
  348     \} else \{\par
  349         __table_instance_destroy(ti);\par
  350         __table_instance_destroy(ufid_ti);\par
  351     \}\par
  352 \}\par
}
}
{\xe \v table_instance_expand\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:table_instance_expand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_expand (struct {\b table_instance} *  {\i ti}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   760 \{\par
  761     return table_instance_rehash(ti, ti->n_buckets * 2, ufid);\par
  762 \}\par
}
}
{\xe \v table_instance_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:table_instance_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void table_instance_insert (struct {\b table_instance} *  {\i ti}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   403 \{\par
  404     struct hlist_head *head;\par
  405 \par
  406     head = find_bucket(ti, flow->flow_table.hash);\par
  407     hlist_add_head_rcu(&flow->flow_table.node[ti->node_ver], head);\par
  408 \}\par
}
}
{\xe \v table_instance_rehash\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:table_instance_rehash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b table_instance}* table_instance_rehash (struct {\b table_instance} *  {\i ti}, int  {\i n_buckets}, {\b bool}  {\i ufid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   450 \{\par
  451     struct table_instance *new_ti;\par
  452 \par
  453     new_ti = table_instance_alloc(n_buckets);\par
  454     if (!new_ti)\par
  455         return NULL;\par
  456 \par
  457     flow_table_copy_flows(ti, new_ti, ufid);\par
  458 \par
  459     return new_ti;\par
  460 \}\par
}
}
{\xe \v tbl_mask_array_alloc\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:tbl_mask_array_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b mask_array}* tbl_mask_array_alloc (int  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227 \{\par
  228     struct mask_array *new;\par
  229 \par
  230     size = max(MASK_ARRAY_SIZE_MIN, size);\par
  231     new = kzalloc(sizeof(struct mask_array) +\par
  232               sizeof(struct sw_flow_mask *) * size, GFP_KERNEL);\par
  233     if (!new)\par
  234         return NULL;\par
  235 \par
  236     new->count = 0;\par
  237     new->max = size;\par
  238 \par
  239     return new;\par
  240 \}\par
}
}
{\xe \v tbl_mask_array_delete_mask\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:tbl_mask_array_delete_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tbl_mask_array_delete_mask (struct {\b mask_array} *  {\i ma}, struct {\b sw_flow_mask} *  {\i mask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   766 \{\par
  767     int i;\par
  768 \par
  769     /* Remove the deleted mask pointers from the array */\par
  770     for (i = 0; i < ma->max; i++) \{\par
  771         if (mask == ovsl_dereference(ma->masks[i])) \{\par
  772             RCU_INIT_POINTER(ma->masks[i], NULL);\par
  773             ma->count--;\par
  774             call_rcu(&mask->rcu, rcu_free_sw_flow_mask_cb);\par
  775             return;\par
  776         \}\par
  777     \}\par
  778     BUG();\par
  779 \}\par
}
}
{\xe \v tbl_mask_array_realloc\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:tbl_mask_array_realloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int tbl_mask_array_realloc (struct {\b flow_table} *  {\i tbl}, int  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   243 \{\par
  244     struct mask_array *old;\par
  245     struct mask_array *new;\par
  246 \par
  247     new = tbl_mask_array_alloc(size);\par
  248     if (!new)\par
  249         return -ENOMEM;\par
  250 \par
  251     old = ovsl_dereference(tbl->mask_array);\par
  252     if (old) \{\par
  253         int i, count = 0;\par
  254 \par
  255         for (i = 0; i < old->max; i++) \{\par
  256             if (ovsl_dereference(old->masks[i]))\par
  257                 new->masks[count++] = old->masks[i];\par
  258         \}\par
  259 \par
  260         new->count = count;\par
  261     \}\par
  262     rcu_assign_pointer(tbl->mask_array, new);\par
  263 \par
  264     if (old)\par
  265         call_rcu(&old->rcu, mask_array_rcu_cb);\par
  266 \par
  267     return 0;\par
  268 \}\par
}
}
{\xe \v ufid_hash\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ufid_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u32 ufid_hash (const struct {\b sw_flow_id} *  {\i sfid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   711 \{\par
  712     return jhash(sfid->ufid, sfid->ufid_len, 0);\par
  713 \}\par
}
}
{\xe \v ufid_table_instance_insert\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:ufid_table_instance_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ufid_table_instance_insert (struct {\b table_instance} *  {\i ti}, struct {\b sw_flow} *  {\i flow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   412 \{\par
  413     struct hlist_head *head;\par
  414 \par
  415     head = find_bucket(ti, flow->ufid_table.hash);\par
  416     hlist_add_head_rcu(&flow->ufid_table.node[ti->node_ver], head);\par
  417 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct kmem_cache* {\b flow_stats_cache} __read_mostly}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flow_cache\:linux/flow_table.c}
{\xe \v linux/flow_table.c\:flow_cache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct kmem_cache* flow_cache{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/flow_table.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/flow_table.h}
{\xe \v /home/vladn/git/ovs/datapath/flow_table.h}
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/in6.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/time.h>}\par
{\f2 #include <linux/flex_array.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include "flow.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_table.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__table_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__table_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b mask_cache_entry}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b mask_array}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b table_instance}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b flow_table}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_alloc} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_free} (struct {\b sw_flow} *, {\b bool} deferred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_init} (struct {\b flow_table} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_count} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_destroy} (struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_flush} (struct {\b flow_table} *{\b flow_table})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_insert} (struct {\b flow_table} *table, struct {\b sw_flow} *flow, const struct {\b sw_flow_mask} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_tbl_remove} (struct {\b flow_table} *table, struct {\b sw_flow} *flow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_flow_tbl_num_masks} (const struct {\b flow_table} *table)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_dump_next} (struct {\b table_instance} *table, u32 *bucket, u32 *idx)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_stats} (struct {\b flow_table} *, const struct {\b sw_flow_key} *, u32 skb_hash, u32 *n_mask_hit)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup} (struct {\b flow_table} *, const struct {\b sw_flow_key} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_exact} (struct {\b flow_table} *tbl, const struct {\b sw_flow_match} *match)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sw_flow} * {\b ovs_flow_tbl_lookup_ufid} (struct {\b flow_table} *, const struct {\b sw_flow_id} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_flow_cmp} (const struct {\b sw_flow} *, const struct {\b sw_flow_match} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_flow_mask_key} (struct {\b sw_flow_key} *{\b dst}, const struct {\b sw_flow_key} *{\b src}, const struct {\b sw_flow_mask} *mask)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct kmem_cache * {\b flow_stats_cache}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_flow_alloc\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_alloc (void )}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    84 \{\par
   85     struct sw_flow *flow;\par
   86     struct flow_stats *stats;\par
   87     int node;\par
   88 \par
   89     flow = kmem_cache_alloc(flow_cache, GFP_KERNEL);\par
   90     if (!flow)\par
   91         return ERR_PTR(-ENOMEM);\par
   92 \par
   93     flow->sf_acts = NULL;\par
   94     flow->mask = NULL;\par
   95     flow->id.ufid_len = 0;\par
   96     flow->id.unmasked_key = NULL;\par
   97     flow->stats_last_writer = NUMA_NO_NODE;\par
   98 \par
   99     /* Initialize the default stat node. */\par
  100     stats = kmem_cache_alloc_node(flow_stats_cache,\par
  101                       GFP_KERNEL | __GFP_ZERO, 0);\par
  102     if (!stats)\par
  103         goto err;\par
  104 \par
  105     spin_lock_init(&stats->lock);\par
  106 \par
  107     RCU_INIT_POINTER(flow->stats[0], stats);\par
  108 \par
  109     for_each_node(node)\par
  110         if (node != 0)\par
  111             RCU_INIT_POINTER(flow->stats[node], NULL);\par
  112 \par
  113     return flow;\par
  114 err:\par
  115     kmem_cache_free(flow_cache, flow);\par
  116     return ERR_PTR(-ENOMEM);\par
  117 \}\par
}
}
{\xe \v ovs_flow_cmp\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_cmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_flow_cmp (const struct {\b sw_flow} * , const struct {\b sw_flow_match} * )}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   725 \{\par
  726     if (ovs_identifier_is_ufid(&flow->id))\par
  727         return flow_cmp_masked_key(flow, match->key, &match->range);\par
  728 \par
  729     return ovs_flow_cmp_unmasked_key(flow, match);\par
  730 \}\par
}
}
{\xe \v ovs_flow_exit\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_exit (void )}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1011 \{\par
 1012     kmem_cache_destroy(flow_stats_cache);\par
 1013     kmem_cache_destroy(flow_cache);\par
 1014 \}\par
}
}
{\xe \v ovs_flow_free\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_free (struct {\b sw_flow} * , {\b bool}  {\i deferred})}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     if (!flow)\par
  178         return;\par
  179 \par
  180     if (deferred)\par
  181         call_rcu(&flow->rcu, rcu_free_flow_callback);\par
  182     else\par
  183         flow_free(flow);\par
  184 \}\par
}
}
{\xe \v ovs_flow_init\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_init (void )}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   986 \{\par
  987     BUILD_BUG_ON(__alignof__(struct sw_flow_key) % __alignof__(long));\par
  988     BUILD_BUG_ON(sizeof(struct sw_flow_key) % sizeof(long));\par
  989 \par
  990     flow_cache = kmem_cache_create("sw_flow", sizeof(struct sw_flow)\par
  991                        + (nr_node_ids\par
  992                       * sizeof(struct flow_stats *)),\par
  993                        0, 0, NULL);\par
  994     if (flow_cache == NULL)\par
  995         return -ENOMEM;\par
  996 \par
  997     flow_stats_cache\par
  998         = kmem_cache_create("sw_flow_stats", sizeof(struct flow_stats),\par
  999                     0, SLAB_HWCACHE_ALIGN, NULL);\par
 1000     if (flow_stats_cache == NULL) \{\par
 1001         kmem_cache_destroy(flow_cache);\par
 1002         flow_cache = NULL;\par
 1003         return -ENOMEM;\par
 1004     \}\par
 1005 \par
 1006     return 0;\par
 1007 \}\par
}
}
{\xe \v ovs_flow_mask_key\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_mask_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_mask_key (struct {\b sw_flow_key} *  {\i dst}, const struct {\b sw_flow_key} *  {\i src}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    67 \{\par
   68     const long *m = (const long *)((const u8 *)&mask->key +\par
   69                 mask->range.start);\par
   70     const long *s = (const long *)((const u8 *)src +\par
   71                 mask->range.start);\par
   72     long *d = (long *)((u8 *)dst + mask->range.start);\par
   73     int i;\par
   74 \par
   75     /* The memory outside of the 'mask->range' are not set since\par
   76      * further operations on 'dst' only uses contents within\par
   77      * 'mask->range'.\par
   78      */\par
   79     for (i = 0; i < range_n_bytes(&mask->range); i += sizeof(long))\par
   80         *d++ = *s++ & *m++;\par
   81 \}\par
}
}
{\xe \v ovs_flow_tbl_count\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_count (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   120 \{\par
  121     return table->count;\par
  122 \}\par
}
}
{\xe \v ovs_flow_tbl_destroy\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_destroy (struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   358 \{\par
  359     struct table_instance *ti = rcu_dereference_raw(table->ti);\par
  360     struct table_instance *ufid_ti = rcu_dereference_raw(table->ufid_ti);\par
  361 \par
  362     free_percpu(table->mask_cache);\par
  363     kfree(rcu_dereference_raw(table->mask_array));\par
  364     table_instance_destroy(ti, ufid_ti, false);\par
  365 \}\par
}
}
{\xe \v ovs_flow_tbl_dump_next\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_dump_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_dump_next (struct {\b table_instance} *  {\i table}, u32 *  {\i bucket}, u32 *  {\i idx})}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   369 \{\par
  370     struct sw_flow *flow;\par
  371     struct hlist_head *head;\par
  372     int ver;\par
  373     int i;\par
  374 \par
  375     ver = ti->node_ver;\par
  376     while (*bucket < ti->n_buckets) \{\par
  377         i = 0;\par
  378         head = flex_array_get(ti->buckets, *bucket);\par
  379         hlist_for_each_entry_rcu(flow, head, flow_table.node[ver]) \{\par
  380             if (i < *last) \{\par
  381                 i++;\par
  382                 continue;\par
  383             \}\par
  384             *last = i + 1;\par
  385             return flow;\par
  386         \}\par
  387         (*bucket)++;\par
  388         *last = 0;\par
  389     \}\par
  390 \par
  391     return NULL;\par
  392 \}\par
}
}
{\xe \v ovs_flow_tbl_flush\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_flush (struct {\b flow_table} *  {\i flow_table})}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   463 \{\par
  464     struct table_instance *old_ti, *new_ti;\par
  465     struct table_instance *old_ufid_ti, *new_ufid_ti;\par
  466 \par
  467     new_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  468     if (!new_ti)\par
  469         return -ENOMEM;\par
  470     new_ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  471     if (!new_ufid_ti)\par
  472         goto err_free_ti;\par
  473 \par
  474     old_ti = ovsl_dereference(flow_table->ti);\par
  475     old_ufid_ti = ovsl_dereference(flow_table->ufid_ti);\par
  476 \par
  477     rcu_assign_pointer(flow_table->ti, new_ti);\par
  478     rcu_assign_pointer(flow_table->ufid_ti, new_ufid_ti);\par
  479     flow_table->last_rehash = jiffies;\par
  480     flow_table->count = 0;\par
  481     flow_table->ufid_count = 0;\par
  482 \par
  483     table_instance_destroy(old_ti, old_ufid_ti, true);\par
  484     return 0;\par
  485 \par
  486 err_free_ti:\par
  487     __table_instance_destroy(new_ti);\par
  488     return -ENOMEM;\par
  489 \}\par
}
}
{\xe \v ovs_flow_tbl_init\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_init (struct {\b flow_table} * )}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271 \{\par
  272     struct table_instance *ti, *ufid_ti;\par
  273     struct mask_array *ma;\par
  274 \par
  275     table->mask_cache = __alloc_percpu(sizeof(struct mask_cache_entry) *\par
  276                       MC_HASH_ENTRIES, __alignof__(struct mask_cache_entry));\par
  277     if (!table->mask_cache)\par
  278         return -ENOMEM;\par
  279 \par
  280     ma = tbl_mask_array_alloc(MASK_ARRAY_SIZE_MIN);\par
  281     if (!ma)\par
  282         goto free_mask_cache;\par
  283 \par
  284     ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  285     if (!ti)\par
  286         goto free_mask_array;\par
  287 \par
  288     ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\par
  289     if (!ufid_ti)\par
  290         goto free_ti;\par
  291 \par
  292     rcu_assign_pointer(table->ti, ti);\par
  293     rcu_assign_pointer(table->ufid_ti, ufid_ti);\par
  294     rcu_assign_pointer(table->mask_array, ma);\par
  295     table->last_rehash = jiffies;\par
  296     table->count = 0;\par
  297     table->ufid_count = 0;\par
  298     return 0;\par
  299 \par
  300 free_ti:\par
  301     __table_instance_destroy(ti);\par
  302 free_mask_array:\par
  303     kfree(ma);\par
  304 free_mask_cache:\par
  305     free_percpu(table->mask_cache);\par
  306     return -ENOMEM;\par
  307 \}\par
}
}
{\xe \v ovs_flow_tbl_insert\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_insert (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow}, const struct {\b sw_flow_mask} *  {\i mask})}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   969 \{\par
  970     int err;\par
  971 \par
  972     err = flow_mask_insert(table, flow, mask);\par
  973     if (err)\par
  974         return err;\par
  975     flow_key_insert(table, flow);\par
  976     if (ovs_identifier_is_ufid(&flow->id))\par
  977         flow_ufid_insert(table, flow);\par
  978 \par
  979     return 0;\par
  980 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup (struct {\b flow_table} * , const struct {\b sw_flow_key} * )}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   677 \{\par
  678     struct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\par
  679     struct mask_array *ma = rcu_dereference_ovsl(tbl->mask_array);\par
  680     u32 __always_unused n_mask_hit;\par
  681     u32 index = 0;\par
  682 \par
  683     return flow_lookup(tbl, ti, ma, key, &n_mask_hit, &index);\par
  684 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_exact\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_lookup_exact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_exact (struct {\b flow_table} *  {\i tbl}, const struct {\b sw_flow_match} *  {\i match})}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   688 \{\par
  689     struct mask_array *ma = ovsl_dereference(tbl->mask_array);\par
  690     int i;\par
  691 \par
  692     /* Always called under ovs-mutex. */\par
  693     for (i = 0; i < ma->max; i++) \{\par
  694         struct table_instance *ti = ovsl_dereference(tbl->ti);\par
  695         u32 __always_unused n_mask_hit;\par
  696         struct sw_flow_mask *mask;\par
  697         struct sw_flow *flow;\par
  698 \par
  699         mask = ovsl_dereference(ma->masks[i]);\par
  700         if (!mask)\par
  701             continue;\par
  702         flow = masked_flow_lookup(ti, match->key, mask, &n_mask_hit);\par
  703         if (flow && ovs_identifier_is_key(&flow->id) &&\par
  704             ovs_flow_cmp_unmasked_key(flow, match))\par
  705             return flow;\par
  706     \}\par
  707     return NULL;\par
  708 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_stats\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_lookup_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_stats (struct {\b flow_table} * , const struct {\b sw_flow_key} * , u32  {\i skb_hash}, u32 *  {\i n_mask_hit})}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   622 \{\par
  623     struct mask_array *ma = rcu_dereference(tbl->mask_array);\par
  624     struct table_instance *ti = rcu_dereference(tbl->ti);\par
  625     struct mask_cache_entry *entries, *ce;\par
  626     struct sw_flow *flow;\par
  627     u32 hash;\par
  628     int seg;\par
  629 \par
  630     *n_mask_hit = 0;\par
  631     if (unlikely(!skb_hash)) \{\par
  632         u32 mask_index = 0;\par
  633 \par
  634         return flow_lookup(tbl, ti, ma, key, n_mask_hit, &mask_index);\par
  635     \}\par
  636 \par
  637     /* Pre and post recirulation flows usually have the same skb_hash\par
  638      * value. To avoid hash collisions, rehash the 'skb_hash' with\par
  639      * 'recirc_id'.  */\par
  640     if (key->recirc_id)\par
  641         skb_hash = jhash_1word(skb_hash, key->recirc_id);\par
  642 \par
  643     ce = NULL;\par
  644     hash = skb_hash;\par
  645     entries = this_cpu_ptr(tbl->mask_cache);\par
  646 \par
  647     /* Find the cache entry 'ce' to operate on. */\par
  648     for (seg = 0; seg < MC_HASH_SEGS; seg++) \{\par
  649         int index = hash & (MC_HASH_ENTRIES - 1);\par
  650         struct mask_cache_entry *e;\par
  651 \par
  652         e = &entries[index];\par
  653         if (e->skb_hash == skb_hash) \{\par
  654             flow = flow_lookup(tbl, ti, ma, key, n_mask_hit,\par
  655                        &e->mask_index);\par
  656             if (!flow)\par
  657                 e->skb_hash = 0;\par
  658             return flow;\par
  659         \}\par
  660 \par
  661         if (!ce || e->skb_hash < ce->skb_hash)\par
  662             ce = e;  /* A better replacement cache candidate. */\par
  663 \par
  664         hash >>= MC_HASH_SHIFT;\par
  665     \}\par
  666 \par
  667     /* Cache miss, do full lookup. */\par
  668     flow = flow_lookup(tbl, ti, ma, key, n_mask_hit, &ce->mask_index);\par
  669     if (flow)\par
  670         ce->skb_hash = skb_hash;\par
  671 \par
  672     return flow;\par
  673 \}\par
}
}
{\xe \v ovs_flow_tbl_lookup_ufid\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_lookup_ufid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b sw_flow}* ovs_flow_tbl_lookup_ufid (struct {\b flow_table} * , const struct {\b sw_flow_id} * )}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   734 \{\par
  735     struct table_instance *ti = rcu_dereference_ovsl(tbl->ufid_ti);\par
  736     struct sw_flow *flow;\par
  737     struct hlist_head *head;\par
  738     u32 hash;\par
  739 \par
  740     hash = ufid_hash(ufid);\par
  741     head = find_bucket(ti, hash);\par
  742     hlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver]) \{\par
  743         if (flow->ufid_table.hash == hash &&\par
  744             ovs_flow_cmp_ufid(flow, ufid))\par
  745             return flow;\par
  746     \}\par
  747     return NULL;\par
  748 \}\par
}
}
{\xe \v ovs_flow_tbl_num_masks\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_num_masks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_flow_tbl_num_masks (const struct {\b flow_table} *  {\i table})}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   751 \{\par
  752     struct mask_array *ma;\par
  753 \par
  754     ma = rcu_dereference_ovsl(table->mask_array);\par
  755     return ma->count;\par
  756 \}\par
}
}
{\xe \v ovs_flow_tbl_remove\:flow_table.h}
{\xe \v flow_table.h\:ovs_flow_tbl_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_flow_tbl_remove (struct {\b flow_table} *  {\i table}, struct {\b sw_flow} *  {\i flow})}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   809 \{\par
  810     struct table_instance *ti = ovsl_dereference(table->ti);\par
  811     struct table_instance *ufid_ti = ovsl_dereference(table->ufid_ti);\par
  812 \par
  813     BUG_ON(table->count == 0);\par
  814     hlist_del_rcu(&flow->flow_table.node[ti->node_ver]);\par
  815     table->count--;\par
  816     if (ovs_identifier_is_ufid(&flow->id)) \{\par
  817         hlist_del_rcu(&flow->ufid_table.node[ufid_ti->node_ver]);\par
  818         table->ufid_count--;\par
  819     \}\par
  820 \par
  821     /* RCU delete the mask. 'flow->mask' is not NULLed, as it should be\par
  822      * accessible as long as the RCU read lock is held.\par
  823      */\par
  824     flow_mask_remove(table, flow->mask);\par
  825 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v flow_stats_cache\:flow_table.h}
{\xe \v flow_table.h\:flow_stats_cache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct kmem_cache* flow_stats_cache}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/dev-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/dev-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/dev-openvswitch.c}
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_bridge.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dev-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2dev-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dev_disable_lro} (struct net_device *dev)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dev_disable_lro\:compat/dev-openvswitch.c}
{\xe \v compat/dev-openvswitch.c\:dev_disable_lro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dev_disable_lro (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    31 \{ \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/dev-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/dev-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/dev-openvswitch.c}
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_bridge.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dev-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dev-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dev_disable_lro} (struct net_device *dev)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dev_disable_lro\:dev-openvswitch.c}
{\xe \v dev-openvswitch.c\:dev_disable_lro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dev_disable_lro (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    31 \{ \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/exthdrs_core.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/exthdrs_core.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/exthdrs_core.c}
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/ipv6.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for exthdrs_core.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2exthdrs__core_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_ipv6_find_hdr} (const struct sk_buff *skb, unsigned int *offset, int {\b target}, unsigned short *fragoff, int *{\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_ipv6_find_hdr})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/exthdrs_core.c}
{\xe \v compat/exthdrs_core.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_ipv6_find_hdr} )}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_ipv6_find_hdr\:compat/exthdrs_core.c}
{\xe \v compat/exthdrs_core.c\:rpl_ipv6_find_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_ipv6_find_hdr (const struct sk_buff *  {\i skb}, unsigned int *  {\i offset}, int  {\i target}, unsigned short *  {\i fragoff}, int *  {\i flags})}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81     unsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\par
   82     u8 nexthdr = ipv6_hdr(skb)->nexthdr;\par
   83     unsigned int len;\par
   84     bool found;\par
   85 \par
   86     if (fragoff)\par
   87         *fragoff = 0;\par
   88 \par
   89     if (*offset) \{\par
   90         struct ipv6hdr _ip6, *ip6;\par
   91 \par
   92         ip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);\par
   93         if (!ip6 || (ip6->version != 6)) \{\par
   94             printk(KERN_ERR "IPv6 header not found\\n");\par
   95             return -EBADMSG;\par
   96         \}\par
   97         start = *offset + sizeof(struct ipv6hdr);\par
   98         nexthdr = ip6->nexthdr;\par
   99     \}\par
  100     len = skb->len - start;\par
  101 \par
  102     do \{\par
  103         struct ipv6_opt_hdr _hdr, *hp;\par
  104         unsigned int hdrlen;\par
  105         found = (nexthdr == target);\par
  106 \par
  107         if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) \{\par
  108             if (target < 0 || found)\par
  109                 break;\par
  110             return -ENOENT;\par
  111         \}\par
  112 \par
  113         hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\par
  114         if (hp == NULL)\par
  115             return -EBADMSG;\par
  116 \par
  117         if (nexthdr == NEXTHDR_ROUTING) \{\par
  118             struct ipv6_rt_hdr _rh, *rh;\par
  119 \par
  120             rh = skb_header_pointer(skb, start, sizeof(_rh),\par
  121                         &_rh);\par
  122             if (rh == NULL)\par
  123                 return -EBADMSG;\par
  124 \par
  125             if (flags && (*flags & IP6_FH_F_SKIP_RH) &&\par
  126                 rh->segments_left == 0)\par
  127                 found = false;\par
  128         \}\par
  129 \par
  130         if (nexthdr == NEXTHDR_FRAGMENT) \{\par
  131             unsigned short _frag_off;\par
  132             __be16 *fp;\par
  133 \par
  134             if (flags)  /* Indicate that this is a fragment */\par
  135                 *flags |= IP6_FH_F_FRAG;\par
  136             fp = skb_header_pointer(skb,\par
  137                         start+offsetof(struct frag_hdr,\par
  138                                    frag_off),\par
  139                         sizeof(_frag_off),\par
  140                         &_frag_off);\par
  141             if (fp == NULL)\par
  142                 return -EBADMSG;\par
  143 \par
  144             _frag_off = ntohs(*fp) & ~0x7;\par
  145             if (_frag_off) \{\par
  146                 if (target < 0 &&\par
  147                     ((!ipv6_ext_hdr(hp->nexthdr)) ||\par
  148                      hp->nexthdr == NEXTHDR_NONE)) \{\par
  149                     if (fragoff)\par
  150                         *fragoff = _frag_off;\par
  151                     return hp->nexthdr;\par
  152                 \}\par
  153                 return -ENOENT;\par
  154             \}\par
  155             hdrlen = 8;\par
  156         \} else if (nexthdr == NEXTHDR_AUTH) \{\par
  157             if (flags && (*flags & IP6_FH_F_AUTH) && (target < 0))\par
  158                 break;\par
  159             hdrlen = (hp->hdrlen + 2) << 2;\par
  160         \} else\par
  161             hdrlen = ipv6_optlen(hp);\par
  162 \par
  163         if (!found) \{\par
  164             nexthdr = hp->nexthdr;\par
  165             len -= hdrlen;\par
  166             start += hdrlen;\par
  167         \}\par
  168     \} while (!found);\par
  169 \par
  170     *offset = start;\par
  171     return nexthdr;\par
  172 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/exthdrs_core.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/exthdrs_core.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/exthdrs_core.c}
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/ipv6.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for exthdrs_core.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "exthdrs__core_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_ipv6_find_hdr} (const struct sk_buff *skb, unsigned int *offset, int {\b target}, unsigned short *fragoff, int *{\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_ipv6_find_hdr})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:exthdrs_core.c}
{\xe \v exthdrs_core.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_ipv6_find_hdr} )}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_ipv6_find_hdr\:exthdrs_core.c}
{\xe \v exthdrs_core.c\:rpl_ipv6_find_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_ipv6_find_hdr (const struct sk_buff *  {\i skb}, unsigned int *  {\i offset}, int  {\i target}, unsigned short *  {\i fragoff}, int *  {\i flags})}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81     unsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\par
   82     u8 nexthdr = ipv6_hdr(skb)->nexthdr;\par
   83     unsigned int len;\par
   84     bool found;\par
   85 \par
   86     if (fragoff)\par
   87         *fragoff = 0;\par
   88 \par
   89     if (*offset) \{\par
   90         struct ipv6hdr _ip6, *ip6;\par
   91 \par
   92         ip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);\par
   93         if (!ip6 || (ip6->version != 6)) \{\par
   94             printk(KERN_ERR "IPv6 header not found\\n");\par
   95             return -EBADMSG;\par
   96         \}\par
   97         start = *offset + sizeof(struct ipv6hdr);\par
   98         nexthdr = ip6->nexthdr;\par
   99     \}\par
  100     len = skb->len - start;\par
  101 \par
  102     do \{\par
  103         struct ipv6_opt_hdr _hdr, *hp;\par
  104         unsigned int hdrlen;\par
  105         found = (nexthdr == target);\par
  106 \par
  107         if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) \{\par
  108             if (target < 0 || found)\par
  109                 break;\par
  110             return -ENOENT;\par
  111         \}\par
  112 \par
  113         hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\par
  114         if (hp == NULL)\par
  115             return -EBADMSG;\par
  116 \par
  117         if (nexthdr == NEXTHDR_ROUTING) \{\par
  118             struct ipv6_rt_hdr _rh, *rh;\par
  119 \par
  120             rh = skb_header_pointer(skb, start, sizeof(_rh),\par
  121                         &_rh);\par
  122             if (rh == NULL)\par
  123                 return -EBADMSG;\par
  124 \par
  125             if (flags && (*flags & IP6_FH_F_SKIP_RH) &&\par
  126                 rh->segments_left == 0)\par
  127                 found = false;\par
  128         \}\par
  129 \par
  130         if (nexthdr == NEXTHDR_FRAGMENT) \{\par
  131             unsigned short _frag_off;\par
  132             __be16 *fp;\par
  133 \par
  134             if (flags)  /* Indicate that this is a fragment */\par
  135                 *flags |= IP6_FH_F_FRAG;\par
  136             fp = skb_header_pointer(skb,\par
  137                         start+offsetof(struct frag_hdr,\par
  138                                    frag_off),\par
  139                         sizeof(_frag_off),\par
  140                         &_frag_off);\par
  141             if (fp == NULL)\par
  142                 return -EBADMSG;\par
  143 \par
  144             _frag_off = ntohs(*fp) & ~0x7;\par
  145             if (_frag_off) \{\par
  146                 if (target < 0 &&\par
  147                     ((!ipv6_ext_hdr(hp->nexthdr)) ||\par
  148                      hp->nexthdr == NEXTHDR_NONE)) \{\par
  149                     if (fragoff)\par
  150                         *fragoff = _frag_off;\par
  151                     return hp->nexthdr;\par
  152                 \}\par
  153                 return -ENOENT;\par
  154             \}\par
  155             hdrlen = 8;\par
  156         \} else if (nexthdr == NEXTHDR_AUTH) \{\par
  157             if (flags && (*flags & IP6_FH_F_AUTH) && (target < 0))\par
  158                 break;\par
  159             hdrlen = (hp->hdrlen + 2) << 2;\par
  160         \} else\par
  161             hdrlen = ipv6_optlen(hp);\par
  162 \par
  163         if (!found) \{\par
  164             nexthdr = hp->nexthdr;\par
  165             len -= hdrlen;\par
  166             start += hdrlen;\par
  167         \}\par
  168     \} while (!found);\par
  169 \par
  170     *offset = start;\par
  171     return nexthdr;\par
  172 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/flex_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/flex_array.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/flex_array.c}
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flex_array.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2flex__array_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/flex_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/flex_array.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/flex_array.c}
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flex_array.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flex__array_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/flow_dissector.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/flow_dissector.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/flow_dissector.c}
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_dissector.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2flow__dissector_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/flow_dissector.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/flow_dissector.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/flow_dissector.c}
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_dissector.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__dissector_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/genetlink-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/genetlink-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/genetlink-openvswitch.c}
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <net/genetlink.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for genetlink-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2genetlink-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_genl_notify} (struct {\b rpl_genl_family} *family, struct sk_buff *skb, struct net *net, u32 portid, u32 group, struct nlmsghdr *nlh, gfp_t {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_genl_notify})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl___genl_register_family} (struct {\b rpl_genl_family} *f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl___genl_register_family})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/genetlink-openvswitch.c}
{\xe \v compat/genetlink-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_genl_notify} )}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/genetlink-openvswitch.c}
{\xe \v compat/genetlink-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl___genl_register_family} )}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl___genl_register_family\:compat/genetlink-openvswitch.c}
{\xe \v compat/genetlink-openvswitch.c\:rpl___genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl___genl_register_family (struct {\b rpl_genl_family} *  {\i f})}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    27 \{\par
   28     int err;\par
   29 \par
   30     f->compat_family.id = f->id;\par
   31     f->compat_family.hdrsize = f->hdrsize;\par
   32     strncpy(f->compat_family.name, f->name, GENL_NAMSIZ);\par
   33     f->compat_family.version = f->version;\par
   34     f->compat_family.maxattr = f->maxattr;\par
   35     f->compat_family.netnsok = f->netnsok;\par
   36 #ifdef HAVE_PARALLEL_OPS\par
   37     f->compat_family.parallel_ops = f->parallel_ops;\par
   38 #endif\par
   39     err = genl_register_family_with_ops(&f->compat_family,\par
   40                         (struct genl_ops *) f->ops, f->n_ops);\par
   41     if (err)\par
   42         goto error;\par
   43 \par
   44     if (f->mcgrps) \{\par
   45         /* Need to Fix GROUP_ID() for more than one group. */\par
   46         BUG_ON(f->n_mcgrps > 1);\par
   47         err = genl_register_mc_group(&f->compat_family,\par
   48                          (struct genl_multicast_group *) f->mcgrps);\par
   49         if (err)\par
   50             goto error;\par
   51     \}\par
   52 error:\par
   53     return err;\par
   54 \par
   55 \}\par
}
}
{\xe \v rpl_genl_notify\:compat/genetlink-openvswitch.c}
{\xe \v compat/genetlink-openvswitch.c\:rpl_genl_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_genl_notify (struct {\b rpl_genl_family} *  {\i family}, struct sk_buff *  {\i skb}, struct net *  {\i net}, u32  {\i portid}, u32  {\i group}, struct nlmsghdr *  {\i nlh}, gfp_t  {\i flags})}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    11 \{\par
   12 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)\par
   13     struct sock *sk = net->genl_sock;\par
   14     int report = 0;\par
   15 \par
   16     if (nlh)\par
   17         report = nlmsg_report(nlh);\par
   18 \par
   19     nlmsg_notify(sk, skb, portid, group, report, flags);\par
   20 #else\par
   21     genl_notify(skb, net, portid, group, nlh, flags);\par
   22 #endif\par
   23 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/genetlink-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/genetlink-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/genetlink-openvswitch.c}
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <net/genetlink.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for genetlink-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "genetlink-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_genl_notify} (struct {\b rpl_genl_family} *family, struct sk_buff *skb, struct net *net, u32 portid, u32 group, struct nlmsghdr *nlh, gfp_t {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_genl_notify})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl___genl_register_family} (struct {\b rpl_genl_family} *f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl___genl_register_family})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:genetlink-openvswitch.c}
{\xe \v genetlink-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_genl_notify} )}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:genetlink-openvswitch.c}
{\xe \v genetlink-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl___genl_register_family} )}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl___genl_register_family\:genetlink-openvswitch.c}
{\xe \v genetlink-openvswitch.c\:rpl___genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl___genl_register_family (struct {\b rpl_genl_family} *  {\i f})}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    27 \{\par
   28     int err;\par
   29 \par
   30     f->compat_family.id = f->id;\par
   31     f->compat_family.hdrsize = f->hdrsize;\par
   32     strncpy(f->compat_family.name, f->name, GENL_NAMSIZ);\par
   33     f->compat_family.version = f->version;\par
   34     f->compat_family.maxattr = f->maxattr;\par
   35     f->compat_family.netnsok = f->netnsok;\par
   36 #ifdef HAVE_PARALLEL_OPS\par
   37     f->compat_family.parallel_ops = f->parallel_ops;\par
   38 #endif\par
   39     err = genl_register_family_with_ops(&f->compat_family,\par
   40                         (struct genl_ops *) f->ops, f->n_ops);\par
   41     if (err)\par
   42         goto error;\par
   43 \par
   44     if (f->mcgrps) \{\par
   45         /* Need to Fix GROUP_ID() for more than one group. */\par
   46         BUG_ON(f->n_mcgrps > 1);\par
   47         err = genl_register_mc_group(&f->compat_family,\par
   48                          (struct genl_multicast_group *) f->mcgrps);\par
   49         if (err)\par
   50             goto error;\par
   51     \}\par
   52 error:\par
   53     return err;\par
   54 \par
   55 \}\par
}
}
{\xe \v rpl_genl_notify\:genetlink-openvswitch.c}
{\xe \v genetlink-openvswitch.c\:rpl_genl_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_genl_notify (struct {\b rpl_genl_family} *  {\i family}, struct sk_buff *  {\i skb}, struct net *  {\i net}, u32  {\i portid}, u32  {\i group}, struct nlmsghdr *  {\i nlh}, gfp_t  {\i flags})}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    11 \{\par
   12 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)\par
   13     struct sock *sk = net->genl_sock;\par
   14     int report = 0;\par
   15 \par
   16     if (nlh)\par
   17         report = nlmsg_report(nlh);\par
   18 \par
   19     nlmsg_notify(sk, skb, portid, group, report, flags);\par
   20 #else\par
   21     genl_notify(skb, net, portid, group, nlh, flags);\par
   22 #endif\par
   23 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/geneve.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/geneve.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/geneve.c}
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for geneve.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2geneve_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:compat/geneve.c}
{\xe \v compat/geneve.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/geneve.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/geneve.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/geneve.c}
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for geneve.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "geneve_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:geneve.c}
{\xe \v geneve.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/gre.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/gre.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/gre.c}
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/kconfig.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_tunnel.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kmod.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/protocol.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gre.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2gre_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/gre.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/gre.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/gre.c}
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/kconfig.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_tunnel.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kmod.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/protocol.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gre.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gre_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/gso.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/gso.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/gso.c}
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_tunnel.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kmod.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/protocol.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gso.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2gso_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vlan_tso}\~ true\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v vlan_tso\:compat/gso.c}
{\xe \v compat/gso.c\:vlan_tso}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vlan_tso\~ true}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/gso.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/gso.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/gso.c}
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_tunnel.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/icmp.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/kmod.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include <net/protocol.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gso.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gso_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vlan_tso}\~ true\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v vlan_tso\:gso.c}
{\xe \v gso.c\:vlan_tso}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vlan_tso\~ true}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/gso.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/gso.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/gso.h}
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gso.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gso_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gso_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_clear_ovs_gso_cb} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b ovs_skb_inner_transport_offset} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_skb_init_inner_protocol} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_skb_set_inner_protocol} (struct sk_buff *skb, __be16 ethertype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be16 {\b ovs_skb_get_inner_protocol} (struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_skb_get_inner_protocol\:gso.h}
{\xe \v gso.h\:ovs_skb_get_inner_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be16 ovs_skb_get_inner_protocol (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   132 \{\par
  133     return skb->inner_protocol;\par
  134 \}\par
}
}
{\xe \v ovs_skb_init_inner_protocol\:gso.h}
{\xe \v gso.h\:ovs_skb_init_inner_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_skb_init_inner_protocol (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   110                                                                     \{\par
  111     /* Nothing to do. The inner_protocol is either zero or\par
  112      * has been set to a value by another user.\par
  113      * Either way it may be considered initialised.\par
  114      */\par
  115 \}\par
}
}
{\xe \v ovs_skb_inner_transport_offset\:gso.h}
{\xe \v gso.h\:ovs_skb_inner_transport_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int ovs_skb_inner_transport_offset (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    87 \{\par
   88     return skb_inner_transport_header(skb) - skb->data;\par
   89 \}\par
}
}
{\xe \v ovs_skb_set_inner_protocol\:gso.h}
{\xe \v gso.h\:ovs_skb_set_inner_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_skb_set_inner_protocol (struct sk_buff *  {\i skb}, __be16  {\i ethertype}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   126 \{\par
  127     skb_set_inner_protocol(skb, ethertype);\par
  128 \}\par
}
}
{\xe \v skb_clear_ovs_gso_cb\:gso.h}
{\xe \v gso.h\:skb_clear_ovs_gso_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_clear_ovs_gso_cb (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    35 \{\par
   36 \par
   37 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/bug.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/bug.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/bug.h}
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler-gcc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler-gcc.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler-gcc.h}
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __packed}\~ {\b __attribute__}((packed))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __always_unused}\~ {\b __attribute__}((unused))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __always_unused\:compiler-gcc.h}
{\xe \v compiler-gcc.h\:__always_unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __always_unused\~ {\b __attribute__}((unused))}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __packed\:compiler-gcc.h}
{\xe \v compiler-gcc.h\:__packed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __packed\~ {\b __attribute__}((packed))}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/compiler.h}
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compiler_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __percpu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __rcu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __percpu\:compiler.h}
{\xe \v compiler.h\:__percpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __percpu}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __rcu\:compiler.h}
{\xe \v compiler.h\:__rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __rcu}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/cpumask.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/cpumask.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/cpumask.h}
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b for_each_possible_cpu}\~ for_each_cpu\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v for_each_possible_cpu\:cpumask.h}
{\xe \v cpumask.h\:for_each_possible_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define for_each_possible_cpu\~ for_each_cpu}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/err.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/err.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/err.h}
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b ERR_CAST} (const void *ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} __must_check {\b IS_ERR_OR_NULL} (__force const void *ptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ERR_CAST\:err.h}
{\xe \v err.h\:ERR_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* ERR_CAST (const void *  {\i ptr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ERR_CAST - Explicitly cast an error-valued pointer to another pointer type : The pointer to cast.\par
Explicitly cast an error-valued pointer to another pointer type in such a way as to make it clear that's what's going on. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    15 \{\par
   16     /* cast away the const */\par
   17     return (void *) ptr;\par
   18 \}\par
}
}
{\xe \v IS_ERR_OR_NULL\:err.h}
{\xe \v err.h\:IS_ERR_OR_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} __must_check IS_ERR_OR_NULL (__force const void *  {\i ptr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23 \{\par
   24     return !ptr || IS_ERR_VALUE((unsigned long)ptr);\par
   25 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/etherdevice.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/etherdevice.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/etherdevice.h}
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for etherdevice.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "etherdevice_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "etherdevice_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ether_addr_copy} (u8 *{\b dst}, const u8 *{\b src})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ether_addr_copy\:etherdevice.h}
{\xe \v etherdevice.h\:ether_addr_copy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ether_addr_copy (u8 *  {\i dst}, const u8 *  {\i src}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39 \{\par
   40 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\par
   41     *(u32 *)dst = *(const u32 *)src;\par
   42     *(u16 *)(dst + 4) = *(const u16 *)(src + 4);\par
   43 #else\par
   44     u16 *a = (u16 *)dst;\par
   45     const u16 *b = (const u16 *)src;\par
   46 \par
   47     a[0] = b[0];\par
   48     a[1] = b[1];\par
   49     a[2] = b[2];\par
   50 #endif\par
   51 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/flex_array.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/flex_array.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/flex_array.h}
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flex_array.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flex__array_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flex__array_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/icmp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/icmp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/icmp.h}
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "icmp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct icmphdr * {\b icmp_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v icmp_hdr\:icmp.h}
{\xe \v icmp.h\:icmp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct icmphdr* icmp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct icmphdr *)skb_transport_header(skb);\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/icmpv6.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/icmpv6.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/icmpv6.h}
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "icmpv6_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct icmp6hdr * {\b icmp6_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v icmp6_hdr\:icmpv6.h}
{\xe \v icmpv6.h\:icmp6_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct icmp6hdr* icmp6_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct icmp6hdr *)skb_transport_header(skb);\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/if.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if.h}
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/if_arp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_arp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_arp.h}
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for if_arp.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if__arp_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if__arp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct arphdr * {\b arp_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arp_hdr\:if_arp.h}
{\xe \v if_arp.h\:arp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct arphdr* arp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    10 \{\par
   11     return (struct arphdr *)skb_network_header(skb);\par
   12 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/if_ether.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_ether.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_ether.h}
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if__ether_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_P_802_3_MIN}\~ 0x0600\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_P_8021AD}\~ 0x88A8          /* 802.1ad Service VLAN         */\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ETH_P_8021AD\:if_ether.h}
{\xe \v if_ether.h\:ETH_P_8021AD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_P_8021AD\~ 0x88A8          /* 802.1ad Service VLAN         */}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ETH_P_802_3_MIN\:if_ether.h}
{\xe \v if_ether.h\:ETH_P_802_3_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_P_802_3_MIN\~ 0x0600}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/if_vlan.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_vlan.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/if_vlan.h}
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for if_vlan.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if__vlan_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "if__vlan_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vlan_insert_tag_set_proto}(skb,  {\b proto},  vlan_tci)\~ {\b rpl_vlan_insert_tag_set_proto}(skb, vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VLAN_PRIO_MASK}\~ 0xe000 /* Priority Code Point */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VLAN_PRIO_SHIFT}\~ 13\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VLAN_CFI_MASK}\~ 0x1000 /* Canonical Format Indicator */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VLAN_TAG_PRESENT}\~ {\b VLAN_CFI_MASK}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __vlan_insert_tag}(skb,  {\b proto},  {\b tci})\~ {\b rpl_vlan_insert_tag}(skb, {\b tci})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_vlan_tag_present}(skb)\~ vlan_tx_tag_present(skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_vlan_tag_get}(skb)\~ vlan_tx_tag_get(skb)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b rpl_vlan_insert_tag_set_proto} (struct sk_buff *skb, u16 vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vlan_set_encap_proto} (struct sk_buff *skb, struct vlan_hdr *vhdr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b rpl_vlan_insert_tag} (struct sk_buff *skb, u16 vlan_tci)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __vlan_insert_tag\:if_vlan.h}
{\xe \v if_vlan.h\:__vlan_insert_tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __vlan_insert_tag( skb,  {\b proto},  {\b tci})\~ {\b rpl_vlan_insert_tag}(skb, {\b tci})}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_vlan_tag_get\:if_vlan.h}
{\xe \v if_vlan.h\:skb_vlan_tag_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_vlan_tag_get( skb)\~ vlan_tx_tag_get(skb)}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_vlan_tag_present\:if_vlan.h}
{\xe \v if_vlan.h\:skb_vlan_tag_present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_vlan_tag_present( skb)\~ vlan_tx_tag_present(skb)}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VLAN_CFI_MASK\:if_vlan.h}
{\xe \v if_vlan.h\:VLAN_CFI_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VLAN_CFI_MASK\~ 0x1000 /* Canonical Format Indicator */}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vlan_insert_tag_set_proto\:if_vlan.h}
{\xe \v if_vlan.h\:vlan_insert_tag_set_proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vlan_insert_tag_set_proto( skb,  {\b proto},  vlan_tci)\~ {\b rpl_vlan_insert_tag_set_proto}(skb, vlan_tci)}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VLAN_PRIO_MASK\:if_vlan.h}
{\xe \v if_vlan.h\:VLAN_PRIO_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VLAN_PRIO_MASK\~ 0xe000 /* Priority Code Point */}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VLAN_PRIO_SHIFT\:if_vlan.h}
{\xe \v if_vlan.h\:VLAN_PRIO_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VLAN_PRIO_SHIFT\~ 13}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VLAN_TAG_PRESENT\:if_vlan.h}
{\xe \v if_vlan.h\:VLAN_TAG_PRESENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VLAN_TAG_PRESENT\~ {\b VLAN_CFI_MASK}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_vlan_insert_tag\:if_vlan.h}
{\xe \v if_vlan.h\:rpl_vlan_insert_tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int rpl_vlan_insert_tag (struct sk_buff *  {\i skb}, u16  {\i vlan_tci}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   152 \{\par
  153     struct vlan_ethhdr *veth;\par
  154 \par
  155     if (skb_cow_head(skb, VLAN_HLEN) < 0)\par
  156         return -ENOMEM;\par
  157 \par
  158     veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);\par
  159 \par
  160     /* Move the mac addresses to the beginning of the new header. */\par
  161     memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);\par
  162     skb->mac_header -= VLAN_HLEN;\par
  163 \par
  164     /* first, the ethernet type */\par
  165     veth->h_vlan_proto = htons(ETH_P_8021Q);\par
  166 \par
  167     /* now, the TCI */\par
  168     veth->h_vlan_TCI = htons(vlan_tci);\par
  169 \par
  170     return 0;\par
  171 \}\par
}
}
{\xe \v rpl_vlan_insert_tag_set_proto\:if_vlan.h}
{\xe \v if_vlan.h\:rpl_vlan_insert_tag_set_proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* rpl_vlan_insert_tag_set_proto (struct sk_buff *  {\i skb}, u16  {\i vlan_tci}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30 \{\par
   31     struct vlan_ethhdr *veth;\par
   32 \par
   33     if (skb_cow_head(skb, VLAN_HLEN) < 0) \{\par
   34         kfree_skb(skb);\par
   35         return NULL;\par
   36     \}\par
   37     veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);\par
   38 \par
   39     /* Move the mac addresses to the beginning of the new header. */\par
   40     memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);\par
   41     skb->mac_header -= VLAN_HLEN;\par
   42 \par
   43     /* first, the ethernet type */\par
   44     veth->h_vlan_proto = htons(ETH_P_8021Q);\par
   45 \par
   46     /* now, the TCI */\par
   47     veth->h_vlan_TCI = htons(vlan_tci);\par
   48 \par
   49     skb->protocol = htons(ETH_P_8021Q);\par
   50 \par
   51     return skb;\par
   52 \}\par
}
}
{\xe \v vlan_set_encap_proto\:if_vlan.h}
{\xe \v if_vlan.h\:vlan_set_encap_proto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vlan_set_encap_proto (struct sk_buff *  {\i skb}, struct vlan_hdr *  {\i vhdr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   113 \{\par
  114     __be16 proto;\par
  115     unsigned char *rawp;\par
  116 \par
  117     /*\par
  118      * Was a VLAN packet, grab the encapsulated protocol, which the layer\par
  119      * three protocols care about.\par
  120      */\par
  121 \par
  122     proto = vhdr->h_vlan_encapsulated_proto;\par
  123     if (ntohs(proto) >= 1536) \{\par
  124         skb->protocol = proto;\par
  125         return;\par
  126     \}\par
  127 \par
  128     rawp = skb->data;\par
  129     if (*(unsigned short *) rawp == 0xFFFF)\par
  130         /*\par
  131          * This is a magic hack to spot IPX packets. Older Novell\par
  132          * breaks the protocol design and runs IPX over 802.3 without\par
  133          * an 802.2 LLC layer. We look for FFFF which isn't a used\par
  134          * 802.2 SSAP/DSAP. This won't work for fault tolerant netware\par
  135          * but does for the rest.\par
  136          */\par
  137         skb->protocol = htons(ETH_P_802_3);\par
  138     else\par
  139         /*\par
  140          * Real 802.2 LLC\par
  141          */\par
  142         skb->protocol = htons(ETH_P_802_2);\par
  143 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/in.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/in.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/in.h}
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for in.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "in_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "in_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ipv4_is_loopback} (__be32 {\b addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ipv4_is_multicast} (__be32 {\b addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ipv4_is_local_multicast} (__be32 {\b addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ipv4_is_lbcast} (__be32 {\b addr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b ipv4_is_zeronet} (__be32 {\b addr})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ipv4_is_lbcast\:in.h}
{\xe \v in.h\:ipv4_is_lbcast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ipv4_is_lbcast (__be32  {\i addr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     /* limited broadcast */\par
   46     return addr == htonl(INADDR_BROADCAST);\par
   47 \}\par
}
}
{\xe \v ipv4_is_local_multicast\:in.h}
{\xe \v in.h\:ipv4_is_local_multicast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ipv4_is_local_multicast (__be32  {\i addr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39 \{\par
   40     return (addr & htonl(0xffffff00)) == htonl(0xe0000000);\par
   41 \}\par
}
}
{\xe \v ipv4_is_loopback\:in.h}
{\xe \v in.h\:ipv4_is_loopback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ipv4_is_loopback (__be32  {\i addr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    29 \{\par
   30     return (addr & htonl(0xff000000)) == htonl(0x7f000000);\par
   31 \}\par
}
}
{\xe \v ipv4_is_multicast\:in.h}
{\xe \v in.h\:ipv4_is_multicast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ipv4_is_multicast (__be32  {\i addr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    34 \{\par
   35     return (addr & htonl(0xf0000000)) == htonl(0xe0000000);\par
   36 \}\par
}
}
{\xe \v ipv4_is_zeronet\:in.h}
{\xe \v in.h\:ipv4_is_zeronet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} ipv4_is_zeronet (__be32  {\i addr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     return (addr & htonl(0xff000000)) == htonl(0x00000000);\par
   52 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/ip.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/ip.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/ip.h}
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ip.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2ip_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2ip_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct iphdr * {\b ip_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b ip_hdrlen} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ip_hdr\:linux/ip.h}
{\xe \v linux/ip.h\:ip_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct iphdr* ip_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    10 \{\par
   11     return (struct iphdr *)skb_network_header(skb);\par
   12 \}\par
}
}
{\xe \v ip_hdrlen\:linux/ip.h}
{\xe \v linux/ip.h\:ip_hdrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int ip_hdrlen (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    15 \{\par
   16     return ip_hdr(skb)->ihl * 4;\par
   17 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/ip.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ip.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ip.h}
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ip.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2ip_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2ip_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b inet_get_local_port_range}\~ {\b rpl_inet_get_local_port_range}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rpl_inet_get_local_port_range} (struct net *net, int *low, int *high)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v inet_get_local_port_range\:net/ip.h}
{\xe \v net/ip.h\:inet_get_local_port_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define inet_get_local_port_range\~ {\b rpl_inet_get_local_port_range}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_inet_get_local_port_range\:net/ip.h}
{\xe \v net/ip.h\:rpl_inet_get_local_port_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rpl_inet_get_local_port_range (struct net *  {\i net}, int *  {\i low}, int *  {\i high}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    18 \{\par
   19     inet_get_local_port_range(low, high);\par
   20 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/ipv6.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/ipv6.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/ipv6.h}
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2ipv6_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct ipv6hdr * {\b ipv6_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ipv6_hdr\:linux/ipv6.h}
{\xe \v linux/ipv6.h\:ipv6_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct ipv6hdr* ipv6_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct ipv6hdr *)skb_network_header(skb);\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/ipv6.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ipv6.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ipv6.h}
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ipv6.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2ipv6_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2ipv6_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NEXTHDR_SCTP}\~ 132 /* Stream Control Transport Protocol */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ipv6_find_hdr}\~ {\b rpl_ipv6_find_hdr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b IP6_FH_F_FRAG} = (1 << 0), 
{\b IP6_FH_F_AUTH} = (1 << 1), 
{\b IP6_FH_F_SKIP_RH} = (1 << 2)
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_ipv6_find_hdr} (const struct sk_buff *skb, unsigned int *offset, int {\b target}, unsigned short *fragoff, int *fragflg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ipv6_find_hdr\:net/ipv6.h}
{\xe \v net/ipv6.h\:ipv6_find_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ipv6_find_hdr\~ {\b rpl_ipv6_find_hdr}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NEXTHDR_SCTP\:net/ipv6.h}
{\xe \v net/ipv6.h\:NEXTHDR_SCTP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NEXTHDR_SCTP\~ 132 /* Stream Control Transport Protocol */}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v IP6_FH_F_FRAG\:net/ipv6.h}
{\xe \v net/ipv6.h\:IP6_FH_F_FRAG}
{\b {\i IP6_FH_F_FRAG{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
}}  \par
{\xe \v IP6_FH_F_AUTH\:net/ipv6.h}
{\xe \v net/ipv6.h\:IP6_FH_F_AUTH}
{\b {\i IP6_FH_F_AUTH{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
}}  \par
{\xe \v IP6_FH_F_SKIP_RH\:net/ipv6.h}
{\xe \v net/ipv6.h\:IP6_FH_F_SKIP_RH}
{\b {\i IP6_FH_F_SKIP_RH{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    20      \{\par
   21     IP6_FH_F_FRAG           = (1 << 0),\par
   22     IP6_FH_F_AUTH           = (1 << 1),\par
   23     IP6_FH_F_SKIP_RH        = (1 << 2),\par
   24 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_ipv6_find_hdr\:net/ipv6.h}
{\xe \v net/ipv6.h\:rpl_ipv6_find_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_ipv6_find_hdr (const struct sk_buff *  {\i skb}, unsigned int *  {\i offset}, int  {\i target}, unsigned short *  {\i fragoff}, int *  {\i fragflg})}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81     unsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\par
   82     u8 nexthdr = ipv6_hdr(skb)->nexthdr;\par
   83     unsigned int len;\par
   84     bool found;\par
   85 \par
   86     if (fragoff)\par
   87         *fragoff = 0;\par
   88 \par
   89     if (*offset) \{\par
   90         struct ipv6hdr _ip6, *ip6;\par
   91 \par
   92         ip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);\par
   93         if (!ip6 || (ip6->version != 6)) \{\par
   94             printk(KERN_ERR "IPv6 header not found\\n");\par
   95             return -EBADMSG;\par
   96         \}\par
   97         start = *offset + sizeof(struct ipv6hdr);\par
   98         nexthdr = ip6->nexthdr;\par
   99     \}\par
  100     len = skb->len - start;\par
  101 \par
  102     do \{\par
  103         struct ipv6_opt_hdr _hdr, *hp;\par
  104         unsigned int hdrlen;\par
  105         found = (nexthdr == target);\par
  106 \par
  107         if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) \{\par
  108             if (target < 0 || found)\par
  109                 break;\par
  110             return -ENOENT;\par
  111         \}\par
  112 \par
  113         hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\par
  114         if (hp == NULL)\par
  115             return -EBADMSG;\par
  116 \par
  117         if (nexthdr == NEXTHDR_ROUTING) \{\par
  118             struct ipv6_rt_hdr _rh, *rh;\par
  119 \par
  120             rh = skb_header_pointer(skb, start, sizeof(_rh),\par
  121                         &_rh);\par
  122             if (rh == NULL)\par
  123                 return -EBADMSG;\par
  124 \par
  125             if (flags && (*flags & IP6_FH_F_SKIP_RH) &&\par
  126                 rh->segments_left == 0)\par
  127                 found = false;\par
  128         \}\par
  129 \par
  130         if (nexthdr == NEXTHDR_FRAGMENT) \{\par
  131             unsigned short _frag_off;\par
  132             __be16 *fp;\par
  133 \par
  134             if (flags)  /* Indicate that this is a fragment */\par
  135                 *flags |= IP6_FH_F_FRAG;\par
  136             fp = skb_header_pointer(skb,\par
  137                         start+offsetof(struct frag_hdr,\par
  138                                    frag_off),\par
  139                         sizeof(_frag_off),\par
  140                         &_frag_off);\par
  141             if (fp == NULL)\par
  142                 return -EBADMSG;\par
  143 \par
  144             _frag_off = ntohs(*fp) & ~0x7;\par
  145             if (_frag_off) \{\par
  146                 if (target < 0 &&\par
  147                     ((!ipv6_ext_hdr(hp->nexthdr)) ||\par
  148                      hp->nexthdr == NEXTHDR_NONE)) \{\par
  149                     if (fragoff)\par
  150                         *fragoff = _frag_off;\par
  151                     return hp->nexthdr;\par
  152                 \}\par
  153                 return -ENOENT;\par
  154             \}\par
  155             hdrlen = 8;\par
  156         \} else if (nexthdr == NEXTHDR_AUTH) \{\par
  157             if (flags && (*flags & IP6_FH_F_AUTH) && (target < 0))\par
  158                 break;\par
  159             hdrlen = (hp->hdrlen + 2) << 2;\par
  160         \} else\par
  161             hdrlen = ipv6_optlen(hp);\par
  162 \par
  163         if (!found) \{\par
  164             nexthdr = hp->nexthdr;\par
  165             len -= hdrlen;\par
  166             start += hdrlen;\par
  167         \}\par
  168     \} while (!found);\par
  169 \par
  170     *offset = start;\par
  171     return nexthdr;\par
  172 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/jiffies.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/jiffies.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/jiffies.h}
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for jiffies.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "jiffies_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "jiffies_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b time_after64}(a,  b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b time_before64}(a,  b)\~ {\b time_after64}(b, a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b time_after_eq64}(a,  b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b time_before_eq64}(a,  b)\~ {\b time_after_eq64}(b, a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v time_after64\:jiffies.h}
{\xe \v jiffies.h\:time_after64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define time_after64( a,  b)}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (typecheck(__u64, a) && \\\par
    typecheck(__u64, b) && \\\par
    ((__s64)(b) - (__s64)(a) < 0))\par
}
}
{\xe \v time_after_eq64\:jiffies.h}
{\xe \v jiffies.h\:time_after_eq64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define time_after_eq64( a,  b)}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (typecheck(__u64, a) && \\\par
    typecheck(__u64, b) && \\\par
    ((__s64)(a) - (__s64)(b) >= 0))\par
}
}
{\xe \v time_before64\:jiffies.h}
{\xe \v jiffies.h\:time_before64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define time_before64( a,  b)\~ {\b time_after64}(b, a)}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time_before_eq64\:jiffies.h}
{\xe \v jiffies.h\:time_before_eq64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define time_before_eq64( a,  b)\~ {\b time_after_eq64}(b, a)}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/kconfig.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/kconfig.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/kconfig.h}
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for kconfig.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "kconfig_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "kconfig_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __ARG_PLACEHOLDER_1}\~ 0,\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b config_enabled}(cfg)\~ {\b _config_enabled}(cfg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _config_enabled}(value)\~ {\b __config_enabled}(__ARG_PLACEHOLDER_##value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __config_enabled}(arg1_or_junk)\~ {\b ___config_enabled}(arg1_or_junk 1, 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ___config_enabled}(__ignored,  val, ...)\~ val\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IS_ENABLED}(option)\~ ({\b config_enabled}(option) || {\b config_enabled}(option##_MODULE))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IS_BUILTIN}(option)\~ {\b config_enabled}(option)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IS_MODULE}(option)\~ {\b config_enabled}(option##_MODULE)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ___config_enabled\:kconfig.h}
{\xe \v kconfig.h\:___config_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ___config_enabled( __ignored,  val,   {\i ...})\~ val}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __ARG_PLACEHOLDER_1\:kconfig.h}
{\xe \v kconfig.h\:__ARG_PLACEHOLDER_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __ARG_PLACEHOLDER_1\~ 0,}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __config_enabled\:kconfig.h}
{\xe \v kconfig.h\:__config_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __config_enabled( arg1_or_junk)\~ {\b ___config_enabled}(arg1_or_junk 1, 0)}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _config_enabled\:kconfig.h}
{\xe \v kconfig.h\:_config_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _config_enabled( value)\~ {\b __config_enabled}(__ARG_PLACEHOLDER_##value)}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v config_enabled\:kconfig.h}
{\xe \v kconfig.h\:config_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define config_enabled( cfg)\~ {\b _config_enabled}(cfg)}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IS_BUILTIN\:kconfig.h}
{\xe \v kconfig.h\:IS_BUILTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IS_BUILTIN( option)\~ {\b config_enabled}(option)}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IS_ENABLED\:kconfig.h}
{\xe \v kconfig.h\:IS_ENABLED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IS_ENABLED( option)\~ ({\b config_enabled}(option) || {\b config_enabled}(option##_MODULE))}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IS_MODULE\:kconfig.h}
{\xe \v kconfig.h\:IS_MODULE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IS_MODULE( option)\~ {\b config_enabled}(option##_MODULE)}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/kernel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/kernel.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/kernel.h}
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/log2.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for kernel.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "kernel_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "kernel_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USHRT_MAX}\~ ((u16)(~0U))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHRT_MAX}\~ ((s16)({\b USHRT_MAX}>>1))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHRT_MIN}\~ ((s16)(-{\b SHRT_MAX} - 1))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DIV_ROUND_UP}(n,  d)\~ (((n) + (d) - 1) / (d))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rounddown}(x,  y)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DIV_ROUND_UP\:kernel.h}
{\xe \v kernel.h\:DIV_ROUND_UP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DIV_ROUND_UP( n,  d)\~ (((n) + (d) - 1) / (d))}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rounddown\:kernel.h}
{\xe \v kernel.h\:rounddown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rounddown( x,  y)}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (               \\\par
\{                           \\\par
    typeof(x) __x = (x);                \\\par
    __x - (__x % (y));              \\\par
\}                           \\\par
)\par
}
}
{\xe \v SHRT_MAX\:kernel.h}
{\xe \v kernel.h\:SHRT_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHRT_MAX\~ ((s16)({\b USHRT_MAX}>>1))}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SHRT_MIN\:kernel.h}
{\xe \v kernel.h\:SHRT_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHRT_MIN\~ ((s16)(-{\b SHRT_MAX} - 1))}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v USHRT_MAX\:kernel.h}
{\xe \v kernel.h\:USHRT_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USHRT_MAX\~ ((u16)(~0U))}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/list.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/list.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/list.h}
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "list_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_entry_safe}(ptr,  {\b type},  member)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_for_each_entry}(pos,  head,  member)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_for_each_entry_safe}(pos,  n,  head,  member)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v hlist_entry_safe\:list.h}
{\xe \v list.h\:hlist_entry_safe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_entry_safe( ptr,  {\b type},  member)}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (\{ typeof(ptr) ____ptr = (ptr); \\\par
     ____ptr ? hlist_entry(____ptr, type, member) : NULL; \\\par
     \})\par
}
}
{\xe \v hlist_for_each_entry\:list.h}
{\xe \v list.h\:hlist_for_each_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_for_each_entry( pos,  head,  member)}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\\\par
         pos;                           \\\par
         pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\par
}
}
{\xe \v hlist_for_each_entry_safe\:list.h}
{\xe \v list.h\:hlist_for_each_entry_safe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_for_each_entry_safe( pos,  n,  head,  member)}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for (pos = hlist_entry_safe((head)->first, typeof(*pos), member);\\\par
         pos && (\{ n = pos->member.next; 1; \});         \\\par
         pos = hlist_entry_safe(n, typeof(*pos), member))\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/mpls.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/mpls.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/mpls.h}
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2mpls_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/mpls.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/mpls.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/mpls.h}
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/netdevice.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mpls.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2mpls_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2mpls_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MPLS_HLEN}\~ 4\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b eth_p_mpls} (__be16 eth_type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned char * {\b skb_mpls_header} (struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MPLS_HLEN\:net/mpls.h}
{\xe \v net/mpls.h\:MPLS_HLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MPLS_HLEN\~ 4}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v eth_p_mpls\:net/mpls.h}
{\xe \v net/mpls.h\:eth_p_mpls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} eth_p_mpls (__be16  {\i eth_type}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23 \{\par
   24     return eth_type == htons(ETH_P_MPLS_UC) ||\par
   25         eth_type == htons(ETH_P_MPLS_MC);\par
   26 \}\par
}
}
{\xe \v skb_mpls_header\:net/mpls.h}
{\xe \v net/mpls.h\:skb_mpls_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned char* skb_mpls_header (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    36 \{\par
   37     return skb_mac_header(skb) + skb->mac_len;\par
   38 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/net.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/net.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/net.h}
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/types.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for net.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_ratelimited_function}(function, ...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_emerg_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_emerg, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_alert_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_alert, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_crit_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_crit, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_err_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_err, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_notice_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_notice, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_warn_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_warn, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_info_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_info, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_dbg_ratelimited}(fmt, ...)\~ {\b net_ratelimited_function}(pr_debug, fmt, ##__VA_ARGS__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __net_get_random_once}\~ {\b rpl___net_get_random_once}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ___NET_RANDOM_STATIC_KEY_INIT}\~ ATOMIC_INIT(0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b net_get_random_once}(buf,  nbytes)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b rpl___net_get_random_once} (void *buf, int nbytes, {\b bool} *done, atomic_t *done_key)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ___NET_RANDOM_STATIC_KEY_INIT\:net.h}
{\xe \v net.h\:___NET_RANDOM_STATIC_KEY_INIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ___NET_RANDOM_STATIC_KEY_INIT\~ ATOMIC_INIT(0)}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __net_get_random_once\:net.h}
{\xe \v net.h\:__net_get_random_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __net_get_random_once\~ {\b rpl___net_get_random_once}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_alert_ratelimited\:net.h}
{\xe \v net.h\:net_alert_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_alert_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_alert, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_crit_ratelimited\:net.h}
{\xe \v net.h\:net_crit_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_crit_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_crit, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_dbg_ratelimited\:net.h}
{\xe \v net.h\:net_dbg_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_dbg_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_debug, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_emerg_ratelimited\:net.h}
{\xe \v net.h\:net_emerg_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_emerg_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_emerg, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_err_ratelimited\:net.h}
{\xe \v net.h\:net_err_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_err_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_err, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_get_random_once\:net.h}
{\xe \v net.h\:net_get_random_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_get_random_once( buf,  nbytes)}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (\{                              \\\par
    bool ___ret = false;                    \\\par
    static bool ___done = false;                \\\par
    static atomic_t ___done_key =               \\\par
            ___NET_RANDOM_STATIC_KEY_INIT;      \\\par
    if (!atomic_read(&___done_key))             \\\par
            ___ret = __net_get_random_once(buf,     \\\par
                           nbytes,      \\\par
                           &___done,    \\\par
                           &___done_key);   \\\par
    ___ret;                         \\\par
\})\par
}
}
{\xe \v net_info_ratelimited\:net.h}
{\xe \v net.h\:net_info_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_info_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_info, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_notice_ratelimited\:net.h}
{\xe \v net.h\:net_notice_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_notice_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_notice, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v net_ratelimited_function\:net.h}
{\xe \v net.h\:net_ratelimited_function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_ratelimited_function( function,   {\i ...})}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{                                \\\par
    if (net_ratelimit())                    \\\par
        function(__VA_ARGS__);              \\\par
\} while (0)\par
}
}
{\xe \v net_warn_ratelimited\:net.h}
{\xe \v net.h\:net_warn_ratelimited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define net_warn_ratelimited( fmt,   {\i ...})\~ {\b net_ratelimited_function}(pr_warn, fmt, ##__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl___net_get_random_once\:net.h}
{\xe \v net.h\:rpl___net_get_random_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} rpl___net_get_random_once (void *  {\i buf}, int  {\i nbytes}, {\b bool} *  {\i done}, atomic_t *  {\i done_key})}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/netdev_features.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netdev_features.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netdev_features.h}
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "netdev__features_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_GRE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_GRE_CSUM}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_IPIP}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_SIT}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_UDP_TUNNEL}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_UDP_TUNNEL_CSUM}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_MPLS}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_GSO_ENCAP_ALL}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v NETIF_F_GSO_ENCAP_ALL\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_ENCAP_ALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_ENCAP_ALL}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (NETIF_F_GSO_GRE |          \\\par
                 NETIF_F_GSO_GRE_CSUM |         \\\par
                 NETIF_F_GSO_IPIP |         \\\par
                 NETIF_F_GSO_SIT |          \\\par
                 NETIF_F_GSO_UDP_TUNNEL |       \\\par
                 NETIF_F_GSO_UDP_TUNNEL_CSUM |      \\\par
                 NETIF_F_GSO_MPLS)\par
}
}
{\xe \v NETIF_F_GSO_GRE\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_GRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_GRE\~ 0}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_GRE_CSUM\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_GRE_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_GRE_CSUM\~ 0}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_IPIP\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_IPIP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_IPIP\~ 0}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_MPLS\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_MPLS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_MPLS\~ 0}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_SIT\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_SIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_SIT\~ 0}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_UDP_TUNNEL\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_UDP_TUNNEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_UDP_TUNNEL\~ 0}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NETIF_F_GSO_UDP_TUNNEL_CSUM\:netdev_features.h}
{\xe \v netdev_features.h\:NETIF_F_GSO_UDP_TUNNEL_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_GSO_UDP_TUNNEL_CSUM\~ 0}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/netdevice.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netdevice.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netdevice.h}
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_bridge.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <linux/u64_stats_sync.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for netdevice.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "netdevice_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "netdevice_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pcpu_sw_netstats}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IFF_TX_SKB_SHARING}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IFF_OVS_DATAPATH}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IFF_LIVE_ADDR_CHANGE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b to_net_dev}(class)\~ container_of(class, struct net_device, NETDEV_DEV_MEMBER)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NET_NAME_UNKNOWN}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b alloc_netdev}(sizeof_priv,  name,  name_assign_type,  setup)\~ alloc_netdev_mq(sizeof_priv, name, setup, 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_F_FSO}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b netdev_alloc_pcpu_stats}({\b type})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef u32 {\b netdev_features_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dev_disable_lro} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct net_device * {\b dev_get_by_index_rcu} (struct net *net, int ifindex)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v alloc_netdev\:netdevice.h}
{\xe \v netdevice.h\:alloc_netdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define alloc_netdev( sizeof_priv,  name,  name_assign_type,  setup)\~ alloc_netdev_mq(sizeof_priv, name, setup, 1)}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IFF_LIVE_ADDR_CHANGE\:netdevice.h}
{\xe \v netdevice.h\:IFF_LIVE_ADDR_CHANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IFF_LIVE_ADDR_CHANGE\~ 0}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IFF_OVS_DATAPATH\:netdevice.h}
{\xe \v netdevice.h\:IFF_OVS_DATAPATH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IFF_OVS_DATAPATH\~ 0}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IFF_TX_SKB_SHARING\:netdevice.h}
{\xe \v netdevice.h\:IFF_TX_SKB_SHARING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IFF_TX_SKB_SHARING\~ 0}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NET_NAME_UNKNOWN\:netdevice.h}
{\xe \v netdevice.h\:NET_NAME_UNKNOWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NET_NAME_UNKNOWN\~ 0}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v netdev_alloc_pcpu_stats\:netdevice.h}
{\xe \v netdevice.h\:netdev_alloc_pcpu_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define netdev_alloc_pcpu_stats( {\b type})}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (\{                              \\\par
    typeof(type) __percpu *pcpu_stats = alloc_percpu(type); \\\par
    if (pcpu_stats) \{                   \\\par
        int ____i;                  \\\par
        for_each_possible_cpu(____i) \{          \\\par
            typeof(type) *stat;         \\\par
            stat = per_cpu_ptr(pcpu_stats, ____i);  \\\par
            u64_stats_init(&stat->syncp);       \\\par
        \}                       \\\par
    \}                           \\\par
    pcpu_stats;                     \\\par
\})\par
}
}
{\xe \v NETIF_F_FSO\:netdevice.h}
{\xe \v netdevice.h\:NETIF_F_FSO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_F_FSO\~ 0}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v to_net_dev\:netdevice.h}
{\xe \v netdevice.h\:to_net_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define to_net_dev( class)\~ container_of(class, struct net_device, NETDEV_DEV_MEMBER)}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v netdev_features_t\:netdevice.h}
{\xe \v netdevice.h\:netdev_features_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef u32 {\b netdev_features_t}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dev_disable_lro\:netdevice.h}
{\xe \v netdevice.h\:dev_disable_lro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dev_disable_lro (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    31 \{ \}\par
}
}
{\xe \v dev_get_by_index_rcu\:netdevice.h}
{\xe \v netdevice.h\:dev_get_by_index_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct net_device* dev_get_by_index_rcu (struct net *  {\i net}, int  {\i ifindex}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    72 \{\par
   73     struct net_device *dev;\par
   74 \par
   75     read_lock(&dev_base_lock);\par
   76     dev = __dev_get_by_index(net, ifindex);\par
   77     read_unlock(&dev_base_lock);\par
   78 \par
   79     return dev;\par
   80 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/netlink.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netlink.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/netlink.h}
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <net/netlink.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for netlink.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2netlink_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2netlink_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLA_F_NESTED}\~ (1 << 15)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLA_F_NET_BYTEORDER}\~ (1 << 14)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLA_TYPE_MASK}\~ (~({\b NLA_F_NESTED} | {\b NLA_F_NET_BYTEORDER}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLMSG_DEFAULT_SIZE}\~ (NLMSG_GOODSIZE - NLMSG_HDRLEN)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v NLA_F_NESTED\:linux/netlink.h}
{\xe \v linux/netlink.h\:NLA_F_NESTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLA_F_NESTED\~ (1 << 15)}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NLA_F_NET_BYTEORDER\:linux/netlink.h}
{\xe \v linux/netlink.h\:NLA_F_NET_BYTEORDER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLA_F_NET_BYTEORDER\~ (1 << 14)}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NLA_TYPE_MASK\:linux/netlink.h}
{\xe \v linux/netlink.h\:NLA_TYPE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLA_TYPE_MASK\~ (~({\b NLA_F_NESTED} | {\b NLA_F_NET_BYTEORDER}))}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NLMSG_DEFAULT_SIZE\:linux/netlink.h}
{\xe \v linux/netlink.h\:NLMSG_DEFAULT_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLMSG_DEFAULT_SIZE\~ (NLMSG_GOODSIZE - NLMSG_HDRLEN)}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/netlink.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/netlink.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/netlink.h}
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for netlink.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2netlink_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2netlink_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b nla_for_each_nested}(pos,  nla,  rem)\~ nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be16 {\b nla_get_be16} (const struct nlattr *nla)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b nla_put_be16} (struct sk_buff *skb, int attrtype, __be16 value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b nla_put_be32} (struct sk_buff *skb, int attrtype, __be32 value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b nla_put_be64} (struct sk_buff *skb, int attrtype, __be64 value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct nlattr * {\b nla_find_nested} (struct nlattr *nla, int attrtype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b nla_is_last} (const struct nlattr *nla, int rem)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v nla_for_each_nested\:net/netlink.h}
{\xe \v net/netlink.h\:nla_for_each_nested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define nla_for_each_nested( pos,  nla,  rem)\~ nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v nla_find_nested\:net/netlink.h}
{\xe \v net/netlink.h\:nla_find_nested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct nlattr* nla_find_nested (struct nlattr *  {\i nla}, int  {\i attrtype}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return nla_find(nla_data(nla), nla_len(nla), attrtype);\par
   63 \}\par
}
}
{\xe \v nla_get_be16\:net/netlink.h}
{\xe \v net/netlink.h\:nla_get_be16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be16 nla_get_be16 (const struct nlattr *  {\i nla}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
nla_get_be16 - return payload of __be16 attribute : __be16 netlink attribute \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    13 \{\par
   14     return *(__be16 *) nla_data(nla);\par
   15 \}\par
}
}
{\xe \v nla_is_last\:net/netlink.h}
{\xe \v net/netlink.h\:nla_is_last}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} nla_is_last (const struct nlattr *  {\i nla}, int  {\i rem}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    68 \{\par
   69     return nla->nla_len == rem;\par
   70 \}\par
}
}
{\xe \v nla_put_be16\:net/netlink.h}
{\xe \v net/netlink.h\:nla_put_be16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int nla_put_be16 (struct sk_buff *  {\i skb}, int  {\i attrtype}, __be16  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    35 \{\par
   36     return nla_put(skb, attrtype, sizeof(__be16), &value);\par
   37 \}\par
}
}
{\xe \v nla_put_be32\:net/netlink.h}
{\xe \v net/netlink.h\:nla_put_be32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int nla_put_be32 (struct sk_buff *  {\i skb}, int  {\i attrtype}, __be32  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    42 \{\par
   43     return nla_put(skb, attrtype, sizeof(__be32), &value);\par
   44 \}\par
}
}
{\xe \v nla_put_be64\:net/netlink.h}
{\xe \v net/netlink.h\:nla_put_be64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int nla_put_be64 (struct sk_buff *  {\i skb}, int  {\i attrtype}, __be64  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    49 \{\par
   50     return nla_put(skb, attrtype, sizeof(__be64), &value);\par
   51 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/openvswitch.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/openvswitch.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/openvswitch.h}
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/types.h>}\par
{\f2 #include <linux/if_ether.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for openvswitch.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "openvswitch_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "openvswitch_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_header}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_dp_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_dp_megaflow_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_vport_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_flow_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ethernet}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_mpls}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_ipv6}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_tcp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_udp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_sctp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_icmp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_icmpv6}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_arp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_key_nd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_action_push_mpls}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_action_push_vlan}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_action_hash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_action_push_tnl}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DATAPATH_FAMILY}\~ "ovs_datapath"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DATAPATH_MCGROUP}\~ "ovs_datapath"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DATAPATH_VERSION}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DP_VER_FEATURES}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DP_ATTR_MAX}\~ ({\b __OVS_DP_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DP_F_UNALIGNED}\~ (1 << 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_DP_F_VPORT_PIDS}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVSP_LOCAL}\~ ((__u32)0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_PACKET_FAMILY}\~ "ovs_packet"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_PACKET_VERSION}\~ 0x1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_PACKET_ATTR_MAX}\~ ({\b __OVS_PACKET_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VPORT_FAMILY}\~ "ovs_vport"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VPORT_MCGROUP}\~ "ovs_vport"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VPORT_VERSION}\~ 0x1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VPORT_TYPE_MAX}\~ ({\b __OVS_VPORT_TYPE_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VPORT_ATTR_MAX}\~ ({\b __OVS_VPORT_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_VXLAN_EXT_MAX}\~ ({\b __OVS_VXLAN_EXT_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_TUNNEL_ATTR_MAX}\~ ({\b __OVS_TUNNEL_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_FLOW_FAMILY}\~ "ovs_flow"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_FLOW_MCGROUP}\~ "ovs_flow"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_FLOW_VERSION}\~ 0x1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_KEY_ATTR_MAX}\~ ({\b __OVS_KEY_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_TUNNEL_KEY_ATTR_MAX}\~ ({\b __OVS_TUNNEL_KEY_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_FRAG_TYPE_MAX}\~ ({\b __OVS_FRAG_TYPE_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_FLOW_ATTR_MAX}\~ ({\b __OVS_FLOW_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_UFID_F_OMIT_KEY}\~ (1 << 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_UFID_F_OMIT_MASK}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_UFID_F_OMIT_ACTIONS}\~ (1 << 2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_SAMPLE_ATTR_MAX}\~ ({\b __OVS_SAMPLE_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_USERSPACE_ATTR_MAX}\~ ({\b __OVS_USERSPACE_ATTR_MAX} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TNL_PUSH_HEADER_SIZE}\~ 512\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OVS_ACTION_ATTR_MAX}\~ ({\b __OVS_ACTION_ATTR_MAX} - 1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_datapath_cmd} \{ {\b OVS_DP_CMD_UNSPEC}, 
{\b OVS_DP_CMD_NEW}, 
{\b OVS_DP_CMD_DEL}, 
{\b OVS_DP_CMD_GET}, 
{\b OVS_DP_CMD_SET}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_datapath_attr} \{ {\b OVS_DP_ATTR_UNSPEC}, 
{\b OVS_DP_ATTR_NAME}, 
{\b OVS_DP_ATTR_UPCALL_PID}, 
{\b OVS_DP_ATTR_STATS}, 
{\b OVS_DP_ATTR_MEGAFLOW_STATS}, 
{\b OVS_DP_ATTR_USER_FEATURES}, 
{\b __OVS_DP_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_packet_cmd} \{ {\b OVS_PACKET_CMD_UNSPEC}, 
{\b OVS_PACKET_CMD_MISS}, 
{\b OVS_PACKET_CMD_ACTION}, 
{\b OVS_PACKET_CMD_EXECUTE}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_packet_attr} \{ {\b OVS_PACKET_ATTR_UNSPEC}, 
{\b OVS_PACKET_ATTR_PACKET}, 
{\b OVS_PACKET_ATTR_KEY}, 
{\b OVS_PACKET_ATTR_ACTIONS}, 
{\b OVS_PACKET_ATTR_USERDATA}, 
{\b OVS_PACKET_ATTR_EGRESS_TUN_KEY}, 
{\b OVS_PACKET_ATTR_UNUSED1}, 
{\b OVS_PACKET_ATTR_UNUSED2}, 
{\b OVS_PACKET_ATTR_PROBE}, 
{\b __OVS_PACKET_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_vport_cmd} \{ {\b OVS_VPORT_CMD_UNSPEC}, 
{\b OVS_VPORT_CMD_NEW}, 
{\b OVS_VPORT_CMD_DEL}, 
{\b OVS_VPORT_CMD_GET}, 
{\b OVS_VPORT_CMD_SET}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_vport_type} \{ {\b OVS_VPORT_TYPE_UNSPEC}, 
{\b OVS_VPORT_TYPE_NETDEV}, 
{\b OVS_VPORT_TYPE_INTERNAL}, 
{\b OVS_VPORT_TYPE_GRE}, 
{\b OVS_VPORT_TYPE_VXLAN}, 
{\b OVS_VPORT_TYPE_GENEVE}, 
{\b OVS_VPORT_TYPE_GRE64} = 104, 
{\b OVS_VPORT_TYPE_LISP} = 105, 
{\b OVS_VPORT_TYPE_STT} = 106, 
{\b __OVS_VPORT_TYPE_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_vport_attr} \{ {\b OVS_VPORT_ATTR_UNSPEC}, 
{\b OVS_VPORT_ATTR_PORT_NO}, 
{\b OVS_VPORT_ATTR_TYPE}, 
{\b OVS_VPORT_ATTR_NAME}, 
{\b OVS_VPORT_ATTR_OPTIONS}, 
{\b OVS_VPORT_ATTR_UPCALL_PID}, 
{\b OVS_VPORT_ATTR_STATS}, 
{\b __OVS_VPORT_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b OVS_VXLAN_EXT_UNSPEC}, 
{\b OVS_VXLAN_EXT_GBP}, 
{\b __OVS_VXLAN_EXT_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b OVS_TUNNEL_ATTR_UNSPEC}, 
{\b OVS_TUNNEL_ATTR_DST_PORT}, 
{\b OVS_TUNNEL_ATTR_EXTENSION}, 
{\b __OVS_TUNNEL_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_flow_cmd} \{ {\b OVS_FLOW_CMD_UNSPEC}, 
{\b OVS_FLOW_CMD_NEW}, 
{\b OVS_FLOW_CMD_DEL}, 
{\b OVS_FLOW_CMD_GET}, 
{\b OVS_FLOW_CMD_SET}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_key_attr} \{ {\b OVS_KEY_ATTR_UNSPEC}, 
{\b OVS_KEY_ATTR_ENCAP}, 
{\b OVS_KEY_ATTR_PRIORITY}, 
{\b OVS_KEY_ATTR_IN_PORT}, 
{\b OVS_KEY_ATTR_ETHERNET}, 
{\b OVS_KEY_ATTR_VLAN}, 
{\b OVS_KEY_ATTR_ETHERTYPE}, 
{\b OVS_KEY_ATTR_IPV4}, 
{\b OVS_KEY_ATTR_IPV6}, 
{\b OVS_KEY_ATTR_TCP}, 
{\b OVS_KEY_ATTR_UDP}, 
{\b OVS_KEY_ATTR_ICMP}, 
{\b OVS_KEY_ATTR_ICMPV6}, 
{\b OVS_KEY_ATTR_ARP}, 
{\b OVS_KEY_ATTR_ND}, 
{\b OVS_KEY_ATTR_SKB_MARK}, 
{\b OVS_KEY_ATTR_TUNNEL}, 
{\b OVS_KEY_ATTR_SCTP}, 
{\b OVS_KEY_ATTR_TCP_FLAGS}, 
{\b OVS_KEY_ATTR_DP_HASH}, 
{\b OVS_KEY_ATTR_RECIRC_ID}, 
{\b OVS_KEY_ATTR_MPLS}, 
{\b __OVS_KEY_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_tunnel_key_attr} \{ {\b OVS_TUNNEL_KEY_ATTR_ID}, 
{\b OVS_TUNNEL_KEY_ATTR_IPV4_SRC}, 
{\b OVS_TUNNEL_KEY_ATTR_IPV4_DST}, 
{\b OVS_TUNNEL_KEY_ATTR_TOS}, 
{\b OVS_TUNNEL_KEY_ATTR_TTL}, 
{\b OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT}, 
{\b OVS_TUNNEL_KEY_ATTR_CSUM}, 
{\b OVS_TUNNEL_KEY_ATTR_OAM}, 
{\b OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS}, 
{\b OVS_TUNNEL_KEY_ATTR_TP_SRC}, 
{\b OVS_TUNNEL_KEY_ATTR_TP_DST}, 
{\b OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS}, 
{\b __OVS_TUNNEL_KEY_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_frag_type} \{ {\b OVS_FRAG_TYPE_NONE}, 
{\b OVS_FRAG_TYPE_FIRST}, 
{\b OVS_FRAG_TYPE_LATER}, 
{\b __OVS_FRAG_TYPE_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_flow_attr} \{ {\b OVS_FLOW_ATTR_UNSPEC}, 
{\b OVS_FLOW_ATTR_KEY}, 
{\b OVS_FLOW_ATTR_ACTIONS}, 
{\b OVS_FLOW_ATTR_STATS}, 
{\b OVS_FLOW_ATTR_TCP_FLAGS}, 
{\b OVS_FLOW_ATTR_USED}, 
{\b OVS_FLOW_ATTR_CLEAR}, 
{\b OVS_FLOW_ATTR_MASK}, 
{\b OVS_FLOW_ATTR_PROBE}, 
{\b OVS_FLOW_ATTR_UFID}, 
{\b OVS_FLOW_ATTR_UFID_FLAGS}, 
{\b __OVS_FLOW_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_sample_attr} \{ {\b OVS_SAMPLE_ATTR_UNSPEC}, 
{\b OVS_SAMPLE_ATTR_PROBABILITY}, 
{\b OVS_SAMPLE_ATTR_ACTIONS}, 
{\b __OVS_SAMPLE_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_userspace_attr} \{ {\b OVS_USERSPACE_ATTR_UNSPEC}, 
{\b OVS_USERSPACE_ATTR_PID}, 
{\b OVS_USERSPACE_ATTR_USERDATA}, 
{\b OVS_USERSPACE_ATTR_EGRESS_TUN_PORT}, 
{\b OVS_USERSPACE_ATTR_ACTIONS}, 
{\b __OVS_USERSPACE_ATTR_MAX}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_hash_alg} \{ {\b OVS_HASH_ALG_L4}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ovs_action_attr} \{ {\b OVS_ACTION_ATTR_UNSPEC}, 
{\b OVS_ACTION_ATTR_OUTPUT}, 
{\b OVS_ACTION_ATTR_USERSPACE}, 
{\b OVS_ACTION_ATTR_SET}, 
{\b OVS_ACTION_ATTR_PUSH_VLAN}, 
{\b OVS_ACTION_ATTR_POP_VLAN}, 
{\b OVS_ACTION_ATTR_SAMPLE}, 
{\b OVS_ACTION_ATTR_RECIRC}, 
{\b OVS_ACTION_ATTR_HASH}, 
{\b OVS_ACTION_ATTR_PUSH_MPLS}, 
{\b OVS_ACTION_ATTR_POP_MPLS}, 
{\b OVS_ACTION_ATTR_SET_MASKED}, 
{\b OVS_ACTION_ATTR_TUNNEL_PUSH}, 
{\b OVS_ACTION_ATTR_TUNNEL_POP}, 
{\b __OVS_ACTION_ATTR_MAX}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v OVS_ACTION_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_ACTION_ATTR_MAX\~ ({\b __OVS_ACTION_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DATAPATH_FAMILY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DATAPATH_FAMILY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DATAPATH_FAMILY\~ "ovs_datapath"}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DATAPATH_MCGROUP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DATAPATH_MCGROUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DATAPATH_MCGROUP\~ "ovs_datapath"}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DATAPATH_VERSION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DATAPATH_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DATAPATH_VERSION\~ 2}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DP_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DP_ATTR_MAX\~ ({\b __OVS_DP_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DP_F_UNALIGNED\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_F_UNALIGNED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DP_F_UNALIGNED\~ (1 << 0)}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DP_F_VPORT_PIDS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_F_VPORT_PIDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DP_F_VPORT_PIDS\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_DP_VER_FEATURES\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_VER_FEATURES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_DP_VER_FEATURES\~ 2}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_FLOW_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_FLOW_ATTR_MAX\~ ({\b __OVS_FLOW_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_FLOW_FAMILY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_FAMILY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_FLOW_FAMILY\~ "ovs_flow"}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_FLOW_MCGROUP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_MCGROUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_FLOW_MCGROUP\~ "ovs_flow"}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_FLOW_VERSION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_FLOW_VERSION\~ 0x1}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_FRAG_TYPE_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FRAG_TYPE_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_FRAG_TYPE_MAX\~ ({\b __OVS_FRAG_TYPE_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_KEY_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_KEY_ATTR_MAX\~ ({\b __OVS_KEY_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_PACKET_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_PACKET_ATTR_MAX\~ ({\b __OVS_PACKET_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_PACKET_FAMILY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_FAMILY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_PACKET_FAMILY\~ "ovs_packet"}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_PACKET_VERSION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_PACKET_VERSION\~ 0x1}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_SAMPLE_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_SAMPLE_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_SAMPLE_ATTR_MAX\~ ({\b __OVS_SAMPLE_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_TUNNEL_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_TUNNEL_ATTR_MAX\~ ({\b __OVS_TUNNEL_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_TUNNEL_KEY_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_TUNNEL_KEY_ATTR_MAX\~ ({\b __OVS_TUNNEL_KEY_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_UFID_F_OMIT_ACTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_UFID_F_OMIT_ACTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_UFID_F_OMIT_ACTIONS\~ (1 << 2)}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_UFID_F_OMIT_KEY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_UFID_F_OMIT_KEY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_UFID_F_OMIT_KEY\~ (1 << 0)}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Omit attributes for notifications.\par
If a datapath request contains an OVS_UFID_F_OMIT_* flag, then the datapath may omit the corresponding 'ovs_flow_attr' from the response. \par
}}
{\xe \v OVS_UFID_F_OMIT_MASK\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_UFID_F_OMIT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_UFID_F_OMIT_MASK\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_USERSPACE_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_USERSPACE_ATTR_MAX\~ ({\b __OVS_USERSPACE_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VPORT_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VPORT_ATTR_MAX\~ ({\b __OVS_VPORT_ATTR_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VPORT_FAMILY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_FAMILY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VPORT_FAMILY\~ "ovs_vport"}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VPORT_MCGROUP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_MCGROUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VPORT_MCGROUP\~ "ovs_vport"}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VPORT_TYPE_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VPORT_TYPE_MAX\~ ({\b __OVS_VPORT_TYPE_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VPORT_VERSION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VPORT_VERSION\~ 0x1}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVS_VXLAN_EXT_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VXLAN_EXT_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVS_VXLAN_EXT_MAX\~ ({\b __OVS_VXLAN_EXT_MAX} - 1)}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OVSP_LOCAL\:openvswitch.h}
{\xe \v openvswitch.h\:OVSP_LOCAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OVSP_LOCAL\~ ((__u32)0)}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TNL_PUSH_HEADER_SIZE\:openvswitch.h}
{\xe \v openvswitch.h\:TNL_PUSH_HEADER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TNL_PUSH_HEADER_SIZE\~ 512}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_VXLAN_EXT_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VXLAN_EXT_UNSPEC}
{\b {\i OVS_VXLAN_EXT_UNSPEC{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
}}  \par
{\xe \v OVS_VXLAN_EXT_GBP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VXLAN_EXT_GBP}
{\b {\i OVS_VXLAN_EXT_GBP{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
}}  \par
{\xe \v __OVS_VXLAN_EXT_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_VXLAN_EXT_MAX}
{\b {\i __OVS_VXLAN_EXT_MAX{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   283      \{\par
  284     OVS_VXLAN_EXT_UNSPEC,\par
  285     OVS_VXLAN_EXT_GBP,      /* Flag or __u32 */\par
  286     __OVS_VXLAN_EXT_MAX,\par
  287 \};\par
}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_TUNNEL_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_ATTR_UNSPEC}
{\b {\i OVS_TUNNEL_ATTR_UNSPEC{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
}}  \par
{\xe \v OVS_TUNNEL_ATTR_DST_PORT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_ATTR_DST_PORT}
{\b {\i OVS_TUNNEL_ATTR_DST_PORT{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
}}  \par
{\xe \v OVS_TUNNEL_ATTR_EXTENSION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_ATTR_EXTENSION}
{\b {\i OVS_TUNNEL_ATTR_EXTENSION{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
}}  \par
{\xe \v __OVS_TUNNEL_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_TUNNEL_ATTR_MAX}
{\b {\i __OVS_TUNNEL_ATTR_MAX{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   293      \{\par
  294     OVS_TUNNEL_ATTR_UNSPEC,\par
  295     OVS_TUNNEL_ATTR_DST_PORT, /* 16-bit UDP port, used by L4 tunnels. */\par
  296     OVS_TUNNEL_ATTR_EXTENSION,\par
  297     __OVS_TUNNEL_ATTR_MAX\par
  298 \};\par
}
}
{\xe \v ovs_action_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_action_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_action_attr}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_action_attr - Action types.\par
: Output packet to port. : Send packet to userspace according to nested OVS_USERSPACE_ATTR_* attributes. : Push a new outermost 802.1Q header onto the packet. : Pop the outermost 802.1Q header off the packet. : Probabilitically executes actions, as specified in the nested OVS_SAMPLE_ATTR_* attributes. : Replaces the contents of an existing header. The single nested OVS_KEY_ATTR_* attribute specifies a header to modify and its value. : Replaces the contents of an existing header. A nested OVS_KEY_ATTR_* attribute specifies a header to modify, its value, and a mask. For every bit set in the mask, the corresponding bit value is copied from the value to the packet header field, rest of the bits are left unchanged. The non-masked value bits must be passed in as zeroes. Masking is not supported for the OVS_KEY_ATTR_TUNNEL attribute. : Recirculate within the data path. : Compute and set flow hash value. : Push a new MPLS label stack entry onto the top of the packets MPLS label stack. Set the ethertype of the encapsulating frame to either ETH_P_MPLS_UC or ETH_P_MPLS_MC to indicate the new packet contents. : Pop an MPLS label stack entry off of the packet's MPLS label stack. Set the encapsulating frame's ethertype to indicate the new packet contents. This could potentially still be ETH_P_MPLS if the resulting MPLS label stack is not empty. If there is no MPLS label stack, as determined by ethertype, no action is taken.\par
Only a single header can be set with a single OVS_ACTION_ATTR_SET. Not all fields within a header are modifiable, e.g. the IPv4 protocol and fragment type may not be changed.\par
: Kernel internal masked set action translated from the . : Push tunnel header described by struct {\b ovs_action_push_tnl}. : Lookup tunnel port by port-no passed and pop tunnel header. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_ACTION_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_UNSPEC}
{\b {\i OVS_ACTION_ATTR_UNSPEC{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
}}  \par
{\xe \v OVS_ACTION_ATTR_OUTPUT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_OUTPUT}
{\b {\i OVS_ACTION_ATTR_OUTPUT{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
}}  \par
{\xe \v OVS_ACTION_ATTR_USERSPACE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_USERSPACE}
{\b {\i OVS_ACTION_ATTR_USERSPACE{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
}}  \par
{\xe \v OVS_ACTION_ATTR_SET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_SET}
{\b {\i OVS_ACTION_ATTR_SET{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
}}  \par
{\xe \v OVS_ACTION_ATTR_PUSH_VLAN\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_PUSH_VLAN}
{\b {\i OVS_ACTION_ATTR_PUSH_VLAN{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
}}  \par
{\xe \v OVS_ACTION_ATTR_POP_VLAN\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_POP_VLAN}
{\b {\i OVS_ACTION_ATTR_POP_VLAN{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
}}  \par
{\xe \v OVS_ACTION_ATTR_SAMPLE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_SAMPLE}
{\b {\i OVS_ACTION_ATTR_SAMPLE{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
}}  \par
{\xe \v OVS_ACTION_ATTR_RECIRC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_RECIRC}
{\b {\i OVS_ACTION_ATTR_RECIRC{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
}}  \par
{\xe \v OVS_ACTION_ATTR_HASH\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_HASH}
{\b {\i OVS_ACTION_ATTR_HASH{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
}}  \par
{\xe \v OVS_ACTION_ATTR_PUSH_MPLS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_PUSH_MPLS}
{\b {\i OVS_ACTION_ATTR_PUSH_MPLS{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
}}  \par
{\xe \v OVS_ACTION_ATTR_POP_MPLS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_POP_MPLS}
{\b {\i OVS_ACTION_ATTR_POP_MPLS{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
}}  \par
{\xe \v OVS_ACTION_ATTR_SET_MASKED\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_SET_MASKED}
{\b {\i OVS_ACTION_ATTR_SET_MASKED{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
}}  \par
{\xe \v OVS_ACTION_ATTR_TUNNEL_PUSH\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_TUNNEL_PUSH}
{\b {\i OVS_ACTION_ATTR_TUNNEL_PUSH{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
}}  \par
{\xe \v OVS_ACTION_ATTR_TUNNEL_POP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_ACTION_ATTR_TUNNEL_POP}
{\b {\i OVS_ACTION_ATTR_TUNNEL_POP{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
}}  \par
{\xe \v __OVS_ACTION_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_ACTION_ATTR_MAX}
{\b {\i __OVS_ACTION_ATTR_MAX{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   690                      \{\par
  691     OVS_ACTION_ATTR_UNSPEC,\par
  692     OVS_ACTION_ATTR_OUTPUT,       /* u32 port number. */\par
  693     OVS_ACTION_ATTR_USERSPACE,    /* Nested OVS_USERSPACE_ATTR_*. */\par
  694     OVS_ACTION_ATTR_SET,          /* One nested OVS_KEY_ATTR_*. */\par
  695     OVS_ACTION_ATTR_PUSH_VLAN,    /* struct ovs_action_push_vlan. */\par
  696     OVS_ACTION_ATTR_POP_VLAN,     /* No argument. */\par
  697     OVS_ACTION_ATTR_SAMPLE,       /* Nested OVS_SAMPLE_ATTR_*. */\par
  698     OVS_ACTION_ATTR_RECIRC,       /* u32 recirc_id. */\par
  699     OVS_ACTION_ATTR_HASH,         /* struct ovs_action_hash. */\par
  700     OVS_ACTION_ATTR_PUSH_MPLS,    /* struct ovs_action_push_mpls. */\par
  701     OVS_ACTION_ATTR_POP_MPLS,     /* __be16 ethertype. */\par
  702     OVS_ACTION_ATTR_SET_MASKED,   /* One nested OVS_KEY_ATTR_* including\par
  703                        * data immediately followed by a mask.\par
  704                        * The data must be zero for the unmasked\par
  705                        * bits. */\par
  706 \par
  707 #ifndef __KERNEL__\par
  708     OVS_ACTION_ATTR_TUNNEL_PUSH,   /* struct ovs_action_push_tnl*/\par
  709     OVS_ACTION_ATTR_TUNNEL_POP,    /* u32 port number. */\par
  710 #endif\par
  711     __OVS_ACTION_ATTR_MAX,        /* Nothing past this will be accepted\par
  712                        * from userspace. */\par
  713 \par
  714 #ifdef __KERNEL__\par
  715     OVS_ACTION_ATTR_SET_TO_MASKED, /* Kernel module internal masked\par
  716                     * set action converted from\par
  717                     * OVS_ACTION_ATTR_SET. */\par
  718 #endif\par
  719 \};\par
}
}
{\xe \v ovs_datapath_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_datapath_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_datapath_attr}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_datapath_attr - attributes for OVS_DP_* commands. : Name of the network device that serves as the "local
port". This is the name of the network device whose dp_ifindex is given in the &struct {\b ovs_header}. Always present in notifications. Required in OVS_DP_NEW requests. May be used as an alternative to specifying dp_ifindex in other requests (with a dp_ifindex of 0). : The Netlink socket in userspace that is initially set on the datapath port (for OVS_ACTION_ATTR_MISS). Only valid on OVS_DP_CMD_NEW requests. A value of zero indicates that upcalls should not be sent. : Statistics about packets that have passed through the datapath. Always present in notifications. : Statistics about mega flow masks usage for the datapath. Always present in notifications.\par
These attributes follow the &struct {\b ovs_header} within the Generic Netlink payload for OVS_DP_* commands. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_DP_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_UNSPEC}
{\b {\i OVS_DP_ATTR_UNSPEC{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
}}  \par
{\xe \v OVS_DP_ATTR_NAME\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_NAME}
{\b {\i OVS_DP_ATTR_NAME{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
}}  \par
{\xe \v OVS_DP_ATTR_UPCALL_PID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_UPCALL_PID}
{\b {\i OVS_DP_ATTR_UPCALL_PID{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
}}  \par
{\xe \v OVS_DP_ATTR_STATS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_STATS}
{\b {\i OVS_DP_ATTR_STATS{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
}}  \par
{\xe \v OVS_DP_ATTR_MEGAFLOW_STATS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_MEGAFLOW_STATS}
{\b {\i OVS_DP_ATTR_MEGAFLOW_STATS{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
}}  \par
{\xe \v OVS_DP_ATTR_USER_FEATURES\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_ATTR_USER_FEATURES}
{\b {\i OVS_DP_ATTR_USER_FEATURES{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
}}  \par
{\xe \v __OVS_DP_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_DP_ATTR_MAX}
{\b {\i __OVS_DP_ATTR_MAX{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   100                        \{\par
  101     OVS_DP_ATTR_UNSPEC,\par
  102     OVS_DP_ATTR_NAME,       /* name of dp_ifindex netdev */\par
  103     OVS_DP_ATTR_UPCALL_PID,     /* Netlink PID to receive upcalls */\par
  104     OVS_DP_ATTR_STATS,      /* struct ovs_dp_stats */\par
  105     OVS_DP_ATTR_MEGAFLOW_STATS, /* struct ovs_dp_megaflow_stats */\par
  106     OVS_DP_ATTR_USER_FEATURES,  /* OVS_DP_F_*  */\par
  107     __OVS_DP_ATTR_MAX\par
  108 \};\par
}
}
{\xe \v ovs_datapath_cmd\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_datapath_cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_datapath_cmd}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_DP_CMD_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_CMD_UNSPEC}
{\b {\i OVS_DP_CMD_UNSPEC{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
}}  \par
{\xe \v OVS_DP_CMD_NEW\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_CMD_NEW}
{\b {\i OVS_DP_CMD_NEW{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
}}  \par
{\xe \v OVS_DP_CMD_DEL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_CMD_DEL}
{\b {\i OVS_DP_CMD_DEL{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
}}  \par
{\xe \v OVS_DP_CMD_GET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_CMD_GET}
{\b {\i OVS_DP_CMD_GET{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
}}  \par
{\xe \v OVS_DP_CMD_SET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_DP_CMD_SET}
{\b {\i OVS_DP_CMD_SET{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    73                       \{\par
   74     OVS_DP_CMD_UNSPEC,\par
   75     OVS_DP_CMD_NEW,\par
   76     OVS_DP_CMD_DEL,\par
   77     OVS_DP_CMD_GET,\par
   78     OVS_DP_CMD_SET\par
   79 \};\par
}
}
{\xe \v ovs_flow_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_flow_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_flow_attr}}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_flow_attr - attributes for OVS_FLOW_* commands. : Nested OVS_KEY_ATTR_* attributes specifying the flow key. Always present in notifications. Required for all requests (except dumps). : Nested OVS_ACTION_ATTR_* attributes specifying the actions to take for packets that match the key. Always present in notifications. Required for OVS_FLOW_CMD_NEW requests, optional for OVS_FLOW_CMD_SET requests. An OVS_FLOW_CMD_SET without OVS_FLOW_ATTR_ACTIONS will not modify the actions. To clear the actions, an OVS_FLOW_ATTR_ACTIONS without any nested attributes must be given. : &struct {\b ovs_flow_stats} giving statistics for this flow. Present in notifications if the stats would be nonzero. Ignored in requests. : An 8-bit value giving the OR'd value of all of the TCP flags seen on packets in this flow. Only present in notifications for TCP flows, and only if it would be nonzero. Ignored in requests. : A 64-bit integer giving the time, in milliseconds on the system monotonic clock, at which a packet was last processed for this flow. Only present in notifications if a packet has been processed for this flow. Ignored in requests. : If present in a OVS_FLOW_CMD_SET request, clears the last-used time, accumulated TCP flags, and statistics for this flow. Otherwise ignored in requests. Never present in notifications. : Nested OVS_KEY_ATTR_* attributes specifying the mask bits for wildcarded flow match. Mask bit value '1' specifies exact match with corresponding flow key bit, while mask bit value '0' specifies a wildcarded match. Omitting attribute is treated as wildcarding all corresponding fields. Optional for all requests. If not present, all flow key bits are exact match bits. : A value between 1-16 octets specifying a unique identifier for the flow. Causes the flow to be indexed by this value rather than the value of the OVS_FLOW_ATTR_KEY attribute. Optional for all requests. Present in notifications if the flow was created with this attribute. : A 32-bit value of OR'd OVS_UFID_F_* flags that provide alternative semantics for flow installation and retrieval. Optional for all requests.\par
These attributes follow the &struct {\b ovs_header} within the Generic Netlink payload for OVS_FLOW_* commands. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_FLOW_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_UNSPEC}
{\b {\i OVS_FLOW_ATTR_UNSPEC{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
}}  \par
{\xe \v OVS_FLOW_ATTR_KEY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_KEY}
{\b {\i OVS_FLOW_ATTR_KEY{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
}}  \par
{\xe \v OVS_FLOW_ATTR_ACTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_ACTIONS}
{\b {\i OVS_FLOW_ATTR_ACTIONS{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
}}  \par
{\xe \v OVS_FLOW_ATTR_STATS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_STATS}
{\b {\i OVS_FLOW_ATTR_STATS{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
}}  \par
{\xe \v OVS_FLOW_ATTR_TCP_FLAGS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_TCP_FLAGS}
{\b {\i OVS_FLOW_ATTR_TCP_FLAGS{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
}}  \par
{\xe \v OVS_FLOW_ATTR_USED\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_USED}
{\b {\i OVS_FLOW_ATTR_USED{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
}}  \par
{\xe \v OVS_FLOW_ATTR_CLEAR\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_CLEAR}
{\b {\i OVS_FLOW_ATTR_CLEAR{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
}}  \par
{\xe \v OVS_FLOW_ATTR_MASK\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_MASK}
{\b {\i OVS_FLOW_ATTR_MASK{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
}}  \par
{\xe \v OVS_FLOW_ATTR_PROBE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_PROBE}
{\b {\i OVS_FLOW_ATTR_PROBE{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
}}  \par
{\xe \v OVS_FLOW_ATTR_UFID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_UFID}
{\b {\i OVS_FLOW_ATTR_UFID{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
}}  \par
{\xe \v OVS_FLOW_ATTR_UFID_FLAGS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_ATTR_UFID_FLAGS}
{\b {\i OVS_FLOW_ATTR_UFID_FLAGS{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
}}  \par
{\xe \v __OVS_FLOW_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_FLOW_ATTR_MAX}
{\b {\i __OVS_FLOW_ATTR_MAX{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   502                    \{\par
  503     OVS_FLOW_ATTR_UNSPEC,\par
  504     OVS_FLOW_ATTR_KEY,       /* Sequence of OVS_KEY_ATTR_* attributes. */\par
  505     OVS_FLOW_ATTR_ACTIONS,   /* Nested OVS_ACTION_ATTR_* attributes. */\par
  506     OVS_FLOW_ATTR_STATS,     /* struct ovs_flow_stats. */\par
  507     OVS_FLOW_ATTR_TCP_FLAGS, /* 8-bit OR'd TCP flags. */\par
  508     OVS_FLOW_ATTR_USED,      /* u64 msecs last used in monotonic time. */\par
  509     OVS_FLOW_ATTR_CLEAR,     /* Flag to clear stats, tcp_flags, used. */\par
  510     OVS_FLOW_ATTR_MASK,      /* Sequence of OVS_KEY_ATTR_* attributes. */\par
  511     OVS_FLOW_ATTR_PROBE,     /* Flow operation is a feature probe, error\par
  512                   * logging should be suppressed. */\par
  513     OVS_FLOW_ATTR_UFID,      /* Variable length unique flow identifier. */\par
  514     OVS_FLOW_ATTR_UFID_FLAGS,/* u32 of OVS_UFID_F_*. */\par
  515     __OVS_FLOW_ATTR_MAX\par
  516 \};\par
}
}
{\xe \v ovs_flow_cmd\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_flow_cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_flow_cmd}}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_FLOW_CMD_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_CMD_UNSPEC}
{\b {\i OVS_FLOW_CMD_UNSPEC{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
}}  \par
{\xe \v OVS_FLOW_CMD_NEW\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_CMD_NEW}
{\b {\i OVS_FLOW_CMD_NEW{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
}}  \par
{\xe \v OVS_FLOW_CMD_DEL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_CMD_DEL}
{\b {\i OVS_FLOW_CMD_DEL{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
}}  \par
{\xe \v OVS_FLOW_CMD_GET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_CMD_GET}
{\b {\i OVS_FLOW_CMD_GET{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
}}  \par
{\xe \v OVS_FLOW_CMD_SET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FLOW_CMD_SET}
{\b {\i OVS_FLOW_CMD_SET{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   308                   \{\par
  309     OVS_FLOW_CMD_UNSPEC,\par
  310     OVS_FLOW_CMD_NEW,\par
  311     OVS_FLOW_CMD_DEL,\par
  312     OVS_FLOW_CMD_GET,\par
  313     OVS_FLOW_CMD_SET\par
  314 \};\par
}
}
{\xe \v ovs_frag_type\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_frag_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_frag_type}}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_frag_type - IPv4 and IPv6 fragment type : Packet is not a fragment. : Packet is a fragment with offset 0. : Packet is a fragment with nonzero offset.\par
Used as the  in &struct {\b ovs_key_ipv4} and as  &struct {\b ovs_key_ipv6}. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_FRAG_TYPE_NONE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FRAG_TYPE_NONE}
{\b {\i OVS_FRAG_TYPE_NONE{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
}}  \par
{\xe \v OVS_FRAG_TYPE_FIRST\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FRAG_TYPE_FIRST}
{\b {\i OVS_FRAG_TYPE_FIRST{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
}}  \par
{\xe \v OVS_FRAG_TYPE_LATER\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_FRAG_TYPE_LATER}
{\b {\i OVS_FRAG_TYPE_LATER{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
}}  \par
{\xe \v __OVS_FRAG_TYPE_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_FRAG_TYPE_MAX}
{\b {\i __OVS_FRAG_TYPE_MAX{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   384                    \{\par
  385     OVS_FRAG_TYPE_NONE,\par
  386     OVS_FRAG_TYPE_FIRST,\par
  387     OVS_FRAG_TYPE_LATER,\par
  388     __OVS_FRAG_TYPE_MAX\par
  389 \};\par
}
}
{\xe \v ovs_hash_alg\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_hash_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_hash_alg}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_HASH_ALG_L4\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_HASH_ALG_L4}
{\b {\i OVS_HASH_ALG_L4{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   609                   \{\par
  610     OVS_HASH_ALG_L4,\par
  611 \};\par
}
}
{\xe \v ovs_key_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_key_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_key_attr}}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_KEY_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_UNSPEC}
{\b {\i OVS_KEY_ATTR_UNSPEC{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
}}  \par
{\xe \v OVS_KEY_ATTR_ENCAP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ENCAP}
{\b {\i OVS_KEY_ATTR_ENCAP{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
}}  \par
{\xe \v OVS_KEY_ATTR_PRIORITY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_PRIORITY}
{\b {\i OVS_KEY_ATTR_PRIORITY{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
}}  \par
{\xe \v OVS_KEY_ATTR_IN_PORT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_IN_PORT}
{\b {\i OVS_KEY_ATTR_IN_PORT{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
}}  \par
{\xe \v OVS_KEY_ATTR_ETHERNET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ETHERNET}
{\b {\i OVS_KEY_ATTR_ETHERNET{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
}}  \par
{\xe \v OVS_KEY_ATTR_VLAN\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_VLAN}
{\b {\i OVS_KEY_ATTR_VLAN{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
}}  \par
{\xe \v OVS_KEY_ATTR_ETHERTYPE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ETHERTYPE}
{\b {\i OVS_KEY_ATTR_ETHERTYPE{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
}}  \par
{\xe \v OVS_KEY_ATTR_IPV4\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_IPV4}
{\b {\i OVS_KEY_ATTR_IPV4{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
}}  \par
{\xe \v OVS_KEY_ATTR_IPV6\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_IPV6}
{\b {\i OVS_KEY_ATTR_IPV6{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
}}  \par
{\xe \v OVS_KEY_ATTR_TCP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_TCP}
{\b {\i OVS_KEY_ATTR_TCP{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
}}  \par
{\xe \v OVS_KEY_ATTR_UDP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_UDP}
{\b {\i OVS_KEY_ATTR_UDP{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
}}  \par
{\xe \v OVS_KEY_ATTR_ICMP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ICMP}
{\b {\i OVS_KEY_ATTR_ICMP{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
}}  \par
{\xe \v OVS_KEY_ATTR_ICMPV6\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ICMPV6}
{\b {\i OVS_KEY_ATTR_ICMPV6{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
}}  \par
{\xe \v OVS_KEY_ATTR_ARP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ARP}
{\b {\i OVS_KEY_ATTR_ARP{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
}}  \par
{\xe \v OVS_KEY_ATTR_ND\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_ND}
{\b {\i OVS_KEY_ATTR_ND{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
}}  \par
{\xe \v OVS_KEY_ATTR_SKB_MARK\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_SKB_MARK}
{\b {\i OVS_KEY_ATTR_SKB_MARK{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
}}  \par
{\xe \v OVS_KEY_ATTR_TUNNEL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_TUNNEL}
{\b {\i OVS_KEY_ATTR_TUNNEL{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
}}  \par
{\xe \v OVS_KEY_ATTR_SCTP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_SCTP}
{\b {\i OVS_KEY_ATTR_SCTP{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
}}  \par
{\xe \v OVS_KEY_ATTR_TCP_FLAGS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_TCP_FLAGS}
{\b {\i OVS_KEY_ATTR_TCP_FLAGS{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
}}  \par
{\xe \v OVS_KEY_ATTR_DP_HASH\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_DP_HASH}
{\b {\i OVS_KEY_ATTR_DP_HASH{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
}}  \par
{\xe \v OVS_KEY_ATTR_RECIRC_ID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_RECIRC_ID}
{\b {\i OVS_KEY_ATTR_RECIRC_ID{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
}}  \par
{\xe \v OVS_KEY_ATTR_MPLS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_KEY_ATTR_MPLS}
{\b {\i OVS_KEY_ATTR_MPLS{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
}}  \par
{\xe \v __OVS_KEY_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_KEY_ATTR_MAX}
{\b {\i __OVS_KEY_ATTR_MAX{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   321                   \{\par
  322     OVS_KEY_ATTR_UNSPEC,\par
  323     OVS_KEY_ATTR_ENCAP, /* Nested set of encapsulated attributes. */\par
  324     OVS_KEY_ATTR_PRIORITY,  /* u32 skb->priority */\par
  325     OVS_KEY_ATTR_IN_PORT,   /* u32 OVS dp port number */\par
  326     OVS_KEY_ATTR_ETHERNET,  /* struct ovs_key_ethernet */\par
  327     OVS_KEY_ATTR_VLAN,  /* be16 VLAN TCI */\par
  328     OVS_KEY_ATTR_ETHERTYPE, /* be16 Ethernet type */\par
  329     OVS_KEY_ATTR_IPV4,      /* struct ovs_key_ipv4 */\par
  330     OVS_KEY_ATTR_IPV6,      /* struct ovs_key_ipv6 */\par
  331     OVS_KEY_ATTR_TCP,       /* struct ovs_key_tcp */\par
  332     OVS_KEY_ATTR_UDP,       /* struct ovs_key_udp */\par
  333     OVS_KEY_ATTR_ICMP,      /* struct ovs_key_icmp */\par
  334     OVS_KEY_ATTR_ICMPV6,    /* struct ovs_key_icmpv6 */\par
  335     OVS_KEY_ATTR_ARP,       /* struct ovs_key_arp */\par
  336     OVS_KEY_ATTR_ND,        /* struct ovs_key_nd */\par
  337     OVS_KEY_ATTR_SKB_MARK,  /* u32 skb mark */\par
  338     OVS_KEY_ATTR_TUNNEL,    /* Nested set of ovs_tunnel attributes */\par
  339     OVS_KEY_ATTR_SCTP,      /* struct ovs_key_sctp */\par
  340     OVS_KEY_ATTR_TCP_FLAGS, /* be16 TCP flags. */\par
  341     OVS_KEY_ATTR_DP_HASH,   /* u32 hash value. Value 0 indicates the hash\par
  342                    is not computed by the datapath. */\par
  343     OVS_KEY_ATTR_RECIRC_ID, /* u32 recirc id */\par
  344     OVS_KEY_ATTR_MPLS,      /* array of struct ovs_key_mpls.\par
  345                  * The implementation may restrict\par
  346                  * the accepted length of the array. */\par
  347 \par
  348 #ifdef __KERNEL__\par
  349     /* Only used within kernel data path. */\par
  350     OVS_KEY_ATTR_TUNNEL_INFO,  /* struct ovs_tunnel_info */\par
  351 #endif\par
  352     __OVS_KEY_ATTR_MAX\par
  353 \};\par
}
}
{\xe \v ovs_packet_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_packet_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_packet_attr}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_packet_attr - attributes for OVS_PACKET_* commands. : Present for all notifications. Contains the entire packet as received, from the start of the Ethernet header onward. For OVS_PACKET_CMD_ACTION, OVS_PACKET_ATTR_PACKET reflects changes made by actions preceding OVS_ACTION_ATTR_USERSPACE, but OVS_PACKET_ATTR_KEY is the flow key extracted from the packet as originally received. : Present for all notifications. Contains the flow key extracted from the packet as nested OVS_KEY_ATTR_* attributes. This allows userspace to adapt its flow setup strategy by comparing its notion of the flow key against the kernel's. When used with OVS_PACKET_CMD_EXECUTE, only metadata key fields (e.g. priority, skb mark) are honored. All the packet header fields are parsed from the packet instead. : Contains actions for the packet. Used for OVS_PACKET_CMD_EXECUTE. It has nested OVS_ACTION_ATTR_* attributes. Also used in upcall when OVS_ACTION_ATTR_USERSPACE has optional OVS_USERSPACE_ATTR_ACTIONS attribute. : Present for an OVS_PACKET_CMD_ACTION notification if the OVS_ACTION_ATTR_USERSPACE action specified an OVS_USERSPACE_ATTR_USERDATA attribute, with the same length and content specified there. : Present for an OVS_PACKET_CMD_ACTION notification if the OVS_ACTION_ATTR_USERSPACE action specified an OVS_USERSPACE_ATTR_EGRESS_TUN_PORT attribute, which is sent only if the output port is actually a tunnel port. Contains the output tunnel key extracted from the packet as nested OVS_TUNNEL_KEY_ATTR_* attributes. These attributes follow the &struct {\b ovs_header} within the Generic Netlink payload for OVS_PACKET_* commands. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_PACKET_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_UNSPEC}
{\b {\i OVS_PACKET_ATTR_UNSPEC{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
}}  \par
{\xe \v OVS_PACKET_ATTR_PACKET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_PACKET}
{\b {\i OVS_PACKET_ATTR_PACKET{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
}}  \par
{\xe \v OVS_PACKET_ATTR_KEY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_KEY}
{\b {\i OVS_PACKET_ATTR_KEY{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
}}  \par
{\xe \v OVS_PACKET_ATTR_ACTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_ACTIONS}
{\b {\i OVS_PACKET_ATTR_ACTIONS{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
}}  \par
{\xe \v OVS_PACKET_ATTR_USERDATA\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_USERDATA}
{\b {\i OVS_PACKET_ATTR_USERDATA{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
}}  \par
{\xe \v OVS_PACKET_ATTR_EGRESS_TUN_KEY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_EGRESS_TUN_KEY}
{\b {\i OVS_PACKET_ATTR_EGRESS_TUN_KEY{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
}}  \par
{\xe \v OVS_PACKET_ATTR_UNUSED1\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_UNUSED1}
{\b {\i OVS_PACKET_ATTR_UNUSED1{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
}}  \par
{\xe \v OVS_PACKET_ATTR_UNUSED2\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_UNUSED2}
{\b {\i OVS_PACKET_ATTR_UNUSED2{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
}}  \par
{\xe \v OVS_PACKET_ATTR_PROBE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_ATTR_PROBE}
{\b {\i OVS_PACKET_ATTR_PROBE{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
}}  \par
{\xe \v __OVS_PACKET_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_PACKET_ATTR_MAX}
{\b {\i __OVS_PACKET_ATTR_MAX{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193                      \{\par
  194     OVS_PACKET_ATTR_UNSPEC,\par
  195     OVS_PACKET_ATTR_PACKET,      /* Packet data. */\par
  196     OVS_PACKET_ATTR_KEY,         /* Nested OVS_KEY_ATTR_* attributes. */\par
  197     OVS_PACKET_ATTR_ACTIONS,     /* Nested OVS_ACTION_ATTR_* attributes. */\par
  198     OVS_PACKET_ATTR_USERDATA,    /* OVS_ACTION_ATTR_USERSPACE arg. */\par
  199     OVS_PACKET_ATTR_EGRESS_TUN_KEY,  /* Nested OVS_TUNNEL_KEY_ATTR_*\par
  200                         attributes. */\par
  201     OVS_PACKET_ATTR_UNUSED1,\par
  202     OVS_PACKET_ATTR_UNUSED2,\par
  203     OVS_PACKET_ATTR_PROBE,      /* Packet operation is a feature probe,\par
  204                        error logging should be suppressed. */\par
  205     __OVS_PACKET_ATTR_MAX\par
  206 \};\par
}
}
{\xe \v ovs_packet_cmd\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_packet_cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_packet_cmd}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_PACKET_CMD_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_CMD_UNSPEC}
{\b {\i OVS_PACKET_CMD_UNSPEC{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
}}  \par
{\xe \v OVS_PACKET_CMD_MISS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_CMD_MISS}
{\b {\i OVS_PACKET_CMD_MISS{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
}}  \par
{\xe \v OVS_PACKET_CMD_ACTION\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_CMD_ACTION}
{\b {\i OVS_PACKET_CMD_ACTION{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
}}  \par
{\xe \v OVS_PACKET_CMD_EXECUTE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_PACKET_CMD_EXECUTE}
{\b {\i OVS_PACKET_CMD_EXECUTE{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153                     \{\par
  154     OVS_PACKET_CMD_UNSPEC,\par
  155 \par
  156     /* Kernel-to-user notifications. */\par
  157     OVS_PACKET_CMD_MISS,    /* Flow table miss. */\par
  158     OVS_PACKET_CMD_ACTION,  /* OVS_ACTION_ATTR_USERSPACE action. */\par
  159 \par
  160     /* Userspace commands. */\par
  161     OVS_PACKET_CMD_EXECUTE  /* Apply actions to a packet. */\par
  162 \};\par
}
}
{\xe \v ovs_sample_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_sample_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_sample_attr}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_sample_attr - Attributes for OVS_ACTION_ATTR_SAMPLE action. : 32-bit fraction of packets to sample with . A value of 0 samples no packets, a value of UINT32_MAX samples all packets and intermediate values sample intermediate fractions of packets. : Set of actions to execute in sampling event. Actions are passed as nested attributes.\par
Executes the specified actions with the given probability on a per-packet basis. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_SAMPLE_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_SAMPLE_ATTR_UNSPEC}
{\b {\i OVS_SAMPLE_ATTR_UNSPEC{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
}}  \par
{\xe \v OVS_SAMPLE_ATTR_PROBABILITY\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_SAMPLE_ATTR_PROBABILITY}
{\b {\i OVS_SAMPLE_ATTR_PROBABILITY{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
}}  \par
{\xe \v OVS_SAMPLE_ATTR_ACTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_SAMPLE_ATTR_ACTIONS}
{\b {\i OVS_SAMPLE_ATTR_ACTIONS{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
}}  \par
{\xe \v __OVS_SAMPLE_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_SAMPLE_ATTR_MAX}
{\b {\i __OVS_SAMPLE_ATTR_MAX{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   542                      \{\par
  543     OVS_SAMPLE_ATTR_UNSPEC,\par
  544     OVS_SAMPLE_ATTR_PROBABILITY, /* u32 number */\par
  545     OVS_SAMPLE_ATTR_ACTIONS,     /* Nested OVS_ACTION_ATTR_* attributes. */\par
  546     __OVS_SAMPLE_ATTR_MAX,\par
  547 \};\par
}
}
{\xe \v ovs_tunnel_key_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_tunnel_key_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_tunnel_key_attr}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_TUNNEL_KEY_ATTR_ID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_ID}
{\b {\i OVS_TUNNEL_KEY_ATTR_ID{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_IPV4_SRC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_IPV4_SRC}
{\b {\i OVS_TUNNEL_KEY_ATTR_IPV4_SRC{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_IPV4_DST\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_IPV4_DST}
{\b {\i OVS_TUNNEL_KEY_ATTR_IPV4_DST{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_TOS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_TOS}
{\b {\i OVS_TUNNEL_KEY_ATTR_TOS{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_TTL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_TTL}
{\b {\i OVS_TUNNEL_KEY_ATTR_TTL{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT}
{\b {\i OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_CSUM\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_CSUM}
{\b {\i OVS_TUNNEL_KEY_ATTR_CSUM{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_OAM\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_OAM}
{\b {\i OVS_TUNNEL_KEY_ATTR_OAM{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS}
{\b {\i OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_TP_SRC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_TP_SRC}
{\b {\i OVS_TUNNEL_KEY_ATTR_TP_SRC{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_TP_DST\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_TP_DST}
{\b {\i OVS_TUNNEL_KEY_ATTR_TP_DST{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
}}  \par
{\xe \v OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS}
{\b {\i OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
}}  \par
{\xe \v __OVS_TUNNEL_KEY_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_TUNNEL_KEY_ATTR_MAX}
{\b {\i __OVS_TUNNEL_KEY_ATTR_MAX{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   357                          \{\par
  358     OVS_TUNNEL_KEY_ATTR_ID,                 /* be64 Tunnel ID */\par
  359     OVS_TUNNEL_KEY_ATTR_IPV4_SRC,           /* be32 src IP address. */\par
  360     OVS_TUNNEL_KEY_ATTR_IPV4_DST,           /* be32 dst IP address. */\par
  361     OVS_TUNNEL_KEY_ATTR_TOS,                /* u8 Tunnel IP ToS. */\par
  362     OVS_TUNNEL_KEY_ATTR_TTL,                /* u8 Tunnel IP TTL. */\par
  363     OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT,      /* No argument, set DF. */\par
  364     OVS_TUNNEL_KEY_ATTR_CSUM,               /* No argument. CSUM packet. */\par
  365     OVS_TUNNEL_KEY_ATTR_OAM,                /* No argument. OAM frame.  */\par
  366     OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,        /* Array of Geneve options. */\par
  367     OVS_TUNNEL_KEY_ATTR_TP_SRC,     /* be16 src Transport Port. */\par
  368     OVS_TUNNEL_KEY_ATTR_TP_DST,     /* be16 dst Transport Port. */\par
  369     OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS,     /* Nested OVS_VXLAN_EXT_* */\par
  370     __OVS_TUNNEL_KEY_ATTR_MAX\par
  371 \};\par
}
}
{\xe \v ovs_userspace_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_userspace_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_userspace_attr}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_userspace_attr - Attributes for OVS_ACTION_ATTR_USERSPACE action. : u32 Netlink PID to which the OVS_PACKET_CMD_ACTION message should be sent. Required. : If present, its variable-length argument is copied to the OVS_PACKET_CMD_ACTION message as OVS_PACKET_ATTR_USERDATA. : If present, u32 output port to get tunnel info. : If present, send actions with upcall. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_USERSPACE_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_UNSPEC}
{\b {\i OVS_USERSPACE_ATTR_UNSPEC{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
}}  \par
{\xe \v OVS_USERSPACE_ATTR_PID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_PID}
{\b {\i OVS_USERSPACE_ATTR_PID{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
}}  \par
{\xe \v OVS_USERSPACE_ATTR_USERDATA\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_USERDATA}
{\b {\i OVS_USERSPACE_ATTR_USERDATA{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
}}  \par
{\xe \v OVS_USERSPACE_ATTR_EGRESS_TUN_PORT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_EGRESS_TUN_PORT}
{\b {\i OVS_USERSPACE_ATTR_EGRESS_TUN_PORT{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
}}  \par
{\xe \v OVS_USERSPACE_ATTR_ACTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_USERSPACE_ATTR_ACTIONS}
{\b {\i OVS_USERSPACE_ATTR_ACTIONS{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
}}  \par
{\xe \v __OVS_USERSPACE_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_USERSPACE_ATTR_MAX}
{\b {\i __OVS_USERSPACE_ATTR_MAX{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   561                         \{\par
  562     OVS_USERSPACE_ATTR_UNSPEC,\par
  563     OVS_USERSPACE_ATTR_PID,       /* u32 Netlink PID to receive upcalls. */\par
  564     OVS_USERSPACE_ATTR_USERDATA,  /* Optional user-specified cookie. */\par
  565     OVS_USERSPACE_ATTR_EGRESS_TUN_PORT,  /* Optional, u32 output port\par
  566                           * to get tunnel info. */\par
  567     OVS_USERSPACE_ATTR_ACTIONS,   /* Optional flag to get actions. */\par
  568     __OVS_USERSPACE_ATTR_MAX\par
  569 \};\par
}
}
{\xe \v ovs_vport_attr\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_vport_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_vport_attr}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
enum ovs_vport_attr - attributes for OVS_VPORT_* commands. : 32-bit port number within datapath. : 32-bit OVS_VPORT_TYPE_* constant describing the type of vport. : Name of vport. For a vport based on a network device this is the name of the network device. Maximum length IFNAMSIZ-1 bytes plus a null terminator. : Vport-specific configuration information. : The array of Netlink socket pids in userspace among which OVS_PACKET_CMD_MISS upcalls will be distributed for packets received on this port. If this is a single-element array of value 0, upcalls should not be sent. : A &struct {\b ovs_vport_stats} giving statistics for packets sent or received through the vport.\par
These attributes follow the &struct {\b ovs_header} within the Generic Netlink payload for OVS_VPORT_* commands.\par
For OVS_VPORT_CMD_NEW requests, the OVS_VPORT_ATTR_TYPE and OVS_VPORT_ATTR_NAME attributes are required. OVS_VPORT_ATTR_PORT_NO is optional; if not specified a free port number is automatically selected. Whether OVS_VPORT_ATTR_OPTIONS is required or optional depends on the type of vport. OVS_VPORT_ATTR_STATS is optional and other attributes are ignored.\par
For other requests, if OVS_VPORT_ATTR_NAME is specified then it is used to look up the vport to operate on; otherwise dp_idx from the &struct {\b ovs_header} plus OVS_VPORT_ATTR_PORT_NO determine the vport. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_VPORT_ATTR_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_UNSPEC}
{\b {\i OVS_VPORT_ATTR_UNSPEC{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
}}  \par
{\xe \v OVS_VPORT_ATTR_PORT_NO\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_PORT_NO}
{\b {\i OVS_VPORT_ATTR_PORT_NO{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
}}  \par
{\xe \v OVS_VPORT_ATTR_TYPE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_TYPE}
{\b {\i OVS_VPORT_ATTR_TYPE{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
}}  \par
{\xe \v OVS_VPORT_ATTR_NAME\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_NAME}
{\b {\i OVS_VPORT_ATTR_NAME{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
}}  \par
{\xe \v OVS_VPORT_ATTR_OPTIONS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_OPTIONS}
{\b {\i OVS_VPORT_ATTR_OPTIONS{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
}}  \par
{\xe \v OVS_VPORT_ATTR_UPCALL_PID\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_UPCALL_PID}
{\b {\i OVS_VPORT_ATTR_UPCALL_PID{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
}}  \par
{\xe \v OVS_VPORT_ATTR_STATS\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_ATTR_STATS}
{\b {\i OVS_VPORT_ATTR_STATS{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
}}  \par
{\xe \v __OVS_VPORT_ATTR_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_VPORT_ATTR_MAX}
{\b {\i __OVS_VPORT_ATTR_MAX{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   269                     \{\par
  270     OVS_VPORT_ATTR_UNSPEC,\par
  271     OVS_VPORT_ATTR_PORT_NO, /* u32 port number within datapath */\par
  272     OVS_VPORT_ATTR_TYPE,    /* u32 OVS_VPORT_TYPE_* constant. */\par
  273     OVS_VPORT_ATTR_NAME,    /* string name, up to IFNAMSIZ bytes long */\par
  274     OVS_VPORT_ATTR_OPTIONS, /* nested attributes, varies by vport type */\par
  275     OVS_VPORT_ATTR_UPCALL_PID, /* array of u32 Netlink socket PIDs for */\par
  276                 /* receiving upcalls */\par
  277     OVS_VPORT_ATTR_STATS,   /* struct ovs_vport_stats */\par
  278     __OVS_VPORT_ATTR_MAX\par
  279 \};\par
}
}
{\xe \v ovs_vport_cmd\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_vport_cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_vport_cmd}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_VPORT_CMD_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_CMD_UNSPEC}
{\b {\i OVS_VPORT_CMD_UNSPEC{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
}}  \par
{\xe \v OVS_VPORT_CMD_NEW\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_CMD_NEW}
{\b {\i OVS_VPORT_CMD_NEW{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
}}  \par
{\xe \v OVS_VPORT_CMD_DEL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_CMD_DEL}
{\b {\i OVS_VPORT_CMD_DEL{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
}}  \par
{\xe \v OVS_VPORT_CMD_GET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_CMD_GET}
{\b {\i OVS_VPORT_CMD_GET{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
}}  \par
{\xe \v OVS_VPORT_CMD_SET\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_CMD_SET}
{\b {\i OVS_VPORT_CMD_SET{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   216                    \{\par
  217     OVS_VPORT_CMD_UNSPEC,\par
  218     OVS_VPORT_CMD_NEW,\par
  219     OVS_VPORT_CMD_DEL,\par
  220     OVS_VPORT_CMD_GET,\par
  221     OVS_VPORT_CMD_SET\par
  222 \};\par
}
}
{\xe \v ovs_vport_type\:openvswitch.h}
{\xe \v openvswitch.h\:ovs_vport_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ovs_vport_type}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OVS_VPORT_TYPE_UNSPEC\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_UNSPEC}
{\b {\i OVS_VPORT_TYPE_UNSPEC{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
}}  \par
{\xe \v OVS_VPORT_TYPE_NETDEV\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_NETDEV}
{\b {\i OVS_VPORT_TYPE_NETDEV{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
}}  \par
{\xe \v OVS_VPORT_TYPE_INTERNAL\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_INTERNAL}
{\b {\i OVS_VPORT_TYPE_INTERNAL{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
}}  \par
{\xe \v OVS_VPORT_TYPE_GRE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_GRE}
{\b {\i OVS_VPORT_TYPE_GRE{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
}}  \par
{\xe \v OVS_VPORT_TYPE_VXLAN\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_VXLAN}
{\b {\i OVS_VPORT_TYPE_VXLAN{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
}}  \par
{\xe \v OVS_VPORT_TYPE_GENEVE\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_GENEVE}
{\b {\i OVS_VPORT_TYPE_GENEVE{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
}}  \par
{\xe \v OVS_VPORT_TYPE_GRE64\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_GRE64}
{\b {\i OVS_VPORT_TYPE_GRE64{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
}}  \par
{\xe \v OVS_VPORT_TYPE_LISP\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_LISP}
{\b {\i OVS_VPORT_TYPE_LISP{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
}}  \par
{\xe \v OVS_VPORT_TYPE_STT\:openvswitch.h}
{\xe \v openvswitch.h\:OVS_VPORT_TYPE_STT}
{\b {\i OVS_VPORT_TYPE_STT{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
}}  \par
{\xe \v __OVS_VPORT_TYPE_MAX\:openvswitch.h}
{\xe \v openvswitch.h\:__OVS_VPORT_TYPE_MAX}
{\b {\i __OVS_VPORT_TYPE_MAX{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   224                     \{\par
  225     OVS_VPORT_TYPE_UNSPEC,\par
  226     OVS_VPORT_TYPE_NETDEV,   /* network device */\par
  227     OVS_VPORT_TYPE_INTERNAL, /* network device implemented by datapath */\par
  228     OVS_VPORT_TYPE_GRE,      /* GRE tunnel. */\par
  229     OVS_VPORT_TYPE_VXLAN,    /* VXLAN tunnel. */\par
  230     OVS_VPORT_TYPE_GENEVE,   /* Geneve tunnel. */\par
  231     OVS_VPORT_TYPE_GRE64 = 104, /* GRE tunnel with 64-bit keys */\par
  232     OVS_VPORT_TYPE_LISP = 105,  /* LISP tunnel */\par
  233     OVS_VPORT_TYPE_STT = 106, /* STT tunnel */\par
  234     __OVS_VPORT_TYPE_MAX\par
  235 \};\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/percpu.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/percpu.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/percpu.h}
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "percpu_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b this_cpu_ptr}(ptr)\~ per_cpu_ptr(ptr, smp_processor_id())\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b this_cpu_read}(ptr)\~ percpu_read(ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b this_cpu_inc}(ptr)\~ percpu_add(ptr, 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b this_cpu_dec}(ptr)\~ percpu_sub(ptr, 1)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v this_cpu_dec\:percpu.h}
{\xe \v percpu.h\:this_cpu_dec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define this_cpu_dec( ptr)\~ percpu_sub(ptr, 1)}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v this_cpu_inc\:percpu.h}
{\xe \v percpu.h\:this_cpu_inc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define this_cpu_inc( ptr)\~ percpu_add(ptr, 1)}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v this_cpu_ptr\:percpu.h}
{\xe \v percpu.h\:this_cpu_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define this_cpu_ptr( ptr)\~ per_cpu_ptr(ptr, smp_processor_id())}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v this_cpu_read\:percpu.h}
{\xe \v percpu.h\:this_cpu_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define this_cpu_read( ptr)\~ percpu_read(ptr)}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/poison.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/poison.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/poison.h}
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FLEX_ARRAY_FREE}\~ 0x6c    /* for use-after-free poisoning */\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FLEX_ARRAY_FREE\:poison.h}
{\xe \v poison.h\:FLEX_ARRAY_FREE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FLEX_ARRAY_FREE\~ 0x6c    /* for use-after-free poisoning */}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/random.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/random.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/random.h}
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b prandom_u32}()\~ random32()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v prandom_u32\:random.h}
{\xe \v random.h\:prandom_u32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define prandom_u32()\~ random32()}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/rculist.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rculist.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rculist.h}
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "rculist_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_first_rcu}(head)\~ (*((struct hlist_node {\b __rcu} **)(&(head)->first)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_next_rcu}(node)\~ (*((struct hlist_node {\b __rcu} **)(&(node)->next)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_pprev_rcu}(node)\~ (*((struct hlist_node {\b __rcu} **)((node)->pprev)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b hlist_for_each_entry_rcu}(pos,  head,  member)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v hlist_first_rcu\:rculist.h}
{\xe \v rculist.h\:hlist_first_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_first_rcu( head)\~ (*((struct hlist_node {\b __rcu} **)(&(head)->first)))}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hlist_for_each_entry_rcu\:rculist.h}
{\xe \v rculist.h\:hlist_for_each_entry_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_for_each_entry_rcu( pos,  head,  member)}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for (pos = hlist_entry_safe (rcu_dereference_raw(hlist_first_rcu(head)),\\\par
            typeof(*(pos)), member);            \\\par
        pos;                            \\\par
        pos = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(\\\par
            &(pos)->member)), typeof(*(pos)), member))\par
}
}
{\xe \v hlist_next_rcu\:rculist.h}
{\xe \v rculist.h\:hlist_next_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_next_rcu( node)\~ (*((struct hlist_node {\b __rcu} **)(&(node)->next)))}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hlist_pprev_rcu\:rculist.h}
{\xe \v rculist.h\:hlist_pprev_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define hlist_pprev_rcu( node)\~ (*((struct hlist_node {\b __rcu} **)((node)->pprev)))}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/rcupdate.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rcupdate.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rcupdate.h}
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "rcupdate_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_check}(p,  c)\~ rcu_dereference(p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_protected}(p,  c)\~ (p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_raw}(p)\~ {\b rcu_dereference_check}(p, 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_access_pointer}(p)\~ rcu_dereference(p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCU_INITIALIZER}(v)\~ (typeof(*(v)) __force {\b __rcu} *)(v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCU_INIT_POINTER}(p,  v)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b rcu_read_lock_held} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v rcu_access_pointer\:rcupdate.h}
{\xe \v rcupdate.h\:rcu_access_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_access_pointer( p)\~ rcu_dereference(p)}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_dereference_check\:rcupdate.h}
{\xe \v rcupdate.h\:rcu_dereference_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_check( p,  c)\~ rcu_dereference(p)}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_dereference_protected\:rcupdate.h}
{\xe \v rcupdate.h\:rcu_dereference_protected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_protected( p,  c)\~ (p)}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_dereference_raw\:rcupdate.h}
{\xe \v rcupdate.h\:rcu_dereference_raw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_raw( p)\~ {\b rcu_dereference_check}(p, 1)}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RCU_INIT_POINTER\:rcupdate.h}
{\xe \v rcupdate.h\:RCU_INIT_POINTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCU_INIT_POINTER( p,  v)}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{ \\\par
                p = RCU_INITIALIZER(v); \\\par
        \} while (0)\par
}
}
{\xe \v RCU_INITIALIZER\:rcupdate.h}
{\xe \v rcupdate.h\:RCU_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCU_INITIALIZER( v)\~ (typeof(*(v)) __force {\b __rcu} *)(v)}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rcu_read_lock_held\:rcupdate.h}
{\xe \v rcupdate.h\:rcu_read_lock_held}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int rcu_read_lock_held (void ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    24 \{\par
   25     return 1;\par
   26 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/reciprocal_div.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/reciprocal_div.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/reciprocal_div.h}
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/types.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for reciprocal_div.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "reciprocal__div_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "reciprocal__div_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reciprocal_value}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b reciprocal_value}\~ {\b rpl_reciprocal_value}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b reciprocal_divide}\~ {\b rpl_reciprocal_divide}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reciprocal_value} {\b rpl_reciprocal_value} (u32 d)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u32 {\b rpl_reciprocal_divide} (u32 a, struct {\b reciprocal_value} R)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v reciprocal_divide\:reciprocal_div.h}
{\xe \v reciprocal_div.h\:reciprocal_divide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define reciprocal_divide\~ {\b rpl_reciprocal_divide}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reciprocal_value\:reciprocal_div.h}
{\xe \v reciprocal_div.h\:reciprocal_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b reciprocal_value}\~ {\b rpl_reciprocal_value}}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_reciprocal_divide\:reciprocal_div.h}
{\xe \v reciprocal_div.h\:rpl_reciprocal_divide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u32 rpl_reciprocal_divide (u32  {\i a}, struct {\b reciprocal_value}  {\i R}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    32 \{\par
   33     u32 t = (u32)(((u64)a * R.m) >> 32);\par
   34     return (t + ((a - t) >> R.sh1)) >> R.sh2;\par
   35 \}\par
}
}
{\xe \v rpl_reciprocal_value\:reciprocal_div.h}
{\xe \v reciprocal_div.h\:rpl_reciprocal_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b reciprocal_value} rpl_reciprocal_value (u32  {\i d})}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct reciprocal_value R;\par
   14     u64 m;\par
   15     int l;\par
   16 \par
   17     l = fls(d - 1);\par
   18     m = ((1ULL << 32) * ((1ULL << l) - d));\par
   19     do_div(m, d);\par
   20     ++m;\par
   21     R.m = (u32)m;\par
   22     R.sh1 = min(l, 1);\par
   23     R.sh2 = max(l - 1, 0);\par
   24 \par
   25     return R;\par
   26 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/rtnetlink.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rtnetlink.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/rtnetlink.h}
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "rtnetlink_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_rtnl}(p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rtnl_dereference}(p)\~ {\b rcu_dereference_protected}(p, lockdep_rtnl_is_held())\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v rcu_dereference_rtnl\:rtnetlink.h}
{\xe \v rtnetlink.h\:rcu_dereference_rtnl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_rtnl( p)}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid rcu_dereference_check(p, rcu_read_lock_held() ||    \\\par
                 lockdep_rtnl_is_held())\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rcu_dereference_rtnl - rcu_dereference with debug checking {\f2 } : The pointer to read, prior to dereferencing\par
Do an rcu_dereference(p), but check caller either holds rcu_read_lock() or RTNL. Note : Please prefer {\b rtnl_dereference()} or rcu_dereference() \par
}}
{\xe \v rtnl_dereference\:rtnetlink.h}
{\xe \v rtnetlink.h\:rtnl_dereference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rtnl_dereference( p)\~ {\b rcu_dereference_protected}(p, lockdep_rtnl_is_held())}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
rtnl_dereference - fetch RCU pointer when updates are prevented by RTNL {\f2 } : The pointer to read, prior to dereferencing\par
Return the value of the specified RCU-protected pointer, but omit both the smp_read_barrier_depends() and the ACCESS_ONCE(), because caller holds RTNL. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/sctp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/sctp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/sctp.h}
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sctp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sctphdr * {\b sctp_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sctp_hdr\:sctp.h}
{\xe \v sctp.h\:sctp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sctphdr* sctp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct sctphdr *)skb_transport_header(skb);\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/skbuff.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/skbuff.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/skbuff.h}
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/mm.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for skbuff.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "skbuff_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "skbuff_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SKB_GSO_GRE_CSUM}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SKB_GSO_UDP_TUNNEL_CSUM}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ignore_df}\~ local_df\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NET_SKB_PAD}\~ 16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKSUM_PARTIAL}\~ CHECKSUM_HW\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKSUM_COMPLETE}\~ CHECKSUM_HW\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b consume_skb}\~ kfree_skb\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_get_hash}\~ skb_get_rxhash\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_zerocopy}\~ {\b rpl_skb_zerocopy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_has_frag_list}\~ skb_has_frags\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_ensure_writable}\~ {\b rpl_skb_ensure_writable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_vlan_pop}\~ {\b rpl_skb_vlan_pop}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_vlan_push}\~ {\b rpl_skb_vlan_push}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b kfree_skb_list}\~ {\b rpl_kfree_skb_list}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_copy_from_linear_data_offset} (const struct sk_buff *skb, const int offset, void *to, const unsigned int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_copy_to_linear_data_offset} (struct sk_buff *skb, const int offset, const void *from, const unsigned int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_reset_tail_pointer} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __skb_cow} (struct sk_buff *skb, unsigned int headroom, int cloned)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b skb_cow_head} (struct sk_buff *skb, unsigned int headroom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct dst_entry * {\b skb_dst} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_dst_set} (struct sk_buff *skb, struct dst_entry *{\b dst})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtable * {\b skb_rtable} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned char * {\b skb_transport_header} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_reset_transport_header} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_set_transport_header} (struct sk_buff *skb, const int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned char * {\b skb_network_header} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_reset_network_header} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_set_network_header} (struct sk_buff *skb, const int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned char * {\b skb_mac_header} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_reset_mac_header} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_set_mac_header} (struct sk_buff *skb, const int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b skb_transport_offset} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b skb_network_offset} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_copy_to_linear_data} (struct sk_buff *skb, const void *from, const unsigned int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b skb_warn_if_lro} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct page * {\b skb_frag_page} (const skb_frag_t *{\b frag})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __skb_frag_set_page} (skb_frag_t *{\b frag}, struct page *page)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_frag_size_set} (skb_frag_t *{\b frag}, unsigned int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __skb_frag_ref} (skb_frag_t *{\b frag})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __skb_frag_unref} (skb_frag_t *{\b frag})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_frag_ref} (struct sk_buff *skb, int f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_frag_unref} (struct sk_buff *skb, int f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_reset_mac_len} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b skb_unclone} (struct sk_buff *skb, gfp_t pri)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b skb_orphan_frags} (struct sk_buff *skb, gfp_t gfp_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_zerocopy} (struct sk_buff *to, struct sk_buff *from, int len, int hlen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_clear_hash} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __skb_fill_page_desc} (struct sk_buff *skb, int i, struct page *page, int off, int size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_ensure_writable} (struct sk_buff *skb, int write_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_pop} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_push} (struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_kfree_skb_list} (struct sk_buff *segs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CHECKSUM_COMPLETE\:skbuff.h}
{\xe \v skbuff.h\:CHECKSUM_COMPLETE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKSUM_COMPLETE\~ CHECKSUM_HW}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECKSUM_PARTIAL\:skbuff.h}
{\xe \v skbuff.h\:CHECKSUM_PARTIAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKSUM_PARTIAL\~ CHECKSUM_HW}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v consume_skb\:skbuff.h}
{\xe \v skbuff.h\:consume_skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define consume_skb\~ kfree_skb}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ignore_df\:skbuff.h}
{\xe \v skbuff.h\:ignore_df}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ignore_df\~ local_df}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kfree_skb_list\:skbuff.h}
{\xe \v skbuff.h\:kfree_skb_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define kfree_skb_list\~ {\b rpl_kfree_skb_list}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v NET_SKB_PAD\:skbuff.h}
{\xe \v skbuff.h\:NET_SKB_PAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NET_SKB_PAD\~ 16}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_ensure_writable\:skbuff.h}
{\xe \v skbuff.h\:skb_ensure_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_ensure_writable\~ {\b rpl_skb_ensure_writable}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_get_hash\:skbuff.h}
{\xe \v skbuff.h\:skb_get_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_get_hash\~ skb_get_rxhash}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SKB_GSO_GRE_CSUM\:skbuff.h}
{\xe \v skbuff.h\:SKB_GSO_GRE_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SKB_GSO_GRE_CSUM\~ 0}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SKB_GSO_UDP_TUNNEL_CSUM\:skbuff.h}
{\xe \v skbuff.h\:SKB_GSO_UDP_TUNNEL_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SKB_GSO_UDP_TUNNEL_CSUM\~ 0}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_has_frag_list\:skbuff.h}
{\xe \v skbuff.h\:skb_has_frag_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_has_frag_list\~ skb_has_frags}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_vlan_pop\:skbuff.h}
{\xe \v skbuff.h\:skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_vlan_pop\~ {\b rpl_skb_vlan_pop}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_vlan_push\:skbuff.h}
{\xe \v skbuff.h\:skb_vlan_push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_vlan_push\~ {\b rpl_skb_vlan_push}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_zerocopy\:skbuff.h}
{\xe \v skbuff.h\:skb_zerocopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_zerocopy\~ {\b rpl_skb_zerocopy}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __skb_cow\:skbuff.h}
{\xe \v skbuff.h\:__skb_cow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __skb_cow (struct sk_buff *  {\i skb}, unsigned int  {\i headroom}, int  {\i cloned}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    87 \{\par
   88     int delta = 0;\par
   89 \par
   90     if (headroom < NET_SKB_PAD)\par
   91         headroom = NET_SKB_PAD;\par
   92     if (headroom > skb_headroom(skb))\par
   93         delta = headroom - skb_headroom(skb);\par
   94 \par
   95     if (delta || cloned)\par
   96         return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD), 0,\par
   97                     GFP_ATOMIC);\par
   98     return 0;\par
   99 \}\par
}
}
{\xe \v __skb_fill_page_desc\:skbuff.h}
{\xe \v skbuff.h\:__skb_fill_page_desc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __skb_fill_page_desc (struct sk_buff *  {\i skb}, int  {\i i}, struct page *  {\i page}, int  {\i off}, int  {\i size}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   347 \{\par
  348     skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\par
  349 \par
  350     __skb_frag_set_page(frag, page);\par
  351     frag->page_offset   = off;\par
  352     skb_frag_size_set(frag, size);\par
  353 \}\par
}
}
{\xe \v __skb_frag_ref\:skbuff.h}
{\xe \v skbuff.h\:__skb_frag_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __skb_frag_ref (skb_frag_t *  {\i frag}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   240 \{\par
  241     get_page(skb_frag_page(frag));\par
  242 \}\par
}
}
{\xe \v __skb_frag_set_page\:skbuff.h}
{\xe \v skbuff.h\:__skb_frag_set_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __skb_frag_set_page (skb_frag_t *  {\i frag}, struct page *  {\i page}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   232 \{\par
  233     frag->page = page;\par
  234 \}\par
}
}
{\xe \v __skb_frag_unref\:skbuff.h}
{\xe \v skbuff.h\:__skb_frag_unref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __skb_frag_unref (skb_frag_t *  {\i frag}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   244 \{\par
  245     put_page(skb_frag_page(frag));\par
  246 \}\par
}
}
{\xe \v rpl_kfree_skb_list\:skbuff.h}
{\xe \v skbuff.h\:rpl_kfree_skb_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_kfree_skb_list (struct sk_buff *  {\i segs})}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     while (segs) \{\par
  275         struct sk_buff *next = segs->next;\par
  276 \par
  277         kfree_skb(segs);\par
  278         segs = next;\par
  279     \}\par
  280 \}\par
}
}
{\xe \v rpl_skb_ensure_writable\:skbuff.h}
{\xe \v skbuff.h\:rpl_skb_ensure_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_ensure_writable (struct sk_buff *  {\i skb}, int  {\i write_len})}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     if (!pskb_may_pull(skb, write_len))\par
  137         return -ENOMEM;\par
  138 \par
  139     if (!skb_cloned(skb) || skb_clone_writable(skb, write_len))\par
  140         return 0;\par
  141 \par
  142     return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);\par
  143 \}\par
}
}
{\xe \v rpl_skb_vlan_pop\:skbuff.h}
{\xe \v skbuff.h\:rpl_skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_pop (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182 \{\par
  183     u16 vlan_tci;\par
  184     __be16 vlan_proto;\par
  185     int err;\par
  186 \par
  187     if (likely(skb_vlan_tag_present(skb))) \{\par
  188         skb->vlan_tci = 0;\par
  189     \} else \{\par
  190         if (unlikely((skb->protocol != htons(ETH_P_8021Q) &&\par
  191                   skb->protocol != htons(ETH_P_8021AD)) ||\par
  192                  skb->len < VLAN_ETH_HLEN))\par
  193             return 0;\par
  194 \par
  195         err = __skb_vlan_pop(skb, &vlan_tci);\par
  196         if (err)\par
  197             return err;\par
  198     \}\par
  199     /* move next vlan tag to hw accel tag */\par
  200     if (likely((skb->protocol != htons(ETH_P_8021Q) &&\par
  201             skb->protocol != htons(ETH_P_8021AD)) ||\par
  202            skb->len < VLAN_ETH_HLEN))\par
  203         return 0;\par
  204 \par
  205     vlan_proto = htons(ETH_P_8021Q);\par
  206     err = __skb_vlan_pop(skb, &vlan_tci);\par
  207     if (unlikely(err))\par
  208         return err;\par
  209 \par
  210     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  211     return 0;\par
  212 \}\par
}
}
{\xe \v rpl_skb_vlan_push\:skbuff.h}
{\xe \v skbuff.h\:rpl_skb_vlan_push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_push (struct sk_buff *  {\i skb}, __be16  {\i vlan_proto}, u16  {\i vlan_tci})}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{\par
  219     if (skb_vlan_tag_present(skb)) \{\par
  220         unsigned int offset = skb->data - skb_mac_header(skb);\par
  221         int err;\par
  222 \par
  223         /* __vlan_insert_tag expect skb->data pointing to mac header.\par
  224          * So change skb->data before calling it and change back to\par
  225          * original position later\par
  226          */\par
  227         __skb_push(skb, offset);\par
  228         err = __vlan_insert_tag(skb, skb->vlan_proto,\par
  229                     skb_vlan_tag_get(skb));\par
  230         if (err)\par
  231             return err;\par
  232         skb->mac_len += VLAN_HLEN;\par
  233         __skb_pull(skb, offset);\par
  234 \par
  235         if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  236             skb->csum = csum_add(skb->csum, csum_partial(skb->data\par
  237                     + (2 * ETH_ALEN), VLAN_HLEN, 0));\par
  238     \}\par
  239     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  240     return 0;\par
  241 \}\par
}
}
{\xe \v rpl_skb_zerocopy\:skbuff.h}
{\xe \v skbuff.h\:rpl_skb_zerocopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_zerocopy (struct sk_buff *  {\i to}, struct sk_buff *  {\i from}, int  {\i len}, int  {\i hlen})}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_clear_hash\:skbuff.h}
{\xe \v skbuff.h\:skb_clear_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_clear_hash (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   330 \{\par
  331 #ifdef HAVE_RXHASH\par
  332     skb->rxhash = 0;\par
  333 #endif\par
  334 #if defined(HAVE_L4_RXHASH) && !defined(HAVE_RHEL_OVS_HOOK)\par
  335     skb->l4_rxhash = 0;\par
  336 #endif\par
  337 \}\par
}
}
{\xe \v skb_copy_from_linear_data_offset\:skbuff.h}
{\xe \v skbuff.h\:skb_copy_from_linear_data_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_copy_from_linear_data_offset (const struct sk_buff *  {\i skb}, const int  {\i offset}, void *  {\i to}, const unsigned int  {\i len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    45 \{\par
   46     memcpy(to, skb->data + offset, len);\par
   47 \}\par
}
}
{\xe \v skb_copy_to_linear_data\:skbuff.h}
{\xe \v skbuff.h\:skb_copy_to_linear_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_copy_to_linear_data (struct sk_buff *  {\i skb}, const void *  {\i from}, const unsigned int  {\i len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   191 \{\par
  192     memcpy(skb->data, from, len);\par
  193 \}\par
}
}
{\xe \v skb_copy_to_linear_data_offset\:skbuff.h}
{\xe \v skbuff.h\:skb_copy_to_linear_data_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_copy_to_linear_data_offset (struct sk_buff *  {\i skb}, const int  {\i offset}, const void *  {\i from}, const unsigned int  {\i len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53 \{\par
   54     memcpy(skb->data + offset, from, len);\par
   55 \}\par
}
}
{\xe \v skb_cow_head\:skbuff.h}
{\xe \v skbuff.h\:skb_cow_head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int skb_cow_head (struct sk_buff *  {\i skb}, unsigned int  {\i headroom}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   102 \{\par
  103     return __skb_cow(skb, headroom, skb_header_cloned(skb));\par
  104 \}\par
}
}
{\xe \v skb_dst\:skbuff.h}
{\xe \v skbuff.h\:skb_dst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct dst_entry* skb_dst (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   109 \{\par
  110     return (struct dst_entry *)skb->dst;\par
  111 \}\par
}
}
{\xe \v skb_dst_set\:skbuff.h}
{\xe \v skbuff.h\:skb_dst_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_dst_set (struct sk_buff *  {\i skb}, struct dst_entry *  {\i dst}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115     skb->dst = dst;\par
  116 \}\par
}
}
{\xe \v skb_frag_page\:skbuff.h}
{\xe \v skbuff.h\:skb_frag_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct page* skb_frag_page (const skb_frag_t *  {\i frag}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227 \{\par
  228     return frag->page;\par
  229 \}\par
}
}
{\xe \v skb_frag_ref\:skbuff.h}
{\xe \v skbuff.h\:skb_frag_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_frag_ref (struct sk_buff *  {\i skb}, int  {\i f}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     __skb_frag_ref(&skb_shinfo(skb)->frags[f]);\par
  251 \}\par
}
}
{\xe \v skb_frag_size_set\:skbuff.h}
{\xe \v skbuff.h\:skb_frag_size_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_frag_size_set (skb_frag_t *  {\i frag}, unsigned int  {\i size}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   236 \{\par
  237     frag->size = size;\par
  238 \}\par
}
}
{\xe \v skb_frag_unref\:skbuff.h}
{\xe \v skbuff.h\:skb_frag_unref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_frag_unref (struct sk_buff *  {\i skb}, int  {\i f}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   254 \{\par
  255     __skb_frag_unref(&skb_shinfo(skb)->frags[f]);\par
  256 \}\par
}
}
{\xe \v skb_mac_header\:skbuff.h}
{\xe \v skbuff.h\:skb_mac_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned char* skb_mac_header (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   164 \{\par
  165     return skb->mac.raw;\par
  166 \}\par
}
}
{\xe \v skb_network_header\:skbuff.h}
{\xe \v skbuff.h\:skb_network_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned char* skb_network_header (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   149 \{\par
  150     return skb->nh.raw;\par
  151 \}\par
}
}
{\xe \v skb_network_offset\:skbuff.h}
{\xe \v skbuff.h\:skb_network_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int skb_network_offset (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   184 \{\par
  185     return skb_network_header(skb) - skb->data;\par
  186 \}\par
}
}
{\xe \v skb_orphan_frags\:skbuff.h}
{\xe \v skbuff.h\:skb_orphan_frags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int skb_orphan_frags (struct sk_buff *  {\i skb}, gfp_t  {\i gfp_mask}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   281 \{\par
  282     return 0;\par
  283 \}\par
}
}
{\xe \v skb_reset_mac_header\:skbuff.h}
{\xe \v skbuff.h\:skb_reset_mac_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_reset_mac_header (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   169 \{\par
  170     skb->mac_header = skb->data;\par
  171 \}\par
}
}
{\xe \v skb_reset_mac_len\:skbuff.h}
{\xe \v skbuff.h\:skb_reset_mac_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_reset_mac_len (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   262 \{\par
  263     skb->mac_len = skb->network_header - skb->mac_header;\par
  264 \}\par
}
}
{\xe \v skb_reset_network_header\:skbuff.h}
{\xe \v skbuff.h\:skb_reset_network_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_reset_network_header (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   154 \{\par
  155     skb->nh.raw = skb->data;\par
  156 \}\par
}
}
{\xe \v skb_reset_tail_pointer\:skbuff.h}
{\xe \v skbuff.h\:skb_reset_tail_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_reset_tail_pointer (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     skb->tail = skb->data;\par
   63 \}\par
}
}
{\xe \v skb_reset_transport_header\:skbuff.h}
{\xe \v skbuff.h\:skb_reset_transport_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_reset_transport_header (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   138 \{\par
  139     skb->h.raw = skb->data;\par
  140 \}\par
}
}
{\xe \v skb_rtable\:skbuff.h}
{\xe \v skbuff.h\:skb_rtable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct rtable* skb_rtable (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     return (struct rtable *)skb->dst;\par
  121 \}\par
}
}
{\xe \v skb_set_mac_header\:skbuff.h}
{\xe \v skbuff.h\:skb_set_mac_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_set_mac_header (struct sk_buff *  {\i skb}, const int  {\i offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   174 \{\par
  175     skb->mac.raw = skb->data + offset;\par
  176 \}\par
}
}
{\xe \v skb_set_network_header\:skbuff.h}
{\xe \v skbuff.h\:skb_set_network_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_set_network_header (struct sk_buff *  {\i skb}, const int  {\i offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   159 \{\par
  160     skb->nh.raw = skb->data + offset;\par
  161 \}\par
}
}
{\xe \v skb_set_transport_header\:skbuff.h}
{\xe \v skbuff.h\:skb_set_transport_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_set_transport_header (struct sk_buff *  {\i skb}, const int  {\i offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144 \{\par
  145     skb->h.raw = skb->data + offset;\par
  146 \}\par
}
}
{\xe \v skb_transport_header\:skbuff.h}
{\xe \v skbuff.h\:skb_transport_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned char* skb_transport_header (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   133 \{\par
  134     return skb->h.raw;\par
  135 \}\par
}
}
{\xe \v skb_transport_offset\:skbuff.h}
{\xe \v skbuff.h\:skb_transport_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int skb_transport_offset (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179 \{\par
  180     return skb_transport_header(skb) - skb->data;\par
  181 \}\par
}
}
{\xe \v skb_unclone\:skbuff.h}
{\xe \v skbuff.h\:skb_unclone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int skb_unclone (struct sk_buff *  {\i skb}, gfp_t  {\i pri}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   269 \{\par
  270     might_sleep_if(pri & __GFP_WAIT);\par
  271 \par
  272     if (skb_cloned(skb))\par
  273         return pskb_expand_head(skb, 0, 0, pri);\par
  274 \par
  275     return 0;\par
  276 \}\par
}
}
{\xe \v skb_warn_if_lro\:skbuff.h}
{\xe \v skbuff.h\:skb_warn_if_lro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} skb_warn_if_lro (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   199 \{\par
  200     return false;\par
  201 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/stddef.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/stddef.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/stddef.h}
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/tcp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/tcp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/tcp.h}
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "tcp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct tcphdr * {\b tcp_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b tcp_hdrlen} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v tcp_hdr\:tcp.h}
{\xe \v tcp.h\:tcp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct tcphdr* tcp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct tcphdr *)skb_transport_header(skb);\par
   10 \}\par
}
}
{\xe \v tcp_hdrlen\:tcp.h}
{\xe \v tcp.h\:tcp_hdrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int tcp_hdrlen (const struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    13 \{\par
   14     return tcp_hdr(skb)->doff * 4;\par
   15 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/types.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/types.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/types.h}
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "types_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef __u16 __bitwise {\b __sum16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef __u32 __bitwise {\b __wsum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef _Bool {\b bool}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v __sum16\:types.h}
{\xe \v types.h\:__sum16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef __u16 __bitwise {\b __sum16}}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __wsum\:types.h}
{\xe \v types.h\:__wsum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef __u32 __bitwise {\b __wsum}}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bool\:types.h}
{\xe \v types.h\:bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef _Bool {\b bool}}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/u64_stats_sync.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/u64_stats_sync.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/u64_stats_sync.h}
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/seqlock.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for u64_stats_sync.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "u64__stats__sync_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "u64__stats__sync_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b u64_stats_sync}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b u64_stats_init}(syncp)\~ do \{ \} while (0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b u64_stats_update_begin} (struct {\b u64_stats_sync} *syncp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b u64_stats_update_end} (struct {\b u64_stats_sync} *syncp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b u64_stats_fetch_begin} (const struct {\b u64_stats_sync} *syncp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b u64_stats_fetch_retry} (const struct {\b u64_stats_sync} *syncp, unsigned int start)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b u64_stats_fetch_begin_irq} (const struct {\b u64_stats_sync} *syncp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b bool} {\b u64_stats_fetch_retry_irq} (const struct {\b u64_stats_sync} *syncp, unsigned int start)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v u64_stats_init\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define u64_stats_init( syncp)\~ do \{ \} while (0)}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v u64_stats_fetch_begin\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_fetch_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int u64_stats_fetch_begin (const struct {\b u64_stats_sync} *  {\i syncp}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    98 \{\par
   99 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
  100     return read_seqcount_begin(&syncp->seq);\par
  101 #else\par
  102 #if BITS_PER_LONG==32\par
  103     preempt_disable();\par
  104 #endif\par
  105     return 0;\par
  106 #endif\par
  107 \}\par
}
}
{\xe \v u64_stats_fetch_begin_irq\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_fetch_begin_irq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int u64_stats_fetch_begin_irq (const struct {\b u64_stats_sync} *  {\i syncp}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   129 \{\par
  130 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
  131     return read_seqcount_begin(&syncp->seq);\par
  132 #else\par
  133 #if BITS_PER_LONG==32\par
  134     local_irq_disable();\par
  135 #endif\par
  136     return 0;\par
  137 #endif\par
  138 \}\par
}
}
{\xe \v u64_stats_fetch_retry\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_fetch_retry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} u64_stats_fetch_retry (const struct {\b u64_stats_sync} *  {\i syncp}, unsigned int  {\i start}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{\par
  112 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
  113     return read_seqcount_retry(&syncp->seq, start);\par
  114 #else\par
  115 #if BITS_PER_LONG==32\par
  116     preempt_enable();\par
  117 #endif\par
  118     return false;\par
  119 #endif\par
  120 \}\par
}
}
{\xe \v u64_stats_fetch_retry_irq\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_fetch_retry_irq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b bool} u64_stats_fetch_retry_irq (const struct {\b u64_stats_sync} *  {\i syncp}, unsigned int  {\i start}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   142 \{\par
  143 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
  144     return read_seqcount_retry(&syncp->seq, start);\par
  145 #else\par
  146 #if BITS_PER_LONG==32\par
  147     local_irq_enable();\par
  148 #endif\par
  149     return false;\par
  150 #endif\par
  151 \}\par
}
}
{\xe \v u64_stats_update_begin\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_update_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void u64_stats_update_begin (struct {\b u64_stats_sync} *  {\i syncp}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    84 \{\par
   85 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
   86     write_seqcount_begin(&syncp->seq);\par
   87 #endif\par
   88 \}\par
}
}
{\xe \v u64_stats_update_end\:u64_stats_sync.h}
{\xe \v u64_stats_sync.h\:u64_stats_update_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void u64_stats_update_end (struct {\b u64_stats_sync} *  {\i syncp}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    91 \{\par
   92 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)\par
   93     write_seqcount_end(&syncp->seq);\par
   94 #endif\par
   95 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/udp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/udp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/udp.h}
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2udp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct udphdr * {\b udp_hdr} (const struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v udp_hdr\:linux/udp.h}
{\xe \v linux/udp.h\:udp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct udphdr* udp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (struct udphdr *)skb_transport_header(skb);\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/udp.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/udp.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/udp.h}
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2udp_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net_2udp_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b udp_flow_src_port}\~ {\b rpl_udp_flow_src_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b udp_set_csum}\~ {\b rpl_udp_set_csum}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be16 {\b rpl_udp_flow_src_port} (struct net *net, struct sk_buff *skb, int min, int max, {\b bool} use_eth)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b __sum16} {\b udp_v4_check} (int len, __be32 saddr, __be32 daddr, {\b __wsum} base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_udp_set_csum} ({\b bool} nocheck, struct sk_buff *skb, __be32 saddr, __be32 daddr, int len)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v udp_flow_src_port\:net/udp.h}
{\xe \v net/udp.h\:udp_flow_src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define udp_flow_src_port\~ {\b rpl_udp_flow_src_port}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v udp_set_csum\:net/udp.h}
{\xe \v net/udp.h\:udp_set_csum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define udp_set_csum\~ {\b rpl_udp_set_csum}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_udp_flow_src_port\:net/udp.h}
{\xe \v net/udp.h\:rpl_udp_flow_src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be16 rpl_udp_flow_src_port (struct net *  {\i net}, struct sk_buff *  {\i skb}, int  {\i min}, int  {\i max}, {\b bool}  {\i use_eth}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19 \{\par
   20     u32 hash;\par
   21 \par
   22     if (min >= max) \{\par
   23         /* Use default range */\par
   24         inet_get_local_port_range(net, &min, &max);\par
   25     \}\par
   26 \par
   27     hash = skb_get_hash(skb);\par
   28     if (unlikely(!hash) && use_eth) \{\par
   29         /* Can't find a normal hash, caller has indicated an Ethernet\par
   30          * packet so use that to compute a hash.\par
   31          */\par
   32         hash = jhash(skb->data, 2 * ETH_ALEN,\par
   33                  (__force u32) skb->protocol);\par
   34     \}\par
   35 \par
   36     /* Since this is being sent on the wire obfuscate hash a bit\par
   37      * to minimize possbility that any useful information to an\par
   38      * attacker is leaked. Only upper 16 bits are relevant in the\par
   39      * computation for 16 bit port value.\par
   40      */\par
   41     hash ^= hash << 16;\par
   42 \par
   43     return htons((((u64) hash * (max - min)) >> 32) + min);\par
   44 \}\par
}
}
{\xe \v rpl_udp_set_csum\:net/udp.h}
{\xe \v net/udp.h\:rpl_udp_set_csum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_udp_set_csum ({\b bool}  {\i nocheck}, struct sk_buff *  {\i skb}, __be32  {\i saddr}, __be32  {\i daddr}, int  {\i len})}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct udphdr *uh = udp_hdr(skb);\par
   14 \par
   15     if (nocheck)\par
   16         uh->check = 0;\par
   17     else if (skb_is_gso(skb))\par
   18         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   19     else if (skb_dst(skb) && skb_dst(skb)->dev &&\par
   20          (skb_dst(skb)->dev->features & NETIF_F_V4_CSUM)) \{\par
   21 \par
   22         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   23 \par
   24         skb->ip_summed = CHECKSUM_PARTIAL;\par
   25         skb->csum_start = skb_transport_header(skb) - skb->head;\par
   26         skb->csum_offset = offsetof(struct udphdr, check);\par
   27         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   28     \} else \{\par
   29         __wsum csum;\par
   30 \par
   31         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   32 \par
   33         uh->check = 0;\par
   34         csum = skb_checksum(skb, 0, len, 0);\par
   35         uh->check = udp_v4_check(len, saddr, daddr, csum);\par
   36         if (uh->check == 0)\par
   37             uh->check = CSUM_MANGLED_0;\par
   38 \par
   39         skb->ip_summed = CHECKSUM_UNNECESSARY;\par
   40     \}\par
   41 \}\par
}
}
{\xe \v udp_v4_check\:net/udp.h}
{\xe \v net/udp.h\:udp_v4_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b __sum16} udp_v4_check (int  {\i len}, __be32  {\i saddr}, __be32  {\i daddr}, {\b __wsum}  {\i base}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{\par
   53     return csum_tcpudp_magic(saddr, daddr, len, IPPROTO_UDP, base);\par
   54 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/linux/workqueue.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/workqueue.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/linux/workqueue.h}
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "workqueue_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/checksum.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/checksum.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/checksum.h}
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "checksum_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CSUM_MANGLED_0}\~ ((__force {\b __sum16})0xffff)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b __wsum} {\b csum_unfold} ({\b __sum16} n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b csum_replace4} ({\b __sum16} *sum, __be32 from, __be32 to)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b csum_replace2} ({\b __sum16} *sum, __be16 from, __be16 to)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CSUM_MANGLED_0\:checksum.h}
{\xe \v checksum.h\:CSUM_MANGLED_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CSUM_MANGLED_0\~ ((__force {\b __sum16})0xffff)}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v csum_replace2\:checksum.h}
{\xe \v checksum.h\:csum_replace2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void csum_replace2 ({\b __sum16} *  {\i sum}, __be16  {\i from}, __be16  {\i to}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30 \{\par
   31     csum_replace4(sum, (__force __be32)from, (__force __be32)to);\par
   32 \}\par
}
}
{\xe \v csum_replace4\:checksum.h}
{\xe \v checksum.h\:csum_replace4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void csum_replace4 ({\b __sum16} *  {\i sum}, __be32  {\i from}, __be32  {\i to}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23 \{\par
   24     __be32 diff[] = \{ ~from, to \};\par
   25 \par
   26     *sum = csum_fold(csum_partial((char *)diff, sizeof(diff), ~csum_unfold(*sum)));\par
   27 \}\par
}
}
{\xe \v csum_unfold\:checksum.h}
{\xe \v checksum.h\:csum_unfold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b __wsum} csum_unfold ({\b __sum16}  {\i n}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     return (__force __wsum)n;\par
   10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/sctp/checksum.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/sctp/checksum.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/sctp/checksum.h}
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sctp_2checksum_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __le32 {\b sctp_compute_cksum} (const struct sk_buff *skb, unsigned int offset)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sctp_compute_cksum\:sctp/checksum.h}
{\xe \v sctp/checksum.h\:sctp_compute_cksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __le32 sctp_compute_cksum (const struct sk_buff *  {\i skb}, unsigned int  {\i offset}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     9 \{\par
   10     const struct sk_buff *iter;\par
   11 \par
   12     __u32 crc32 = sctp_start_cksum(skb->data + offset,\par
   13                        skb_headlen(skb) - offset);\par
   14     skb_walk_frags(skb, iter)\par
   15         crc32 = sctp_update_cksum((__u8 *) iter->data,\par
   16                       skb_headlen(iter), crc32);\par
   17 \par
   18     /* Open-code sctp_end_cksum() to avoid a sparse warning due to a bug in\par
   19      * sparse annotations in Linux fixed in 3.10 in commit eee1d5a14 (sctp:\par
   20      * Correct type and usage of sctp_end_cksum()). */\par
   21     return cpu_to_le32(~crc32);\par
   22 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/dst.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/dst.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/dst.h}
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dst.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dst_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dst_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b skb_dst_drop} (struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v skb_dst_drop\:dst.h}
{\xe \v dst.h\:skb_dst_drop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void skb_dst_drop (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    17 \{\par
   18     if (skb->dst)\par
   19         dst_release(skb_dst(skb));\par
   20     skb->dst = NULL;\par
   21 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/flow_keys.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/flow_keys.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/flow_keys.h}
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for flow_keys.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "flow__keys_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/genetlink.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/genetlink.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/genetlink.h}
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <net/net_namespace.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for genetlink.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "genetlink_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "genetlink_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b rpl_genl_family}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genl_family}\~ {\b rpl_genl_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genl_notify}\~ {\b rpl_genl_notify}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genlmsg_put}\~ {\b rpl_genlmsg_put}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genl_unregister_family}\~ {\b rpl_genl_unregister_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genl_set_err}\~ rpl_genl_set_err\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genlmsg_multicast_netns}\~ rpl_genlmsg_multicast_netns\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __genl_register_family}\~ {\b rpl___genl_register_family}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b genl_register_family}\~ {\b rpl_genl_register_family}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_genl_notify} (struct {\b genl_family} *family, struct sk_buff *skb, struct net *net, u32 portid, u32 group, struct nlmsghdr *nlh, gfp_t {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b rpl_genlmsg_put} (struct sk_buff *skb, u32 portid, u32 seq, struct {\b genl_family} *family, int {\b flags}, u8 cmd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b rpl_genl_unregister_family} (struct {\b genl_family} *family)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genl_set_err} (struct {\b genl_family} *family, struct net *net, u32 portid, u32 group, int code)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genlmsg_multicast_netns} (struct {\b genl_family} *family, struct net *net, struct sk_buff *skb, u32 portid, unsigned int group, gfp_t {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl___genl_register_family} (struct {\b genl_family} *family)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b rpl_genl_register_family} (struct {\b genl_family} *family)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b genlmsg_new_unicast} (size_t payload, struct genl_info *info, gfp_t {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genl_has_listeners} (struct {\b genl_family} *family, struct net *net, unsigned int group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b genlmsg_parse} (const struct nlmsghdr *nlh, const struct {\b genl_family} *family, struct nlattr *tb[], int maxtype, const struct nla_policy *policy)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __genl_register_family\:genetlink.h}
{\xe \v genetlink.h\:__genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __genl_register_family\~ {\b rpl___genl_register_family}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genl_family\:genetlink.h}
{\xe \v genetlink.h\:genl_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genl_family\~ {\b rpl_genl_family}}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genl_notify\:genetlink.h}
{\xe \v genetlink.h\:genl_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genl_notify\~ {\b rpl_genl_notify}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genl_register_family\:genetlink.h}
{\xe \v genetlink.h\:genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genl_register_family\~ {\b rpl_genl_register_family}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genl_set_err\:genetlink.h}
{\xe \v genetlink.h\:genl_set_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genl_set_err\~ rpl_genl_set_err}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genl_unregister_family\:genetlink.h}
{\xe \v genetlink.h\:genl_unregister_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genl_unregister_family\~ {\b rpl_genl_unregister_family}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genlmsg_multicast_netns\:genetlink.h}
{\xe \v genetlink.h\:genlmsg_multicast_netns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genlmsg_multicast_netns\~ rpl_genlmsg_multicast_netns}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v genlmsg_put\:genetlink.h}
{\xe \v genetlink.h\:genlmsg_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define genlmsg_put\~ {\b rpl_genlmsg_put}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v genl_has_listeners\:genetlink.h}
{\xe \v genetlink.h\:genl_has_listeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genl_has_listeners (struct {\b genl_family} *  {\i family}, struct net *  {\i net}, unsigned int  {\i group}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{\par
  112 #ifdef HAVE_MCGRP_OFFSET\par
  113     if (WARN_ON_ONCE(group >= family->n_mcgrps))\par
  114         return -EINVAL;\par
  115     group = family->mcgrp_offset + group;\par
  116 #endif\par
  117     return netlink_has_listeners(net->genl_sock, group);\par
  118 \}\par
}
}
{\xe \v genl_set_err\:genetlink.h}
{\xe \v genetlink.h\:genl_set_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genl_set_err (struct {\b genl_family} *  {\i family}, struct net *  {\i net}, u32  {\i portid}, u32  {\i group}, int  {\i code}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    69 \{\par
   70 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)\par
   71     netlink_set_err(net->genl_sock, portid, group, code);\par
   72     return 0;\par
   73 #else\par
   74     return netlink_set_err(net->genl_sock, portid, group, code);\par
   75 #endif\par
   76 \}\par
}
}
{\xe \v genlmsg_multicast_netns\:genetlink.h}
{\xe \v genetlink.h\:genlmsg_multicast_netns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genlmsg_multicast_netns (struct {\b genl_family} *  {\i family}, struct net *  {\i net}, struct sk_buff *  {\i skb}, u32  {\i portid}, unsigned int  {\i group}, gfp_t  {\i flags}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    82 \{\par
   83     return nlmsg_multicast(net->genl_sock, skb, portid, group, flags);\par
   84 \}\par
}
}
{\xe \v genlmsg_new_unicast\:genetlink.h}
{\xe \v genetlink.h\:genlmsg_new_unicast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* genlmsg_new_unicast (size_t  {\i payload}, struct genl_info *  {\i info}, gfp_t  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   103 \{\par
  104     return genlmsg_new(payload, flags);\par
  105 \}\par
}
}
{\xe \v genlmsg_parse\:genetlink.h}
{\xe \v genetlink.h\:genlmsg_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int genlmsg_parse (const struct nlmsghdr *  {\i nlh}, const struct {\b genl_family} *  {\i family}, struct nlattr *  {\i tb}[], int  {\i maxtype}, const struct nla_policy *  {\i policy}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   142 \{\par
  143     return nlmsg_parse(nlh, family->hdrsize + GENL_HDRLEN, tb, maxtype,\par
  144                policy);\par
  145 \}\par
}
}
{\xe \v rpl___genl_register_family\:genetlink.h}
{\xe \v genetlink.h\:rpl___genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl___genl_register_family (struct {\b genl_family} *  {\i family})}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_genl_notify\:genetlink.h}
{\xe \v genetlink.h\:rpl_genl_notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_genl_notify (struct {\b genl_family} *  {\i family}, struct sk_buff *  {\i skb}, struct net *  {\i net}, u32  {\i portid}, u32  {\i group}, struct nlmsghdr *  {\i nlh}, gfp_t  {\i flags})}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_genl_register_family\:genetlink.h}
{\xe \v genetlink.h\:rpl_genl_register_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int rpl_genl_register_family (struct {\b genl_family} *  {\i family}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    92 \{\par
   93     family->module = THIS_MODULE;\par
   94     return rpl___genl_register_family(family);\par
   95 \}\par
}
}
{\xe \v rpl_genl_unregister_family\:genetlink.h}
{\xe \v genetlink.h\:rpl_genl_unregister_family}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int rpl_genl_unregister_family (struct {\b genl_family} *  {\i family}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return genl_unregister_family(&family->compat_family);\par
   63 \}\par
}
}
{\xe \v rpl_genlmsg_put\:genetlink.h}
{\xe \v genetlink.h\:rpl_genlmsg_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* rpl_genlmsg_put (struct sk_buff *  {\i skb}, u32  {\i portid}, u32  {\i seq}, struct {\b genl_family} *  {\i family}, int  {\i flags}, u8  {\i cmd}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    54 \{\par
   55     return genlmsg_put(skb, portid, seq, &family->compat_family, flags, cmd);\par
   56 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/geneve.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/geneve.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/geneve.h}
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for geneve.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "geneve_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "geneve_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/gre.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/gre.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/gre.h}
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for gre.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gre_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "gre_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b gre_cisco_protocol}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_GRE_PROTO_PRIORITY}\~ 255\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gre_cisco_register}\~ {\b rpl_gre_cisco_register}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gre_cisco_unregister}\~ {\b rpl_gre_cisco_unregister}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gre_handle_offloads}\~ {\b rpl_gre_handle_offloads}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_gre_cisco_register} (struct {\b gre_cisco_protocol} *{\b proto})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_gre_cisco_unregister} (struct {\b gre_cisco_protocol} *{\b proto})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sk_buff * {\b rpl_gre_handle_offloads} (struct sk_buff *skb, {\b bool} gre_csum)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v gre_cisco_register\:gre.h}
{\xe \v gre.h\:gre_cisco_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gre_cisco_register\~ {\b rpl_gre_cisco_register}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v gre_cisco_unregister\:gre.h}
{\xe \v gre.h\:gre_cisco_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gre_cisco_unregister\~ {\b rpl_gre_cisco_unregister}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v gre_handle_offloads\:gre.h}
{\xe \v gre.h\:gre_handle_offloads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gre_handle_offloads\~ {\b rpl_gre_handle_offloads}}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MAX_GRE_PROTO_PRIORITY\:gre.h}
{\xe \v gre.h\:MAX_GRE_PROTO_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_GRE_PROTO_PRIORITY\~ 255}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_gre_cisco_register\:gre.h}
{\xe \v gre.h\:rpl_gre_cisco_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_gre_cisco_register (struct {\b gre_cisco_protocol} *  {\i proto})}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_gre_cisco_unregister\:gre.h}
{\xe \v gre.h\:rpl_gre_cisco_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_gre_cisco_unregister (struct {\b gre_cisco_protocol} *  {\i proto})}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_gre_handle_offloads\:gre.h}
{\xe \v gre.h\:rpl_gre_handle_offloads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sk_buff* rpl_gre_handle_offloads (struct sk_buff *  {\i skb}, {\b bool}  {\i gre_csum})}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/inet_frag.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/inet_frag.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/inet_frag.h}
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for inet_frag.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "inet__frag_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/ip_tunnels.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ip_tunnels.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/ip_tunnels.h}
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ip_tunnels.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ip__tunnels_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ip__tunnels_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tnl_ptk_info}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ovs_iptunnel_handle_offloads}(skb,  csum_help,  gso_type_mask,  fix_segment)\~ iptunnel_handle_offloads(skb, csum_help, gso_type_mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_CSUM}\~ __cpu_to_be16(0x01)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_ROUTING}\~ __cpu_to_be16(0x02)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_KEY}\~ __cpu_to_be16(0x04)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_SEQ}\~ __cpu_to_be16(0x08)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_STRICT}\~ __cpu_to_be16(0x10)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_REC}\~ __cpu_to_be16(0x20)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_VERSION}\~ __cpu_to_be16(0x40)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_NO_KEY}\~ __cpu_to_be16(0x80)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PACKET_RCVD}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PACKET_REJECT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_DONT_FRAGMENT}\~ __cpu_to_be16(0x0100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_OAM}\~ __cpu_to_be16(0x0200)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_CRIT_OPT}\~ __cpu_to_be16(0x0400)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_GENEVE_OPT}\~ __cpu_to_be16(0x0800)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_VXLAN_OPT}\~ __cpu_to_be16(0x1000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TUNNEL_OPTIONS_PRESENT}\~ ({\b TUNNEL_GENEVE_OPT} | {\b TUNNEL_VXLAN_OPT})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b skb_is_encapsulated}\~ {\b ovs_skb_is_encapsulated}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_skb_is_encapsulated} (struct sk_buff *skb)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ovs_iptunnel_handle_offloads\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:ovs_iptunnel_handle_offloads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ovs_iptunnel_handle_offloads( skb,  csum_help,  gso_type_mask,  fix_segment)\~ iptunnel_handle_offloads(skb, csum_help, gso_type_mask)}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PACKET_RCVD\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:PACKET_RCVD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PACKET_RCVD\~ 0}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PACKET_REJECT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:PACKET_REJECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PACKET_REJECT\~ 1}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skb_is_encapsulated\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:skb_is_encapsulated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define skb_is_encapsulated\~ {\b ovs_skb_is_encapsulated}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_CRIT_OPT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_CRIT_OPT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_CRIT_OPT\~ __cpu_to_be16(0x0400)}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_CSUM\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_CSUM\~ __cpu_to_be16(0x01)}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_DONT_FRAGMENT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_DONT_FRAGMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_DONT_FRAGMENT\~ __cpu_to_be16(0x0100)}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_GENEVE_OPT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_GENEVE_OPT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_GENEVE_OPT\~ __cpu_to_be16(0x0800)}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_KEY\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_KEY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_KEY\~ __cpu_to_be16(0x04)}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_NO_KEY\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_NO_KEY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_NO_KEY\~ __cpu_to_be16(0x80)}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_OAM\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_OAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_OAM\~ __cpu_to_be16(0x0200)}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_OPTIONS_PRESENT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_OPTIONS_PRESENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_OPTIONS_PRESENT\~ ({\b TUNNEL_GENEVE_OPT} | {\b TUNNEL_VXLAN_OPT})}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_REC\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_REC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_REC\~ __cpu_to_be16(0x20)}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_ROUTING\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_ROUTING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_ROUTING\~ __cpu_to_be16(0x02)}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_SEQ\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_SEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_SEQ\~ __cpu_to_be16(0x08)}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_STRICT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_STRICT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_STRICT\~ __cpu_to_be16(0x10)}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_VERSION\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_VERSION\~ __cpu_to_be16(0x40)}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TUNNEL_VXLAN_OPT\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:TUNNEL_VXLAN_OPT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TUNNEL_VXLAN_OPT\~ __cpu_to_be16(0x1000)}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_skb_is_encapsulated\:ip_tunnels.h}
{\xe \v ip_tunnels.h\:ovs_skb_is_encapsulated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_skb_is_encapsulated (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     /* checking for inner protocol should be sufficient on newer kernel, but\par
  178      * old kernel just set encapsulation bit.\par
  179      */\par
  180     return ovs_skb_get_inner_protocol(skb) || skb_encapsulation(skb);\par
  181 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/net_namespace.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/net_namespace.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/net_namespace.h}
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net__namespace_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEFINE_COMPAT_PNET_REG_FUNC}(TYPE)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEFINE_COMPAT_PNET_REG_FUNC\:net_namespace.h}
{\xe \v net_namespace.h\:DEFINE_COMPAT_PNET_REG_FUNC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEFINE_COMPAT_PNET_REG_FUNC( TYPE)}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/sock.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/sock.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/sock.h}
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sock_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __sk_user_data}(sk)\~ ((*((void {\b __rcu} **)&(sk)->sk_user_data)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_dereference_sk_user_data}(sk)\~ rcu_dereference({\b __sk_user_data}((sk)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b rcu_assign_sk_user_data}(sk,  ptr)\~ rcu_assign_pointer({\b __sk_user_data}((sk)), ptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __sk_user_data\:sock.h}
{\xe \v sock.h\:__sk_user_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __sk_user_data( sk)\~ ((*((void {\b __rcu} **)&(sk)->sk_user_data)))}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_assign_sk_user_data\:sock.h}
{\xe \v sock.h\:rcu_assign_sk_user_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_assign_sk_user_data( sk,  ptr)\~ rcu_assign_pointer({\b __sk_user_data}((sk)), ptr)}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_dereference_sk_user_data\:sock.h}
{\xe \v sock.h\:rcu_dereference_sk_user_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define rcu_dereference_sk_user_data( sk)\~ rcu_dereference({\b __sk_user_data}((sk)))}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/stt.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/stt.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/stt.h}
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kconfig.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for stt.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "stt_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "stt_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/udp_tunnel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/udp_tunnel.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/udp_tunnel.h}
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/kconfig.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp_tunnel.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "udp__tunnel_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "udp__tunnel_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b udp_tunnel_handle_offloads}\~ {\b rpl_udp_tunnel_handle_offloads}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct sk_buff * {\b rpl_udp_tunnel_handle_offloads} (struct sk_buff *skb, {\b bool} udp_csum, {\b bool} is_vxlan)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v udp_tunnel_handle_offloads\:udp_tunnel.h}
{\xe \v udp_tunnel.h\:udp_tunnel_handle_offloads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define udp_tunnel_handle_offloads\~ {\b rpl_udp_tunnel_handle_offloads}}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_udp_tunnel_handle_offloads\:udp_tunnel.h}
{\xe \v udp_tunnel.h\:rpl_udp_tunnel_handle_offloads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct sk_buff* rpl_udp_tunnel_handle_offloads (struct sk_buff *  {\i skb}, {\b bool}  {\i udp_csum}, {\b bool}  {\i is_vxlan}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    13 \{\par
   14     if (skb_is_gso(skb) && skb_is_encapsulated(skb)) \{\par
   15         kfree_skb(skb);\par
   16         return ERR_PTR(-ENOSYS);\par
   17     \}\par
   18     return udp_tunnel_handle_offloads(skb, udp_csum);\par
   19 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/include/net/vxlan.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/include/net/vxlan.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/include/net/vxlan.h}
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vxlan.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vxlan_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vxlan_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlanhdr_gbp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_metadata}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_sock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_HF_VNI}\~ 0x08000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_HF_GBP}\~ 0x80000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_N_VID}\~ (1u << 24)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_VID_MASK}\~ ({\b VXLAN_N_VID} - 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_HLEN}\~ (sizeof(struct udphdr) + sizeof(struct {\b vxlanhdr}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_GBP_USED_BITS}\~ ({\b VXLAN_HF_GBP} | 0xFFFFFF)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_GBP_DONT_LEARN}\~ (BIT(6) << 16)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_GBP_POLICY_APPLIED}\~ (BIT(3) << 16)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_GBP_ID_MASK}\~ (0xFFFF)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_F_GBP}\~ 0x800\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_F_UDP_CSUM}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VXLAN_F_RCV_FLAGS}\~ {\b VXLAN_F_GBP}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vxlan_sock}\~ rpl_vxlan_sock\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vxlan_rcv_t}\~ rpl_vxlan_rcv_t\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vxlan_sock_add}\~ {\b rpl_vxlan_sock_add}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vxlan_sock_release}\~ {\b rpl_vxlan_sock_release}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b vxlan_xmit_skb}\~ {\b rpl_vxlan_xmit_skb}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void( {\b vxlan_rcv_t}) (struct {\b vxlan_sock} *vh, struct sk_buff *skb, struct {\b vxlan_metadata} *md)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_sock} * {\b rpl_vxlan_sock_add} (struct net *net, __be16 port, {\b vxlan_rcv_t} *rcv, void *data, {\b bool} no_share, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_vxlan_sock_release} (struct {\b vxlan_sock} *vs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_vxlan_xmit_skb} (struct {\b vxlan_sock} *vs, struct rtable *rt, struct sk_buff *skb, __be32 {\b src}, __be32 {\b dst}, __u8 {\b tos}, __u8 {\b ttl}, __be16 df, __be16 src_port, __be16 dst_port, struct {\b vxlan_metadata} *md, {\b bool} xnet, u32 vxflags)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v VXLAN_F_GBP\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_F_GBP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_F_GBP\~ 0x800}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_F_RCV_FLAGS\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_F_RCV_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_F_RCV_FLAGS\~ {\b VXLAN_F_GBP}}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_F_UDP_CSUM\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_F_UDP_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_F_UDP_CSUM\~ 0x40}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_GBP_DONT_LEARN\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_GBP_DONT_LEARN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_GBP_DONT_LEARN\~ (BIT(6) << 16)}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_GBP_ID_MASK\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_GBP_ID_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_GBP_ID_MASK\~ (0xFFFF)}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_GBP_POLICY_APPLIED\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_GBP_POLICY_APPLIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_GBP_POLICY_APPLIED\~ (BIT(3) << 16)}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_GBP_USED_BITS\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_GBP_USED_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_GBP_USED_BITS\~ ({\b VXLAN_HF_GBP} | 0xFFFFFF)}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_HF_GBP\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_HF_GBP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_HF_GBP\~ 0x80000000}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_HF_VNI\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_HF_VNI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_HF_VNI\~ 0x08000000}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_HLEN\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_HLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_HLEN\~ (sizeof(struct udphdr) + sizeof(struct {\b vxlanhdr}))}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_N_VID\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_N_VID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_N_VID\~ (1u << 24)}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vxlan_rcv_t\:vxlan.h}
{\xe \v vxlan.h\:vxlan_rcv_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vxlan_rcv_t\~ rpl_vxlan_rcv_t}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vxlan_sock\:vxlan.h}
{\xe \v vxlan.h\:vxlan_sock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b vxlan_sock}\~ rpl_vxlan_sock}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vxlan_sock_add\:vxlan.h}
{\xe \v vxlan.h\:vxlan_sock_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vxlan_sock_add\~ {\b rpl_vxlan_sock_add}}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vxlan_sock_release\:vxlan.h}
{\xe \v vxlan.h\:vxlan_sock_release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vxlan_sock_release\~ {\b rpl_vxlan_sock_release}}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VXLAN_VID_MASK\:vxlan.h}
{\xe \v vxlan.h\:VXLAN_VID_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VXLAN_VID_MASK\~ ({\b VXLAN_N_VID} - 1)}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vxlan_xmit_skb\:vxlan.h}
{\xe \v vxlan.h\:vxlan_xmit_skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define vxlan_xmit_skb\~ {\b rpl_vxlan_xmit_skb}}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v vxlan_rcv_t\:vxlan.h}
{\xe \v vxlan.h\:vxlan_rcv_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void( vxlan_rcv_t) (struct {\b vxlan_sock} *vh, struct sk_buff *skb, struct {\b vxlan_metadata} *md)}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rpl_vxlan_sock_add\:vxlan.h}
{\xe \v vxlan.h\:rpl_vxlan_sock_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vxlan_sock}* rpl_vxlan_sock_add (struct net *  {\i net}, __be16  {\i port}, {\b vxlan_rcv_t} *  {\i rcv}, void *  {\i data}, {\b bool}  {\i no_share}, u32  {\i flags})}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314 \{\par
  315     return vxlan_socket_create(net, port, rcv, data, flags);\par
  316 \}\par
}
}
{\xe \v rpl_vxlan_sock_release\:vxlan.h}
{\xe \v vxlan.h\:rpl_vxlan_sock_release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_vxlan_sock_release (struct {\b vxlan_sock} *  {\i vs})}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   320 \{\par
  321     ASSERT_OVSL();\par
  322 \par
  323     queue_work(system_wq, &vs->del_work);\par
  324 \}\par
}
}
{\xe \v rpl_vxlan_xmit_skb\:vxlan.h}
{\xe \v vxlan.h\:rpl_vxlan_xmit_skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_vxlan_xmit_skb (struct {\b vxlan_sock} *  {\i vs}, struct rtable *  {\i rt}, struct sk_buff *  {\i skb}, __be32  {\i src}, __be32  {\i dst}, __u8  {\i tos}, __u8  {\i ttl}, __be16  {\i df}, __be16  {\i src_port}, __be16  {\i dst_port}, struct {\b vxlan_metadata} *  {\i md}, {\b bool}  {\i xnet}, u32  {\i vxflags})}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   188 \{\par
  189     struct vxlanhdr *vxh;\par
  190     int min_headroom;\par
  191     int err;\par
  192     bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);\par
  193 \par
  194     min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len\par
  195             + VXLAN_HLEN + sizeof(struct iphdr)\par
  196             + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  197 \par
  198     /* Need space for new headers (invalidates iph ptr) */\par
  199     err = skb_cow_head(skb, min_headroom);\par
  200     if (unlikely(err)) \{\par
  201         kfree_skb(skb);\par
  202         return err;\par
  203     \}\par
  204 \par
  205     skb = vlan_hwaccel_push_inside(skb);\par
  206     if (WARN_ON(!skb))\par
  207         return -ENOMEM;\par
  208 \par
  209     skb = udp_tunnel_handle_offloads(skb, udp_sum, true);\par
  210     if (IS_ERR(skb))\par
  211         return PTR_ERR(skb);\par
  212 \par
  213     vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));\par
  214     vxh->vx_flags = htonl(VXLAN_HF_VNI);\par
  215     vxh->vx_vni = md->vni;\par
  216 \par
  217     if (vxflags & VXLAN_F_GBP)\par
  218         vxlan_build_gbp_hdr(vxh, vxflags, md);\par
  219 \par
  220     vxlan_set_owner(vs->sock->sk, skb);\par
  221 \par
  222     ovs_skb_set_inner_protocol(skb, htons(ETH_P_TEB));\par
  223 \par
  224     return udp_tunnel_xmit_skb(rt, skb, src, dst, tos,\par
  225                    ttl, df, src_port, dst_port, xnet,\par
  226                    !udp_sum);\par
  227 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/ip_tunnels_core.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/ip_tunnels_core.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/ip_tunnels_core.c}
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/in.h>}\par
{\f2 #include <linux/in_route.h>}\par
{\f2 #include <linux/inetdevice.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <linux/workqueue.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "compat.h"}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ip_tunnels_core.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2ip__tunnels__core_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_skb_is_encapsulated} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_skb_is_encapsulated})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:compat/ip_tunnels_core.c}
{\xe \v compat/ip_tunnels_core.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/ip_tunnels_core.c}
{\xe \v compat/ip_tunnels_core.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_skb_is_encapsulated} )}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_skb_is_encapsulated\:compat/ip_tunnels_core.c}
{\xe \v compat/ip_tunnels_core.c\:ovs_skb_is_encapsulated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_skb_is_encapsulated (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     /* checking for inner protocol should be sufficient on newer kernel, but\par
  178      * old kernel just set encapsulation bit.\par
  179      */\par
  180     return ovs_skb_get_inner_protocol(skb) || skb_encapsulation(skb);\par
  181 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/ip_tunnels_core.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/ip_tunnels_core.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/ip_tunnels_core.c}
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/in.h>}\par
{\f2 #include <linux/in_route.h>}\par
{\f2 #include <linux/inetdevice.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <linux/workqueue.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "compat.h"}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ip_tunnels_core.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ip__tunnels__core_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b ovs_skb_is_encapsulated} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_skb_is_encapsulated})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:ip_tunnels_core.c}
{\xe \v ip_tunnels_core.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:ip_tunnels_core.c}
{\xe \v ip_tunnels_core.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_skb_is_encapsulated} )}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_skb_is_encapsulated\:ip_tunnels_core.c}
{\xe \v ip_tunnels_core.c\:ovs_skb_is_encapsulated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} ovs_skb_is_encapsulated (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     /* checking for inner protocol should be sufficient on newer kernel, but\par
  178      * old kernel just set encapsulation bit.\par
  179      */\par
  180     return ovs_skb_get_inner_protocol(skb) || skb_encapsulation(skb);\par
  181 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/net_namespace.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/net_namespace.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/net_namespace.c}
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for net_namespace.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2net__namespace_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/net_namespace.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/net_namespace.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/net_namespace.c}
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for net_namespace.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net__namespace_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/netdevice.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/netdevice.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/netdevice.c}
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for netdevice.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2netdevice_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/netdevice.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/netdevice.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/netdevice.c}
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <net/mpls.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for netdevice.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "netdevice_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/reciprocal_div.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/reciprocal_div.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/reciprocal_div.c}
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kernel.h>}\par
{\f2 #include <asm/div64.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/reciprocal_div.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for reciprocal_div.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2reciprocal__div_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reciprocal_value} {\b rpl_reciprocal_value} (u32 d)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_reciprocal_value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/reciprocal_div.c}
{\xe \v compat/reciprocal_div.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_reciprocal_value} )}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_reciprocal_value\:compat/reciprocal_div.c}
{\xe \v compat/reciprocal_div.c\:rpl_reciprocal_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b reciprocal_value} rpl_reciprocal_value (u32  {\i d})}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct reciprocal_value R;\par
   14     u64 m;\par
   15     int l;\par
   16 \par
   17     l = fls(d - 1);\par
   18     m = ((1ULL << 32) * ((1ULL << l) - d));\par
   19     do_div(m, d);\par
   20     ++m;\par
   21     R.m = (u32)m;\par
   22     R.sh1 = min(l, 1);\par
   23     R.sh2 = max(l - 1, 0);\par
   24 \par
   25     return R;\par
   26 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/reciprocal_div.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/reciprocal_div.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/reciprocal_div.c}
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kernel.h>}\par
{\f2 #include <asm/div64.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/reciprocal_div.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for reciprocal_div.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "reciprocal__div_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reciprocal_value} {\b rpl_reciprocal_value} (u32 d)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_reciprocal_value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:reciprocal_div.c}
{\xe \v reciprocal_div.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_reciprocal_value} )}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_reciprocal_value\:reciprocal_div.c}
{\xe \v reciprocal_div.c\:rpl_reciprocal_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b reciprocal_value} rpl_reciprocal_value (u32  {\i d})}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct reciprocal_value R;\par
   14     u64 m;\par
   15     int l;\par
   16 \par
   17     l = fls(d - 1);\par
   18     m = ((1ULL << 32) * ((1ULL << l) - d));\par
   19     do_div(m, d);\par
   20     ++m;\par
   21     R.m = (u32)m;\par
   22     R.sh1 = min(l, 1);\par
   23     R.sh2 = max(l - 1, 0);\par
   24 \par
   25     return R;\par
   26 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/skbuff-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/skbuff-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/skbuff-openvswitch.c}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for skbuff-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2skbuff-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_ensure_writable} (struct sk_buff *skb, int write_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_ensure_writable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __skb_vlan_pop} (struct sk_buff *skb, u16 *vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_pop} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_vlan_pop})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_push} (struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_vlan_push})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_kfree_skb_list} (struct sk_buff *segs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL} ({\b rpl_kfree_skb_list})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __skb_vlan_pop\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:__skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __skb_vlan_pop (struct sk_buff *  {\i skb}, u16 *  {\i vlan_tci}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     struct vlan_hdr *vhdr;\par
  152     unsigned int offset = skb->data - skb_mac_header(skb);\par
  153     int err;\par
  154 \par
  155     __skb_push(skb, offset);\par
  156     err = skb_ensure_writable(skb, VLAN_ETH_HLEN);\par
  157     if (unlikely(err))\par
  158         goto pull;\par
  159 \par
  160     skb_postpull_rcsum(skb, skb->data + (2 * ETH_ALEN), VLAN_HLEN);\par
  161 \par
  162     vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);\par
  163     *vlan_tci = ntohs(vhdr->h_vlan_TCI);\par
  164 \par
  165     memmove(skb->data + VLAN_HLEN, skb->data, 2 * ETH_ALEN);\par
  166     __skb_pull(skb, VLAN_HLEN);\par
  167 \par
  168     vlan_set_encap_proto(skb, vhdr);\par
  169     skb->mac_header += VLAN_HLEN;\par
  170 \par
  171     if (skb_network_offset(skb) < ETH_HLEN)\par
  172         skb_set_network_header(skb, ETH_HLEN);\par
  173 \par
  174     skb_reset_mac_len(skb);\par
  175 pull:\par
  176     __skb_pull(skb, offset);\par
  177 \par
  178     return err;\par
  179 \}\par
}
}
{\xe \v EXPORT_SYMBOL\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:EXPORT_SYMBOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL ({\b rpl_kfree_skb_list} )}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_ensure_writable} )}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_vlan_pop} )}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_vlan_push} )}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_kfree_skb_list\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:rpl_kfree_skb_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_kfree_skb_list (struct sk_buff *  {\i segs})}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     while (segs) \{\par
  275         struct sk_buff *next = segs->next;\par
  276 \par
  277         kfree_skb(segs);\par
  278         segs = next;\par
  279     \}\par
  280 \}\par
}
}
{\xe \v rpl_skb_ensure_writable\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:rpl_skb_ensure_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_ensure_writable (struct sk_buff *  {\i skb}, int  {\i write_len})}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     if (!pskb_may_pull(skb, write_len))\par
  137         return -ENOMEM;\par
  138 \par
  139     if (!skb_cloned(skb) || skb_clone_writable(skb, write_len))\par
  140         return 0;\par
  141 \par
  142     return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);\par
  143 \}\par
}
}
{\xe \v rpl_skb_vlan_pop\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:rpl_skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_pop (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182 \{\par
  183     u16 vlan_tci;\par
  184     __be16 vlan_proto;\par
  185     int err;\par
  186 \par
  187     if (likely(skb_vlan_tag_present(skb))) \{\par
  188         skb->vlan_tci = 0;\par
  189     \} else \{\par
  190         if (unlikely((skb->protocol != htons(ETH_P_8021Q) &&\par
  191                   skb->protocol != htons(ETH_P_8021AD)) ||\par
  192                  skb->len < VLAN_ETH_HLEN))\par
  193             return 0;\par
  194 \par
  195         err = __skb_vlan_pop(skb, &vlan_tci);\par
  196         if (err)\par
  197             return err;\par
  198     \}\par
  199     /* move next vlan tag to hw accel tag */\par
  200     if (likely((skb->protocol != htons(ETH_P_8021Q) &&\par
  201             skb->protocol != htons(ETH_P_8021AD)) ||\par
  202            skb->len < VLAN_ETH_HLEN))\par
  203         return 0;\par
  204 \par
  205     vlan_proto = htons(ETH_P_8021Q);\par
  206     err = __skb_vlan_pop(skb, &vlan_tci);\par
  207     if (unlikely(err))\par
  208         return err;\par
  209 \par
  210     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  211     return 0;\par
  212 \}\par
}
}
{\xe \v rpl_skb_vlan_push\:compat/skbuff-openvswitch.c}
{\xe \v compat/skbuff-openvswitch.c\:rpl_skb_vlan_push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_push (struct sk_buff *  {\i skb}, __be16  {\i vlan_proto}, u16  {\i vlan_tci})}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{\par
  219     if (skb_vlan_tag_present(skb)) \{\par
  220         unsigned int offset = skb->data - skb_mac_header(skb);\par
  221         int err;\par
  222 \par
  223         /* __vlan_insert_tag expect skb->data pointing to mac header.\par
  224          * So change skb->data before calling it and change back to\par
  225          * original position later\par
  226          */\par
  227         __skb_push(skb, offset);\par
  228         err = __vlan_insert_tag(skb, skb->vlan_proto,\par
  229                     skb_vlan_tag_get(skb));\par
  230         if (err)\par
  231             return err;\par
  232         skb->mac_len += VLAN_HLEN;\par
  233         __skb_pull(skb, offset);\par
  234 \par
  235         if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  236             skb->csum = csum_add(skb->csum, csum_partial(skb->data\par
  237                     + (2 * ETH_ALEN), VLAN_HLEN, 0));\par
  238     \}\par
  239     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  240     return 0;\par
  241 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/skbuff-openvswitch.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/skbuff-openvswitch.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/skbuff-openvswitch.c}
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for skbuff-openvswitch.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "skbuff-openvswitch_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_ensure_writable} (struct sk_buff *skb, int write_len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_ensure_writable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __skb_vlan_pop} (struct sk_buff *skb, u16 *vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_pop} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_vlan_pop})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_skb_vlan_push} (struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_skb_vlan_push})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_kfree_skb_list} (struct sk_buff *segs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL} ({\b rpl_kfree_skb_list})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __skb_vlan_pop\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:__skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __skb_vlan_pop (struct sk_buff *  {\i skb}, u16 *  {\i vlan_tci}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     struct vlan_hdr *vhdr;\par
  152     unsigned int offset = skb->data - skb_mac_header(skb);\par
  153     int err;\par
  154 \par
  155     __skb_push(skb, offset);\par
  156     err = skb_ensure_writable(skb, VLAN_ETH_HLEN);\par
  157     if (unlikely(err))\par
  158         goto pull;\par
  159 \par
  160     skb_postpull_rcsum(skb, skb->data + (2 * ETH_ALEN), VLAN_HLEN);\par
  161 \par
  162     vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);\par
  163     *vlan_tci = ntohs(vhdr->h_vlan_TCI);\par
  164 \par
  165     memmove(skb->data + VLAN_HLEN, skb->data, 2 * ETH_ALEN);\par
  166     __skb_pull(skb, VLAN_HLEN);\par
  167 \par
  168     vlan_set_encap_proto(skb, vhdr);\par
  169     skb->mac_header += VLAN_HLEN;\par
  170 \par
  171     if (skb_network_offset(skb) < ETH_HLEN)\par
  172         skb_set_network_header(skb, ETH_HLEN);\par
  173 \par
  174     skb_reset_mac_len(skb);\par
  175 pull:\par
  176     __skb_pull(skb, offset);\par
  177 \par
  178     return err;\par
  179 \}\par
}
}
{\xe \v EXPORT_SYMBOL\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:EXPORT_SYMBOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL ({\b rpl_kfree_skb_list} )}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_ensure_writable} )}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_vlan_pop} )}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_skb_vlan_push} )}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_kfree_skb_list\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:rpl_kfree_skb_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_kfree_skb_list (struct sk_buff *  {\i segs})}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     while (segs) \{\par
  275         struct sk_buff *next = segs->next;\par
  276 \par
  277         kfree_skb(segs);\par
  278         segs = next;\par
  279     \}\par
  280 \}\par
}
}
{\xe \v rpl_skb_ensure_writable\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:rpl_skb_ensure_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_ensure_writable (struct sk_buff *  {\i skb}, int  {\i write_len})}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     if (!pskb_may_pull(skb, write_len))\par
  137         return -ENOMEM;\par
  138 \par
  139     if (!skb_cloned(skb) || skb_clone_writable(skb, write_len))\par
  140         return 0;\par
  141 \par
  142     return pskb_expand_head(skb, 0, 0, GFP_ATOMIC);\par
  143 \}\par
}
}
{\xe \v rpl_skb_vlan_pop\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:rpl_skb_vlan_pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_pop (struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182 \{\par
  183     u16 vlan_tci;\par
  184     __be16 vlan_proto;\par
  185     int err;\par
  186 \par
  187     if (likely(skb_vlan_tag_present(skb))) \{\par
  188         skb->vlan_tci = 0;\par
  189     \} else \{\par
  190         if (unlikely((skb->protocol != htons(ETH_P_8021Q) &&\par
  191                   skb->protocol != htons(ETH_P_8021AD)) ||\par
  192                  skb->len < VLAN_ETH_HLEN))\par
  193             return 0;\par
  194 \par
  195         err = __skb_vlan_pop(skb, &vlan_tci);\par
  196         if (err)\par
  197             return err;\par
  198     \}\par
  199     /* move next vlan tag to hw accel tag */\par
  200     if (likely((skb->protocol != htons(ETH_P_8021Q) &&\par
  201             skb->protocol != htons(ETH_P_8021AD)) ||\par
  202            skb->len < VLAN_ETH_HLEN))\par
  203         return 0;\par
  204 \par
  205     vlan_proto = htons(ETH_P_8021Q);\par
  206     err = __skb_vlan_pop(skb, &vlan_tci);\par
  207     if (unlikely(err))\par
  208         return err;\par
  209 \par
  210     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  211     return 0;\par
  212 \}\par
}
}
{\xe \v rpl_skb_vlan_push\:skbuff-openvswitch.c}
{\xe \v skbuff-openvswitch.c\:rpl_skb_vlan_push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_skb_vlan_push (struct sk_buff *  {\i skb}, __be16  {\i vlan_proto}, u16  {\i vlan_tci})}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{\par
  219     if (skb_vlan_tag_present(skb)) \{\par
  220         unsigned int offset = skb->data - skb_mac_header(skb);\par
  221         int err;\par
  222 \par
  223         /* __vlan_insert_tag expect skb->data pointing to mac header.\par
  224          * So change skb->data before calling it and change back to\par
  225          * original position later\par
  226          */\par
  227         __skb_push(skb, offset);\par
  228         err = __vlan_insert_tag(skb, skb->vlan_proto,\par
  229                     skb_vlan_tag_get(skb));\par
  230         if (err)\par
  231             return err;\par
  232         skb->mac_len += VLAN_HLEN;\par
  233         __skb_pull(skb, offset);\par
  234 \par
  235         if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  236             skb->csum = csum_add(skb->csum, csum_partial(skb->data\par
  237                     + (2 * ETH_ALEN), VLAN_HLEN, 0));\par
  238     \}\par
  239     __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);\par
  240     return 0;\par
  241 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/stt.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/stt.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/stt.c}
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <asm/unaligned.h>}\par
{\f2 #include <linux/delay.h>}\par
{\f2 #include <linux/flex_array.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/log2.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/netfilter.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/workqueue.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/sock.h>}\par
{\f2 #include <net/stt.h>}\par
{\f2 #include <net/tcp.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for stt.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2stt_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/stt.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/stt.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/stt.c}
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <asm/unaligned.h>}\par
{\f2 #include <linux/delay.h>}\par
{\f2 #include <linux/flex_array.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/ipv6.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/log2.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/netfilter.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/tcp.h>}\par
{\f2 #include <linux/workqueue.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/sock.h>}\par
{\f2 #include <net/stt.h>}\par
{\f2 #include <net/tcp.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include "gso.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for stt.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "stt_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/udp.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/udp.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/udp.c}
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <net/udp.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2udp_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_udp_set_csum} ({\b bool} nocheck, struct sk_buff *skb, __be32 saddr, __be32 daddr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_udp_set_csum})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/udp.c}
{\xe \v compat/udp.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_udp_set_csum} )}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_udp_set_csum\:compat/udp.c}
{\xe \v compat/udp.c\:rpl_udp_set_csum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_udp_set_csum ({\b bool}  {\i nocheck}, struct sk_buff *  {\i skb}, __be32  {\i saddr}, __be32  {\i daddr}, int  {\i len})}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct udphdr *uh = udp_hdr(skb);\par
   14 \par
   15     if (nocheck)\par
   16         uh->check = 0;\par
   17     else if (skb_is_gso(skb))\par
   18         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   19     else if (skb_dst(skb) && skb_dst(skb)->dev &&\par
   20          (skb_dst(skb)->dev->features & NETIF_F_V4_CSUM)) \{\par
   21 \par
   22         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   23 \par
   24         skb->ip_summed = CHECKSUM_PARTIAL;\par
   25         skb->csum_start = skb_transport_header(skb) - skb->head;\par
   26         skb->csum_offset = offsetof(struct udphdr, check);\par
   27         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   28     \} else \{\par
   29         __wsum csum;\par
   30 \par
   31         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   32 \par
   33         uh->check = 0;\par
   34         csum = skb_checksum(skb, 0, len, 0);\par
   35         uh->check = udp_v4_check(len, saddr, daddr, csum);\par
   36         if (uh->check == 0)\par
   37             uh->check = CSUM_MANGLED_0;\par
   38 \par
   39         skb->ip_summed = CHECKSUM_UNNECESSARY;\par
   40     \}\par
   41 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/udp.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/udp.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/udp.c}
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <net/udp.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "udp_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_udp_set_csum} ({\b bool} nocheck, struct sk_buff *skb, __be32 saddr, __be32 daddr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_udp_set_csum})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:udp.c}
{\xe \v udp.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_udp_set_csum} )}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rpl_udp_set_csum\:udp.c}
{\xe \v udp.c\:rpl_udp_set_csum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_udp_set_csum ({\b bool}  {\i nocheck}, struct sk_buff *  {\i skb}, __be32  {\i saddr}, __be32  {\i daddr}, int  {\i len})}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     struct udphdr *uh = udp_hdr(skb);\par
   14 \par
   15     if (nocheck)\par
   16         uh->check = 0;\par
   17     else if (skb_is_gso(skb))\par
   18         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   19     else if (skb_dst(skb) && skb_dst(skb)->dev &&\par
   20          (skb_dst(skb)->dev->features & NETIF_F_V4_CSUM)) \{\par
   21 \par
   22         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   23 \par
   24         skb->ip_summed = CHECKSUM_PARTIAL;\par
   25         skb->csum_start = skb_transport_header(skb) - skb->head;\par
   26         skb->csum_offset = offsetof(struct udphdr, check);\par
   27         uh->check = ~udp_v4_check(len, saddr, daddr, 0);\par
   28     \} else \{\par
   29         __wsum csum;\par
   30 \par
   31         BUG_ON(skb->ip_summed == CHECKSUM_PARTIAL);\par
   32 \par
   33         uh->check = 0;\par
   34         csum = skb_checksum(skb, 0, len, 0);\par
   35         uh->check = udp_v4_check(len, saddr, daddr, csum);\par
   36         if (uh->check == 0)\par
   37             uh->check = CSUM_MANGLED_0;\par
   38 \par
   39         skb->ip_summed = CHECKSUM_UNNECESSARY;\par
   40     \}\par
   41 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/udp_tunnel.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/udp_tunnel.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/udp_tunnel.c}
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp_tunnel.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2udp__tunnel_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/udp_tunnel.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/udp_tunnel.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/udp_tunnel.c}
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for udp_tunnel.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "udp__tunnel_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/utils.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/utils.c}
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/ctype.h>}\par
{\f2 #include <linux/inet.h>}\par
{\f2 #include <linux/mm.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <net/checksum.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <linux/string.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/init.h>}\par
{\f2 #include <linux/ratelimit.h>}\par
{\f2 #include <net/sock.h>}\par
{\f2 #include <asm/byteorder.h>}\par
{\f2 #include <asm/uaccess.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for utils.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2utils_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/utils.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/utils.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/utils.c}
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/jiffies.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/ctype.h>}\par
{\f2 #include <linux/inet.h>}\par
{\f2 #include <linux/mm.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <net/checksum.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <linux/string.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/init.h>}\par
{\f2 #include <linux/ratelimit.h>}\par
{\f2 #include <net/sock.h>}\par
{\f2 #include <asm/byteorder.h>}\par
{\f2 #include <asm/uaccess.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for utils.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "utils_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/compat/vxlan.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/compat/vxlan.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/compat/vxlan.c}
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/errno.h>}\par
{\f2 #include <linux/slab.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/igmp.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/hash.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <net/arp.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/udp_tunnel.h>}\par
{\f2 #include <net/rtnetlink.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/vxlan.h>}\par
{\f2 #include "compat.h"}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vxlan.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "compat_2vxlan_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlanhdr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_udp_encap_recv} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_sock_put} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_set_owner} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_build_gbp_hdr} (struct {\b vxlanhdr} *vxh, u32 vxflags, struct {\b vxlan_metadata} *md)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_vxlan_xmit_skb} (struct {\b vxlan_sock} *vs, struct rtable *rt, struct sk_buff *skb, __be32 {\b src}, __be32 {\b dst}, __u8 {\b tos}, __u8 {\b ttl}, __be16 df, __be16 src_port, __be16 dst_port, struct {\b vxlan_metadata} *md, {\b bool} xnet, u32 vxflags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_xmit_skb})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_vs} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_del_work} (struct work_struct *work)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct socket * {\b vxlan_create_sock} (struct net *net, {\b bool} {\b ipv6}, __be16 port, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vxlan_sock} * {\b vxlan_socket_create} (struct net *net, __be16 port, {\b vxlan_rcv_t} *rcv, void *data, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_sock} * {\b rpl_vxlan_sock_add} (struct net *net, __be16 port, {\b vxlan_rcv_t} *rcv, void *data, {\b bool} no_share, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_sock_add})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_vxlan_sock_release} (struct {\b vxlan_sock} *vs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_sock_release})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_xmit_skb} )}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_sock_add} )}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_sock_release} )}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_free_vs\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:rcu_free_vs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_vs (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232     struct vxlan_sock *vs = container_of(rcu, struct vxlan_sock, rcu);\par
  233 \par
  234     kfree(vs);\par
  235 \}\par
}
}
{\xe \v rpl_vxlan_sock_add\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:rpl_vxlan_sock_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vxlan_sock}* rpl_vxlan_sock_add (struct net *  {\i net}, __be16  {\i port}, {\b vxlan_rcv_t} *  {\i rcv}, void *  {\i data}, {\b bool}  {\i no_share}, u32  {\i flags})}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314 \{\par
  315     return vxlan_socket_create(net, port, rcv, data, flags);\par
  316 \}\par
}
}
{\xe \v rpl_vxlan_sock_release\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:rpl_vxlan_sock_release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_vxlan_sock_release (struct {\b vxlan_sock} *  {\i vs})}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   320 \{\par
  321     ASSERT_OVSL();\par
  322 \par
  323     queue_work(system_wq, &vs->del_work);\par
  324 \}\par
}
}
{\xe \v rpl_vxlan_xmit_skb\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:rpl_vxlan_xmit_skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_vxlan_xmit_skb (struct {\b vxlan_sock} *  {\i vs}, struct rtable *  {\i rt}, struct sk_buff *  {\i skb}, __be32  {\i src}, __be32  {\i dst}, __u8  {\i tos}, __u8  {\i ttl}, __be16  {\i df}, __be16  {\i src_port}, __be16  {\i dst_port}, struct {\b vxlan_metadata} *  {\i md}, {\b bool}  {\i xnet}, u32  {\i vxflags})}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   188 \{\par
  189     struct vxlanhdr *vxh;\par
  190     int min_headroom;\par
  191     int err;\par
  192     bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);\par
  193 \par
  194     min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len\par
  195             + VXLAN_HLEN + sizeof(struct iphdr)\par
  196             + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  197 \par
  198     /* Need space for new headers (invalidates iph ptr) */\par
  199     err = skb_cow_head(skb, min_headroom);\par
  200     if (unlikely(err)) \{\par
  201         kfree_skb(skb);\par
  202         return err;\par
  203     \}\par
  204 \par
  205     skb = vlan_hwaccel_push_inside(skb);\par
  206     if (WARN_ON(!skb))\par
  207         return -ENOMEM;\par
  208 \par
  209     skb = udp_tunnel_handle_offloads(skb, udp_sum, true);\par
  210     if (IS_ERR(skb))\par
  211         return PTR_ERR(skb);\par
  212 \par
  213     vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));\par
  214     vxh->vx_flags = htonl(VXLAN_HF_VNI);\par
  215     vxh->vx_vni = md->vni;\par
  216 \par
  217     if (vxflags & VXLAN_F_GBP)\par
  218         vxlan_build_gbp_hdr(vxh, vxflags, md);\par
  219 \par
  220     vxlan_set_owner(vs->sock->sk, skb);\par
  221 \par
  222     ovs_skb_set_inner_protocol(skb, htons(ETH_P_TEB));\par
  223 \par
  224     return udp_tunnel_xmit_skb(rt, skb, src, dst, tos,\par
  225                    ttl, df, src_port, dst_port, xnet,\par
  226                    !udp_sum);\par
  227 \}\par
}
}
{\xe \v vxlan_build_gbp_hdr\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_build_gbp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_build_gbp_hdr (struct {\b vxlanhdr} *  {\i vxh}, u32  {\i vxflags}, struct {\b vxlan_metadata} *  {\i md}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166     struct vxlanhdr_gbp *gbp;\par
  167 \par
  168     if (!md->gbp)\par
  169         return;\par
  170 \par
  171     gbp = (struct vxlanhdr_gbp *)vxh;\par
  172     vxh->vx_flags |= htonl(VXLAN_HF_GBP);\par
  173 \par
  174     if (md->gbp & VXLAN_GBP_DONT_LEARN)\par
  175         gbp->dont_learn = 1;\par
  176 \par
  177     if (md->gbp & VXLAN_GBP_POLICY_APPLIED)\par
  178         gbp->policy_applied = 1;\par
  179 \par
  180     gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);\par
  181 \}\par
}
}
{\xe \v vxlan_create_sock\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_create_sock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct socket* vxlan_create_sock (struct net *  {\i net}, {\b bool}  {\i ipv6}, __be16  {\i port}, u32  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   247 \{\par
  248     struct socket *sock;\par
  249     struct udp_port_cfg udp_conf;\par
  250     int err;\par
  251 \par
  252     memset(&udp_conf, 0, sizeof(udp_conf));\par
  253 \par
  254     if (ipv6) \{\par
  255         udp_conf.family = AF_INET6;\par
  256         /* The checksum flag is silently ignored but it\par
  257          * doesn't make sense here anyways because OVS enables\par
  258          * checksums on a finer granularity than per-socket.\par
  259          */\par
  260     \} else \{\par
  261         udp_conf.family = AF_INET;\par
  262         udp_conf.local_ip.s_addr = htonl(INADDR_ANY);\par
  263     \}\par
  264 \par
  265     udp_conf.local_udp_port = port;\par
  266 \par
  267     /* Open UDP socket */\par
  268     err = udp_sock_create(net, &udp_conf, &sock);\par
  269     if (err < 0)\par
  270         return ERR_PTR(err);\par
  271 \par
  272     return sock;\par
  273 \}\par
}
}
{\xe \v vxlan_del_work\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_del_work}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_del_work (struct work_struct *  {\i work}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   238 \{\par
  239     struct vxlan_sock *vs = container_of(work, struct vxlan_sock, del_work);\par
  240 \par
  241     udp_tunnel_sock_release(vs->sock);\par
  242     call_rcu(&vs->rcu, rcu_free_vs);\par
  243 \}\par
}
}
{\xe \v vxlan_set_owner\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_set_owner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_set_owner (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157     skb_orphan(skb);\par
  158     sock_hold(sk);\par
  159     skb->sk = sk;\par
  160     skb->destructor = vxlan_sock_put;\par
  161 \}\par
}
}
{\xe \v vxlan_sock_put\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_sock_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_sock_put (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     sock_put(skb->sk);\par
  152 \}\par
}
}
{\xe \v vxlan_socket_create\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_socket_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vxlan_sock}* vxlan_socket_create (struct net *  {\i net}, __be16  {\i port}, {\b vxlan_rcv_t} *  {\i rcv}, void *  {\i data}, u32  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   277 \{\par
  278     struct vxlan_sock *vs;\par
  279     struct socket *sock;\par
  280     struct udp_tunnel_sock_cfg tunnel_cfg;\par
  281 \par
  282     vs = kmalloc(sizeof(*vs), GFP_KERNEL);\par
  283     if (!vs) \{\par
  284         pr_debug("memory alocation failure\\n");\par
  285         return ERR_PTR(-ENOMEM);\par
  286     \}\par
  287 \par
  288     INIT_WORK(&vs->del_work, vxlan_del_work);\par
  289 \par
  290     sock = vxlan_create_sock(net, false, port, flags);\par
  291     if (IS_ERR(sock)) \{\par
  292         kfree(vs);\par
  293         return ERR_CAST(sock);\par
  294     \}\par
  295 \par
  296     vs->sock = sock;\par
  297     vs->rcv = rcv;\par
  298     vs->data = data;\par
  299     vs->flags = (flags & VXLAN_F_RCV_FLAGS);\par
  300 \par
  301     tunnel_cfg.sk_user_data = vs;\par
  302     tunnel_cfg.encap_type = 1;\par
  303     tunnel_cfg.encap_rcv = vxlan_udp_encap_recv;\par
  304     tunnel_cfg.encap_destroy = NULL;\par
  305 \par
  306     setup_udp_tunnel_sock(net, sock, &tunnel_cfg);\par
  307 \par
  308     return vs;\par
  309 \}\par
}
}
{\xe \v vxlan_udp_encap_recv\:compat/vxlan.c}
{\xe \v compat/vxlan.c\:vxlan_udp_encap_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_udp_encap_recv (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    73 \{\par
   74     struct vxlan_sock *vs;\par
   75     struct vxlanhdr *vxh;\par
   76     u32 flags, vni;\par
   77     struct vxlan_metadata md = \{0\};\par
   78 \par
   79     /* Need Vxlan and inner Ethernet header to be present */\par
   80     if (!pskb_may_pull(skb, VXLAN_HLEN))\par
   81         goto error;\par
   82 \par
   83     vxh = (struct vxlanhdr *)(udp_hdr(skb) + 1);\par
   84     flags = ntohl(vxh->vx_flags);\par
   85     vni = ntohl(vxh->vx_vni);\par
   86 \par
   87     if (flags & VXLAN_HF_VNI) \{\par
   88         flags &= ~VXLAN_HF_VNI;\par
   89     \} else \{\par
   90         /* VNI flag always required to be set */\par
   91         goto bad_flags;\par
   92     \}\par
   93 \par
   94     if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))\par
   95         goto drop;\par
   96 \par
   97     vs = rcu_dereference_sk_user_data(sk);\par
   98     if (!vs)\par
   99         goto drop;\par
  100 \par
  101     /* For backwards compatibility, only allow reserved fields to be\par
  102     * used by VXLAN extensions if explicitly requested.\par
  103     */\par
  104     if ((flags & VXLAN_HF_GBP) && (vs->flags & VXLAN_F_GBP)) \{\par
  105         struct vxlanhdr_gbp *gbp;\par
  106 \par
  107         gbp = (struct vxlanhdr_gbp *)vxh;\par
  108         md.gbp = ntohs(gbp->policy_id);\par
  109 \par
  110         if (gbp->dont_learn)\par
  111             md.gbp |= VXLAN_GBP_DONT_LEARN;\par
  112 \par
  113         if (gbp->policy_applied)\par
  114             md.gbp |= VXLAN_GBP_POLICY_APPLIED;\par
  115 \par
  116         flags &= ~VXLAN_GBP_USED_BITS;\par
  117     \}\par
  118 \par
  119     if (flags || (vni & 0xff)) \{\par
  120         /* If there are any unprocessed flags remaining treat\par
  121         * this as a malformed packet. This behavior diverges from\par
  122         * VXLAN RFC (RFC7348) which stipulates that bits in reserved\par
  123         * in reserved fields are to be ignored. The approach here\par
  124         * maintains compatbility with previous stack code, and also\par
  125         * is more robust and provides a little more security in\par
  126         * adding extensions to VXLAN.\par
  127         */\par
  128 \par
  129         goto bad_flags;\par
  130     \}\par
  131 \par
  132     md.vni = vxh->vx_vni;\par
  133     vs->rcv(vs, skb, &md);\par
  134     return 0;\par
  135 \par
  136 drop:\par
  137     /* Consume bad packet */\par
  138     kfree_skb(skb);\par
  139     return 0;\par
  140 bad_flags:\par
  141     pr_debug("invalid vxlan flags=%#x vni=%#x\\n",\par
  142          ntohl(vxh->vx_flags), ntohl(vxh->vx_vni));\par
  143 \par
  144 error:\par
  145     /* Return non vxlan pkt */\par
  146     return 1;\par
  147 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vxlan.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vxlan.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vxlan.c}
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/types.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/errno.h>}\par
{\f2 #include <linux/slab.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/igmp.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if_ether.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/hash.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <net/arp.h>}\par
{\f2 #include <net/ndisc.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/gre.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/udp_tunnel.h>}\par
{\f2 #include <net/rtnetlink.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/vxlan.h>}\par
{\f2 #include "compat.h"}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vxlan.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vxlan_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlanhdr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_udp_encap_recv} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_sock_put} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_set_owner} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_build_gbp_hdr} (struct {\b vxlanhdr} *vxh, u32 vxflags, struct {\b vxlan_metadata} *md)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rpl_vxlan_xmit_skb} (struct {\b vxlan_sock} *vs, struct rtable *rt, struct sk_buff *skb, __be32 {\b src}, __be32 {\b dst}, __u8 {\b tos}, __u8 {\b ttl}, __be16 df, __be16 src_port, __be16 dst_port, struct {\b vxlan_metadata} *md, {\b bool} xnet, u32 vxflags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_xmit_skb})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rcu_free_vs} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_del_work} (struct work_struct *work)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct socket * {\b vxlan_create_sock} (struct net *net, {\b bool} {\b ipv6}, __be16 port, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vxlan_sock} * {\b vxlan_socket_create} (struct net *net, __be16 port, {\b vxlan_rcv_t} *rcv, void *data, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_sock} * {\b rpl_vxlan_sock_add} (struct net *net, __be16 port, {\b vxlan_rcv_t} *rcv, void *data, {\b bool} no_share, u32 {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_sock_add})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rpl_vxlan_sock_release} (struct {\b vxlan_sock} *vs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b rpl_vxlan_sock_release})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:vxlan.c}
{\xe \v vxlan.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:vxlan.c}
{\xe \v vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_xmit_skb} )}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vxlan.c}
{\xe \v vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_sock_add} )}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vxlan.c}
{\xe \v vxlan.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b rpl_vxlan_sock_release} )}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rcu_free_vs\:vxlan.c}
{\xe \v vxlan.c\:rcu_free_vs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rcu_free_vs (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232     struct vxlan_sock *vs = container_of(rcu, struct vxlan_sock, rcu);\par
  233 \par
  234     kfree(vs);\par
  235 \}\par
}
}
{\xe \v rpl_vxlan_sock_add\:vxlan.c}
{\xe \v vxlan.c\:rpl_vxlan_sock_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vxlan_sock}* rpl_vxlan_sock_add (struct net *  {\i net}, __be16  {\i port}, {\b vxlan_rcv_t} *  {\i rcv}, void *  {\i data}, {\b bool}  {\i no_share}, u32  {\i flags})}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314 \{\par
  315     return vxlan_socket_create(net, port, rcv, data, flags);\par
  316 \}\par
}
}
{\xe \v rpl_vxlan_sock_release\:vxlan.c}
{\xe \v vxlan.c\:rpl_vxlan_sock_release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rpl_vxlan_sock_release (struct {\b vxlan_sock} *  {\i vs})}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   320 \{\par
  321     ASSERT_OVSL();\par
  322 \par
  323     queue_work(system_wq, &vs->del_work);\par
  324 \}\par
}
}
{\xe \v rpl_vxlan_xmit_skb\:vxlan.c}
{\xe \v vxlan.c\:rpl_vxlan_xmit_skb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rpl_vxlan_xmit_skb (struct {\b vxlan_sock} *  {\i vs}, struct rtable *  {\i rt}, struct sk_buff *  {\i skb}, __be32  {\i src}, __be32  {\i dst}, __u8  {\i tos}, __u8  {\i ttl}, __be16  {\i df}, __be16  {\i src_port}, __be16  {\i dst_port}, struct {\b vxlan_metadata} *  {\i md}, {\b bool}  {\i xnet}, u32  {\i vxflags})}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   188 \{\par
  189     struct vxlanhdr *vxh;\par
  190     int min_headroom;\par
  191     int err;\par
  192     bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);\par
  193 \par
  194     min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len\par
  195             + VXLAN_HLEN + sizeof(struct iphdr)\par
  196             + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  197 \par
  198     /* Need space for new headers (invalidates iph ptr) */\par
  199     err = skb_cow_head(skb, min_headroom);\par
  200     if (unlikely(err)) \{\par
  201         kfree_skb(skb);\par
  202         return err;\par
  203     \}\par
  204 \par
  205     skb = vlan_hwaccel_push_inside(skb);\par
  206     if (WARN_ON(!skb))\par
  207         return -ENOMEM;\par
  208 \par
  209     skb = udp_tunnel_handle_offloads(skb, udp_sum, true);\par
  210     if (IS_ERR(skb))\par
  211         return PTR_ERR(skb);\par
  212 \par
  213     vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));\par
  214     vxh->vx_flags = htonl(VXLAN_HF_VNI);\par
  215     vxh->vx_vni = md->vni;\par
  216 \par
  217     if (vxflags & VXLAN_F_GBP)\par
  218         vxlan_build_gbp_hdr(vxh, vxflags, md);\par
  219 \par
  220     vxlan_set_owner(vs->sock->sk, skb);\par
  221 \par
  222     ovs_skb_set_inner_protocol(skb, htons(ETH_P_TEB));\par
  223 \par
  224     return udp_tunnel_xmit_skb(rt, skb, src, dst, tos,\par
  225                    ttl, df, src_port, dst_port, xnet,\par
  226                    !udp_sum);\par
  227 \}\par
}
}
{\xe \v vxlan_build_gbp_hdr\:vxlan.c}
{\xe \v vxlan.c\:vxlan_build_gbp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_build_gbp_hdr (struct {\b vxlanhdr} *  {\i vxh}, u32  {\i vxflags}, struct {\b vxlan_metadata} *  {\i md}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166     struct vxlanhdr_gbp *gbp;\par
  167 \par
  168     if (!md->gbp)\par
  169         return;\par
  170 \par
  171     gbp = (struct vxlanhdr_gbp *)vxh;\par
  172     vxh->vx_flags |= htonl(VXLAN_HF_GBP);\par
  173 \par
  174     if (md->gbp & VXLAN_GBP_DONT_LEARN)\par
  175         gbp->dont_learn = 1;\par
  176 \par
  177     if (md->gbp & VXLAN_GBP_POLICY_APPLIED)\par
  178         gbp->policy_applied = 1;\par
  179 \par
  180     gbp->policy_id = htons(md->gbp & VXLAN_GBP_ID_MASK);\par
  181 \}\par
}
}
{\xe \v vxlan_create_sock\:vxlan.c}
{\xe \v vxlan.c\:vxlan_create_sock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct socket* vxlan_create_sock (struct net *  {\i net}, {\b bool}  {\i ipv6}, __be16  {\i port}, u32  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   247 \{\par
  248     struct socket *sock;\par
  249     struct udp_port_cfg udp_conf;\par
  250     int err;\par
  251 \par
  252     memset(&udp_conf, 0, sizeof(udp_conf));\par
  253 \par
  254     if (ipv6) \{\par
  255         udp_conf.family = AF_INET6;\par
  256         /* The checksum flag is silently ignored but it\par
  257          * doesn't make sense here anyways because OVS enables\par
  258          * checksums on a finer granularity than per-socket.\par
  259          */\par
  260     \} else \{\par
  261         udp_conf.family = AF_INET;\par
  262         udp_conf.local_ip.s_addr = htonl(INADDR_ANY);\par
  263     \}\par
  264 \par
  265     udp_conf.local_udp_port = port;\par
  266 \par
  267     /* Open UDP socket */\par
  268     err = udp_sock_create(net, &udp_conf, &sock);\par
  269     if (err < 0)\par
  270         return ERR_PTR(err);\par
  271 \par
  272     return sock;\par
  273 \}\par
}
}
{\xe \v vxlan_del_work\:vxlan.c}
{\xe \v vxlan.c\:vxlan_del_work}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_del_work (struct work_struct *  {\i work}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   238 \{\par
  239     struct vxlan_sock *vs = container_of(work, struct vxlan_sock, del_work);\par
  240 \par
  241     udp_tunnel_sock_release(vs->sock);\par
  242     call_rcu(&vs->rcu, rcu_free_vs);\par
  243 \}\par
}
}
{\xe \v vxlan_set_owner\:vxlan.c}
{\xe \v vxlan.c\:vxlan_set_owner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_set_owner (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157     skb_orphan(skb);\par
  158     sock_hold(sk);\par
  159     skb->sk = sk;\par
  160     skb->destructor = vxlan_sock_put;\par
  161 \}\par
}
}
{\xe \v vxlan_sock_put\:vxlan.c}
{\xe \v vxlan.c\:vxlan_sock_put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_sock_put (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   150 \{\par
  151     sock_put(skb->sk);\par
  152 \}\par
}
}
{\xe \v vxlan_socket_create\:vxlan.c}
{\xe \v vxlan.c\:vxlan_socket_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vxlan_sock}* vxlan_socket_create (struct net *  {\i net}, __be16  {\i port}, {\b vxlan_rcv_t} *  {\i rcv}, void *  {\i data}, u32  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   277 \{\par
  278     struct vxlan_sock *vs;\par
  279     struct socket *sock;\par
  280     struct udp_tunnel_sock_cfg tunnel_cfg;\par
  281 \par
  282     vs = kmalloc(sizeof(*vs), GFP_KERNEL);\par
  283     if (!vs) \{\par
  284         pr_debug("memory alocation failure\\n");\par
  285         return ERR_PTR(-ENOMEM);\par
  286     \}\par
  287 \par
  288     INIT_WORK(&vs->del_work, vxlan_del_work);\par
  289 \par
  290     sock = vxlan_create_sock(net, false, port, flags);\par
  291     if (IS_ERR(sock)) \{\par
  292         kfree(vs);\par
  293         return ERR_CAST(sock);\par
  294     \}\par
  295 \par
  296     vs->sock = sock;\par
  297     vs->rcv = rcv;\par
  298     vs->data = data;\par
  299     vs->flags = (flags & VXLAN_F_RCV_FLAGS);\par
  300 \par
  301     tunnel_cfg.sk_user_data = vs;\par
  302     tunnel_cfg.encap_type = 1;\par
  303     tunnel_cfg.encap_rcv = vxlan_udp_encap_recv;\par
  304     tunnel_cfg.encap_destroy = NULL;\par
  305 \par
  306     setup_udp_tunnel_sock(net, sock, &tunnel_cfg);\par
  307 \par
  308     return vs;\par
  309 \}\par
}
}
{\xe \v vxlan_udp_encap_recv\:vxlan.c}
{\xe \v vxlan.c\:vxlan_udp_encap_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_udp_encap_recv (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    73 \{\par
   74     struct vxlan_sock *vs;\par
   75     struct vxlanhdr *vxh;\par
   76     u32 flags, vni;\par
   77     struct vxlan_metadata md = \{0\};\par
   78 \par
   79     /* Need Vxlan and inner Ethernet header to be present */\par
   80     if (!pskb_may_pull(skb, VXLAN_HLEN))\par
   81         goto error;\par
   82 \par
   83     vxh = (struct vxlanhdr *)(udp_hdr(skb) + 1);\par
   84     flags = ntohl(vxh->vx_flags);\par
   85     vni = ntohl(vxh->vx_vni);\par
   86 \par
   87     if (flags & VXLAN_HF_VNI) \{\par
   88         flags &= ~VXLAN_HF_VNI;\par
   89     \} else \{\par
   90         /* VNI flag always required to be set */\par
   91         goto bad_flags;\par
   92     \}\par
   93 \par
   94     if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))\par
   95         goto drop;\par
   96 \par
   97     vs = rcu_dereference_sk_user_data(sk);\par
   98     if (!vs)\par
   99         goto drop;\par
  100 \par
  101     /* For backwards compatibility, only allow reserved fields to be\par
  102     * used by VXLAN extensions if explicitly requested.\par
  103     */\par
  104     if ((flags & VXLAN_HF_GBP) && (vs->flags & VXLAN_F_GBP)) \{\par
  105         struct vxlanhdr_gbp *gbp;\par
  106 \par
  107         gbp = (struct vxlanhdr_gbp *)vxh;\par
  108         md.gbp = ntohs(gbp->policy_id);\par
  109 \par
  110         if (gbp->dont_learn)\par
  111             md.gbp |= VXLAN_GBP_DONT_LEARN;\par
  112 \par
  113         if (gbp->policy_applied)\par
  114             md.gbp |= VXLAN_GBP_POLICY_APPLIED;\par
  115 \par
  116         flags &= ~VXLAN_GBP_USED_BITS;\par
  117     \}\par
  118 \par
  119     if (flags || (vni & 0xff)) \{\par
  120         /* If there are any unprocessed flags remaining treat\par
  121         * this as a malformed packet. This behavior diverges from\par
  122         * VXLAN RFC (RFC7348) which stipulates that bits in reserved\par
  123         * in reserved fields are to be ignored. The approach here\par
  124         * maintains compatbility with previous stack code, and also\par
  125         * is more robust and provides a little more security in\par
  126         * adding extensions to VXLAN.\par
  127         */\par
  128 \par
  129         goto bad_flags;\par
  130     \}\par
  131 \par
  132     md.vni = vxh->vx_vni;\par
  133     vs->rcv(vs, skb, &md);\par
  134     return 0;\par
  135 \par
  136 drop:\par
  137     /* Consume bad packet */\par
  138     kfree_skb(skb);\par
  139     return 0;\par
  140 bad_flags:\par
  141     pr_debug("invalid vxlan flags=%#x vni=%#x\\n",\par
  142          ntohl(vxh->vx_flags), ntohl(vxh->vx_vni));\par
  143 \par
  144 error:\par
  145     /* Return non vxlan pkt */\par
  146     return 1;\par
  147 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/kcompat.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/kcompat.h}
{\xe \v /home/vladn/git/ovs/datapath/linux/kcompat.h}
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_ERR_CAST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_IS_ERR_OR_NULL}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_ETH_HW_ADDR_RANDOM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_ETHER_ADDR_COPY}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_VLAN_SET_ENCAP_PROTO}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_IPV4_IS_MULTICAST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_INET_GET_LOCAL_PORT_RANGE_USING_NET}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_DEV_DISABLE_LRO}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_DEV_GET_STATS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_DEV_GET_BY_INDEX_RCU}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE___SKB_GSO_SEGMENT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_CAN_CHECKSUM_PROTOCOL}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NETDEV_FEATURES_T}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_PCPU_SW_NETSTATS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NF_HOOKFN_ARG_OPS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_PRANDOM_U32}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_RCU_READ_LOCK_HELD}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_LOCKDEP_RTNL_IS_HELD}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_KFREE_SKB_LIST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_DST_ACCESSOR_FUNCS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_COPY_FROM_LINEAR_DATA_OFFSET}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_RESET_TAIL_POINTER}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_COW_HEAD}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKBUFF_HEADER_HELPERS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_ICMP6_HDR}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_WARN_LRO}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_CONSUME_SKB}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_FRAG_PAGE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_HAS_FRAG_LIST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE___SKB_FILL_PAGE_DESC}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_RESET_MAC_LEN}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_UNCLONE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_ORPHAN_FRAGS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_GET_HASH}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_CLEAR_HASH}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_ZEROCOPY}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_ENSURE_WRITABLE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_VLAN_POP}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_VLAN_PUSH}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_BOOL_TYPE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_CSUM_TYPES}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_CSUM_REPLACE4}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_CSUM_UNFOLD}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_GENL_HAS_LISTENERS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_MCGRP_OFFSET}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_PARALLEL_OPS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_GENLMSG_NEW_UNICAST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_GENL_HAS_LISTENERS_TAKES_NET}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_GENL_NOTIFY_TAKES_FAMILY}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_GRE_CISCO_REGISTER}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_IP6_FH_F_SKIP_RH}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_GET_BE16}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_PUT_BE16}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_PUT_BE32}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_PUT_BE64}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_FIND_NESTED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NLA_IS_LAST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SCTP_COMPUTE_CKSUM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_VLAN_INSERT_TAG_SET_PROTO}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE___VLAN_INSERT_TAG}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_U64_STATS_FETCH_BEGIN_IRQ}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_UDP_FLOW_SRC_PORT}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_UDP_V4_CHECK}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_UDP_SET_CSUM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_IGNORE_DF_RENAME}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_GSO_GRE_CSUM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_SKB_GSO_UDP_TUNNEL_CSUM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAVE_NET_NAME_UNKNOWN}\~ 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HAVE___SKB_FILL_PAGE_DESC\:kcompat.h}
{\xe \v kcompat.h\:HAVE___SKB_FILL_PAGE_DESC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE___SKB_FILL_PAGE_DESC\~ 1}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE___SKB_GSO_SEGMENT\:kcompat.h}
{\xe \v kcompat.h\:HAVE___SKB_GSO_SEGMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE___SKB_GSO_SEGMENT\~ 1}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE___VLAN_INSERT_TAG\:kcompat.h}
{\xe \v kcompat.h\:HAVE___VLAN_INSERT_TAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE___VLAN_INSERT_TAG\~ 1}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_BOOL_TYPE\:kcompat.h}
{\xe \v kcompat.h\:HAVE_BOOL_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_BOOL_TYPE\~ 1}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_CAN_CHECKSUM_PROTOCOL\:kcompat.h}
{\xe \v kcompat.h\:HAVE_CAN_CHECKSUM_PROTOCOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_CAN_CHECKSUM_PROTOCOL\~ 1}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_CONSUME_SKB\:kcompat.h}
{\xe \v kcompat.h\:HAVE_CONSUME_SKB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_CONSUME_SKB\~ 1}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_CSUM_REPLACE4\:kcompat.h}
{\xe \v kcompat.h\:HAVE_CSUM_REPLACE4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_CSUM_REPLACE4\~ 1}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_CSUM_TYPES\:kcompat.h}
{\xe \v kcompat.h\:HAVE_CSUM_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_CSUM_TYPES\~ 1}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_CSUM_UNFOLD\:kcompat.h}
{\xe \v kcompat.h\:HAVE_CSUM_UNFOLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_CSUM_UNFOLD\~ 1}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_DEV_DISABLE_LRO\:kcompat.h}
{\xe \v kcompat.h\:HAVE_DEV_DISABLE_LRO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_DEV_DISABLE_LRO\~ 1}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_DEV_GET_BY_INDEX_RCU\:kcompat.h}
{\xe \v kcompat.h\:HAVE_DEV_GET_BY_INDEX_RCU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_DEV_GET_BY_INDEX_RCU\~ 1}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_DEV_GET_STATS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_DEV_GET_STATS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_DEV_GET_STATS\~ 1}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_ERR_CAST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_ERR_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_ERR_CAST\~ 1}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_ETH_HW_ADDR_RANDOM\:kcompat.h}
{\xe \v kcompat.h\:HAVE_ETH_HW_ADDR_RANDOM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_ETH_HW_ADDR_RANDOM\~ 1}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_ETHER_ADDR_COPY\:kcompat.h}
{\xe \v kcompat.h\:HAVE_ETHER_ADDR_COPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_ETHER_ADDR_COPY\~ 1}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_GENL_HAS_LISTENERS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_GENL_HAS_LISTENERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_GENL_HAS_LISTENERS\~ 1}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_GENL_HAS_LISTENERS_TAKES_NET\:kcompat.h}
{\xe \v kcompat.h\:HAVE_GENL_HAS_LISTENERS_TAKES_NET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_GENL_HAS_LISTENERS_TAKES_NET\~ 1}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_GENL_NOTIFY_TAKES_FAMILY\:kcompat.h}
{\xe \v kcompat.h\:HAVE_GENL_NOTIFY_TAKES_FAMILY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_GENL_NOTIFY_TAKES_FAMILY\~ 1}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_GENLMSG_NEW_UNICAST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_GENLMSG_NEW_UNICAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_GENLMSG_NEW_UNICAST\~ 1}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_GRE_CISCO_REGISTER\:kcompat.h}
{\xe \v kcompat.h\:HAVE_GRE_CISCO_REGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_GRE_CISCO_REGISTER\~ 1}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_ICMP6_HDR\:kcompat.h}
{\xe \v kcompat.h\:HAVE_ICMP6_HDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_ICMP6_HDR\~ 1}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_IGNORE_DF_RENAME\:kcompat.h}
{\xe \v kcompat.h\:HAVE_IGNORE_DF_RENAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_IGNORE_DF_RENAME\~ 1}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_INET_GET_LOCAL_PORT_RANGE_USING_NET\:kcompat.h}
{\xe \v kcompat.h\:HAVE_INET_GET_LOCAL_PORT_RANGE_USING_NET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_INET_GET_LOCAL_PORT_RANGE_USING_NET\~ 1}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_IP6_FH_F_SKIP_RH\:kcompat.h}
{\xe \v kcompat.h\:HAVE_IP6_FH_F_SKIP_RH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_IP6_FH_F_SKIP_RH\~ 1}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_IPV4_IS_MULTICAST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_IPV4_IS_MULTICAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_IPV4_IS_MULTICAST\~ 1}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_IS_ERR_OR_NULL\:kcompat.h}
{\xe \v kcompat.h\:HAVE_IS_ERR_OR_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_IS_ERR_OR_NULL\~ 1}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_KFREE_SKB_LIST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_KFREE_SKB_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_KFREE_SKB_LIST\~ 1}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_LOCKDEP_RTNL_IS_HELD\:kcompat.h}
{\xe \v kcompat.h\:HAVE_LOCKDEP_RTNL_IS_HELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_LOCKDEP_RTNL_IS_HELD\~ 1}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_MCGRP_OFFSET\:kcompat.h}
{\xe \v kcompat.h\:HAVE_MCGRP_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_MCGRP_OFFSET\~ 1}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NET_NAME_UNKNOWN\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NET_NAME_UNKNOWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NET_NAME_UNKNOWN\~ 1}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NETDEV_FEATURES_T\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NETDEV_FEATURES_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NETDEV_FEATURES_T\~ 1}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NF_HOOKFN_ARG_OPS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NF_HOOKFN_ARG_OPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NF_HOOKFN_ARG_OPS\~ 1}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_FIND_NESTED\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_FIND_NESTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_FIND_NESTED\~ 1}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_GET_BE16\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_GET_BE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_GET_BE16\~ 1}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_IS_LAST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_IS_LAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_IS_LAST\~ 1}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_PUT_BE16\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_PUT_BE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_PUT_BE16\~ 1}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_PUT_BE32\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_PUT_BE32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_PUT_BE32\~ 1}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_NLA_PUT_BE64\:kcompat.h}
{\xe \v kcompat.h\:HAVE_NLA_PUT_BE64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_NLA_PUT_BE64\~ 1}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_PARALLEL_OPS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_PARALLEL_OPS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_PARALLEL_OPS\~ 1}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_PCPU_SW_NETSTATS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_PCPU_SW_NETSTATS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_PCPU_SW_NETSTATS\~ 1}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_PRANDOM_U32\:kcompat.h}
{\xe \v kcompat.h\:HAVE_PRANDOM_U32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_PRANDOM_U32\~ 1}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_RCU_READ_LOCK_HELD\:kcompat.h}
{\xe \v kcompat.h\:HAVE_RCU_READ_LOCK_HELD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_RCU_READ_LOCK_HELD\~ 1}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SCTP_COMPUTE_CKSUM\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SCTP_COMPUTE_CKSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SCTP_COMPUTE_CKSUM\~ 1}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_CLEAR_HASH\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_CLEAR_HASH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_CLEAR_HASH\~ 1}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_COPY_FROM_LINEAR_DATA_OFFSET\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_COPY_FROM_LINEAR_DATA_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_COPY_FROM_LINEAR_DATA_OFFSET\~ 1}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_COW_HEAD\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_COW_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_COW_HEAD\~ 1}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_DST_ACCESSOR_FUNCS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_DST_ACCESSOR_FUNCS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_DST_ACCESSOR_FUNCS\~ 1}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_ENSURE_WRITABLE\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_ENSURE_WRITABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_ENSURE_WRITABLE\~ 1}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_FRAG_PAGE\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_FRAG_PAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_FRAG_PAGE\~ 1}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_GET_HASH\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_GET_HASH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_GET_HASH\~ 1}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_GSO_GRE_CSUM\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_GSO_GRE_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_GSO_GRE_CSUM\~ 1}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_GSO_UDP_TUNNEL_CSUM\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_GSO_UDP_TUNNEL_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_GSO_UDP_TUNNEL_CSUM\~ 1}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_HAS_FRAG_LIST\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_HAS_FRAG_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_HAS_FRAG_LIST\~ 1}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_ORPHAN_FRAGS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_ORPHAN_FRAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_ORPHAN_FRAGS\~ 1}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_RESET_MAC_LEN\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_RESET_MAC_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_RESET_MAC_LEN\~ 1}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_RESET_TAIL_POINTER\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_RESET_TAIL_POINTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_RESET_TAIL_POINTER\~ 1}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_UNCLONE\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_UNCLONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_UNCLONE\~ 1}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_VLAN_POP\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_VLAN_POP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_VLAN_POP\~ 1}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_VLAN_PUSH\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_VLAN_PUSH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_VLAN_PUSH\~ 1}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_WARN_LRO\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_WARN_LRO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_WARN_LRO\~ 1}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKB_ZEROCOPY\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKB_ZEROCOPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKB_ZEROCOPY\~ 1}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_SKBUFF_HEADER_HELPERS\:kcompat.h}
{\xe \v kcompat.h\:HAVE_SKBUFF_HEADER_HELPERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_SKBUFF_HEADER_HELPERS\~ 1}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_U64_STATS_FETCH_BEGIN_IRQ\:kcompat.h}
{\xe \v kcompat.h\:HAVE_U64_STATS_FETCH_BEGIN_IRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_U64_STATS_FETCH_BEGIN_IRQ\~ 1}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_UDP_FLOW_SRC_PORT\:kcompat.h}
{\xe \v kcompat.h\:HAVE_UDP_FLOW_SRC_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_UDP_FLOW_SRC_PORT\~ 1}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_UDP_SET_CSUM\:kcompat.h}
{\xe \v kcompat.h\:HAVE_UDP_SET_CSUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_UDP_SET_CSUM\~ 1}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_UDP_V4_CHECK\:kcompat.h}
{\xe \v kcompat.h\:HAVE_UDP_V4_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_UDP_V4_CHECK\~ 1}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_VLAN_INSERT_TAG_SET_PROTO\:kcompat.h}
{\xe \v kcompat.h\:HAVE_VLAN_INSERT_TAG_SET_PROTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_VLAN_INSERT_TAG_SET_PROTO\~ 1}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAVE_VLAN_SET_ENCAP_PROTO\:kcompat.h}
{\xe \v kcompat.h\:HAVE_VLAN_SET_ENCAP_PROTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAVE_VLAN_SET_ENCAP_PROTO\~ 1}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/openvswitch.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/openvswitch.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/openvswitch.mod.c}
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for openvswitch.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "openvswitch_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"EA4DBC7987F183433ED0F79")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:openvswitch.mod.c}
{\xe \v openvswitch.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:openvswitch.mod.c}
{\xe \v openvswitch.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:openvswitch.mod.c}
{\xe \v openvswitch.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:openvswitch.mod.c}
{\xe \v openvswitch.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:openvswitch.mod.c}
{\xe \v openvswitch.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "EA4DBC7987F183433ED0F79" )}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-geneve.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-geneve.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-geneve.c}
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <net/geneve.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-geneve.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-geneve_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b geneve_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b geneve_port} - Keeps track of open UDP ports : The socket created for this port number. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_geneve_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (geneve_ports)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b geneve_port} * {\b geneve_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genevehdr * {\b geneve_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tunnel_id_to_vni} (__be64 {\b tun_id}, __u8 *vni)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be64 {\b vni_to_tunnel_id} (const __u8 *vni)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b geneve_rcv} (struct geneve_sock *gs, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b geneve_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b geneve_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_tnl_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b geneve_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_geneve_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_geneve_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_geneve_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_geneve_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: Geneve swiching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-5")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v geneve_get_egress_tun_info\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   239 \{\par
  240     struct geneve_port *geneve_port = geneve_vport(vport);\par
  241     struct net *net = ovs_dp_get_net(vport->dp);\par
  242     __be16 dport = inet_sport(geneve_port->gs->sock->sk);\par
  243     __be16 sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\par
  244 \par
  245     /* Get tp_src and tp_dst, refert to geneve_build_header().\par
  246      */\par
  247     return ovs_tunnel_get_egress_info(egress_tun_info,\par
  248                       ovs_dp_get_net(vport->dp),\par
  249                       OVS_CB(skb)->egress_tun_info,\par
  250                       IPPROTO_UDP, skb->mark, sport, dport);\par
  251 \}\par
}
}
{\xe \v geneve_get_name\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* geneve_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232     struct geneve_port *geneve_port = geneve_vport(vport);\par
  233 \par
  234     return geneve_port->name;\par
  235 \}\par
}
}
{\xe \v geneve_get_options\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108 \{\par
  109     struct geneve_port *geneve_port = geneve_vport(vport);\par
  110     __be16 dst_port = inet_sport(geneve_port->gs->sock->sk);\par
  111 \par
  112     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\par
  113         return -EMSGSIZE;\par
  114     return 0;\par
  115 \}\par
}
}
{\xe \v geneve_hdr\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct genevehdr* geneve_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     return (struct genevehdr *)(udp_hdr(skb) + 1);\par
   52 \}\par
}
}
{\xe \v geneve_rcv\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void geneve_rcv (struct geneve_sock *  {\i gs}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82     struct vport *vport = gs->rcv_data;\par
   83     struct genevehdr *geneveh = geneve_hdr(skb);\par
   84     int opts_len;\par
   85     struct ovs_tunnel_info tun_info;\par
   86     __be64 key;\par
   87     __be16 flags;\par
   88 \par
   89     opts_len = geneveh->opt_len * 4;\par
   90 \par
   91     flags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |\par
   92         (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0) |\par
   93         (geneveh->oam ? TUNNEL_OAM : 0) |\par
   94         (geneveh->critical ? TUNNEL_CRIT_OPT : 0);\par
   95 \par
   96     key = vni_to_tunnel_id(geneveh->vni);\par
   97 \par
   98     ovs_flow_tun_info_init(&tun_info, ip_hdr(skb),\par
   99                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
  100                    key, flags,\par
  101                    geneveh->options, opts_len);\par
  102 \par
  103     ovs_vport_receive(vport, skb, &tun_info);\par
  104 \}\par
}
}
{\xe \v geneve_tnl_create\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* geneve_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   127 \{\par
  128     struct net *net = ovs_dp_get_net(parms->dp);\par
  129     struct nlattr *options = parms->options;\par
  130     struct geneve_port *geneve_port;\par
  131     struct geneve_sock *gs;\par
  132     struct vport *vport;\par
  133     struct nlattr *a;\par
  134     int err;\par
  135     u16 dst_port;\par
  136 \par
  137     if (!options) \{\par
  138         err = -EINVAL;\par
  139         goto error;\par
  140     \}\par
  141 \par
  142     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  143     if (a && nla_len(a) == sizeof(u16)) \{\par
  144         dst_port = nla_get_u16(a);\par
  145     \} else \{\par
  146         /* Require destination port from userspace. */\par
  147         err = -EINVAL;\par
  148         goto error;\par
  149     \}\par
  150 \par
  151     vport = ovs_vport_alloc(sizeof(struct geneve_port),\par
  152                 &ovs_geneve_vport_ops, parms);\par
  153     if (IS_ERR(vport))\par
  154         return vport;\par
  155 \par
  156     geneve_port = geneve_vport(vport);\par
  157     strncpy(geneve_port->name, parms->name, IFNAMSIZ);\par
  158 \par
  159     gs = geneve_sock_add(net, htons(dst_port), geneve_rcv, vport, true, 0);\par
  160     if (IS_ERR(gs)) \{\par
  161         ovs_vport_free(vport);\par
  162         return (void *)gs;\par
  163     \}\par
  164     geneve_port->gs = gs;\par
  165 \par
  166     return vport;\par
  167 error:\par
  168     return ERR_PTR(err);\par
  169 \}\par
}
}
{\xe \v geneve_tnl_destroy\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void geneve_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   118 \{\par
  119     struct geneve_port *geneve_port = geneve_vport(vport);\par
  120 \par
  121     geneve_sock_release(geneve_port->gs);\par
  122 \par
  123     ovs_vport_deferred_free(vport);\par
  124 \}\par
}
}
{\xe \v geneve_tnl_send\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_tnl_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_tnl_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   172 \{\par
  173     const struct ovs_key_ipv4_tunnel *tun_key;\par
  174     struct ovs_tunnel_info *tun_info;\par
  175     struct net *net = ovs_dp_get_net(vport->dp);\par
  176     struct geneve_port *geneve_port = geneve_vport(vport);\par
  177     __be16 dport = inet_sport(geneve_port->gs->sock->sk);\par
  178     __be16 sport;\par
  179     __be32 saddr;\par
  180     struct rtable *rt;\par
  181     u8 vni[3], opts_len, *opts;\par
  182     __be16 df;\par
  183     int err;\par
  184 \par
  185     tun_info = OVS_CB(skb)->egress_tun_info;\par
  186     if (unlikely(!tun_info)) \{\par
  187         err = -EINVAL;\par
  188         goto error;\par
  189     \}\par
  190 \par
  191     tun_key = &tun_info->tunnel;\par
  192 \par
  193     saddr = tun_key->ipv4_src;\par
  194     rt = find_route(ovs_dp_get_net(vport->dp),\par
  195             &saddr, tun_key->ipv4_dst,\par
  196             IPPROTO_UDP, tun_key->ipv4_tos,\par
  197             skb->mark);\par
  198     if (IS_ERR(rt)) \{\par
  199         err = PTR_ERR(rt);\par
  200         goto error;\par
  201     \}\par
  202 \par
  203     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  204     sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\par
  205     tunnel_id_to_vni(tun_key->tun_id, vni);\par
  206     skb->ignore_df = 1;\par
  207 \par
  208     if (tun_key->tun_flags & TUNNEL_GENEVE_OPT) \{\par
  209         opts = (u8 *)tun_info->options;\par
  210         opts_len = tun_info->options_len;\par
  211     \} else \{\par
  212         opts = NULL;\par
  213         opts_len = 0;\par
  214     \}\par
  215 \par
  216     err = geneve_xmit_skb(geneve_port->gs, rt, skb, saddr,\par
  217                   tun_key->ipv4_dst, tun_key->ipv4_tos,\par
  218                   tun_key->ipv4_ttl, df, sport, dport,\par
  219                   tun_key->tun_flags, vni, opts_len, opts,\par
  220                   !!(tun_key->tun_flags & TUNNEL_CSUM), false);\par
  221     if (err < 0)\par
  222         ip_rt_put(rt);\par
  223     return err;\par
  224 \par
  225 error:\par
  226     kfree_skb(skb);\par
  227     return err;\par
  228 \}\par
}
}
{\xe \v geneve_vport\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:geneve_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b geneve_port}* geneve_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    45 \{\par
   46     return vport_priv(vport);\par
   47 \}\par
}
}
{\xe \v LIST_HEAD\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (geneve_ports ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_ALIAS\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-5" )}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: Geneve swiching port" )}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_geneve_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_geneve_tnl_init} )}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_geneve_tnl_exit\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:ovs_geneve_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_geneve_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270 \{\par
  271     ovs_vport_ops_unregister(&ovs_geneve_vport_ops);\par
  272 \}\par
}
}
{\xe \v ovs_geneve_tnl_init\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:ovs_geneve_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_geneve_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   265 \{\par
  266     return ovs_vport_ops_register(&ovs_geneve_vport_ops);\par
  267 \}\par
}
}
{\xe \v tunnel_id_to_vni\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:tunnel_id_to_vni}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tunnel_id_to_vni (__be64  {\i tun_id}, __u8 *  {\i vni}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56 \{\par
   57 #ifdef __BIG_ENDIAN\par
   58     vni[0] = (__force __u8)(tun_id >> 16);\par
   59     vni[1] = (__force __u8)(tun_id >> 8);\par
   60     vni[2] = (__force __u8)tun_id;\par
   61 #else\par
   62     vni[0] = (__force __u8)((__force u64)tun_id >> 40);\par
   63     vni[1] = (__force __u8)((__force u64)tun_id >> 48);\par
   64     vni[2] = (__force __u8)((__force u64)tun_id >> 56);\par
   65 #endif\par
   66 \}\par
}
}
{\xe \v vni_to_tunnel_id\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:vni_to_tunnel_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be64 vni_to_tunnel_id (const __u8 *  {\i vni}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71 #ifdef __BIG_ENDIAN\par
   72     return (vni[0] << 16) | (vni[1] << 8) | vni[2];\par
   73 #else\par
   74     return (__force __be64)(((__force u64)vni[0] << 40) |\par
   75                 ((__force u64)vni[1] << 48) |\par
   76                 ((__force u64)vni[2] << 56));\par
   77 #endif\par
   78 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_geneve_vport_ops\:linux/vport-geneve.c}
{\xe \v linux/vport-geneve.c\:ovs_geneve_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_geneve_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_GENEVE,\par
    .create         = geneve_tnl_create,\par
    .destroy        = geneve_tnl_destroy,\par
    .get_name       = geneve_get_name,\par
    .get_options        = geneve_get_options,\par
    .send           = geneve_tnl_send,\par
    .get_egress_tun_info    = geneve_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-geneve.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-geneve.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-geneve.c}
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <net/geneve.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-geneve.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-geneve_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b geneve_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b geneve_port} - Keeps track of open UDP ports : The socket created for this port number. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_geneve_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (geneve_ports)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b geneve_port} * {\b geneve_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct genevehdr * {\b geneve_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tunnel_id_to_vni} (__be64 {\b tun_id}, __u8 *vni)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be64 {\b vni_to_tunnel_id} (const __u8 *vni)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b geneve_rcv} (struct geneve_sock *gs, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b geneve_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b geneve_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_tnl_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b geneve_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b geneve_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_geneve_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_geneve_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_geneve_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_geneve_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: Geneve swiching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-5")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:vport-geneve.c}
{\xe \v vport-geneve.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v geneve_get_egress_tun_info\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   239 \{\par
  240     struct geneve_port *geneve_port = geneve_vport(vport);\par
  241     struct net *net = ovs_dp_get_net(vport->dp);\par
  242     __be16 dport = inet_sport(geneve_port->gs->sock->sk);\par
  243     __be16 sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\par
  244 \par
  245     /* Get tp_src and tp_dst, refert to geneve_build_header().\par
  246      */\par
  247     return ovs_tunnel_get_egress_info(egress_tun_info,\par
  248                       ovs_dp_get_net(vport->dp),\par
  249                       OVS_CB(skb)->egress_tun_info,\par
  250                       IPPROTO_UDP, skb->mark, sport, dport);\par
  251 \}\par
}
}
{\xe \v geneve_get_name\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* geneve_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232     struct geneve_port *geneve_port = geneve_vport(vport);\par
  233 \par
  234     return geneve_port->name;\par
  235 \}\par
}
}
{\xe \v geneve_get_options\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108 \{\par
  109     struct geneve_port *geneve_port = geneve_vport(vport);\par
  110     __be16 dst_port = inet_sport(geneve_port->gs->sock->sk);\par
  111 \par
  112     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\par
  113         return -EMSGSIZE;\par
  114     return 0;\par
  115 \}\par
}
}
{\xe \v geneve_hdr\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct genevehdr* geneve_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     return (struct genevehdr *)(udp_hdr(skb) + 1);\par
   52 \}\par
}
}
{\xe \v geneve_rcv\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void geneve_rcv (struct geneve_sock *  {\i gs}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82     struct vport *vport = gs->rcv_data;\par
   83     struct genevehdr *geneveh = geneve_hdr(skb);\par
   84     int opts_len;\par
   85     struct ovs_tunnel_info tun_info;\par
   86     __be64 key;\par
   87     __be16 flags;\par
   88 \par
   89     opts_len = geneveh->opt_len * 4;\par
   90 \par
   91     flags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |\par
   92         (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0) |\par
   93         (geneveh->oam ? TUNNEL_OAM : 0) |\par
   94         (geneveh->critical ? TUNNEL_CRIT_OPT : 0);\par
   95 \par
   96     key = vni_to_tunnel_id(geneveh->vni);\par
   97 \par
   98     ovs_flow_tun_info_init(&tun_info, ip_hdr(skb),\par
   99                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
  100                    key, flags,\par
  101                    geneveh->options, opts_len);\par
  102 \par
  103     ovs_vport_receive(vport, skb, &tun_info);\par
  104 \}\par
}
}
{\xe \v geneve_tnl_create\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* geneve_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   127 \{\par
  128     struct net *net = ovs_dp_get_net(parms->dp);\par
  129     struct nlattr *options = parms->options;\par
  130     struct geneve_port *geneve_port;\par
  131     struct geneve_sock *gs;\par
  132     struct vport *vport;\par
  133     struct nlattr *a;\par
  134     int err;\par
  135     u16 dst_port;\par
  136 \par
  137     if (!options) \{\par
  138         err = -EINVAL;\par
  139         goto error;\par
  140     \}\par
  141 \par
  142     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  143     if (a && nla_len(a) == sizeof(u16)) \{\par
  144         dst_port = nla_get_u16(a);\par
  145     \} else \{\par
  146         /* Require destination port from userspace. */\par
  147         err = -EINVAL;\par
  148         goto error;\par
  149     \}\par
  150 \par
  151     vport = ovs_vport_alloc(sizeof(struct geneve_port),\par
  152                 &ovs_geneve_vport_ops, parms);\par
  153     if (IS_ERR(vport))\par
  154         return vport;\par
  155 \par
  156     geneve_port = geneve_vport(vport);\par
  157     strncpy(geneve_port->name, parms->name, IFNAMSIZ);\par
  158 \par
  159     gs = geneve_sock_add(net, htons(dst_port), geneve_rcv, vport, true, 0);\par
  160     if (IS_ERR(gs)) \{\par
  161         ovs_vport_free(vport);\par
  162         return (void *)gs;\par
  163     \}\par
  164     geneve_port->gs = gs;\par
  165 \par
  166     return vport;\par
  167 error:\par
  168     return ERR_PTR(err);\par
  169 \}\par
}
}
{\xe \v geneve_tnl_destroy\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void geneve_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   118 \{\par
  119     struct geneve_port *geneve_port = geneve_vport(vport);\par
  120 \par
  121     geneve_sock_release(geneve_port->gs);\par
  122 \par
  123     ovs_vport_deferred_free(vport);\par
  124 \}\par
}
}
{\xe \v geneve_tnl_send\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_tnl_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int geneve_tnl_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   172 \{\par
  173     const struct ovs_key_ipv4_tunnel *tun_key;\par
  174     struct ovs_tunnel_info *tun_info;\par
  175     struct net *net = ovs_dp_get_net(vport->dp);\par
  176     struct geneve_port *geneve_port = geneve_vport(vport);\par
  177     __be16 dport = inet_sport(geneve_port->gs->sock->sk);\par
  178     __be16 sport;\par
  179     __be32 saddr;\par
  180     struct rtable *rt;\par
  181     u8 vni[3], opts_len, *opts;\par
  182     __be16 df;\par
  183     int err;\par
  184 \par
  185     tun_info = OVS_CB(skb)->egress_tun_info;\par
  186     if (unlikely(!tun_info)) \{\par
  187         err = -EINVAL;\par
  188         goto error;\par
  189     \}\par
  190 \par
  191     tun_key = &tun_info->tunnel;\par
  192 \par
  193     saddr = tun_key->ipv4_src;\par
  194     rt = find_route(ovs_dp_get_net(vport->dp),\par
  195             &saddr, tun_key->ipv4_dst,\par
  196             IPPROTO_UDP, tun_key->ipv4_tos,\par
  197             skb->mark);\par
  198     if (IS_ERR(rt)) \{\par
  199         err = PTR_ERR(rt);\par
  200         goto error;\par
  201     \}\par
  202 \par
  203     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  204     sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\par
  205     tunnel_id_to_vni(tun_key->tun_id, vni);\par
  206     skb->ignore_df = 1;\par
  207 \par
  208     if (tun_key->tun_flags & TUNNEL_GENEVE_OPT) \{\par
  209         opts = (u8 *)tun_info->options;\par
  210         opts_len = tun_info->options_len;\par
  211     \} else \{\par
  212         opts = NULL;\par
  213         opts_len = 0;\par
  214     \}\par
  215 \par
  216     err = geneve_xmit_skb(geneve_port->gs, rt, skb, saddr,\par
  217                   tun_key->ipv4_dst, tun_key->ipv4_tos,\par
  218                   tun_key->ipv4_ttl, df, sport, dport,\par
  219                   tun_key->tun_flags, vni, opts_len, opts,\par
  220                   !!(tun_key->tun_flags & TUNNEL_CSUM), false);\par
  221     if (err < 0)\par
  222         ip_rt_put(rt);\par
  223     return err;\par
  224 \par
  225 error:\par
  226     kfree_skb(skb);\par
  227     return err;\par
  228 \}\par
}
}
{\xe \v geneve_vport\:vport-geneve.c}
{\xe \v vport-geneve.c\:geneve_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b geneve_port}* geneve_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    45 \{\par
   46     return vport_priv(vport);\par
   47 \}\par
}
}
{\xe \v LIST_HEAD\:vport-geneve.c}
{\xe \v vport-geneve.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (geneve_ports ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_ALIAS\:vport-geneve.c}
{\xe \v vport-geneve.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-5" )}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:vport-geneve.c}
{\xe \v vport-geneve.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: Geneve swiching port" )}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:vport-geneve.c}
{\xe \v vport-geneve.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_geneve_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:vport-geneve.c}
{\xe \v vport-geneve.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_geneve_tnl_init} )}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:vport-geneve.c}
{\xe \v vport-geneve.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_geneve_tnl_exit\:vport-geneve.c}
{\xe \v vport-geneve.c\:ovs_geneve_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_geneve_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270 \{\par
  271     ovs_vport_ops_unregister(&ovs_geneve_vport_ops);\par
  272 \}\par
}
}
{\xe \v ovs_geneve_tnl_init\:vport-geneve.c}
{\xe \v vport-geneve.c\:ovs_geneve_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_geneve_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   265 \{\par
  266     return ovs_vport_ops_register(&ovs_geneve_vport_ops);\par
  267 \}\par
}
}
{\xe \v tunnel_id_to_vni\:vport-geneve.c}
{\xe \v vport-geneve.c\:tunnel_id_to_vni}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tunnel_id_to_vni (__be64  {\i tun_id}, __u8 *  {\i vni}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56 \{\par
   57 #ifdef __BIG_ENDIAN\par
   58     vni[0] = (__force __u8)(tun_id >> 16);\par
   59     vni[1] = (__force __u8)(tun_id >> 8);\par
   60     vni[2] = (__force __u8)tun_id;\par
   61 #else\par
   62     vni[0] = (__force __u8)((__force u64)tun_id >> 40);\par
   63     vni[1] = (__force __u8)((__force u64)tun_id >> 48);\par
   64     vni[2] = (__force __u8)((__force u64)tun_id >> 56);\par
   65 #endif\par
   66 \}\par
}
}
{\xe \v vni_to_tunnel_id\:vport-geneve.c}
{\xe \v vport-geneve.c\:vni_to_tunnel_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be64 vni_to_tunnel_id (const __u8 *  {\i vni}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71 #ifdef __BIG_ENDIAN\par
   72     return (vni[0] << 16) | (vni[1] << 8) | vni[2];\par
   73 #else\par
   74     return (__force __be64)(((__force u64)vni[0] << 40) |\par
   75                 ((__force u64)vni[1] << 48) |\par
   76                 ((__force u64)vni[2] << 56));\par
   77 #endif\par
   78 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_geneve_vport_ops\:vport-geneve.c}
{\xe \v vport-geneve.c\:ovs_geneve_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_geneve_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_GENEVE,\par
    .create         = geneve_tnl_create,\par
    .destroy        = geneve_tnl_destroy,\par
    .get_name       = geneve_get_name,\par
    .get_options        = geneve_get_options,\par
    .send           = geneve_tnl_send,\par
    .get_egress_tun_info    = geneve_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-geneve.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-geneve.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-geneve.mod.c}
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-geneve.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-geneve_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"3762CFBD2F1BF6C5CBAB244")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:vport-geneve.mod.c}
{\xe \v vport-geneve.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-geneve.mod.c}
{\xe \v vport-geneve.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-geneve.mod.c}
{\xe \v vport-geneve.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-geneve.mod.c}
{\xe \v vport-geneve.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-geneve.mod.c}
{\xe \v vport-geneve.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "3762CFBD2F1BF6C5CBAB244" )}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-gre.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-gre.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-gre.c}
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kconfig.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-gre.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-gre_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-gre.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-gre.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-gre.c}
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kconfig.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-gre.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-gre_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-gre.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-gre.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-gre.mod.c}
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-gre.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-gre_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"BE7AFAE9E43A0368BB55878")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:vport-gre.mod.c}
{\xe \v vport-gre.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-gre.mod.c}
{\xe \v vport-gre.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-gre.mod.c}
{\xe \v vport-gre.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-gre.mod.c}
{\xe \v vport-gre.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-gre.mod.c}
{\xe \v vport-gre.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "BE7AFAE9E43A0368BB55878" )}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-internal_dev.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-internal_dev.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-internal_dev.c}
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/hardirq.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <linux/netdev_features.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/dst.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-internal_dev.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-internal__dev_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b internal_dev}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b internal_dev} * {\b internal_dev_priv} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtnl_link_stats64 * {\b internal_dev_get_stats} (struct net_device *netdev, struct rtnl_link_stats64 *stats)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_xmit} (struct sk_buff *skb, struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_open} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_stop} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_getinfo} (struct net_device *netdev, struct ethtool_drvinfo *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_change_mtu} (struct net_device *netdev, int new_mtu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_destructor} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b do_setup} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b internal_dev_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_recv} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_is_internal_dev} (const struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_internal_dev_get_vport} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_internal_dev_rtnl_link_register} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_internal_dev_rtnl_link_unregister} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_internal_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct ethtool_ops {\b internal_dev_ethtool_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct net_device_ops {\b internal_dev_netdev_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtnl_link_ops internal_dev_link_ops {\b __read_mostly}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v do_setup\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:do_setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void do_setup (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154     ether_setup(netdev);\par
  155 \par
  156     netdev->netdev_ops = &internal_dev_netdev_ops;\par
  157 \par
  158     netdev->priv_flags &= ~IFF_TX_SKB_SHARING;\par
  159     netdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\par
  160     netdev->destructor = internal_dev_destructor;\par
  161     netdev->ethtool_ops = &internal_dev_ethtool_ops;\par
  162     netdev->rtnl_link_ops = &internal_dev_link_ops;\par
  163     netdev->tx_queue_len = 0;\par
  164 \par
  165     netdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |\par
  166                NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |\par
  167                NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL;\par
  168 \par
  169     netdev->vlan_features = netdev->features;\par
  170     netdev->features |= NETIF_F_HW_VLAN_CTAG_TX;\par
  171 \par
  172 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)\par
  173     netdev->hw_features = netdev->features & ~NETIF_F_LLTX;\par
  174 #endif\par
  175 \par
  176 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)\par
  177     netdev->hw_enc_features = netdev->features;\par
  178 #endif\par
  179 \par
  180     eth_hw_addr_random(netdev);\par
  181 \}\par
}
}
{\xe \v internal_dev_change_mtu\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_change_mtu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_change_mtu (struct net_device *  {\i netdev}, int  {\i new_mtu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     if (new_mtu < 68)\par
  121         return -EINVAL;\par
  122 \par
  123     netdev->mtu = new_mtu;\par
  124     return 0;\par
  125 \}\par
}
}
{\xe \v internal_dev_create\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* internal_dev_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   184 \{\par
  185     struct vport *vport;\par
  186     struct netdev_vport *netdev_vport;\par
  187     struct internal_dev *internal_dev;\par
  188     int err;\par
  189 \par
  190     vport = ovs_vport_alloc(sizeof(struct netdev_vport),\par
  191                 &ovs_internal_vport_ops, parms);\par
  192     if (IS_ERR(vport)) \{\par
  193         err = PTR_ERR(vport);\par
  194         goto error;\par
  195     \}\par
  196 \par
  197     netdev_vport = netdev_vport_priv(vport);\par
  198 \par
  199     netdev_vport->dev = alloc_netdev(sizeof(struct internal_dev),\par
  200                      parms->name, NET_NAME_UNKNOWN, do_setup);\par
  201     if (!netdev_vport->dev) \{\par
  202         err = -ENOMEM;\par
  203         goto error_free_vport;\par
  204     \}\par
  205 \par
  206     dev_net_set(netdev_vport->dev, ovs_dp_get_net(vport->dp));\par
  207     internal_dev = internal_dev_priv(netdev_vport->dev);\par
  208     internal_dev->vport = vport;\par
  209 \par
  210     /* Restrict bridge port to current netns. */\par
  211     if (vport->port_no == OVSP_LOCAL)\par
  212         netdev_vport->dev->features |= NETIF_F_NETNS_LOCAL;\par
  213 \par
  214     rtnl_lock();\par
  215     err = register_netdevice(netdev_vport->dev);\par
  216     if (err)\par
  217         goto error_free_netdev;\par
  218 \par
  219     dev_set_promiscuity(netdev_vport->dev, 1);\par
  220     rtnl_unlock();\par
  221     netif_start_queue(netdev_vport->dev);\par
  222 \par
  223     return vport;\par
  224 \par
  225 error_free_netdev:\par
  226     rtnl_unlock();\par
  227     free_netdev(netdev_vport->dev);\par
  228 error_free_vport:\par
  229     ovs_vport_free(vport);\par
  230 error:\par
  231     return ERR_PTR(err);\par
  232 \}\par
}
}
{\xe \v internal_dev_destroy\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   235 \{\par
  236     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  237 \par
  238     netif_stop_queue(netdev_vport->dev);\par
  239     rtnl_lock();\par
  240     dev_set_promiscuity(netdev_vport->dev, -1);\par
  241 \par
  242     /* unregister_netdevice() waits for an RCU grace period. */\par
  243     unregister_netdevice(netdev_vport->dev);\par
  244 \par
  245     rtnl_unlock();\par
  246 \}\par
}
}
{\xe \v internal_dev_destructor\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_destructor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_destructor (struct net_device *  {\i dev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   128 \{\par
  129     struct vport *vport = ovs_internal_dev_get_vport(dev);\par
  130 \par
  131     ovs_vport_free(vport);\par
  132     free_netdev(dev);\par
  133 \}\par
}
}
{\xe \v internal_dev_get_stats\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_get_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct rtnl_link_stats64* internal_dev_get_stats (struct net_device *  {\i netdev}, struct rtnl_link_stats64 *  {\i stats}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{\par
   53 #else\par
   54 static struct net_device_stats *internal_dev_sys_stats(struct net_device *netdev)\par
   55 \{\par
   56     struct net_device_stats *stats = &netdev->stats;\par
   57 #endif\par
   58     struct vport *vport = ovs_internal_dev_get_vport(netdev);\par
   59     struct ovs_vport_stats vport_stats;\par
   60 \par
   61     ovs_vport_get_stats(vport, &vport_stats);\par
   62 \par
   63     /* The tx and rx stats need to be swapped because the\par
   64      * switch and host OS have opposite perspectives.\par
   65      */\par
   66     stats->rx_packets   = vport_stats.tx_packets;\par
   67     stats->tx_packets   = vport_stats.rx_packets;\par
   68     stats->rx_bytes     = vport_stats.tx_bytes;\par
   69     stats->tx_bytes     = vport_stats.rx_bytes;\par
   70     stats->rx_errors    = vport_stats.tx_errors;\par
   71     stats->tx_errors    = vport_stats.rx_errors;\par
   72     stats->rx_dropped   = vport_stats.tx_dropped;\par
   73     stats->tx_dropped   = vport_stats.rx_dropped;\par
   74 \par
   75     return stats;\par
   76 \}\par
}
}
{\xe \v internal_dev_getinfo\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_getinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_getinfo (struct net_device *  {\i netdev}, struct ethtool_drvinfo *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102     strlcpy(info->driver, "openvswitch", sizeof(info->driver));\par
  103 \}\par
}
}
{\xe \v internal_dev_open\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_open (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89     netif_start_queue(netdev);\par
   90     return 0;\par
   91 \}\par
}
}
{\xe \v internal_dev_priv\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_priv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b internal_dev}* internal_dev_priv (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     return netdev_priv(netdev);\par
   46 \}\par
}
}
{\xe \v internal_dev_recv\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_recv (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     struct net_device *netdev = netdev_vport_priv(vport)->dev;\par
  251     int len;\par
  252 \par
  253     if (unlikely(!(netdev->flags & IFF_UP))) \{\par
  254         kfree_skb(skb);\par
  255         return 0;\par
  256     \}\par
  257 \par
  258 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)\par
  259     if (skb_vlan_tag_present(skb)) \{\par
  260         if (unlikely(!vlan_insert_tag_set_proto(skb,\par
  261                             skb->vlan_proto,\par
  262                             skb_vlan_tag_get(skb))))\par
  263             return 0;\par
  264 \par
  265         if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  266             skb->csum = csum_add(skb->csum,\par
  267                          csum_partial(skb->data + (2 * ETH_ALEN),\par
  268                               VLAN_HLEN, 0));\par
  269 \par
  270         vlan_set_tci(skb, 0);\par
  271     \}\par
  272 #endif\par
  273 \par
  274     len = skb->len;\par
  275 \par
  276     skb_dst_drop(skb);\par
  277     nf_reset(skb);\par
  278     secpath_reset(skb);\par
  279 \par
  280     skb->dev = netdev;\par
  281     skb->pkt_type = PACKET_HOST;\par
  282     skb->protocol = eth_type_trans(skb, netdev);\par
  283     skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\par
  284 \par
  285     netif_rx(skb);\par
  286 \par
  287     return len;\par
  288 \}\par
}
}
{\xe \v internal_dev_stop\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_stop (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94 \{\par
   95     netif_stop_queue(netdev);\par
   96     return 0;\par
   97 \}\par
}
}
{\xe \v internal_dev_xmit\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_xmit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_xmit (struct sk_buff *  {\i skb}, struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81     rcu_read_lock();\par
   82     ovs_vport_receive(internal_dev_priv(netdev)->vport, skb, NULL);\par
   83     rcu_read_unlock();\par
   84     return 0;\par
   85 \}\par
}
}
{\xe \v ovs_internal_dev_get_vport\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:ovs_internal_dev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_internal_dev_get_vport (struct net_device *  {\i netdev})}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   304 \{\par
  305     if (!ovs_is_internal_dev(netdev))\par
  306         return NULL;\par
  307 \par
  308     return internal_dev_priv(netdev)->vport;\par
  309 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_register\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:ovs_internal_dev_rtnl_link_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_internal_dev_rtnl_link_register (void )}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   312 \{\par
  313     int err;\par
  314 \par
  315     err = rtnl_link_register(&internal_dev_link_ops);\par
  316     if (err < 0)\par
  317         return err;\par
  318 \par
  319     err = ovs_vport_ops_register(&ovs_internal_vport_ops);\par
  320     if (err < 0)\par
  321         rtnl_link_unregister(&internal_dev_link_ops);\par
  322 \par
  323     return err;\par
  324 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_unregister\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:ovs_internal_dev_rtnl_link_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_internal_dev_rtnl_link_unregister (void )}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   327 \{\par
  328     ovs_vport_ops_unregister(&ovs_internal_vport_ops);\par
  329     rtnl_link_unregister(&internal_dev_link_ops);\par
  330 \}\par
}
}
{\xe \v ovs_is_internal_dev\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:ovs_is_internal_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_is_internal_dev (const struct net_device *  {\i netdev})}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   299 \{\par
  300     return netdev->netdev_ops == &internal_dev_netdev_ops;\par
  301 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rtnl_link_ops internal_dev_link_ops __read_mostly{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .kind = "openvswitch",\par
\}\par
}
}
{\xe \v internal_dev_ethtool_ops\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_ethtool_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct ethtool_ops internal_dev_ethtool_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .get_drvinfo    = internal_dev_getinfo,\par
    .get_link   = ethtool_op_get_link,\par
\par
\par
\par
\par
\par
\par
\par
\par
\}\par
}
}
{\xe \v internal_dev_netdev_ops\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:internal_dev_netdev_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct net_device_ops internal_dev_netdev_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .ndo_open = internal_dev_open,\par
    .ndo_stop = internal_dev_stop,\par
    .ndo_start_xmit = internal_dev_xmit,\par
    .ndo_set_mac_address = eth_mac_addr,\par
    .ndo_change_mtu = internal_dev_change_mtu,\par
\par
    .ndo_get_stats64 = internal_dev_get_stats,\par
\par
\par
\par
\}\par
}
}
{\xe \v ovs_internal_vport_ops\:linux/vport-internal_dev.c}
{\xe \v linux/vport-internal_dev.c\:ovs_internal_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_internal_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type       = OVS_VPORT_TYPE_INTERNAL,\par
    .create     = internal_dev_create,\par
    .destroy    = internal_dev_destroy,\par
    .get_name   = ovs_netdev_get_name,\par
    .send       = internal_dev_recv,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-internal_dev.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-internal_dev.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-internal_dev.c}
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/hardirq.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/ethtool.h>}\par
{\f2 #include <linux/netdev_features.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/dst.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-internal_dev.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-internal__dev_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b internal_dev}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b internal_dev} * {\b internal_dev_priv} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtnl_link_stats64 * {\b internal_dev_get_stats} (struct net_device *netdev, struct rtnl_link_stats64 *stats)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_xmit} (struct sk_buff *skb, struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_open} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_stop} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_getinfo} (struct net_device *netdev, struct ethtool_drvinfo *info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_change_mtu} (struct net_device *netdev, int new_mtu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_destructor} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b do_setup} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b internal_dev_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b internal_dev_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b internal_dev_recv} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_is_internal_dev} (const struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_internal_dev_get_vport} (struct net_device *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_internal_dev_rtnl_link_register} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_internal_dev_rtnl_link_unregister} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_internal_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct ethtool_ops {\b internal_dev_ethtool_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct net_device_ops {\b internal_dev_netdev_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rtnl_link_ops internal_dev_link_ops {\b __read_mostly}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v do_setup\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:do_setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void do_setup (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154     ether_setup(netdev);\par
  155 \par
  156     netdev->netdev_ops = &internal_dev_netdev_ops;\par
  157 \par
  158     netdev->priv_flags &= ~IFF_TX_SKB_SHARING;\par
  159     netdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\par
  160     netdev->destructor = internal_dev_destructor;\par
  161     netdev->ethtool_ops = &internal_dev_ethtool_ops;\par
  162     netdev->rtnl_link_ops = &internal_dev_link_ops;\par
  163     netdev->tx_queue_len = 0;\par
  164 \par
  165     netdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |\par
  166                NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |\par
  167                NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL;\par
  168 \par
  169     netdev->vlan_features = netdev->features;\par
  170     netdev->features |= NETIF_F_HW_VLAN_CTAG_TX;\par
  171 \par
  172 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)\par
  173     netdev->hw_features = netdev->features & ~NETIF_F_LLTX;\par
  174 #endif\par
  175 \par
  176 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)\par
  177     netdev->hw_enc_features = netdev->features;\par
  178 #endif\par
  179 \par
  180     eth_hw_addr_random(netdev);\par
  181 \}\par
}
}
{\xe \v internal_dev_change_mtu\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_change_mtu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_change_mtu (struct net_device *  {\i netdev}, int  {\i new_mtu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     if (new_mtu < 68)\par
  121         return -EINVAL;\par
  122 \par
  123     netdev->mtu = new_mtu;\par
  124     return 0;\par
  125 \}\par
}
}
{\xe \v internal_dev_create\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* internal_dev_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   184 \{\par
  185     struct vport *vport;\par
  186     struct netdev_vport *netdev_vport;\par
  187     struct internal_dev *internal_dev;\par
  188     int err;\par
  189 \par
  190     vport = ovs_vport_alloc(sizeof(struct netdev_vport),\par
  191                 &ovs_internal_vport_ops, parms);\par
  192     if (IS_ERR(vport)) \{\par
  193         err = PTR_ERR(vport);\par
  194         goto error;\par
  195     \}\par
  196 \par
  197     netdev_vport = netdev_vport_priv(vport);\par
  198 \par
  199     netdev_vport->dev = alloc_netdev(sizeof(struct internal_dev),\par
  200                      parms->name, NET_NAME_UNKNOWN, do_setup);\par
  201     if (!netdev_vport->dev) \{\par
  202         err = -ENOMEM;\par
  203         goto error_free_vport;\par
  204     \}\par
  205 \par
  206     dev_net_set(netdev_vport->dev, ovs_dp_get_net(vport->dp));\par
  207     internal_dev = internal_dev_priv(netdev_vport->dev);\par
  208     internal_dev->vport = vport;\par
  209 \par
  210     /* Restrict bridge port to current netns. */\par
  211     if (vport->port_no == OVSP_LOCAL)\par
  212         netdev_vport->dev->features |= NETIF_F_NETNS_LOCAL;\par
  213 \par
  214     rtnl_lock();\par
  215     err = register_netdevice(netdev_vport->dev);\par
  216     if (err)\par
  217         goto error_free_netdev;\par
  218 \par
  219     dev_set_promiscuity(netdev_vport->dev, 1);\par
  220     rtnl_unlock();\par
  221     netif_start_queue(netdev_vport->dev);\par
  222 \par
  223     return vport;\par
  224 \par
  225 error_free_netdev:\par
  226     rtnl_unlock();\par
  227     free_netdev(netdev_vport->dev);\par
  228 error_free_vport:\par
  229     ovs_vport_free(vport);\par
  230 error:\par
  231     return ERR_PTR(err);\par
  232 \}\par
}
}
{\xe \v internal_dev_destroy\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   235 \{\par
  236     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  237 \par
  238     netif_stop_queue(netdev_vport->dev);\par
  239     rtnl_lock();\par
  240     dev_set_promiscuity(netdev_vport->dev, -1);\par
  241 \par
  242     /* unregister_netdevice() waits for an RCU grace period. */\par
  243     unregister_netdevice(netdev_vport->dev);\par
  244 \par
  245     rtnl_unlock();\par
  246 \}\par
}
}
{\xe \v internal_dev_destructor\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_destructor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_destructor (struct net_device *  {\i dev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   128 \{\par
  129     struct vport *vport = ovs_internal_dev_get_vport(dev);\par
  130 \par
  131     ovs_vport_free(vport);\par
  132     free_netdev(dev);\par
  133 \}\par
}
}
{\xe \v internal_dev_get_stats\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_get_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct rtnl_link_stats64* internal_dev_get_stats (struct net_device *  {\i netdev}, struct rtnl_link_stats64 *  {\i stats}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    52 \{\par
   53 #else\par
   54 static struct net_device_stats *internal_dev_sys_stats(struct net_device *netdev)\par
   55 \{\par
   56     struct net_device_stats *stats = &netdev->stats;\par
   57 #endif\par
   58     struct vport *vport = ovs_internal_dev_get_vport(netdev);\par
   59     struct ovs_vport_stats vport_stats;\par
   60 \par
   61     ovs_vport_get_stats(vport, &vport_stats);\par
   62 \par
   63     /* The tx and rx stats need to be swapped because the\par
   64      * switch and host OS have opposite perspectives.\par
   65      */\par
   66     stats->rx_packets   = vport_stats.tx_packets;\par
   67     stats->tx_packets   = vport_stats.rx_packets;\par
   68     stats->rx_bytes     = vport_stats.tx_bytes;\par
   69     stats->tx_bytes     = vport_stats.rx_bytes;\par
   70     stats->rx_errors    = vport_stats.tx_errors;\par
   71     stats->tx_errors    = vport_stats.rx_errors;\par
   72     stats->rx_dropped   = vport_stats.tx_dropped;\par
   73     stats->tx_dropped   = vport_stats.rx_dropped;\par
   74 \par
   75     return stats;\par
   76 \}\par
}
}
{\xe \v internal_dev_getinfo\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_getinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void internal_dev_getinfo (struct net_device *  {\i netdev}, struct ethtool_drvinfo *  {\i info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102     strlcpy(info->driver, "openvswitch", sizeof(info->driver));\par
  103 \}\par
}
}
{\xe \v internal_dev_open\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_open (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    88 \{\par
   89     netif_start_queue(netdev);\par
   90     return 0;\par
   91 \}\par
}
}
{\xe \v internal_dev_priv\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_priv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b internal_dev}* internal_dev_priv (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     return netdev_priv(netdev);\par
   46 \}\par
}
}
{\xe \v internal_dev_recv\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_recv (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   249 \{\par
  250     struct net_device *netdev = netdev_vport_priv(vport)->dev;\par
  251     int len;\par
  252 \par
  253     if (unlikely(!(netdev->flags & IFF_UP))) \{\par
  254         kfree_skb(skb);\par
  255         return 0;\par
  256     \}\par
  257 \par
  258 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)\par
  259     if (skb_vlan_tag_present(skb)) \{\par
  260         if (unlikely(!vlan_insert_tag_set_proto(skb,\par
  261                             skb->vlan_proto,\par
  262                             skb_vlan_tag_get(skb))))\par
  263             return 0;\par
  264 \par
  265         if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  266             skb->csum = csum_add(skb->csum,\par
  267                          csum_partial(skb->data + (2 * ETH_ALEN),\par
  268                               VLAN_HLEN, 0));\par
  269 \par
  270         vlan_set_tci(skb, 0);\par
  271     \}\par
  272 #endif\par
  273 \par
  274     len = skb->len;\par
  275 \par
  276     skb_dst_drop(skb);\par
  277     nf_reset(skb);\par
  278     secpath_reset(skb);\par
  279 \par
  280     skb->dev = netdev;\par
  281     skb->pkt_type = PACKET_HOST;\par
  282     skb->protocol = eth_type_trans(skb, netdev);\par
  283     skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\par
  284 \par
  285     netif_rx(skb);\par
  286 \par
  287     return len;\par
  288 \}\par
}
}
{\xe \v internal_dev_stop\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_stop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_stop (struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94 \{\par
   95     netif_stop_queue(netdev);\par
   96     return 0;\par
   97 \}\par
}
}
{\xe \v internal_dev_xmit\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_xmit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int internal_dev_xmit (struct sk_buff *  {\i skb}, struct net_device *  {\i netdev}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80 \{\par
   81     rcu_read_lock();\par
   82     ovs_vport_receive(internal_dev_priv(netdev)->vport, skb, NULL);\par
   83     rcu_read_unlock();\par
   84     return 0;\par
   85 \}\par
}
}
{\xe \v ovs_internal_dev_get_vport\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:ovs_internal_dev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_internal_dev_get_vport (struct net_device *  {\i netdev})}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   304 \{\par
  305     if (!ovs_is_internal_dev(netdev))\par
  306         return NULL;\par
  307 \par
  308     return internal_dev_priv(netdev)->vport;\par
  309 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_register\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:ovs_internal_dev_rtnl_link_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_internal_dev_rtnl_link_register (void )}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   312 \{\par
  313     int err;\par
  314 \par
  315     err = rtnl_link_register(&internal_dev_link_ops);\par
  316     if (err < 0)\par
  317         return err;\par
  318 \par
  319     err = ovs_vport_ops_register(&ovs_internal_vport_ops);\par
  320     if (err < 0)\par
  321         rtnl_link_unregister(&internal_dev_link_ops);\par
  322 \par
  323     return err;\par
  324 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_unregister\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:ovs_internal_dev_rtnl_link_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_internal_dev_rtnl_link_unregister (void )}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   327 \{\par
  328     ovs_vport_ops_unregister(&ovs_internal_vport_ops);\par
  329     rtnl_link_unregister(&internal_dev_link_ops);\par
  330 \}\par
}
}
{\xe \v ovs_is_internal_dev\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:ovs_is_internal_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_is_internal_dev (const struct net_device *  {\i netdev})}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   299 \{\par
  300     return netdev->netdev_ops == &internal_dev_netdev_ops;\par
  301 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __read_mostly\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:__read_mostly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rtnl_link_ops internal_dev_link_ops __read_mostly{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .kind = "openvswitch",\par
\}\par
}
}
{\xe \v internal_dev_ethtool_ops\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_ethtool_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct ethtool_ops internal_dev_ethtool_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .get_drvinfo    = internal_dev_getinfo,\par
    .get_link   = ethtool_op_get_link,\par
\par
\par
\par
\par
\par
\par
\par
\par
\}\par
}
}
{\xe \v internal_dev_netdev_ops\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:internal_dev_netdev_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct net_device_ops internal_dev_netdev_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .ndo_open = internal_dev_open,\par
    .ndo_stop = internal_dev_stop,\par
    .ndo_start_xmit = internal_dev_xmit,\par
    .ndo_set_mac_address = eth_mac_addr,\par
    .ndo_change_mtu = internal_dev_change_mtu,\par
\par
    .ndo_get_stats64 = internal_dev_get_stats,\par
\par
\par
\par
\}\par
}
}
{\xe \v ovs_internal_vport_ops\:vport-internal_dev.c}
{\xe \v vport-internal_dev.c\:ovs_internal_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_internal_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type       = OVS_VPORT_TYPE_INTERNAL,\par
    .create     = internal_dev_create,\par
    .destroy    = internal_dev_destroy,\par
    .get_name   = ovs_netdev_get_name,\par
    .send       = internal_dev_recv,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-lisp.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-lisp.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-lisp.c}
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/udp_tunnel.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-lisp.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-lisp_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lisphdr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lisp_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LISP_HLEN}\~ (sizeof(struct udphdr) + sizeof(struct {\b lisphdr}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b lisp_port} - Keeps track of open UDP ports : lisp UDP port no. : list element in . : The socket created for this port number. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_lisp_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (lisp_ports)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisp_port} * {\b lisp_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisp_port} * {\b lisp_find_port} (struct net *net, __be16 port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisphdr} * {\b lisp_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tunnel_id_to_instance_id} (__be64 {\b tun_id}, __u8 *iid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be64 {\b instance_id_to_tunnel_id} (__u8 *iid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u16 {\b get_src_port} (struct net *net, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b lisp_build_header} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_rcv} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_socket_init} (struct {\b lisp_port} *{\b lisp_port}, struct net *net)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b lisp_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b lisp_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b lisp_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_lisp_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_lisp_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_lisp_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_lisp_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: LISP switching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-105")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LISP_HLEN\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:LISP_HLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LISP_HLEN\~ (sizeof(struct udphdr) + sizeof(struct {\b lisphdr}))}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_src_port\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:get_src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u16 get_src_port (struct net *  {\i net}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   170 \{\par
  171     u32 hash = skb_get_hash(skb);\par
  172     unsigned int range;\par
  173     int high;\par
  174     int low;\par
  175 \par
  176     if (!hash) \{\par
  177         if (skb->protocol == htons(ETH_P_IP)) \{\par
  178             struct iphdr *iph;\par
  179             int size = (sizeof(iph->saddr) * 2) / sizeof(u32);\par
  180 \par
  181             iph = (struct iphdr *) skb_network_header(skb);\par
  182             hash = jhash2((const u32 *)&iph->saddr, size, 0);\par
  183         \} else if (skb->protocol == htons(ETH_P_IPV6)) \{\par
  184             struct ipv6hdr *ipv6hdr;\par
  185 \par
  186             ipv6hdr = (struct ipv6hdr *) skb_network_header(skb);\par
  187             hash = jhash2((const u32 *)&ipv6hdr->saddr,\par
  188                       (sizeof(struct in6_addr) * 2) / sizeof(u32), 0);\par
  189         \} else \{\par
  190             pr_warn_once("LISP inner protocol is not IP when "\par
  191                      "calculating hash.\\n");\par
  192         \}\par
  193     \}\par
  194 \par
  195     inet_get_local_port_range(net, &low, &high);\par
  196     range = (high - low) + 1;\par
  197     return (((u64) hash * range) >> 32) + low;\par
  198 \}\par
}
}
{\xe \v instance_id_to_tunnel_id\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:instance_id_to_tunnel_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be64 instance_id_to_tunnel_id (__u8 *  {\i iid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157 #ifdef __BIG_ENDIAN\par
  158     return (iid[0] << 16) | (iid[1] << 8) | iid[2];\par
  159 #else\par
  160     return (__force __be64)(((__force u64)iid[0] << 40) |\par
  161                 ((__force u64)iid[1] << 48) |\par
  162                 ((__force u64)iid[2] << 56));\par
  163 #endif\par
  164 \}\par
}
}
{\xe \v lisp_build_header\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_build_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void lisp_build_header (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   201 \{\par
  202     struct lisphdr *lisph;\par
  203     const struct ovs_key_ipv4_tunnel *tun_key;\par
  204 \par
  205     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  206 \par
  207     lisph = (struct lisphdr *)__skb_push(skb, sizeof(struct lisphdr));\par
  208     lisph->nonce_present = 0;   /* We don't support echo nonce algorithm */\par
  209     lisph->locator_status_bits_present = 1; /* Set LSB */\par
  210     lisph->solicit_echo_nonce = 0;  /* No echo noncing */\par
  211     lisph->map_version_present = 0; /* No mapping versioning, nonce instead */\par
  212     lisph->instance_id_present = 1; /* Store the tun_id as Instance ID  */\par
  213     lisph->reserved_flags = 0;  /* Reserved flags, set to 0  */\par
  214 \par
  215     lisph->u1.nonce[0] = 0;\par
  216     lisph->u1.nonce[1] = 0;\par
  217     lisph->u1.nonce[2] = 0;\par
  218 \par
  219     tunnel_id_to_instance_id(tun_key->tun_id, &lisph->u2.word2.instance_id[0]);\par
  220     lisph->u2.word2.locator_status_bits = 1;\par
  221 \}\par
}
}
{\xe \v lisp_find_port\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_find_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisp_port}* lisp_find_port (struct net *  {\i net}, __be16  {\i port}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   122 \{\par
  123     struct lisp_port *lisp_port;\par
  124 \par
  125     list_for_each_entry_rcu(lisp_port, &lisp_ports, list) \{\par
  126         if (lisp_port->dst_port == port &&\par
  127             net_eq(sock_net(lisp_port->lisp_rcv_socket->sk), net))\par
  128             return lisp_port;\par
  129     \}\par
  130 \par
  131     return NULL;\par
  132 \}\par
}
}
{\xe \v lisp_get_egress_tun_info\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   479 \{\par
  480     struct net *net = ovs_dp_get_net(vport->dp);\par
  481     struct lisp_port *lisp_port = lisp_vport(vport);\par
  482 \par
  483     if (skb->protocol != htons(ETH_P_IP) &&\par
  484         skb->protocol != htons(ETH_P_IPV6)) \{\par
  485         return -EINVAL;\par
  486     \}\par
  487 \par
  488     /*\par
  489      * Get tp_src and tp_dst, refert to lisp_build_header().\par
  490      */\par
  491     return ovs_tunnel_get_egress_info(egress_tun_info, net,\par
  492                       OVS_CB(skb)->egress_tun_info,\par
  493                       IPPROTO_UDP, skb->mark,\par
  494                       htons(get_src_port(net, skb)),\par
  495                       lisp_port->dst_port);\par
  496 \}\par
}
}
{\xe \v lisp_get_name\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* lisp_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   472 \{\par
  473     struct lisp_port *lisp_port = lisp_vport(vport);\par
  474     return lisp_port->name;\par
  475 \}\par
}
}
{\xe \v lisp_get_options\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316     struct lisp_port *lisp_port = lisp_vport(vport);\par
  317 \par
  318     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(lisp_port->dst_port)))\par
  319         return -EMSGSIZE;\par
  320     return 0;\par
  321 \}\par
}
}
{\xe \v lisp_hdr\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisphdr}* lisp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     return (struct lisphdr *)(udp_hdr(skb) + 1);\par
  137 \}\par
}
}
{\xe \v lisp_rcv\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_rcv (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   225 \{\par
  226     struct lisp_port *lisp_port;\par
  227     struct lisphdr *lisph;\par
  228     struct iphdr *iph, *inner_iph;\par
  229     struct ovs_tunnel_info tun_info;\par
  230     __be64 key;\par
  231     struct ethhdr *ethh;\par
  232     __be16 protocol;\par
  233 \par
  234     lisp_port = rcu_dereference_sk_user_data(sk);\par
  235     if (unlikely(!lisp_port))\par
  236         goto error;\par
  237 \par
  238     if (iptunnel_pull_header(skb, LISP_HLEN, 0))\par
  239         goto error;\par
  240 \par
  241     lisph = lisp_hdr(skb);\par
  242 \par
  243     if (lisph->instance_id_present != 1)\par
  244         key = 0;\par
  245     else\par
  246         key = instance_id_to_tunnel_id(&lisph->u2.word2.instance_id[0]);\par
  247 \par
  248     /* Save outer tunnel values */\par
  249     iph = ip_hdr(skb);\par
  250     ovs_flow_tun_info_init(&tun_info, iph,\par
  251                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
  252                    key, TUNNEL_KEY, NULL, 0);\par
  253 \par
  254     /* Drop non-IP inner packets */\par
  255     inner_iph = (struct iphdr *)(lisph + 1);\par
  256     switch (inner_iph->version) \{\par
  257     case 4:\par
  258         protocol = htons(ETH_P_IP);\par
  259         break;\par
  260     case 6:\par
  261         protocol = htons(ETH_P_IPV6);\par
  262         break;\par
  263     default:\par
  264         goto error;\par
  265     \}\par
  266     skb->protocol = protocol;\par
  267 \par
  268     /* Add Ethernet header */\par
  269     ethh = (struct ethhdr *)skb_push(skb, ETH_HLEN);\par
  270     memset(ethh, 0, ETH_HLEN);\par
  271     ethh->h_dest[0] = 0x02;\par
  272     ethh->h_source[0] = 0x02;\par
  273     ethh->h_proto = protocol;\par
  274 \par
  275     ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\par
  276 \par
  277     ovs_vport_receive(vport_from_priv(lisp_port), skb, &tun_info);\par
  278     goto out;\par
  279 \par
  280 error:\par
  281     kfree_skb(skb);\par
  282 out:\par
  283     return 0;\par
  284 \}\par
}
}
{\xe \v lisp_send\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   385 \{\par
  386     struct ovs_key_ipv4_tunnel *tun_key;\par
  387     struct lisp_port *lisp_port = lisp_vport(vport);\par
  388     struct net *net = ovs_dp_get_net(vport->dp);\par
  389     int network_offset = skb_network_offset(skb);\par
  390     struct rtable *rt;\par
  391     int min_headroom;\par
  392     __be32 saddr;\par
  393     __be16 src_port, dst_port;\par
  394     __be16 df;\par
  395     int sent_len;\par
  396     int err;\par
  397 \par
  398     if (unlikely(!OVS_CB(skb)->egress_tun_info)) \{\par
  399         err = -EINVAL;\par
  400         goto error;\par
  401     \}\par
  402 \par
  403     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  404 \par
  405     if (skb->protocol != htons(ETH_P_IP) &&\par
  406         skb->protocol != htons(ETH_P_IPV6)) \{\par
  407         err = 0;\par
  408         goto error;\par
  409     \}\par
  410 \par
  411     /* Route lookup */\par
  412     saddr = tun_key->ipv4_src;\par
  413     rt = find_route(ovs_dp_get_net(vport->dp),\par
  414             &saddr, tun_key->ipv4_dst,\par
  415             IPPROTO_UDP, tun_key->ipv4_tos,\par
  416             skb->mark);\par
  417     if (IS_ERR(rt)) \{\par
  418         err = PTR_ERR(rt);\par
  419         goto error;\par
  420     \}\par
  421 \par
  422     min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len\par
  423             + sizeof(struct iphdr) + LISP_HLEN;\par
  424 \par
  425     if (skb_headroom(skb) < min_headroom || skb_header_cloned(skb)) \{\par
  426         int head_delta = SKB_DATA_ALIGN(min_headroom -\par
  427                         skb_headroom(skb) +\par
  428                         16);\par
  429 \par
  430         err = pskb_expand_head(skb, max_t(int, head_delta, 0),\par
  431                     0, GFP_ATOMIC);\par
  432         if (unlikely(err))\par
  433             goto err_free_rt;\par
  434     \}\par
  435 \par
  436     /* Reset l2 headers. */\par
  437     skb_pull(skb, network_offset);\par
  438     skb_reset_mac_header(skb);\par
  439     vlan_set_tci(skb, 0);\par
  440 \par
  441     skb = udp_tunnel_handle_offloads(skb, false, false);\par
  442     if (IS_ERR(skb)) \{\par
  443         err = PTR_ERR(skb);\par
  444         skb = NULL;\par
  445         goto err_free_rt;\par
  446     \}\par
  447 \par
  448     src_port = htons(get_src_port(net, skb));\par
  449     dst_port = lisp_port->dst_port;\par
  450 \par
  451     lisp_build_header(skb);\par
  452 \par
  453     skb->ignore_df = 1;\par
  454 \par
  455     ovs_skb_set_inner_protocol(skb, skb->protocol);\par
  456 \par
  457     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  458     sent_len = udp_tunnel_xmit_skb(rt, skb, saddr, tun_key->ipv4_dst,\par
  459                        tun_key->ipv4_tos, tun_key->ipv4_ttl,\par
  460                        df, src_port, dst_port, false, true);\par
  461 \par
  462     return sent_len > 0 ? sent_len + network_offset : sent_len;\par
  463 \par
  464 err_free_rt:\par
  465     ip_rt_put(rt);\par
  466 error:\par
  467     kfree_skb(skb);\par
  468     return err;\par
  469 \}\par
}
}
{\xe \v lisp_socket_init\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_socket_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_socket_init (struct {\b lisp_port} *  {\i lisp_port}, struct net *  {\i net}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   287 \{\par
  288     struct udp_port_cfg udp_conf;\par
  289     struct udp_tunnel_sock_cfg tunnel_cfg;\par
  290     int err;\par
  291 \par
  292     memset(&udp_conf, 0, sizeof(udp_conf));\par
  293 \par
  294     udp_conf.family = AF_INET;\par
  295     udp_conf.local_ip.s_addr = htonl(INADDR_ANY);\par
  296     udp_conf.local_udp_port = lisp_port->dst_port;\par
  297 \par
  298         err = udp_sock_create(net, &udp_conf, &lisp_port->lisp_rcv_socket);\par
  299         if (err < 0) \{\par
  300         pr_warn("cannot register lisp protocol handler: %d\\n", err);\par
  301                 return err;\par
  302     \}\par
  303 \par
  304     tunnel_cfg.sk_user_data = lisp_port;\par
  305     tunnel_cfg.encap_type = 1;\par
  306     tunnel_cfg.encap_rcv = lisp_rcv;\par
  307     tunnel_cfg.encap_destroy = NULL;\par
  308 \par
  309     setup_udp_tunnel_sock(net, lisp_port->lisp_rcv_socket, &tunnel_cfg);\par
  310 \par
  311     return 0;\par
  312 \}\par
}
}
{\xe \v lisp_tnl_create\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* lisp_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   333 \{\par
  334     struct net *net = ovs_dp_get_net(parms->dp);\par
  335     struct nlattr *options = parms->options;\par
  336     struct lisp_port *lisp_port;\par
  337     struct vport *vport;\par
  338     struct nlattr *a;\par
  339     int err;\par
  340     u16 dst_port;\par
  341 \par
  342     if (!options) \{\par
  343         err = -EINVAL;\par
  344         goto error;\par
  345     \}\par
  346 \par
  347     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  348     if (a && nla_len(a) == sizeof(u16)) \{\par
  349         dst_port = nla_get_u16(a);\par
  350     \} else \{\par
  351         /* Require destination port from userspace. */\par
  352         err = -EINVAL;\par
  353         goto error;\par
  354     \}\par
  355 \par
  356     /* Verify if we already have a socket created for this port */\par
  357     if (lisp_find_port(net, htons(dst_port))) \{\par
  358         err = -EEXIST;\par
  359         goto error;\par
  360     \}\par
  361 \par
  362     vport = ovs_vport_alloc(sizeof(struct lisp_port),\par
  363                 &ovs_lisp_vport_ops, parms);\par
  364     if (IS_ERR(vport))\par
  365         return vport;\par
  366 \par
  367     lisp_port = lisp_vport(vport);\par
  368     lisp_port->dst_port = htons(dst_port);\par
  369     strncpy(lisp_port->name, parms->name, IFNAMSIZ);\par
  370 \par
  371     err = lisp_socket_init(lisp_port, net);\par
  372     if (err)\par
  373         goto error_free;\par
  374 \par
  375     list_add_tail_rcu(&lisp_port->list, &lisp_ports);\par
  376     return vport;\par
  377 \par
  378 error_free:\par
  379     ovs_vport_free(vport);\par
  380 error:\par
  381     return ERR_PTR(err);\par
  382 \}\par
}
}
{\xe \v lisp_tnl_destroy\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void lisp_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   324 \{\par
  325     struct lisp_port *lisp_port = lisp_vport(vport);\par
  326 \par
  327     list_del_rcu(&lisp_port->list);\par
  328     udp_tunnel_sock_release(lisp_port->lisp_rcv_socket);\par
  329     ovs_vport_deferred_free(vport);\par
  330 \}\par
}
}
{\xe \v lisp_vport\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:lisp_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisp_port}* lisp_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117 \{\par
  118     return vport_priv(vport);\par
  119 \}\par
}
}
{\xe \v LIST_HEAD\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (lisp_ports ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_ALIAS\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-105" )}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: LISP switching port" )}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_lisp_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_lisp_tnl_init} )}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_lisp_tnl_exit\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:ovs_lisp_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_lisp_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   515 \{\par
  516     ovs_vport_ops_unregister(&ovs_lisp_vport_ops);\par
  517 \}\par
}
}
{\xe \v ovs_lisp_tnl_init\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:ovs_lisp_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_lisp_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   510 \{\par
  511     return ovs_vport_ops_register(&ovs_lisp_vport_ops);\par
  512 \}\par
}
}
{\xe \v tunnel_id_to_instance_id\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:tunnel_id_to_instance_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tunnel_id_to_instance_id (__be64  {\i tun_id}, __u8 *  {\i iid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   141 \{\par
  142 \par
  143 #ifdef __BIG_ENDIAN\par
  144     iid[0] = (__force __u8)(tun_id >> 16);\par
  145     iid[1] = (__force __u8)(tun_id >> 8);\par
  146     iid[2] = (__force __u8)tun_id;\par
  147 #else\par
  148     iid[0] = (__force __u8)((__force u64)tun_id >> 40);\par
  149     iid[1] = (__force __u8)((__force u64)tun_id >> 48);\par
  150     iid[2] = (__force __u8)((__force u64)tun_id >> 56);\par
  151 #endif\par
  152 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_lisp_vport_ops\:linux/vport-lisp.c}
{\xe \v linux/vport-lisp.c\:ovs_lisp_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_lisp_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_LISP,\par
    .create         = lisp_tnl_create,\par
    .destroy        = lisp_tnl_destroy,\par
    .get_name       = lisp_get_name,\par
    .get_options        = lisp_get_options,\par
    .send           = lisp_send,\par
    .get_egress_tun_info    = lisp_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-lisp.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-lisp.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-lisp.c}
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/udp_tunnel.h>}\par
{\f2 #include <net/xfrm.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-lisp.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-lisp_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lisphdr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b lisp_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LISP_HLEN}\~ (sizeof(struct udphdr) + sizeof(struct {\b lisphdr}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b lisp_port} - Keeps track of open UDP ports : lisp UDP port no. : list element in . : The socket created for this port number. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_lisp_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (lisp_ports)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisp_port} * {\b lisp_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisp_port} * {\b lisp_find_port} (struct net *net, __be16 port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b lisphdr} * {\b lisp_hdr} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tunnel_id_to_instance_id} (__be64 {\b tun_id}, __u8 *iid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static __be64 {\b instance_id_to_tunnel_id} (__u8 *iid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u16 {\b get_src_port} (struct net *net, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b lisp_build_header} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_rcv} (struct sock *sk, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_socket_init} (struct {\b lisp_port} *{\b lisp_port}, struct net *net)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b lisp_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b lisp_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b lisp_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lisp_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_lisp_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_lisp_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_lisp_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_lisp_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: LISP switching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-105")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LISP_HLEN\:vport-lisp.c}
{\xe \v vport-lisp.c\:LISP_HLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LISP_HLEN\~ (sizeof(struct udphdr) + sizeof(struct {\b lisphdr}))}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pr_fmt\:vport-lisp.c}
{\xe \v vport-lisp.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_src_port\:vport-lisp.c}
{\xe \v vport-lisp.c\:get_src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u16 get_src_port (struct net *  {\i net}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   170 \{\par
  171     u32 hash = skb_get_hash(skb);\par
  172     unsigned int range;\par
  173     int high;\par
  174     int low;\par
  175 \par
  176     if (!hash) \{\par
  177         if (skb->protocol == htons(ETH_P_IP)) \{\par
  178             struct iphdr *iph;\par
  179             int size = (sizeof(iph->saddr) * 2) / sizeof(u32);\par
  180 \par
  181             iph = (struct iphdr *) skb_network_header(skb);\par
  182             hash = jhash2((const u32 *)&iph->saddr, size, 0);\par
  183         \} else if (skb->protocol == htons(ETH_P_IPV6)) \{\par
  184             struct ipv6hdr *ipv6hdr;\par
  185 \par
  186             ipv6hdr = (struct ipv6hdr *) skb_network_header(skb);\par
  187             hash = jhash2((const u32 *)&ipv6hdr->saddr,\par
  188                       (sizeof(struct in6_addr) * 2) / sizeof(u32), 0);\par
  189         \} else \{\par
  190             pr_warn_once("LISP inner protocol is not IP when "\par
  191                      "calculating hash.\\n");\par
  192         \}\par
  193     \}\par
  194 \par
  195     inet_get_local_port_range(net, &low, &high);\par
  196     range = (high - low) + 1;\par
  197     return (((u64) hash * range) >> 32) + low;\par
  198 \}\par
}
}
{\xe \v instance_id_to_tunnel_id\:vport-lisp.c}
{\xe \v vport-lisp.c\:instance_id_to_tunnel_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static __be64 instance_id_to_tunnel_id (__u8 *  {\i iid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157 #ifdef __BIG_ENDIAN\par
  158     return (iid[0] << 16) | (iid[1] << 8) | iid[2];\par
  159 #else\par
  160     return (__force __be64)(((__force u64)iid[0] << 40) |\par
  161                 ((__force u64)iid[1] << 48) |\par
  162                 ((__force u64)iid[2] << 56));\par
  163 #endif\par
  164 \}\par
}
}
{\xe \v lisp_build_header\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_build_header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void lisp_build_header (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   201 \{\par
  202     struct lisphdr *lisph;\par
  203     const struct ovs_key_ipv4_tunnel *tun_key;\par
  204 \par
  205     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  206 \par
  207     lisph = (struct lisphdr *)__skb_push(skb, sizeof(struct lisphdr));\par
  208     lisph->nonce_present = 0;   /* We don't support echo nonce algorithm */\par
  209     lisph->locator_status_bits_present = 1; /* Set LSB */\par
  210     lisph->solicit_echo_nonce = 0;  /* No echo noncing */\par
  211     lisph->map_version_present = 0; /* No mapping versioning, nonce instead */\par
  212     lisph->instance_id_present = 1; /* Store the tun_id as Instance ID  */\par
  213     lisph->reserved_flags = 0;  /* Reserved flags, set to 0  */\par
  214 \par
  215     lisph->u1.nonce[0] = 0;\par
  216     lisph->u1.nonce[1] = 0;\par
  217     lisph->u1.nonce[2] = 0;\par
  218 \par
  219     tunnel_id_to_instance_id(tun_key->tun_id, &lisph->u2.word2.instance_id[0]);\par
  220     lisph->u2.word2.locator_status_bits = 1;\par
  221 \}\par
}
}
{\xe \v lisp_find_port\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_find_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisp_port}* lisp_find_port (struct net *  {\i net}, __be16  {\i port}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   122 \{\par
  123     struct lisp_port *lisp_port;\par
  124 \par
  125     list_for_each_entry_rcu(lisp_port, &lisp_ports, list) \{\par
  126         if (lisp_port->dst_port == port &&\par
  127             net_eq(sock_net(lisp_port->lisp_rcv_socket->sk), net))\par
  128             return lisp_port;\par
  129     \}\par
  130 \par
  131     return NULL;\par
  132 \}\par
}
}
{\xe \v lisp_get_egress_tun_info\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   479 \{\par
  480     struct net *net = ovs_dp_get_net(vport->dp);\par
  481     struct lisp_port *lisp_port = lisp_vport(vport);\par
  482 \par
  483     if (skb->protocol != htons(ETH_P_IP) &&\par
  484         skb->protocol != htons(ETH_P_IPV6)) \{\par
  485         return -EINVAL;\par
  486     \}\par
  487 \par
  488     /*\par
  489      * Get tp_src and tp_dst, refert to lisp_build_header().\par
  490      */\par
  491     return ovs_tunnel_get_egress_info(egress_tun_info, net,\par
  492                       OVS_CB(skb)->egress_tun_info,\par
  493                       IPPROTO_UDP, skb->mark,\par
  494                       htons(get_src_port(net, skb)),\par
  495                       lisp_port->dst_port);\par
  496 \}\par
}
}
{\xe \v lisp_get_name\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* lisp_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   472 \{\par
  473     struct lisp_port *lisp_port = lisp_vport(vport);\par
  474     return lisp_port->name;\par
  475 \}\par
}
}
{\xe \v lisp_get_options\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316     struct lisp_port *lisp_port = lisp_vport(vport);\par
  317 \par
  318     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(lisp_port->dst_port)))\par
  319         return -EMSGSIZE;\par
  320     return 0;\par
  321 \}\par
}
}
{\xe \v lisp_hdr\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_hdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisphdr}* lisp_hdr (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   135 \{\par
  136     return (struct lisphdr *)(udp_hdr(skb) + 1);\par
  137 \}\par
}
}
{\xe \v lisp_rcv\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_rcv (struct sock *  {\i sk}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   225 \{\par
  226     struct lisp_port *lisp_port;\par
  227     struct lisphdr *lisph;\par
  228     struct iphdr *iph, *inner_iph;\par
  229     struct ovs_tunnel_info tun_info;\par
  230     __be64 key;\par
  231     struct ethhdr *ethh;\par
  232     __be16 protocol;\par
  233 \par
  234     lisp_port = rcu_dereference_sk_user_data(sk);\par
  235     if (unlikely(!lisp_port))\par
  236         goto error;\par
  237 \par
  238     if (iptunnel_pull_header(skb, LISP_HLEN, 0))\par
  239         goto error;\par
  240 \par
  241     lisph = lisp_hdr(skb);\par
  242 \par
  243     if (lisph->instance_id_present != 1)\par
  244         key = 0;\par
  245     else\par
  246         key = instance_id_to_tunnel_id(&lisph->u2.word2.instance_id[0]);\par
  247 \par
  248     /* Save outer tunnel values */\par
  249     iph = ip_hdr(skb);\par
  250     ovs_flow_tun_info_init(&tun_info, iph,\par
  251                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
  252                    key, TUNNEL_KEY, NULL, 0);\par
  253 \par
  254     /* Drop non-IP inner packets */\par
  255     inner_iph = (struct iphdr *)(lisph + 1);\par
  256     switch (inner_iph->version) \{\par
  257     case 4:\par
  258         protocol = htons(ETH_P_IP);\par
  259         break;\par
  260     case 6:\par
  261         protocol = htons(ETH_P_IPV6);\par
  262         break;\par
  263     default:\par
  264         goto error;\par
  265     \}\par
  266     skb->protocol = protocol;\par
  267 \par
  268     /* Add Ethernet header */\par
  269     ethh = (struct ethhdr *)skb_push(skb, ETH_HLEN);\par
  270     memset(ethh, 0, ETH_HLEN);\par
  271     ethh->h_dest[0] = 0x02;\par
  272     ethh->h_source[0] = 0x02;\par
  273     ethh->h_proto = protocol;\par
  274 \par
  275     ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\par
  276 \par
  277     ovs_vport_receive(vport_from_priv(lisp_port), skb, &tun_info);\par
  278     goto out;\par
  279 \par
  280 error:\par
  281     kfree_skb(skb);\par
  282 out:\par
  283     return 0;\par
  284 \}\par
}
}
{\xe \v lisp_send\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   385 \{\par
  386     struct ovs_key_ipv4_tunnel *tun_key;\par
  387     struct lisp_port *lisp_port = lisp_vport(vport);\par
  388     struct net *net = ovs_dp_get_net(vport->dp);\par
  389     int network_offset = skb_network_offset(skb);\par
  390     struct rtable *rt;\par
  391     int min_headroom;\par
  392     __be32 saddr;\par
  393     __be16 src_port, dst_port;\par
  394     __be16 df;\par
  395     int sent_len;\par
  396     int err;\par
  397 \par
  398     if (unlikely(!OVS_CB(skb)->egress_tun_info)) \{\par
  399         err = -EINVAL;\par
  400         goto error;\par
  401     \}\par
  402 \par
  403     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  404 \par
  405     if (skb->protocol != htons(ETH_P_IP) &&\par
  406         skb->protocol != htons(ETH_P_IPV6)) \{\par
  407         err = 0;\par
  408         goto error;\par
  409     \}\par
  410 \par
  411     /* Route lookup */\par
  412     saddr = tun_key->ipv4_src;\par
  413     rt = find_route(ovs_dp_get_net(vport->dp),\par
  414             &saddr, tun_key->ipv4_dst,\par
  415             IPPROTO_UDP, tun_key->ipv4_tos,\par
  416             skb->mark);\par
  417     if (IS_ERR(rt)) \{\par
  418         err = PTR_ERR(rt);\par
  419         goto error;\par
  420     \}\par
  421 \par
  422     min_headroom = LL_RESERVED_SPACE(rt_dst(rt).dev) + rt_dst(rt).header_len\par
  423             + sizeof(struct iphdr) + LISP_HLEN;\par
  424 \par
  425     if (skb_headroom(skb) < min_headroom || skb_header_cloned(skb)) \{\par
  426         int head_delta = SKB_DATA_ALIGN(min_headroom -\par
  427                         skb_headroom(skb) +\par
  428                         16);\par
  429 \par
  430         err = pskb_expand_head(skb, max_t(int, head_delta, 0),\par
  431                     0, GFP_ATOMIC);\par
  432         if (unlikely(err))\par
  433             goto err_free_rt;\par
  434     \}\par
  435 \par
  436     /* Reset l2 headers. */\par
  437     skb_pull(skb, network_offset);\par
  438     skb_reset_mac_header(skb);\par
  439     vlan_set_tci(skb, 0);\par
  440 \par
  441     skb = udp_tunnel_handle_offloads(skb, false, false);\par
  442     if (IS_ERR(skb)) \{\par
  443         err = PTR_ERR(skb);\par
  444         skb = NULL;\par
  445         goto err_free_rt;\par
  446     \}\par
  447 \par
  448     src_port = htons(get_src_port(net, skb));\par
  449     dst_port = lisp_port->dst_port;\par
  450 \par
  451     lisp_build_header(skb);\par
  452 \par
  453     skb->ignore_df = 1;\par
  454 \par
  455     ovs_skb_set_inner_protocol(skb, skb->protocol);\par
  456 \par
  457     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  458     sent_len = udp_tunnel_xmit_skb(rt, skb, saddr, tun_key->ipv4_dst,\par
  459                        tun_key->ipv4_tos, tun_key->ipv4_ttl,\par
  460                        df, src_port, dst_port, false, true);\par
  461 \par
  462     return sent_len > 0 ? sent_len + network_offset : sent_len;\par
  463 \par
  464 err_free_rt:\par
  465     ip_rt_put(rt);\par
  466 error:\par
  467     kfree_skb(skb);\par
  468     return err;\par
  469 \}\par
}
}
{\xe \v lisp_socket_init\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_socket_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lisp_socket_init (struct {\b lisp_port} *  {\i lisp_port}, struct net *  {\i net}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   287 \{\par
  288     struct udp_port_cfg udp_conf;\par
  289     struct udp_tunnel_sock_cfg tunnel_cfg;\par
  290     int err;\par
  291 \par
  292     memset(&udp_conf, 0, sizeof(udp_conf));\par
  293 \par
  294     udp_conf.family = AF_INET;\par
  295     udp_conf.local_ip.s_addr = htonl(INADDR_ANY);\par
  296     udp_conf.local_udp_port = lisp_port->dst_port;\par
  297 \par
  298         err = udp_sock_create(net, &udp_conf, &lisp_port->lisp_rcv_socket);\par
  299         if (err < 0) \{\par
  300         pr_warn("cannot register lisp protocol handler: %d\\n", err);\par
  301                 return err;\par
  302     \}\par
  303 \par
  304     tunnel_cfg.sk_user_data = lisp_port;\par
  305     tunnel_cfg.encap_type = 1;\par
  306     tunnel_cfg.encap_rcv = lisp_rcv;\par
  307     tunnel_cfg.encap_destroy = NULL;\par
  308 \par
  309     setup_udp_tunnel_sock(net, lisp_port->lisp_rcv_socket, &tunnel_cfg);\par
  310 \par
  311     return 0;\par
  312 \}\par
}
}
{\xe \v lisp_tnl_create\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* lisp_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   333 \{\par
  334     struct net *net = ovs_dp_get_net(parms->dp);\par
  335     struct nlattr *options = parms->options;\par
  336     struct lisp_port *lisp_port;\par
  337     struct vport *vport;\par
  338     struct nlattr *a;\par
  339     int err;\par
  340     u16 dst_port;\par
  341 \par
  342     if (!options) \{\par
  343         err = -EINVAL;\par
  344         goto error;\par
  345     \}\par
  346 \par
  347     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  348     if (a && nla_len(a) == sizeof(u16)) \{\par
  349         dst_port = nla_get_u16(a);\par
  350     \} else \{\par
  351         /* Require destination port from userspace. */\par
  352         err = -EINVAL;\par
  353         goto error;\par
  354     \}\par
  355 \par
  356     /* Verify if we already have a socket created for this port */\par
  357     if (lisp_find_port(net, htons(dst_port))) \{\par
  358         err = -EEXIST;\par
  359         goto error;\par
  360     \}\par
  361 \par
  362     vport = ovs_vport_alloc(sizeof(struct lisp_port),\par
  363                 &ovs_lisp_vport_ops, parms);\par
  364     if (IS_ERR(vport))\par
  365         return vport;\par
  366 \par
  367     lisp_port = lisp_vport(vport);\par
  368     lisp_port->dst_port = htons(dst_port);\par
  369     strncpy(lisp_port->name, parms->name, IFNAMSIZ);\par
  370 \par
  371     err = lisp_socket_init(lisp_port, net);\par
  372     if (err)\par
  373         goto error_free;\par
  374 \par
  375     list_add_tail_rcu(&lisp_port->list, &lisp_ports);\par
  376     return vport;\par
  377 \par
  378 error_free:\par
  379     ovs_vport_free(vport);\par
  380 error:\par
  381     return ERR_PTR(err);\par
  382 \}\par
}
}
{\xe \v lisp_tnl_destroy\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void lisp_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   324 \{\par
  325     struct lisp_port *lisp_port = lisp_vport(vport);\par
  326 \par
  327     list_del_rcu(&lisp_port->list);\par
  328     udp_tunnel_sock_release(lisp_port->lisp_rcv_socket);\par
  329     ovs_vport_deferred_free(vport);\par
  330 \}\par
}
}
{\xe \v lisp_vport\:vport-lisp.c}
{\xe \v vport-lisp.c\:lisp_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b lisp_port}* lisp_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   117 \{\par
  118     return vport_priv(vport);\par
  119 \}\par
}
}
{\xe \v LIST_HEAD\:vport-lisp.c}
{\xe \v vport-lisp.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (lisp_ports ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_ALIAS\:vport-lisp.c}
{\xe \v vport-lisp.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-105" )}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:vport-lisp.c}
{\xe \v vport-lisp.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: LISP switching port" )}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:vport-lisp.c}
{\xe \v vport-lisp.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_lisp_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:vport-lisp.c}
{\xe \v vport-lisp.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_lisp_tnl_init} )}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:vport-lisp.c}
{\xe \v vport-lisp.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_lisp_tnl_exit\:vport-lisp.c}
{\xe \v vport-lisp.c\:ovs_lisp_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_lisp_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   515 \{\par
  516     ovs_vport_ops_unregister(&ovs_lisp_vport_ops);\par
  517 \}\par
}
}
{\xe \v ovs_lisp_tnl_init\:vport-lisp.c}
{\xe \v vport-lisp.c\:ovs_lisp_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_lisp_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   510 \{\par
  511     return ovs_vport_ops_register(&ovs_lisp_vport_ops);\par
  512 \}\par
}
}
{\xe \v tunnel_id_to_instance_id\:vport-lisp.c}
{\xe \v vport-lisp.c\:tunnel_id_to_instance_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tunnel_id_to_instance_id (__be64  {\i tun_id}, __u8 *  {\i iid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   141 \{\par
  142 \par
  143 #ifdef __BIG_ENDIAN\par
  144     iid[0] = (__force __u8)(tun_id >> 16);\par
  145     iid[1] = (__force __u8)(tun_id >> 8);\par
  146     iid[2] = (__force __u8)tun_id;\par
  147 #else\par
  148     iid[0] = (__force __u8)((__force u64)tun_id >> 40);\par
  149     iid[1] = (__force __u8)((__force u64)tun_id >> 48);\par
  150     iid[2] = (__force __u8)((__force u64)tun_id >> 56);\par
  151 #endif\par
  152 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_lisp_vport_ops\:vport-lisp.c}
{\xe \v vport-lisp.c\:ovs_lisp_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_lisp_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_LISP,\par
    .create         = lisp_tnl_create,\par
    .destroy        = lisp_tnl_destroy,\par
    .get_name       = lisp_get_name,\par
    .get_options        = lisp_get_options,\par
    .send           = lisp_send,\par
    .get_egress_tun_info    = lisp_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-lisp.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-lisp.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-lisp.mod.c}
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-lisp.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-lisp_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"F769FC95B99016E6C6013D1")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:vport-lisp.mod.c}
{\xe \v vport-lisp.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-lisp.mod.c}
{\xe \v vport-lisp.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-lisp.mod.c}
{\xe \v vport-lisp.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-lisp.mod.c}
{\xe \v vport-lisp.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-lisp.mod.c}
{\xe \v vport-lisp.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "F769FC95B99016E6C6013D1" )}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-netdev.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-netdev.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-netdev.c}
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_bridge.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/rtnetlink.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/llc.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-netdev.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-netdev_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b netdev_port_receive} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static rx_handler_result_t {\b netdev_frame_hook} (struct sk_buff **pskb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct net_device * {\b get_dpdev} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b netdev_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_port_rcu} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_detach_dev} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b netdev_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_netdev_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b packet_length} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b netdev_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_netdev_get_vport} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int __init {\b ovs_netdev_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_netdev_vport_ops}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v free_port_rcu\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:free_port_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_port_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157     struct netdev_vport *netdev_vport = container_of(rcu,\par
  158                     struct netdev_vport, rcu);\par
  159 \par
  160     dev_put(netdev_vport->dev);\par
  161     ovs_vport_free(vport_from_priv(netdev_vport));\par
  162 \}\par
}
}
{\xe \v get_dpdev\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:get_dpdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct net_device* get_dpdev (const struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90 \{\par
   91     struct vport *local;\par
   92 \par
   93     local = ovs_vport_ovsl(dp, OVSP_LOCAL);\par
   94     BUG_ON(!local);\par
   95     return netdev_vport_priv(local)->dev;\par
   96 \}\par
}
}
{\xe \v netdev_create\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:netdev_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* netdev_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99 \{\par
  100     struct vport *vport;\par
  101     struct netdev_vport *netdev_vport;\par
  102     int err;\par
  103 \par
  104     vport = ovs_vport_alloc(sizeof(struct netdev_vport),\par
  105                 &ovs_netdev_vport_ops, parms);\par
  106     if (IS_ERR(vport)) \{\par
  107         err = PTR_ERR(vport);\par
  108         goto error;\par
  109     \}\par
  110 \par
  111     netdev_vport = netdev_vport_priv(vport);\par
  112 \par
  113     netdev_vport->dev = dev_get_by_name(ovs_dp_get_net(vport->dp), parms->name);\par
  114     if (!netdev_vport->dev) \{\par
  115         err = -ENODEV;\par
  116         goto error_free_vport;\par
  117     \}\par
  118 \par
  119     if (netdev_vport->dev->flags & IFF_LOOPBACK ||\par
  120         netdev_vport->dev->type != ARPHRD_ETHER ||\par
  121         ovs_is_internal_dev(netdev_vport->dev)) \{\par
  122         err = -EINVAL;\par
  123         goto error_put;\par
  124     \}\par
  125 \par
  126     rtnl_lock();\par
  127     err = netdev_master_upper_dev_link(netdev_vport->dev,\par
  128                        get_dpdev(vport->dp));\par
  129     if (err)\par
  130         goto error_unlock;\par
  131 \par
  132     err = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\par
  133                      vport);\par
  134     if (err)\par
  135         goto error_master_upper_dev_unlink;\par
  136 \par
  137     dev_set_promiscuity(netdev_vport->dev, 1);\par
  138     netdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;\par
  139     rtnl_unlock();\par
  140 \par
  141     return vport;\par
  142 \par
  143 error_master_upper_dev_unlink:\par
  144     netdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));\par
  145 error_unlock:\par
  146     rtnl_unlock();\par
  147 error_put:\par
  148     dev_put(netdev_vport->dev);\par
  149 error_free_vport:\par
  150     ovs_vport_free(vport);\par
  151 error:\par
  152     return ERR_PTR(err);\par
  153 \}\par
}
}
{\xe \v netdev_destroy\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:netdev_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void netdev_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   177 \{\par
  178     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  179 \par
  180     rtnl_lock();\par
  181     if (ovs_netdev_get_vport(netdev_vport->dev))\par
  182         ovs_netdev_detach_dev(vport);\par
  183     rtnl_unlock();\par
  184 \par
  185     call_rcu(&netdev_vport->rcu, free_port_rcu);\par
  186 \}\par
}
}
{\xe \v netdev_frame_hook\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:netdev_frame_hook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static rx_handler_result_t netdev_frame_hook (struct sk_buff **  {\i pskb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     struct sk_buff *skb = *pskb;\par
   46     struct vport *vport;\par
   47 \par
   48     if (unlikely(skb->pkt_type == PACKET_LOOPBACK))\par
   49         return RX_HANDLER_PASS;\par
   50 \par
   51     vport = ovs_netdev_get_vport(skb->dev);\par
   52 \par
   53     netdev_port_receive(vport, skb);\par
   54 \par
   55     return RX_HANDLER_CONSUMED;\par
   56 \}\par
}
}
{\xe \v netdev_port_receive\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:netdev_port_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void netdev_port_receive (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   196 \{\par
  197     if (unlikely(!vport))\par
  198         goto error;\par
  199 \par
  200     if (unlikely(skb_warn_if_lro(skb)))\par
  201         goto error;\par
  202 \par
  203     /* Make our own copy of the packet.  Otherwise we will mangle the\par
  204      * packet for anyone who came before us (e.g. tcpdump via AF_PACKET).\par
  205      * (No one comes after us, since we tell handle_bridge() that we took\par
  206      * the packet.)\par
  207      */\par
  208     skb = skb_share_check(skb, GFP_ATOMIC);\par
  209     if (unlikely(!skb))\par
  210         return;\par
  211 \par
  212     skb_push(skb, ETH_HLEN);\par
  213     ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\par
  214 \par
  215     ovs_vport_receive(vport, skb, NULL);\par
  216     return;\par
  217 \par
  218 error:\par
  219     kfree_skb(skb);\par
  220 \}\par
}
}
{\xe \v netdev_send\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:netdev_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int netdev_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   233 \{\par
  234     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  235     int mtu = netdev_vport->dev->mtu;\par
  236     int len;\par
  237 \par
  238     if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) \{\par
  239         net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\\n",\par
  240                      netdev_vport->dev->name,\par
  241                      packet_length(skb), mtu);\par
  242         goto drop;\par
  243     \}\par
  244 \par
  245     skb->dev = netdev_vport->dev;\par
  246     len = skb->len;\par
  247     dev_queue_xmit(skb);\par
  248 \par
  249     return len;\par
  250 \par
  251 drop:\par
  252     kfree_skb(skb);\par
  253     return 0;\par
  254 \}\par
}
}
{\xe \v ovs_netdev_detach_dev\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_detach_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_detach_dev (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  167 \par
  168     ASSERT_RTNL();\par
  169     netdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\par
  170     netdev_rx_handler_unregister(netdev_vport->dev);\par
  171     netdev_upper_dev_unlink(netdev_vport->dev,\par
  172                 netdev_master_upper_dev_get(netdev_vport->dev));\par
  173     dev_set_promiscuity(netdev_vport->dev, -1);\par
  174 \}\par
}
}
{\xe \v ovs_netdev_exit\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_exit (void )}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     ovs_vport_ops_unregister(&ovs_netdev_vport_ops);\par
  294 \}\par
}
}
{\xe \v ovs_netdev_get_name\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_netdev_get_name (const struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   189 \{\par
  190     const struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  191     return netdev_vport->dev->name;\par
  192 \}\par
}
}
{\xe \v ovs_netdev_get_vport\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_netdev_get_vport (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \\\par
  260     defined HAVE_RHEL_OVS_HOOK\par
  261 #ifdef HAVE_OVS_DATAPATH\par
  262     if (likely(dev->priv_flags & IFF_OVS_DATAPATH))\par
  263 #else\par
  264     if (likely(rcu_access_pointer(dev->rx_handler) == netdev_frame_hook))\par
  265 #endif\par
  266 #ifdef HAVE_RHEL_OVS_HOOK\par
  267         return (struct vport *)rcu_dereference_rtnl(dev->ax25_ptr);\par
  268 #else\par
  269         return (struct vport *)rcu_dereference_rtnl(dev->rx_handler_data);\par
  270 #endif\par
  271     else\par
  272         return NULL;\par
  273 #else\par
  274     return (struct vport *)rcu_dereference_rtnl(dev->br_port);\par
  275 #endif\par
  276 \}\par
}
}
{\xe \v ovs_netdev_init\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __init ovs_netdev_init (void )}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   287 \{\par
  288     return ovs_vport_ops_register(&ovs_netdev_vport_ops);\par
  289 \}\par
}
}
{\xe \v packet_length\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:packet_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int packet_length (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224     unsigned int length = skb->len - ETH_HLEN;\par
  225 \par
  226     if (skb->protocol == htons(ETH_P_8021Q))\par
  227         length -= VLAN_HLEN;\par
  228 \par
  229     return length;\par
  230 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_netdev_vport_ops\:linux/vport-netdev.c}
{\xe \v linux/vport-netdev.c\:ovs_netdev_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_netdev_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type       = OVS_VPORT_TYPE_NETDEV,\par
    .create     = netdev_create,\par
    .destroy    = netdev_destroy,\par
    .get_name   = ovs_netdev_get_name,\par
    .send       = netdev_send,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-netdev.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-netdev.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-netdev.c}
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_arp.h>}\par
{\f2 #include <linux/if_bridge.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/llc.h>}\par
{\f2 #include <linux/rtnetlink.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/netdevice.h>}\par
{\f2 #include <net/llc.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vlan.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
{\f2 #include "vport-netdev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-netdev.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-netdev_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b netdev_port_receive} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static rx_handler_result_t {\b netdev_frame_hook} (struct sk_buff **pskb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct net_device * {\b get_dpdev} (const struct {\b datapath} *dp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b netdev_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b free_port_rcu} (struct rcu_head *rcu)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_detach_dev} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b netdev_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_netdev_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b packet_length} (const struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b netdev_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_netdev_get_vport} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int __init {\b ovs_netdev_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_exit} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_netdev_vport_ops}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:vport-netdev.c}
{\xe \v vport-netdev.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v free_port_rcu\:vport-netdev.c}
{\xe \v vport-netdev.c\:free_port_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_port_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   156 \{\par
  157     struct netdev_vport *netdev_vport = container_of(rcu,\par
  158                     struct netdev_vport, rcu);\par
  159 \par
  160     dev_put(netdev_vport->dev);\par
  161     ovs_vport_free(vport_from_priv(netdev_vport));\par
  162 \}\par
}
}
{\xe \v get_dpdev\:vport-netdev.c}
{\xe \v vport-netdev.c\:get_dpdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct net_device* get_dpdev (const struct {\b datapath} *  {\i dp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90 \{\par
   91     struct vport *local;\par
   92 \par
   93     local = ovs_vport_ovsl(dp, OVSP_LOCAL);\par
   94     BUG_ON(!local);\par
   95     return netdev_vport_priv(local)->dev;\par
   96 \}\par
}
}
{\xe \v netdev_create\:vport-netdev.c}
{\xe \v vport-netdev.c\:netdev_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* netdev_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99 \{\par
  100     struct vport *vport;\par
  101     struct netdev_vport *netdev_vport;\par
  102     int err;\par
  103 \par
  104     vport = ovs_vport_alloc(sizeof(struct netdev_vport),\par
  105                 &ovs_netdev_vport_ops, parms);\par
  106     if (IS_ERR(vport)) \{\par
  107         err = PTR_ERR(vport);\par
  108         goto error;\par
  109     \}\par
  110 \par
  111     netdev_vport = netdev_vport_priv(vport);\par
  112 \par
  113     netdev_vport->dev = dev_get_by_name(ovs_dp_get_net(vport->dp), parms->name);\par
  114     if (!netdev_vport->dev) \{\par
  115         err = -ENODEV;\par
  116         goto error_free_vport;\par
  117     \}\par
  118 \par
  119     if (netdev_vport->dev->flags & IFF_LOOPBACK ||\par
  120         netdev_vport->dev->type != ARPHRD_ETHER ||\par
  121         ovs_is_internal_dev(netdev_vport->dev)) \{\par
  122         err = -EINVAL;\par
  123         goto error_put;\par
  124     \}\par
  125 \par
  126     rtnl_lock();\par
  127     err = netdev_master_upper_dev_link(netdev_vport->dev,\par
  128                        get_dpdev(vport->dp));\par
  129     if (err)\par
  130         goto error_unlock;\par
  131 \par
  132     err = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\par
  133                      vport);\par
  134     if (err)\par
  135         goto error_master_upper_dev_unlink;\par
  136 \par
  137     dev_set_promiscuity(netdev_vport->dev, 1);\par
  138     netdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;\par
  139     rtnl_unlock();\par
  140 \par
  141     return vport;\par
  142 \par
  143 error_master_upper_dev_unlink:\par
  144     netdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));\par
  145 error_unlock:\par
  146     rtnl_unlock();\par
  147 error_put:\par
  148     dev_put(netdev_vport->dev);\par
  149 error_free_vport:\par
  150     ovs_vport_free(vport);\par
  151 error:\par
  152     return ERR_PTR(err);\par
  153 \}\par
}
}
{\xe \v netdev_destroy\:vport-netdev.c}
{\xe \v vport-netdev.c\:netdev_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void netdev_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   177 \{\par
  178     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  179 \par
  180     rtnl_lock();\par
  181     if (ovs_netdev_get_vport(netdev_vport->dev))\par
  182         ovs_netdev_detach_dev(vport);\par
  183     rtnl_unlock();\par
  184 \par
  185     call_rcu(&netdev_vport->rcu, free_port_rcu);\par
  186 \}\par
}
}
{\xe \v netdev_frame_hook\:vport-netdev.c}
{\xe \v vport-netdev.c\:netdev_frame_hook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static rx_handler_result_t netdev_frame_hook (struct sk_buff **  {\i pskb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44 \{\par
   45     struct sk_buff *skb = *pskb;\par
   46     struct vport *vport;\par
   47 \par
   48     if (unlikely(skb->pkt_type == PACKET_LOOPBACK))\par
   49         return RX_HANDLER_PASS;\par
   50 \par
   51     vport = ovs_netdev_get_vport(skb->dev);\par
   52 \par
   53     netdev_port_receive(vport, skb);\par
   54 \par
   55     return RX_HANDLER_CONSUMED;\par
   56 \}\par
}
}
{\xe \v netdev_port_receive\:vport-netdev.c}
{\xe \v vport-netdev.c\:netdev_port_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void netdev_port_receive (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   196 \{\par
  197     if (unlikely(!vport))\par
  198         goto error;\par
  199 \par
  200     if (unlikely(skb_warn_if_lro(skb)))\par
  201         goto error;\par
  202 \par
  203     /* Make our own copy of the packet.  Otherwise we will mangle the\par
  204      * packet for anyone who came before us (e.g. tcpdump via AF_PACKET).\par
  205      * (No one comes after us, since we tell handle_bridge() that we took\par
  206      * the packet.)\par
  207      */\par
  208     skb = skb_share_check(skb, GFP_ATOMIC);\par
  209     if (unlikely(!skb))\par
  210         return;\par
  211 \par
  212     skb_push(skb, ETH_HLEN);\par
  213     ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\par
  214 \par
  215     ovs_vport_receive(vport, skb, NULL);\par
  216     return;\par
  217 \par
  218 error:\par
  219     kfree_skb(skb);\par
  220 \}\par
}
}
{\xe \v netdev_send\:vport-netdev.c}
{\xe \v vport-netdev.c\:netdev_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int netdev_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   233 \{\par
  234     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  235     int mtu = netdev_vport->dev->mtu;\par
  236     int len;\par
  237 \par
  238     if (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) \{\par
  239         net_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\\n",\par
  240                      netdev_vport->dev->name,\par
  241                      packet_length(skb), mtu);\par
  242         goto drop;\par
  243     \}\par
  244 \par
  245     skb->dev = netdev_vport->dev;\par
  246     len = skb->len;\par
  247     dev_queue_xmit(skb);\par
  248 \par
  249     return len;\par
  250 \par
  251 drop:\par
  252     kfree_skb(skb);\par
  253     return 0;\par
  254 \}\par
}
}
{\xe \v ovs_netdev_detach_dev\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_detach_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_detach_dev (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  167 \par
  168     ASSERT_RTNL();\par
  169     netdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\par
  170     netdev_rx_handler_unregister(netdev_vport->dev);\par
  171     netdev_upper_dev_unlink(netdev_vport->dev,\par
  172                 netdev_master_upper_dev_get(netdev_vport->dev));\par
  173     dev_set_promiscuity(netdev_vport->dev, -1);\par
  174 \}\par
}
}
{\xe \v ovs_netdev_exit\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_exit (void )}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     ovs_vport_ops_unregister(&ovs_netdev_vport_ops);\par
  294 \}\par
}
}
{\xe \v ovs_netdev_get_name\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_netdev_get_name (const struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   189 \{\par
  190     const struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  191     return netdev_vport->dev->name;\par
  192 \}\par
}
}
{\xe \v ovs_netdev_get_vport\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_netdev_get_vport (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \\\par
  260     defined HAVE_RHEL_OVS_HOOK\par
  261 #ifdef HAVE_OVS_DATAPATH\par
  262     if (likely(dev->priv_flags & IFF_OVS_DATAPATH))\par
  263 #else\par
  264     if (likely(rcu_access_pointer(dev->rx_handler) == netdev_frame_hook))\par
  265 #endif\par
  266 #ifdef HAVE_RHEL_OVS_HOOK\par
  267         return (struct vport *)rcu_dereference_rtnl(dev->ax25_ptr);\par
  268 #else\par
  269         return (struct vport *)rcu_dereference_rtnl(dev->rx_handler_data);\par
  270 #endif\par
  271     else\par
  272         return NULL;\par
  273 #else\par
  274     return (struct vport *)rcu_dereference_rtnl(dev->br_port);\par
  275 #endif\par
  276 \}\par
}
}
{\xe \v ovs_netdev_init\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __init ovs_netdev_init (void )}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   287 \{\par
  288     return ovs_vport_ops_register(&ovs_netdev_vport_ops);\par
  289 \}\par
}
}
{\xe \v packet_length\:vport-netdev.c}
{\xe \v vport-netdev.c\:packet_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int packet_length (const struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224     unsigned int length = skb->len - ETH_HLEN;\par
  225 \par
  226     if (skb->protocol == htons(ETH_P_8021Q))\par
  227         length -= VLAN_HLEN;\par
  228 \par
  229     return length;\par
  230 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ovs_netdev_vport_ops\:vport-netdev.c}
{\xe \v vport-netdev.c\:ovs_netdev_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_netdev_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type       = OVS_VPORT_TYPE_NETDEV,\par
    .create     = netdev_create,\par
    .destroy    = netdev_destroy,\par
    .get_name   = ovs_netdev_get_name,\par
    .send       = netdev_send,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-stt.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-stt.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-stt.c}
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/stt.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-stt.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-stt_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:linux/vport-stt.c}
{\xe \v linux/vport-stt.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-stt.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-stt.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-stt.c}
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/stt.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-stt.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-stt_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:vport-stt.c}
{\xe \v vport-stt.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-stt.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-stt.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-stt.mod.c}
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-stt.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-stt_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"A6BA625537E148452E26A71")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:vport-stt.mod.c}
{\xe \v vport-stt.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-stt.mod.c}
{\xe \v vport-stt.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-stt.mod.c}
{\xe \v vport-stt.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-stt.mod.c}
{\xe \v vport-stt.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-stt.mod.c}
{\xe \v vport-stt.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "A6BA625537E148452E26A71" )}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-vxlan.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-vxlan.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-vxlan.c}
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/rtnetlink.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/vxlan.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
{\f2 #include "vport-vxlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-vxlan.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport-vxlan_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b vxlan_port} - Keeps track of open UDP ports : {\b vxlan_sock} created for the port. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_vxlan_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b exts_policy} [{\b OVS_VXLAN_EXT_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vxlan_port} * {\b vxlan_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_rcv} (struct {\b vxlan_sock} *vs, struct sk_buff *skb, struct {\b vxlan_metadata} *md)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_configure_exts} (struct {\b vport} *{\b vport}, struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b vxlan_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_ext_gbp} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_tnl_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b vxlan_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_vxlan_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_vxlan_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_vxlan_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_vxlan_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: VXLAN switching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-4")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MODULE_ALIAS\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-4" )}}
\par
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: VXLAN switching port" )}}
\par
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_vxlan_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_vxlan_tnl_init} )}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_vxlan_tnl_exit\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:ovs_vxlan_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_vxlan_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   316 \{\par
  317     ovs_vport_ops_unregister(&ovs_vxlan_vport_ops);\par
  318 \}\par
}
}
{\xe \v ovs_vxlan_tnl_init\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:ovs_vxlan_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_vxlan_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   311 \{\par
  312     return ovs_vport_ops_register(&ovs_vxlan_vport_ops);\par
  313 \}\par
}
}
{\xe \v vxlan_configure_exts\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_configure_exts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_configure_exts (struct {\b vport} *  {\i vport}, struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   132 \{\par
  133     struct nlattr *exts[OVS_VXLAN_EXT_MAX+1];\par
  134     struct vxlan_port *vxlan_port;\par
  135     int err;\par
  136 \par
  137     if (nla_len(attr) < sizeof(struct nlattr))\par
  138         return -EINVAL;\par
  139 \par
  140     err = nla_parse_nested(exts, OVS_VXLAN_EXT_MAX, attr, exts_policy);\par
  141     if (err < 0)\par
  142         return err;\par
  143 \par
  144     vxlan_port = vxlan_vport(vport);\par
  145 \par
  146     if (exts[OVS_VXLAN_EXT_GBP])\par
  147         vxlan_port->exts |= VXLAN_F_GBP;\par
  148 \par
  149     return 0;\par
  150 \}\par
}
}
{\xe \v vxlan_ext_gbp\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_ext_gbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_ext_gbp (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   208 \{\par
  209     const struct ovs_tunnel_info *tun_info;\par
  210     const struct ovs_vxlan_opts *opts;\par
  211 \par
  212     tun_info = OVS_CB(skb)->egress_tun_info;\par
  213     opts = tun_info->options;\par
  214 \par
  215     if (tun_info->tunnel.tun_flags & TUNNEL_VXLAN_OPT &&\par
  216         tun_info->options_len >= sizeof(*opts))\par
  217         return opts->gbp;\par
  218     else\par
  219         return 0;\par
  220 \}\par
}
}
{\xe \v vxlan_get_egress_tun_info\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     struct net *net = ovs_dp_get_net(vport->dp);\par
  281     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  282     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
  283     __be16 src_port;\par
  284 \par
  285     src_port = udp_flow_src_port(net, skb, 0, 0, true);\par
  286 \par
  287     return ovs_tunnel_get_egress_info(egress_tun_info, net,\par
  288                       OVS_CB(skb)->egress_tun_info,\par
  289                       IPPROTO_UDP, skb->mark,\par
  290                       src_port, dst_port);\par
  291 \}\par
}
}
{\xe \v vxlan_get_name\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* vxlan_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   294 \{\par
  295     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  296     return vxlan_port->name;\par
  297 \}\par
}
}
{\xe \v vxlan_get_options\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94 \{\par
   95     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
   96     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
   97 \par
   98     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\par
   99         return -EMSGSIZE;\par
  100 \par
  101     if (vxlan_port->exts) \{\par
  102         struct nlattr *exts;\par
  103 \par
  104         exts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);\par
  105         if (!exts)\par
  106             return -EMSGSIZE;\par
  107 \par
  108         if (vxlan_port->exts & VXLAN_F_GBP &&\par
  109             nla_put_flag(skb, OVS_VXLAN_EXT_GBP))\par
  110             return -EMSGSIZE;\par
  111 \par
  112         nla_nest_end(skb, exts);\par
  113     \}\par
  114 \par
  115     return 0;\par
  116 \}\par
}
}
{\xe \v vxlan_rcv\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_rcv (struct {\b vxlan_sock} *  {\i vs}, struct sk_buff *  {\i skb}, struct {\b vxlan_metadata} *  {\i md}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    67 \{\par
   68     struct ovs_tunnel_info tun_info;\par
   69     struct vxlan_port *vxlan_port;\par
   70     struct vport *vport = vs->data;\par
   71     struct iphdr *iph;\par
   72     struct ovs_vxlan_opts opts = \{\par
   73         .gbp = md->gbp,\par
   74     \};\par
   75     __be64 key;\par
   76     __be16 flags;\par
   77 \par
   78     flags = TUNNEL_KEY | (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0);\par
   79     vxlan_port = vxlan_vport(vport);\par
   80     if (vxlan_port->exts & VXLAN_F_GBP && md->gbp)\par
   81         flags |= TUNNEL_VXLAN_OPT;\par
   82 \par
   83     /* Save outer tunnel values */\par
   84     iph = ip_hdr(skb);\par
   85     key = cpu_to_be64(ntohl(md->vni) >> 8);\par
   86     ovs_flow_tun_info_init(&tun_info, iph,\par
   87                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
   88                    key, flags, &opts, sizeof(opts));\par
   89 \par
   90     ovs_vport_receive(vport, skb, &tun_info);\par
   91 \}\par
}
}
{\xe \v vxlan_tnl_create\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* vxlan_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154     struct net *net = ovs_dp_get_net(parms->dp);\par
  155     struct nlattr *options = parms->options;\par
  156     struct vxlan_port *vxlan_port;\par
  157     struct vxlan_sock *vs;\par
  158     struct vport *vport;\par
  159     struct nlattr *a;\par
  160     u16 dst_port;\par
  161     int err;\par
  162 \par
  163     if (!options) \{\par
  164         err = -EINVAL;\par
  165         goto error;\par
  166     \}\par
  167     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  168     if (a && nla_len(a) == sizeof(u16)) \{\par
  169         dst_port = nla_get_u16(a);\par
  170     \} else \{\par
  171         /* Require destination port from userspace. */\par
  172         err = -EINVAL;\par
  173         goto error;\par
  174     \}\par
  175 \par
  176     vport = ovs_vport_alloc(sizeof(struct vxlan_port),\par
  177                 &ovs_vxlan_vport_ops, parms);\par
  178     if (IS_ERR(vport))\par
  179         return vport;\par
  180 \par
  181     vxlan_port = vxlan_vport(vport);\par
  182     strncpy(vxlan_port->name, parms->name, IFNAMSIZ);\par
  183 \par
  184     a = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);\par
  185     if (a) \{\par
  186         err = vxlan_configure_exts(vport, a);\par
  187         if (err) \{\par
  188             ovs_vport_free(vport);\par
  189             goto error;\par
  190         \}\par
  191     \}\par
  192 \par
  193     vs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, true,\par
  194                 vxlan_port->exts);\par
  195     if (IS_ERR(vs)) \{\par
  196         ovs_vport_free(vport);\par
  197         return (void *)vs;\par
  198     \}\par
  199     vxlan_port->vs = vs;\par
  200 \par
  201     return vport;\par
  202 \par
  203 error:\par
  204     return ERR_PTR(err);\par
  205 \}\par
}
}
{\xe \v vxlan_tnl_destroy\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  121 \par
  122     vxlan_sock_release(vxlan_port->vs);\par
  123 \par
  124     ovs_vport_deferred_free(vport);\par
  125 \}\par
}
}
{\xe \v vxlan_tnl_send\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_tnl_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_tnl_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224     struct ovs_key_ipv4_tunnel *tun_key;\par
  225     struct net *net = ovs_dp_get_net(vport->dp);\par
  226     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  227     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
  228     struct vxlan_metadata md = \{0\};\par
  229     struct rtable *rt;\par
  230     __be16 src_port;\par
  231     __be32 saddr;\par
  232     __be16 df;\par
  233     int err;\par
  234     u32 vxflags;\par
  235 \par
  236     if (unlikely(!OVS_CB(skb)->egress_tun_info)) \{\par
  237         err = -EINVAL;\par
  238         goto error;\par
  239     \}\par
  240 \par
  241     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  242 \par
  243     /* Route lookup */\par
  244     saddr = tun_key->ipv4_src;\par
  245     rt = find_route(ovs_dp_get_net(vport->dp),\par
  246             &saddr, tun_key->ipv4_dst,\par
  247             IPPROTO_UDP, tun_key->ipv4_tos,\par
  248             skb->mark);\par
  249     if (IS_ERR(rt)) \{\par
  250         err = PTR_ERR(rt);\par
  251         goto error;\par
  252     \}\par
  253 \par
  254     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  255     skb->ignore_df = 1;\par
  256 \par
  257     src_port = udp_flow_src_port(net, skb, 0, 0, true);\par
  258     md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);\par
  259     md.gbp = vxlan_ext_gbp(skb);\par
  260     vxflags = vxlan_port->exts |\par
  261               (tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);\par
  262 \par
  263     err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,\par
  264                  saddr, tun_key->ipv4_dst,\par
  265                  tun_key->ipv4_tos,\par
  266                  tun_key->ipv4_ttl, df,\par
  267                  src_port, dst_port,\par
  268                  &md, false, vxflags);\par
  269     if (err < 0)\par
  270         ip_rt_put(rt);\par
  271     return err;\par
  272 error:\par
  273     kfree_skb(skb);\par
  274     return err;\par
  275 \}\par
}
}
{\xe \v vxlan_vport\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:vxlan_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vxlan_port}* vxlan_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return vport_priv(vport);\par
   63 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v exts_policy\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:exts_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy exts_policy[{\b OVS_VXLAN_EXT_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VXLAN_EXT_GBP] = \{ .type = NLA_FLAG, \},\par
\}\par
}
}
{\xe \v ovs_vxlan_vport_ops\:linux/vport-vxlan.c}
{\xe \v linux/vport-vxlan.c\:ovs_vxlan_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_vxlan_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_VXLAN,\par
    .create         = vxlan_tnl_create,\par
    .destroy        = vxlan_tnl_destroy,\par
    .get_name       = vxlan_get_name,\par
    .get_options        = vxlan_get_options,\par
    .send           = vxlan_tnl_send,\par
    .get_egress_tun_info    = vxlan_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-vxlan.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-vxlan.c}
{\xe \v /home/vladn/git/ovs/datapath/vport-vxlan.c}
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/version.h>}\par
{\f2 #include <linux/in.h>}\par
{\f2 #include <linux/ip.h>}\par
{\f2 #include <linux/net.h>}\par
{\f2 #include <linux/rculist.h>}\par
{\f2 #include <linux/udp.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <net/icmp.h>}\par
{\f2 #include <net/ip.h>}\par
{\f2 #include <net/udp.h>}\par
{\f2 #include <net/ip_tunnels.h>}\par
{\f2 #include <net/rtnetlink.h>}\par
{\f2 #include <net/route.h>}\par
{\f2 #include <net/dsfield.h>}\par
{\f2 #include <net/inet_ecn.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include <net/netns/generic.h>}\par
{\f2 #include <net/vxlan.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
{\f2 #include "vport-vxlan.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-vxlan.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-vxlan_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vxlan_port}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b pr_fmt}(fmt)\~ KBUILD_MODNAME ": " fmt\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: vport name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
struct {\b vxlan_port} - Keeps track of open UDP ports : {\b vxlan_sock} created for the port. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport_ops} {\b ovs_vxlan_vport_ops}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct nla_policy {\b exts_policy} [{\b OVS_VXLAN_EXT_MAX}+1]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vxlan_port} * {\b vxlan_vport} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_rcv} (struct {\b vxlan_sock} *vs, struct sk_buff *skb, struct {\b vxlan_metadata} *md)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vxlan_tnl_destroy} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_configure_exts} (struct {\b vport} *{\b vport}, struct nlattr *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b vxlan_tnl_create} (const struct {\b vport_parms} *parms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_ext_gbp} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_tnl_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b vxlan_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *egress_tun_info)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b vxlan_get_name} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int __init {\b ovs_vxlan_tnl_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void __exit {\b ovs_vxlan_tnl_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_init} ({\b ovs_vxlan_tnl_init})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b module_exit} ({\b ovs_vxlan_tnl_exit})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_DESCRIPTION} ("OVS: VXLAN switching port")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_LICENSE} ("GPL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_ALIAS} ("vport-{\b type}-4")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v pr_fmt\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:pr_fmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define pr_fmt( fmt)\~ KBUILD_MODNAME ": " fmt}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MODULE_ALIAS\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:MODULE_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_ALIAS ("vport-{\b type}-4" )}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_DESCRIPTION\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:MODULE_DESCRIPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_DESCRIPTION ("OVS: VXLAN switching port" )}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_exit\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:module_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_exit ({\b ovs_vxlan_tnl_exit} )}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v module_init\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:module_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
module_init ({\b ovs_vxlan_tnl_init} )}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_LICENSE\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:MODULE_LICENSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_LICENSE ("GPL" )}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_vxlan_tnl_exit\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:ovs_vxlan_tnl_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __exit ovs_vxlan_tnl_exit (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   316 \{\par
  317     ovs_vport_ops_unregister(&ovs_vxlan_vport_ops);\par
  318 \}\par
}
}
{\xe \v ovs_vxlan_tnl_init\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:ovs_vxlan_tnl_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __init ovs_vxlan_tnl_init (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   311 \{\par
  312     return ovs_vport_ops_register(&ovs_vxlan_vport_ops);\par
  313 \}\par
}
}
{\xe \v vxlan_configure_exts\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_configure_exts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_configure_exts (struct {\b vport} *  {\i vport}, struct nlattr *  {\i attr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   132 \{\par
  133     struct nlattr *exts[OVS_VXLAN_EXT_MAX+1];\par
  134     struct vxlan_port *vxlan_port;\par
  135     int err;\par
  136 \par
  137     if (nla_len(attr) < sizeof(struct nlattr))\par
  138         return -EINVAL;\par
  139 \par
  140     err = nla_parse_nested(exts, OVS_VXLAN_EXT_MAX, attr, exts_policy);\par
  141     if (err < 0)\par
  142         return err;\par
  143 \par
  144     vxlan_port = vxlan_vport(vport);\par
  145 \par
  146     if (exts[OVS_VXLAN_EXT_GBP])\par
  147         vxlan_port->exts |= VXLAN_F_GBP;\par
  148 \par
  149     return 0;\par
  150 \}\par
}
}
{\xe \v vxlan_ext_gbp\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_ext_gbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_ext_gbp (struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   208 \{\par
  209     const struct ovs_tunnel_info *tun_info;\par
  210     const struct ovs_vxlan_opts *opts;\par
  211 \par
  212     tun_info = OVS_CB(skb)->egress_tun_info;\par
  213     opts = tun_info->options;\par
  214 \par
  215     if (tun_info->tunnel.tun_flags & TUNNEL_VXLAN_OPT &&\par
  216         tun_info->options_len >= sizeof(*opts))\par
  217         return opts->gbp;\par
  218     else\par
  219         return 0;\par
  220 \}\par
}
}
{\xe \v vxlan_get_egress_tun_info\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i egress_tun_info}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     struct net *net = ovs_dp_get_net(vport->dp);\par
  281     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  282     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
  283     __be16 src_port;\par
  284 \par
  285     src_port = udp_flow_src_port(net, skb, 0, 0, true);\par
  286 \par
  287     return ovs_tunnel_get_egress_info(egress_tun_info, net,\par
  288                       OVS_CB(skb)->egress_tun_info,\par
  289                       IPPROTO_UDP, skb->mark,\par
  290                       src_port, dst_port);\par
  291 \}\par
}
}
{\xe \v vxlan_get_name\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* vxlan_get_name (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   294 \{\par
  295     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  296     return vxlan_port->name;\par
  297 \}\par
}
}
{\xe \v vxlan_get_options\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94 \{\par
   95     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
   96     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
   97 \par
   98     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\par
   99         return -EMSGSIZE;\par
  100 \par
  101     if (vxlan_port->exts) \{\par
  102         struct nlattr *exts;\par
  103 \par
  104         exts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);\par
  105         if (!exts)\par
  106             return -EMSGSIZE;\par
  107 \par
  108         if (vxlan_port->exts & VXLAN_F_GBP &&\par
  109             nla_put_flag(skb, OVS_VXLAN_EXT_GBP))\par
  110             return -EMSGSIZE;\par
  111 \par
  112         nla_nest_end(skb, exts);\par
  113     \}\par
  114 \par
  115     return 0;\par
  116 \}\par
}
}
{\xe \v vxlan_rcv\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_rcv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_rcv (struct {\b vxlan_sock} *  {\i vs}, struct sk_buff *  {\i skb}, struct {\b vxlan_metadata} *  {\i md}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    67 \{\par
   68     struct ovs_tunnel_info tun_info;\par
   69     struct vxlan_port *vxlan_port;\par
   70     struct vport *vport = vs->data;\par
   71     struct iphdr *iph;\par
   72     struct ovs_vxlan_opts opts = \{\par
   73         .gbp = md->gbp,\par
   74     \};\par
   75     __be64 key;\par
   76     __be16 flags;\par
   77 \par
   78     flags = TUNNEL_KEY | (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0);\par
   79     vxlan_port = vxlan_vport(vport);\par
   80     if (vxlan_port->exts & VXLAN_F_GBP && md->gbp)\par
   81         flags |= TUNNEL_VXLAN_OPT;\par
   82 \par
   83     /* Save outer tunnel values */\par
   84     iph = ip_hdr(skb);\par
   85     key = cpu_to_be64(ntohl(md->vni) >> 8);\par
   86     ovs_flow_tun_info_init(&tun_info, iph,\par
   87                    udp_hdr(skb)->source, udp_hdr(skb)->dest,\par
   88                    key, flags, &opts, sizeof(opts));\par
   89 \par
   90     ovs_vport_receive(vport, skb, &tun_info);\par
   91 \}\par
}
}
{\xe \v vxlan_tnl_create\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_tnl_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* vxlan_tnl_create (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154     struct net *net = ovs_dp_get_net(parms->dp);\par
  155     struct nlattr *options = parms->options;\par
  156     struct vxlan_port *vxlan_port;\par
  157     struct vxlan_sock *vs;\par
  158     struct vport *vport;\par
  159     struct nlattr *a;\par
  160     u16 dst_port;\par
  161     int err;\par
  162 \par
  163     if (!options) \{\par
  164         err = -EINVAL;\par
  165         goto error;\par
  166     \}\par
  167     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\par
  168     if (a && nla_len(a) == sizeof(u16)) \{\par
  169         dst_port = nla_get_u16(a);\par
  170     \} else \{\par
  171         /* Require destination port from userspace. */\par
  172         err = -EINVAL;\par
  173         goto error;\par
  174     \}\par
  175 \par
  176     vport = ovs_vport_alloc(sizeof(struct vxlan_port),\par
  177                 &ovs_vxlan_vport_ops, parms);\par
  178     if (IS_ERR(vport))\par
  179         return vport;\par
  180 \par
  181     vxlan_port = vxlan_vport(vport);\par
  182     strncpy(vxlan_port->name, parms->name, IFNAMSIZ);\par
  183 \par
  184     a = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);\par
  185     if (a) \{\par
  186         err = vxlan_configure_exts(vport, a);\par
  187         if (err) \{\par
  188             ovs_vport_free(vport);\par
  189             goto error;\par
  190         \}\par
  191     \}\par
  192 \par
  193     vs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, true,\par
  194                 vxlan_port->exts);\par
  195     if (IS_ERR(vs)) \{\par
  196         ovs_vport_free(vport);\par
  197         return (void *)vs;\par
  198     \}\par
  199     vxlan_port->vs = vs;\par
  200 \par
  201     return vport;\par
  202 \par
  203 error:\par
  204     return ERR_PTR(err);\par
  205 \}\par
}
}
{\xe \v vxlan_tnl_destroy\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_tnl_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vxlan_tnl_destroy (struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  121 \par
  122     vxlan_sock_release(vxlan_port->vs);\par
  123 \par
  124     ovs_vport_deferred_free(vport);\par
  125 \}\par
}
}
{\xe \v vxlan_tnl_send\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_tnl_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int vxlan_tnl_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{\par
  224     struct ovs_key_ipv4_tunnel *tun_key;\par
  225     struct net *net = ovs_dp_get_net(vport->dp);\par
  226     struct vxlan_port *vxlan_port = vxlan_vport(vport);\par
  227     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);\par
  228     struct vxlan_metadata md = \{0\};\par
  229     struct rtable *rt;\par
  230     __be16 src_port;\par
  231     __be32 saddr;\par
  232     __be16 df;\par
  233     int err;\par
  234     u32 vxflags;\par
  235 \par
  236     if (unlikely(!OVS_CB(skb)->egress_tun_info)) \{\par
  237         err = -EINVAL;\par
  238         goto error;\par
  239     \}\par
  240 \par
  241     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\par
  242 \par
  243     /* Route lookup */\par
  244     saddr = tun_key->ipv4_src;\par
  245     rt = find_route(ovs_dp_get_net(vport->dp),\par
  246             &saddr, tun_key->ipv4_dst,\par
  247             IPPROTO_UDP, tun_key->ipv4_tos,\par
  248             skb->mark);\par
  249     if (IS_ERR(rt)) \{\par
  250         err = PTR_ERR(rt);\par
  251         goto error;\par
  252     \}\par
  253 \par
  254     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\par
  255     skb->ignore_df = 1;\par
  256 \par
  257     src_port = udp_flow_src_port(net, skb, 0, 0, true);\par
  258     md.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);\par
  259     md.gbp = vxlan_ext_gbp(skb);\par
  260     vxflags = vxlan_port->exts |\par
  261               (tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);\par
  262 \par
  263     err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,\par
  264                  saddr, tun_key->ipv4_dst,\par
  265                  tun_key->ipv4_tos,\par
  266                  tun_key->ipv4_ttl, df,\par
  267                  src_port, dst_port,\par
  268                  &md, false, vxflags);\par
  269     if (err < 0)\par
  270         ip_rt_put(rt);\par
  271     return err;\par
  272 error:\par
  273     kfree_skb(skb);\par
  274     return err;\par
  275 \}\par
}
}
{\xe \v vxlan_vport\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:vxlan_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vxlan_port}* vxlan_vport (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    61 \{\par
   62     return vport_priv(vport);\par
   63 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v exts_policy\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:exts_policy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const struct nla_policy exts_policy[{\b OVS_VXLAN_EXT_MAX}+1]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    [OVS_VXLAN_EXT_GBP] = \{ .type = NLA_FLAG, \},\par
\}\par
}
}
{\xe \v ovs_vxlan_vport_ops\:vport-vxlan.c}
{\xe \v vport-vxlan.c\:ovs_vxlan_vport_ops}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops} ovs_vxlan_vport_ops{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .type           = OVS_VPORT_TYPE_VXLAN,\par
    .create         = vxlan_tnl_create,\par
    .destroy        = vxlan_tnl_destroy,\par
    .get_name       = vxlan_get_name,\par
    .get_options        = vxlan_get_options,\par
    .send           = vxlan_tnl_send,\par
    .get_egress_tun_info    = vxlan_get_egress_tun_info,\par
    .owner          = THIS_MODULE,\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport-vxlan.mod.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport-vxlan.mod.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport-vxlan.mod.c}
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/module.h>}\par
{\f2 #include <linux/vermagic.h>}\par
{\f2 #include <linux/compiler.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-vxlan.mod.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-vxlan_8mod_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (vermagic, VERMAGIC_STRING)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
__visible struct module __this_module {\b __attribute__} ((section(".gnu.linkonce.this_module")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const struct modversion_info ____versions[] __used {\b __attribute__} ((section("__versions")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char __module_depends[] __used {\b __attribute__} ((section(".modinfo")))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MODULE_INFO} (srcversion,"6E49FC69118A97855434D3D")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:vport-vxlan.mod.c}
{\xe \v vport-vxlan.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__visible struct module __this_module __attribute__ ((section(".gnu.linkonce.this_module")) )}}
\par
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-vxlan.mod.c}
{\xe \v vport-vxlan.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const struct modversion_info ____versions [] __used __attribute__ ((section("__versions")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:vport-vxlan.mod.c}
{\xe \v vport-vxlan.mod.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char __module_depends [] __used __attribute__ ((section(".modinfo")) ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-vxlan.mod.c}
{\xe \v vport-vxlan.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (vermagic , VERMAGIC_STRING )}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MODULE_INFO\:vport-vxlan.mod.c}
{\xe \v vport-vxlan.mod.c\:MODULE_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MODULE_INFO (srcversion , "6E49FC69118A97855434D3D" )}}
\par
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/linux/vport.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/linux/vport.c}
{\xe \v /home/vladn/git/ovs/datapath/linux/vport.c}
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/kconfig.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/mutex.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/rtnetlink.h>}\par
{\f2 #include <linux/compat.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vport.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "linux_2vport_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VPORT_HASH_BUCKETS}\~ 1024\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (vport_ops_list)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b hash_bucket} (const struct net *net, const char *name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_ops_register} (struct {\b vport_ops} *ops)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_ops_register})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_ops_unregister} (struct {\b vport_ops} *ops)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_ops_unregister})\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid : name of port to find\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_locate - find a port that has already been created\par
Must be called with ovs or RCU read lock. \par
}}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b ovs_vport_record_error} (struct {\b vport} *, enum {\b vport_err_type} err_type)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_locate} (const struct net *net, const char *name)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_alloc} (int priv_size, const struct {\b vport_ops} *ops, const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_alloc})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static struct {\b vport_ops} * {\b ovs_vport_lookup} (const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_free} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_free})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_add} (const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_set_options} (struct {\b vport} *{\b vport}, struct nlattr *options)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_del} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_get_stats} (struct {\b vport} *{\b vport}, struct {\b ovs_vport_stats} *stats)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b vport_portids_destroy_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_set_upcall_portids} (struct {\b vport} *{\b vport}, const struct nlattr *ids)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_upcall_portids} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
u32 {\b ovs_vport_find_upcall_portid} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_receive} (struct {\b vport} *{\b vport}, struct sk_buff *skb, const struct {\b ovs_tunnel_info} *tun_info)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_receive})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b free_vport_rcu} (struct rcu_head *rcu)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_deferred_free} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_deferred_free})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_tunnel_get_egress_info} (struct {\b ovs_tunnel_info} *egress_tun_info, struct net *net, const struct {\b ovs_tunnel_info} *tun_info, u8 ipproto, u32 {\b skb_mark}, __be16 {\b tp_src}, __be16 {\b tp_dst})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_tunnel_get_egress_info})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *info)\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b dev_table}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v VPORT_HASH_BUCKETS\:linux/vport.c}
{\xe \v linux/vport.c\:VPORT_HASH_BUCKETS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VPORT_HASH_BUCKETS\~ 1024}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_ops_register} )}}
\par
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_ops_unregister} )}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_alloc} )}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_free} )}}
\par
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_receive} )}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_deferred_free} )}}
\par
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:linux/vport.c}
{\xe \v linux/vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_tunnel_get_egress_info} )}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v free_vport_rcu\:linux/vport.c}
{\xe \v linux/vport.c\:free_vport_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_vport_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   571 \{\par
  572     struct vport *vport = container_of(rcu, struct vport, rcu);\par
  573 \par
  574     ovs_vport_free(vport);\par
  575 \}\par
}
}
{\xe \v hash_bucket\:linux/vport.c}
{\xe \v linux/vport.c\:hash_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* hash_bucket (const struct net *  {\i net}, const char *  {\i name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75 \{\par
   76     unsigned int hash = jhash(name, strlen(name), (unsigned long) net);\par
   77     return &dev_table[hash & (VPORT_HASH_BUCKETS - 1)];\par
   78 \}\par
}
}
{\xe \v LIST_HEAD\:linux/vport.c}
{\xe \v linux/vport.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (vport_ops_list ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_tunnel_get_egress_info\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_tunnel_get_egress_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_tunnel_get_egress_info (struct {\b ovs_tunnel_info} *  {\i egress_tun_info}, struct net *  {\i net}, const struct {\b ovs_tunnel_info} *  {\i tun_info}, u8  {\i ipproto}, u32  {\i skb_mark}, __be16  {\i tp_src}, __be16  {\i tp_dst})}}
\par
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   593 \{\par
  594     const struct ovs_key_ipv4_tunnel *tun_key;\par
  595     struct rtable *rt;\par
  596     __be32 saddr;\par
  597 \par
  598     if (unlikely(!tun_info))\par
  599         return -EINVAL;\par
  600 \par
  601     tun_key = &tun_info->tunnel;\par
  602     saddr = tun_key->ipv4_src;\par
  603     /* Route lookup to get srouce IP address: saddr.\par
  604      * The process may need to be changed if the corresponding process\par
  605      * in vports ops changed.\par
  606      */\par
  607     rt = find_route(net,\par
  608             &saddr,\par
  609             tun_key->ipv4_dst,\par
  610             ipproto,\par
  611             tun_key->ipv4_tos,\par
  612             skb_mark);\par
  613     if (IS_ERR(rt))\par
  614         return PTR_ERR(rt);\par
  615 \par
  616     ip_rt_put(rt);\par
  617 \par
  618     /* Generate egress_tun_info based on tun_info,\par
  619      * saddr, tp_src and tp_dst\par
  620      */\par
  621     __ovs_flow_tun_info_init(egress_tun_info,\par
  622                  saddr, tun_key->ipv4_dst,\par
  623                  tun_key->ipv4_tos,\par
  624                  tun_key->ipv4_ttl,\par
  625                  tp_src, tp_dst,\par
  626                  tun_key->tun_id,\par
  627                  tun_key->tun_flags,\par
  628                  tun_info->options,\par
  629                  tun_info->options_len);\par
  630 \par
  631     return 0;\par
  632 \}\par
}
}
{\xe \v ovs_vport_add\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_add (const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_add - add vport device (for kernel callers)\par
: Information about new vport.\par
Creates a new vport with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   211 \{\par
  212     struct vport_ops *ops;\par
  213     struct vport *vport;\par
  214 \par
  215     ops = ovs_vport_lookup(parms);\par
  216     if (ops) \{\par
  217         struct hlist_head *bucket;\par
  218 \par
  219         if (!try_module_get(ops->owner))\par
  220             return ERR_PTR(-EAFNOSUPPORT);\par
  221 \par
  222         vport = ops->create(parms);\par
  223         if (IS_ERR(vport)) \{\par
  224             module_put(ops->owner);\par
  225             return vport;\par
  226         \}\par
  227 \par
  228         bucket = hash_bucket(ovs_dp_get_net(vport->dp),\par
  229                      vport->ops->get_name(vport));\par
  230         hlist_add_head_rcu(&vport->hash_node, bucket);\par
  231         return vport;\par
  232     \}\par
  233 \par
  234     /* Unlock to attempt module load and return -EAGAIN if load\par
  235      * was successful as we need to restart the port addition\par
  236      * workflow.\par
  237      */\par
  238     ovs_unlock();\par
  239     request_module("vport-type-%d", parms->type);\par
  240     ovs_lock();\par
  241 \par
  242     if (!ovs_vport_lookup(parms))\par
  243         return ERR_PTR(-EAFNOSUPPORT);\par
  244     else\par
  245         return ERR_PTR(-EAGAIN);\par
  246 \}\par
}
}
{\xe \v ovs_vport_alloc\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_alloc (int  {\i priv_size}, const struct {\b vport_ops} *  {\i ops}, const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_alloc - allocate and initialize new vport\par
: Size of private data area to allocate. : vport device ops\par
Allocate and initialize a new vport defined by . The vport will contain a private data area of size  that can be accessed using {\b vport_priv()}. vports that are no longer needed should be released with {\b ovs_vport_free()}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   139 \{\par
  140     struct vport *vport;\par
  141     size_t alloc_size;\par
  142 \par
  143     alloc_size = sizeof(struct vport);\par
  144     if (priv_size) \{\par
  145         alloc_size = ALIGN(alloc_size, VPORT_ALIGN);\par
  146         alloc_size += priv_size;\par
  147     \}\par
  148 \par
  149     vport = kzalloc(alloc_size, GFP_KERNEL);\par
  150     if (!vport)\par
  151         return ERR_PTR(-ENOMEM);\par
  152 \par
  153     vport->dp = parms->dp;\par
  154     vport->port_no = parms->port_no;\par
  155     vport->ops = ops;\par
  156     INIT_HLIST_NODE(&vport->dp_hash_node);\par
  157 \par
  158     if (ovs_vport_set_upcall_portids(vport, parms->upcall_portids)) \{\par
  159         kfree(vport);\par
  160         return ERR_PTR(-EINVAL);\par
  161     \}\par
  162 \par
  163     vport->percpu_stats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\par
  164     if (!vport->percpu_stats) \{\par
  165         kfree(vport);\par
  166         return ERR_PTR(-ENOMEM);\par
  167     \}\par
  168 \par
  169     return vport;\par
  170 \}\par
}
}
{\xe \v ovs_vport_deferred_free\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_deferred_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_deferred_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579     if (!vport)\par
  580         return;\par
  581 \par
  582     call_rcu(&vport->rcu, free_vport_rcu);\par
  583 \}\par
}
}
{\xe \v ovs_vport_del\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_del (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_del - delete existing vport device\par
: vport to delete.\par
Detaches  from its datapath and destroys it. It is possible to fail for reasons such as lack of memory. ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     ASSERT_OVSL();\par
  275 \par
  276     hlist_del_rcu(&vport->hash_node);\par
  277     module_put(vport->ops->owner);\par
  278     vport->ops->destroy(vport);\par
  279 \}\par
}
}
{\xe \v ovs_vport_exit\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_exit (void )}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_exit - shutdown vport subsystem\par
Called at module exit time to shutdown the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71     kfree(dev_table);\par
   72 \}\par
}
}
{\xe \v ovs_vport_find_upcall_portid\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_find_upcall_portid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_vport_find_upcall_portid (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_find_upcall_portid - find the upcall portid to send upcall.\par
: vport from which the missed packet is received. : skb that the missed packet was received.\par
Uses the {\b skb_get_hash()} to select the upcall portid to send the upcall.\par
Returns the portid of the target socket. Must be called with rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   459 \{\par
  460     struct vport_portids *ids;\par
  461     u32 hash;\par
  462 \par
  463     ids = rcu_dereference(vport->upcall_portids);\par
  464 \par
  465     if (ids->n_ids == 1 && ids->ids[0] == 0)\par
  466         return 0;\par
  467 \par
  468     hash = skb_get_hash(skb);\par
  469     return ids->ids[hash - ids->n_ids * reciprocal_divide(hash, ids->rn_ids)];\par
  470 \}\par
}
}
{\xe \v ovs_vport_free\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_free - uninitialize and free vport\par
: vport to free\par
Frees a vport allocated with {\b ovs_vport_alloc()} when it is no longer needed.\par
The caller must ensure that an RCU grace period has passed since the last time  was in a datapath. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195 \{\par
  196     kfree(rcu_dereference_raw(vport->upcall_portids));\par
  197     free_percpu(vport->percpu_stats);\par
  198     kfree(vport);\par
  199 \}\par
}
}
{\xe \v ovs_vport_get_egress_tun_info\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i info})}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   637 \{\par
  638     /* get_egress_tun_info() is only implemented on tunnel ports. */\par
  639     if (unlikely(!vport->ops->get_egress_tun_info))\par
  640         return -EINVAL;\par
  641 \par
  642     return vport->ops->get_egress_tun_info(vport, skb, info);\par
  643 \}\par
}
}
{\xe \v ovs_vport_get_options\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_options - retrieve device options\par
: vport from which to retrieve the options. : sk_buff where options should be appended.\par
Retrieves the configuration of the given device, appending an OVS_VPORT_ATTR_OPTIONS attribute that in turn contains nested vport-specific attributes to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room, or another negative error code if a real error occurred. If an error occurs,  is left unmodified.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351 \{\par
  352     struct nlattr *nla;\par
  353     int err;\par
  354 \par
  355     if (!vport->ops->get_options)\par
  356         return 0;\par
  357 \par
  358     nla = nla_nest_start(skb, OVS_VPORT_ATTR_OPTIONS);\par
  359     if (!nla)\par
  360         return -EMSGSIZE;\par
  361 \par
  362     err = vport->ops->get_options(vport, skb);\par
  363     if (err) \{\par
  364         nla_nest_cancel(skb, nla);\par
  365         return err;\par
  366     \}\par
  367 \par
  368     nla_nest_end(skb, nla);\par
  369     return 0;\par
  370 \}\par
}
}
{\xe \v ovs_vport_get_stats\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_get_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_get_stats (struct {\b vport} *  {\i vport}, struct {\b ovs_vport_stats} *  {\i stats})}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_stats - retrieve device stats\par
: vport from which to retrieve the stats : location to store stats\par
Retrieves transmit, receive, and error stats for the given device.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int i;\par
  294 \par
  295     /* We potentially have two surces of stats that need to be\par
  296      * combined: those we have collected (split into err_stats and\par
  297      * percpu_stats), and device error stats from netdev->get_stats()\par
  298      * (for errors that happen downstream and therefore aren't\par
  299      * reported through our vport_record_error() function).\par
  300      * Stats from first source are reported by ovs over\par
  301      * OVS_VPORT_ATTR_STATS.\par
  302      * netdev-stats can be directly read over netlink-ioctl.\par
  303      */\par
  304 \par
  305     stats->rx_errors  = atomic_long_read(&vport->err_stats.rx_errors);\par
  306     stats->tx_errors  = atomic_long_read(&vport->err_stats.tx_errors);\par
  307     stats->tx_dropped = atomic_long_read(&vport->err_stats.tx_dropped);\par
  308     stats->rx_dropped = atomic_long_read(&vport->err_stats.rx_dropped);\par
  309 \par
  310     stats->rx_bytes     = 0;\par
  311     stats->rx_packets   = 0;\par
  312     stats->tx_bytes     = 0;\par
  313     stats->tx_packets   = 0;\par
  314 \par
  315     for_each_possible_cpu(i) \{\par
  316         const struct pcpu_sw_netstats *percpu_stats;\par
  317         struct pcpu_sw_netstats local_stats;\par
  318         unsigned int start;\par
  319 \par
  320         percpu_stats = per_cpu_ptr(vport->percpu_stats, i);\par
  321 \par
  322         do \{\par
  323             start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);\par
  324             local_stats = *percpu_stats;\par
  325         \} while (u64_stats_fetch_retry_irq(&percpu_stats->syncp, start));\par
  326 \par
  327         stats->rx_bytes     += local_stats.rx_bytes;\par
  328         stats->rx_packets   += local_stats.rx_packets;\par
  329         stats->tx_bytes     += local_stats.tx_bytes;\par
  330         stats->tx_packets   += local_stats.tx_packets;\par
  331     \}\par
  332 \}\par
}
}
{\xe \v ovs_vport_get_upcall_portids\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_get_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_upcall_portids (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_upcall_portids - get the upcall_portids of .\par
: vport from which to retrieve the portids. : sk_buff where portids should be appended.\par
Retrieves the configuration of the given vport, appending the OVS_VPORT_ATTR_UPCALL_PID attribute which is the array of upcall portids to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room. If an error occurs,  is left unmodified. Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{\par
  436     struct vport_portids *ids;\par
  437 \par
  438     ids = rcu_dereference_ovsl(vport->upcall_portids);\par
  439 \par
  440     if (vport->dp->user_features & OVS_DP_F_VPORT_PIDS)\par
  441         return nla_put(skb, OVS_VPORT_ATTR_UPCALL_PID,\par
  442                    ids->n_ids * sizeof(u32), (void *) ids->ids);\par
  443     else\par
  444         return nla_put_u32(skb, OVS_VPORT_ATTR_UPCALL_PID, ids->ids[0]);\par
  445 \}\par
}
}
{\xe \v ovs_vport_init\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_init (void )}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_init - initialize vport subsystem\par
Called at module load time to initialize the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     dev_table = kzalloc(VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\par
   57                 GFP_KERNEL);\par
   58     if (!dev_table)\par
   59         return -ENOMEM;\par
   60 \par
   61     return 0;\par
   62 \}\par
}
}
{\xe \v ovs_vport_locate\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_locate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_locate (const struct net *  {\i net}, const char *  {\i name})}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115     struct hlist_head *bucket = hash_bucket(net, name);\par
  116     struct vport *vport;\par
  117 \par
  118     hlist_for_each_entry_rcu(vport, bucket, hash_node)\par
  119         if (!strcmp(name, vport->ops->get_name(vport)) &&\par
  120             net_eq(ovs_dp_get_net(vport->dp), net))\par
  121             return vport;\par
  122 \par
  123     return NULL;\par
  124 \}\par
}
}
{\xe \v ovs_vport_lookup\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops}* ovs_vport_lookup (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   174 \{\par
  175     struct vport_ops *ops;\par
  176 \par
  177     list_for_each_entry(ops, &vport_ops_list, list)\par
  178         if (ops->type == parms->type)\par
  179             return ops;\par
  180 \par
  181     return NULL;\par
  182 \}\par
}
}
{\xe \v ovs_vport_ops_register\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_ops_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_ops_register (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82     int err = -EEXIST;\par
   83     struct vport_ops *o;\par
   84 \par
   85     ovs_lock();\par
   86     list_for_each_entry(o, &vport_ops_list, list)\par
   87     if (ops->type == o->type)\par
   88         goto errout;\par
   89 \par
   90     list_add_tail(&ops->list, &vport_ops_list);\par
   91     err = 0;\par
   92 errout:\par
   93     ovs_unlock();\par
   94     return err;\par
   95 \}\par
}
}
{\xe \v ovs_vport_ops_unregister\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_ops_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_ops_unregister (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99 \{\par
  100     ovs_lock();\par
  101     list_del(&ops->list);\par
  102     ovs_unlock();\par
  103 \}\par
}
}
{\xe \v ovs_vport_receive\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_receive (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, const struct {\b ovs_tunnel_info} *  {\i tun_info})}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_receive - pass up received packet to the datapath for processing\par
: vport that received the packet : skb that was received : tunnel (if any) that carried packet\par
Must be called with rcu_read_lock. The packet cannot be shared and skb->data should point to the Ethernet header. The caller must have already called compute_ip_summed() to initialize the checksumming fields. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   485 \{\par
  486     struct pcpu_sw_netstats *stats;\par
  487     struct sw_flow_key key;\par
  488     int error;\par
  489 \par
  490     stats = this_cpu_ptr(vport->percpu_stats);\par
  491     u64_stats_update_begin(&stats->syncp);\par
  492     stats->rx_packets++;\par
  493     stats->rx_bytes += skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  494     u64_stats_update_end(&stats->syncp);\par
  495 \par
  496     ovs_skb_init_inner_protocol(skb);\par
  497     OVS_CB(skb)->input_vport = vport;\par
  498     OVS_CB(skb)->egress_tun_info = NULL;\par
  499     error = ovs_flow_key_extract(tun_info, skb, &key);\par
  500     if (unlikely(error)) \{\par
  501         kfree_skb(skb);\par
  502         return;\par
  503     \}\par
  504     ovs_dp_process_packet(skb, &key);\par
  505 \}\par
}
}
{\xe \v ovs_vport_record_error\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_record_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_vport_record_error (struct {\b vport} *  {\i vport}, enum {\b vport_err_type}  {\i err_type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_record_error - indicate device error to generic stats layer\par
: vport that encountered the error : one of enum vport_err_type types to indicate the error type\par
If using the vport generic stats layer indicate that an error of the given type has occurred. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   549 \{\par
  550     switch (err_type) \{\par
  551     case VPORT_E_RX_DROPPED:\par
  552         atomic_long_inc(&vport->err_stats.rx_dropped);\par
  553         break;\par
  554 \par
  555     case VPORT_E_RX_ERROR:\par
  556         atomic_long_inc(&vport->err_stats.rx_errors);\par
  557         break;\par
  558 \par
  559     case VPORT_E_TX_DROPPED:\par
  560         atomic_long_inc(&vport->err_stats.tx_dropped);\par
  561         break;\par
  562 \par
  563     case VPORT_E_TX_ERROR:\par
  564         atomic_long_inc(&vport->err_stats.tx_errors);\par
  565         break;\par
  566     \}\par
  567 \par
  568 \}\par
}
}
{\xe \v ovs_vport_send\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_send - send a packet on a device\par
: vport on which to send the packet : skb to send\par
Sends the given packet and returns the length of data sent. Either ovs lock or rcu_read_lock must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   518 \{\par
  519     int sent = vport->ops->send(vport, skb);\par
  520 \par
  521     if (likely(sent > 0)) \{\par
  522         struct pcpu_sw_netstats *stats;\par
  523 \par
  524         stats = this_cpu_ptr(vport->percpu_stats);\par
  525 \par
  526         u64_stats_update_begin(&stats->syncp);\par
  527         stats->tx_packets++;\par
  528         stats->tx_bytes += sent;\par
  529         u64_stats_update_end(&stats->syncp);\par
  530     \} else if (sent < 0) \{\par
  531         ovs_vport_record_error(vport, VPORT_E_TX_ERROR);\par
  532     \} else \{\par
  533         ovs_vport_record_error(vport, VPORT_E_TX_DROPPED);\par
  534     \}\par
  535     return sent;\par
  536 \}\par
}
}
{\xe \v ovs_vport_set_options\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_set_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_options (struct {\b vport} *  {\i vport}, struct nlattr *  {\i options})}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_options - modify existing vport device (for kernel callers)\par
: vport to modify. : New configuration.\par
Modifies an existing device with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     if (!vport->ops->set_options)\par
  260         return -EOPNOTSUPP;\par
  261     return vport->ops->set_options(vport, options);\par
  262 \}\par
}
}
{\xe \v ovs_vport_set_upcall_portids\:linux/vport.c}
{\xe \v linux/vport.c\:ovs_vport_set_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_upcall_portids (struct {\b vport} *  {\i vport}, const struct nlattr *  {\i ids})}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_upcall_portids - set upcall portids of .\par
: vport to modify. : new configuration, an array of port ids.\par
Sets the vport's upcall_portids to .\par
Returns 0 if successful, -EINVAL if  is zero length or cannot be parsed as an array of U32.\par
Must be called with ovs_mutex. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   394 \{\par
  395     struct vport_portids *old, *vport_portids;\par
  396 \par
  397     if (!nla_len(ids) || nla_len(ids) % sizeof(u32))\par
  398         return -EINVAL;\par
  399 \par
  400     old = ovsl_dereference(vport->upcall_portids);\par
  401 \par
  402     vport_portids = kmalloc(sizeof *vport_portids + nla_len(ids),\par
  403                 GFP_KERNEL);\par
  404     if (!vport_portids)\par
  405         return -ENOMEM;\par
  406 \par
  407     vport_portids->n_ids = nla_len(ids) / sizeof(u32);\par
  408     vport_portids->rn_ids = reciprocal_value(vport_portids->n_ids);\par
  409     nla_memcpy(vport_portids->ids, ids, nla_len(ids));\par
  410 \par
  411     rcu_assign_pointer(vport->upcall_portids, vport_portids);\par
  412 \par
  413     if (old)\par
  414         call_rcu(&old->rcu, vport_portids_destroy_rcu_cb);\par
  415 \par
  416     return 0;\par
  417 \}\par
}
}
{\xe \v vport_portids_destroy_rcu_cb\:linux/vport.c}
{\xe \v linux/vport.c\:vport_portids_destroy_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vport_portids_destroy_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   373 \{\par
  374     struct vport_portids *ids = container_of(rcu, struct vport_portids,\par
  375                          rcu);\par
  376 \par
  377     kfree(ids);\par
  378 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dev_table\:linux/vport.c}
{\xe \v linux/vport.c\:dev_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_head* dev_table{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport.c File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport.c}
{\xe \v /home/vladn/git/ovs/datapath/vport.c}
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/etherdevice.h>}\par
{\f2 #include <linux/if.h>}\par
{\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/jhash.h>}\par
{\f2 #include <linux/kconfig.h>}\par
{\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/module.h>}\par
{\f2 #include <linux/mutex.h>}\par
{\f2 #include <linux/percpu.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include <linux/rtnetlink.h>}\par
{\f2 #include <linux/compat.h>}\par
{\f2 #include <linux/version.h>}\par
{\f2 #include <net/net_namespace.h>}\par
{\f2 #include "datapath.h"}\par
{\f2 #include "gso.h"}\par
{\f2 #include "vport.h"}\par
{\f2 #include "vport-internal_dev.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VPORT_HASH_BUCKETS}\~ 1024\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b LIST_HEAD} (vport_ops_list)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b hash_bucket} (const struct net *net, const char *name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_ops_register} (struct {\b vport_ops} *ops)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_ops_register})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_ops_unregister} (struct {\b vport_ops} *ops)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_ops_unregister})\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid : name of port to find\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_locate - find a port that has already been created\par
Must be called with ovs or RCU read lock. \par
}}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 

{
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b ovs_vport_record_error} (struct {\b vport} *, enum {\b vport_err_type} err_type)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_locate} (const struct net *net, const char *name)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_alloc} (int priv_size, const struct {\b vport_ops} *ops, const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_alloc})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static struct {\b vport_ops} * {\b ovs_vport_lookup} (const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_free} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_free})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_add} (const struct {\b vport_parms} *parms)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_set_options} (struct {\b vport} *{\b vport}, struct nlattr *options)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_del} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_get_stats} (struct {\b vport} *{\b vport}, struct {\b ovs_vport_stats} *stats)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_options} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b vport_portids_destroy_rcu_cb} (struct rcu_head *rcu)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_set_upcall_portids} (struct {\b vport} *{\b vport}, const struct nlattr *ids)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_upcall_portids} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
u32 {\b ovs_vport_find_upcall_portid} (const struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_receive} (struct {\b vport} *{\b vport}, struct sk_buff *skb, const struct {\b ovs_tunnel_info} *tun_info)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_receive})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_send} (struct {\b vport} *{\b vport}, struct sk_buff *skb)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
static void {\b free_vport_rcu} (struct rcu_head *rcu)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
void {\b ovs_vport_deferred_free} (struct {\b vport} *{\b vport})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_vport_deferred_free})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_tunnel_get_egress_info} (struct {\b ovs_tunnel_info} *egress_tun_info, struct net *net, const struct {\b ovs_tunnel_info} *tun_info, u8 ipproto, u32 {\b skb_mark}, __be16 {\b tp_src}, __be16 {\b tp_dst})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b EXPORT_SYMBOL_GPL} ({\b ovs_tunnel_get_egress_info})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int {\b ovs_vport_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *info)\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct hlist_head * {\b dev_table}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v VPORT_HASH_BUCKETS\:vport.c}
{\xe \v vport.c\:VPORT_HASH_BUCKETS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VPORT_HASH_BUCKETS\~ 1024}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_ops_register} )}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_ops_unregister} )}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_alloc} )}}
\par
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_free} )}}
\par
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_receive} )}}
\par
{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_vport_deferred_free} )}}
\par
{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXPORT_SYMBOL_GPL\:vport.c}
{\xe \v vport.c\:EXPORT_SYMBOL_GPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EXPORT_SYMBOL_GPL ({\b ovs_tunnel_get_egress_info} )}}
\par
{\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v free_vport_rcu\:vport.c}
{\xe \v vport.c\:free_vport_rcu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void free_vport_rcu (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   571 \{\par
  572     struct vport *vport = container_of(rcu, struct vport, rcu);\par
  573 \par
  574     ovs_vport_free(vport);\par
  575 \}\par
}
}
{\xe \v hash_bucket\:vport.c}
{\xe \v vport.c\:hash_bucket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct hlist_head* hash_bucket (const struct net *  {\i net}, const char *  {\i name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75 \{\par
   76     unsigned int hash = jhash(name, strlen(name), (unsigned long) net);\par
   77     return &dev_table[hash & (VPORT_HASH_BUCKETS - 1)];\par
   78 \}\par
}
}
{\xe \v LIST_HEAD\:vport.c}
{\xe \v vport.c\:LIST_HEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static LIST_HEAD (vport_ops_list ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ovs_tunnel_get_egress_info\:vport.c}
{\xe \v vport.c\:ovs_tunnel_get_egress_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_tunnel_get_egress_info (struct {\b ovs_tunnel_info} *  {\i egress_tun_info}, struct net *  {\i net}, const struct {\b ovs_tunnel_info} *  {\i tun_info}, u8  {\i ipproto}, u32  {\i skb_mark}, __be16  {\i tp_src}, __be16  {\i tp_dst})}}
\par
{\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   593 \{\par
  594     const struct ovs_key_ipv4_tunnel *tun_key;\par
  595     struct rtable *rt;\par
  596     __be32 saddr;\par
  597 \par
  598     if (unlikely(!tun_info))\par
  599         return -EINVAL;\par
  600 \par
  601     tun_key = &tun_info->tunnel;\par
  602     saddr = tun_key->ipv4_src;\par
  603     /* Route lookup to get srouce IP address: saddr.\par
  604      * The process may need to be changed if the corresponding process\par
  605      * in vports ops changed.\par
  606      */\par
  607     rt = find_route(net,\par
  608             &saddr,\par
  609             tun_key->ipv4_dst,\par
  610             ipproto,\par
  611             tun_key->ipv4_tos,\par
  612             skb_mark);\par
  613     if (IS_ERR(rt))\par
  614         return PTR_ERR(rt);\par
  615 \par
  616     ip_rt_put(rt);\par
  617 \par
  618     /* Generate egress_tun_info based on tun_info,\par
  619      * saddr, tp_src and tp_dst\par
  620      */\par
  621     __ovs_flow_tun_info_init(egress_tun_info,\par
  622                  saddr, tun_key->ipv4_dst,\par
  623                  tun_key->ipv4_tos,\par
  624                  tun_key->ipv4_ttl,\par
  625                  tp_src, tp_dst,\par
  626                  tun_key->tun_id,\par
  627                  tun_key->tun_flags,\par
  628                  tun_info->options,\par
  629                  tun_info->options_len);\par
  630 \par
  631     return 0;\par
  632 \}\par
}
}
{\xe \v ovs_vport_add\:vport.c}
{\xe \v vport.c\:ovs_vport_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_add (const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_add - add vport device (for kernel callers)\par
: Information about new vport.\par
Creates a new vport with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   211 \{\par
  212     struct vport_ops *ops;\par
  213     struct vport *vport;\par
  214 \par
  215     ops = ovs_vport_lookup(parms);\par
  216     if (ops) \{\par
  217         struct hlist_head *bucket;\par
  218 \par
  219         if (!try_module_get(ops->owner))\par
  220             return ERR_PTR(-EAFNOSUPPORT);\par
  221 \par
  222         vport = ops->create(parms);\par
  223         if (IS_ERR(vport)) \{\par
  224             module_put(ops->owner);\par
  225             return vport;\par
  226         \}\par
  227 \par
  228         bucket = hash_bucket(ovs_dp_get_net(vport->dp),\par
  229                      vport->ops->get_name(vport));\par
  230         hlist_add_head_rcu(&vport->hash_node, bucket);\par
  231         return vport;\par
  232     \}\par
  233 \par
  234     /* Unlock to attempt module load and return -EAGAIN if load\par
  235      * was successful as we need to restart the port addition\par
  236      * workflow.\par
  237      */\par
  238     ovs_unlock();\par
  239     request_module("vport-type-%d", parms->type);\par
  240     ovs_lock();\par
  241 \par
  242     if (!ovs_vport_lookup(parms))\par
  243         return ERR_PTR(-EAFNOSUPPORT);\par
  244     else\par
  245         return ERR_PTR(-EAGAIN);\par
  246 \}\par
}
}
{\xe \v ovs_vport_alloc\:vport.c}
{\xe \v vport.c\:ovs_vport_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_alloc (int  {\i priv_size}, const struct {\b vport_ops} *  {\i ops}, const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_alloc - allocate and initialize new vport\par
: Size of private data area to allocate. : vport device ops\par
Allocate and initialize a new vport defined by . The vport will contain a private data area of size  that can be accessed using {\b vport_priv()}. vports that are no longer needed should be released with {\b ovs_vport_free()}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   139 \{\par
  140     struct vport *vport;\par
  141     size_t alloc_size;\par
  142 \par
  143     alloc_size = sizeof(struct vport);\par
  144     if (priv_size) \{\par
  145         alloc_size = ALIGN(alloc_size, VPORT_ALIGN);\par
  146         alloc_size += priv_size;\par
  147     \}\par
  148 \par
  149     vport = kzalloc(alloc_size, GFP_KERNEL);\par
  150     if (!vport)\par
  151         return ERR_PTR(-ENOMEM);\par
  152 \par
  153     vport->dp = parms->dp;\par
  154     vport->port_no = parms->port_no;\par
  155     vport->ops = ops;\par
  156     INIT_HLIST_NODE(&vport->dp_hash_node);\par
  157 \par
  158     if (ovs_vport_set_upcall_portids(vport, parms->upcall_portids)) \{\par
  159         kfree(vport);\par
  160         return ERR_PTR(-EINVAL);\par
  161     \}\par
  162 \par
  163     vport->percpu_stats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\par
  164     if (!vport->percpu_stats) \{\par
  165         kfree(vport);\par
  166         return ERR_PTR(-ENOMEM);\par
  167     \}\par
  168 \par
  169     return vport;\par
  170 \}\par
}
}
{\xe \v ovs_vport_deferred_free\:vport.c}
{\xe \v vport.c\:ovs_vport_deferred_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_deferred_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579     if (!vport)\par
  580         return;\par
  581 \par
  582     call_rcu(&vport->rcu, free_vport_rcu);\par
  583 \}\par
}
}
{\xe \v ovs_vport_del\:vport.c}
{\xe \v vport.c\:ovs_vport_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_del (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_del - delete existing vport device\par
: vport to delete.\par
Detaches  from its datapath and destroys it. It is possible to fail for reasons such as lack of memory. ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     ASSERT_OVSL();\par
  275 \par
  276     hlist_del_rcu(&vport->hash_node);\par
  277     module_put(vport->ops->owner);\par
  278     vport->ops->destroy(vport);\par
  279 \}\par
}
}
{\xe \v ovs_vport_exit\:vport.c}
{\xe \v vport.c\:ovs_vport_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_exit (void )}}
\par
{\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_exit - shutdown vport subsystem\par
Called at module exit time to shutdown the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71     kfree(dev_table);\par
   72 \}\par
}
}
{\xe \v ovs_vport_find_upcall_portid\:vport.c}
{\xe \v vport.c\:ovs_vport_find_upcall_portid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_vport_find_upcall_portid (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_find_upcall_portid - find the upcall portid to send upcall.\par
: vport from which the missed packet is received. : skb that the missed packet was received.\par
Uses the {\b skb_get_hash()} to select the upcall portid to send the upcall.\par
Returns the portid of the target socket. Must be called with rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   459 \{\par
  460     struct vport_portids *ids;\par
  461     u32 hash;\par
  462 \par
  463     ids = rcu_dereference(vport->upcall_portids);\par
  464 \par
  465     if (ids->n_ids == 1 && ids->ids[0] == 0)\par
  466         return 0;\par
  467 \par
  468     hash = skb_get_hash(skb);\par
  469     return ids->ids[hash - ids->n_ids * reciprocal_divide(hash, ids->rn_ids)];\par
  470 \}\par
}
}
{\xe \v ovs_vport_free\:vport.c}
{\xe \v vport.c\:ovs_vport_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_free - uninitialize and free vport\par
: vport to free\par
Frees a vport allocated with {\b ovs_vport_alloc()} when it is no longer needed.\par
The caller must ensure that an RCU grace period has passed since the last time  was in a datapath. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195 \{\par
  196     kfree(rcu_dereference_raw(vport->upcall_portids));\par
  197     free_percpu(vport->percpu_stats);\par
  198     kfree(vport);\par
  199 \}\par
}
}
{\xe \v ovs_vport_get_egress_tun_info\:vport.c}
{\xe \v vport.c\:ovs_vport_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i info})}}
\par
{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   637 \{\par
  638     /* get_egress_tun_info() is only implemented on tunnel ports. */\par
  639     if (unlikely(!vport->ops->get_egress_tun_info))\par
  640         return -EINVAL;\par
  641 \par
  642     return vport->ops->get_egress_tun_info(vport, skb, info);\par
  643 \}\par
}
}
{\xe \v ovs_vport_get_options\:vport.c}
{\xe \v vport.c\:ovs_vport_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_options - retrieve device options\par
: vport from which to retrieve the options. : sk_buff where options should be appended.\par
Retrieves the configuration of the given device, appending an OVS_VPORT_ATTR_OPTIONS attribute that in turn contains nested vport-specific attributes to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room, or another negative error code if a real error occurred. If an error occurs,  is left unmodified.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351 \{\par
  352     struct nlattr *nla;\par
  353     int err;\par
  354 \par
  355     if (!vport->ops->get_options)\par
  356         return 0;\par
  357 \par
  358     nla = nla_nest_start(skb, OVS_VPORT_ATTR_OPTIONS);\par
  359     if (!nla)\par
  360         return -EMSGSIZE;\par
  361 \par
  362     err = vport->ops->get_options(vport, skb);\par
  363     if (err) \{\par
  364         nla_nest_cancel(skb, nla);\par
  365         return err;\par
  366     \}\par
  367 \par
  368     nla_nest_end(skb, nla);\par
  369     return 0;\par
  370 \}\par
}
}
{\xe \v ovs_vport_get_stats\:vport.c}
{\xe \v vport.c\:ovs_vport_get_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_get_stats (struct {\b vport} *  {\i vport}, struct {\b ovs_vport_stats} *  {\i stats})}}
\par
{\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_stats - retrieve device stats\par
: vport from which to retrieve the stats : location to store stats\par
Retrieves transmit, receive, and error stats for the given device.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int i;\par
  294 \par
  295     /* We potentially have two surces of stats that need to be\par
  296      * combined: those we have collected (split into err_stats and\par
  297      * percpu_stats), and device error stats from netdev->get_stats()\par
  298      * (for errors that happen downstream and therefore aren't\par
  299      * reported through our vport_record_error() function).\par
  300      * Stats from first source are reported by ovs over\par
  301      * OVS_VPORT_ATTR_STATS.\par
  302      * netdev-stats can be directly read over netlink-ioctl.\par
  303      */\par
  304 \par
  305     stats->rx_errors  = atomic_long_read(&vport->err_stats.rx_errors);\par
  306     stats->tx_errors  = atomic_long_read(&vport->err_stats.tx_errors);\par
  307     stats->tx_dropped = atomic_long_read(&vport->err_stats.tx_dropped);\par
  308     stats->rx_dropped = atomic_long_read(&vport->err_stats.rx_dropped);\par
  309 \par
  310     stats->rx_bytes     = 0;\par
  311     stats->rx_packets   = 0;\par
  312     stats->tx_bytes     = 0;\par
  313     stats->tx_packets   = 0;\par
  314 \par
  315     for_each_possible_cpu(i) \{\par
  316         const struct pcpu_sw_netstats *percpu_stats;\par
  317         struct pcpu_sw_netstats local_stats;\par
  318         unsigned int start;\par
  319 \par
  320         percpu_stats = per_cpu_ptr(vport->percpu_stats, i);\par
  321 \par
  322         do \{\par
  323             start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);\par
  324             local_stats = *percpu_stats;\par
  325         \} while (u64_stats_fetch_retry_irq(&percpu_stats->syncp, start));\par
  326 \par
  327         stats->rx_bytes     += local_stats.rx_bytes;\par
  328         stats->rx_packets   += local_stats.rx_packets;\par
  329         stats->tx_bytes     += local_stats.tx_bytes;\par
  330         stats->tx_packets   += local_stats.tx_packets;\par
  331     \}\par
  332 \}\par
}
}
{\xe \v ovs_vport_get_upcall_portids\:vport.c}
{\xe \v vport.c\:ovs_vport_get_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_upcall_portids (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_upcall_portids - get the upcall_portids of .\par
: vport from which to retrieve the portids. : sk_buff where portids should be appended.\par
Retrieves the configuration of the given vport, appending the OVS_VPORT_ATTR_UPCALL_PID attribute which is the array of upcall portids to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room. If an error occurs,  is left unmodified. Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{\par
  436     struct vport_portids *ids;\par
  437 \par
  438     ids = rcu_dereference_ovsl(vport->upcall_portids);\par
  439 \par
  440     if (vport->dp->user_features & OVS_DP_F_VPORT_PIDS)\par
  441         return nla_put(skb, OVS_VPORT_ATTR_UPCALL_PID,\par
  442                    ids->n_ids * sizeof(u32), (void *) ids->ids);\par
  443     else\par
  444         return nla_put_u32(skb, OVS_VPORT_ATTR_UPCALL_PID, ids->ids[0]);\par
  445 \}\par
}
}
{\xe \v ovs_vport_init\:vport.c}
{\xe \v vport.c\:ovs_vport_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_init (void )}}
\par
{\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_init - initialize vport subsystem\par
Called at module load time to initialize the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     dev_table = kzalloc(VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\par
   57                 GFP_KERNEL);\par
   58     if (!dev_table)\par
   59         return -ENOMEM;\par
   60 \par
   61     return 0;\par
   62 \}\par
}
}
{\xe \v ovs_vport_locate\:vport.c}
{\xe \v vport.c\:ovs_vport_locate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_locate (const struct net *  {\i net}, const char *  {\i name})}}
\par
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115     struct hlist_head *bucket = hash_bucket(net, name);\par
  116     struct vport *vport;\par
  117 \par
  118     hlist_for_each_entry_rcu(vport, bucket, hash_node)\par
  119         if (!strcmp(name, vport->ops->get_name(vport)) &&\par
  120             net_eq(ovs_dp_get_net(vport->dp), net))\par
  121             return vport;\par
  122 \par
  123     return NULL;\par
  124 \}\par
}
}
{\xe \v ovs_vport_lookup\:vport.c}
{\xe \v vport.c\:ovs_vport_lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport_ops}* ovs_vport_lookup (const struct {\b vport_parms} *  {\i parms}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   174 \{\par
  175     struct vport_ops *ops;\par
  176 \par
  177     list_for_each_entry(ops, &vport_ops_list, list)\par
  178         if (ops->type == parms->type)\par
  179             return ops;\par
  180 \par
  181     return NULL;\par
  182 \}\par
}
}
{\xe \v ovs_vport_ops_register\:vport.c}
{\xe \v vport.c\:ovs_vport_ops_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_ops_register (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82     int err = -EEXIST;\par
   83     struct vport_ops *o;\par
   84 \par
   85     ovs_lock();\par
   86     list_for_each_entry(o, &vport_ops_list, list)\par
   87     if (ops->type == o->type)\par
   88         goto errout;\par
   89 \par
   90     list_add_tail(&ops->list, &vport_ops_list);\par
   91     err = 0;\par
   92 errout:\par
   93     ovs_unlock();\par
   94     return err;\par
   95 \}\par
}
}
{\xe \v ovs_vport_ops_unregister\:vport.c}
{\xe \v vport.c\:ovs_vport_ops_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_ops_unregister (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99 \{\par
  100     ovs_lock();\par
  101     list_del(&ops->list);\par
  102     ovs_unlock();\par
  103 \}\par
}
}
{\xe \v ovs_vport_receive\:vport.c}
{\xe \v vport.c\:ovs_vport_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_receive (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, const struct {\b ovs_tunnel_info} *  {\i tun_info})}}
\par
{\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_receive - pass up received packet to the datapath for processing\par
: vport that received the packet : skb that was received : tunnel (if any) that carried packet\par
Must be called with rcu_read_lock. The packet cannot be shared and skb->data should point to the Ethernet header. The caller must have already called compute_ip_summed() to initialize the checksumming fields. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   485 \{\par
  486     struct pcpu_sw_netstats *stats;\par
  487     struct sw_flow_key key;\par
  488     int error;\par
  489 \par
  490     stats = this_cpu_ptr(vport->percpu_stats);\par
  491     u64_stats_update_begin(&stats->syncp);\par
  492     stats->rx_packets++;\par
  493     stats->rx_bytes += skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  494     u64_stats_update_end(&stats->syncp);\par
  495 \par
  496     ovs_skb_init_inner_protocol(skb);\par
  497     OVS_CB(skb)->input_vport = vport;\par
  498     OVS_CB(skb)->egress_tun_info = NULL;\par
  499     error = ovs_flow_key_extract(tun_info, skb, &key);\par
  500     if (unlikely(error)) \{\par
  501         kfree_skb(skb);\par
  502         return;\par
  503     \}\par
  504     ovs_dp_process_packet(skb, &key);\par
  505 \}\par
}
}
{\xe \v ovs_vport_record_error\:vport.c}
{\xe \v vport.c\:ovs_vport_record_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_vport_record_error (struct {\b vport} *  {\i vport}, enum {\b vport_err_type}  {\i err_type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_record_error - indicate device error to generic stats layer\par
: vport that encountered the error : one of enum vport_err_type types to indicate the error type\par
If using the vport generic stats layer indicate that an error of the given type has occurred. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   549 \{\par
  550     switch (err_type) \{\par
  551     case VPORT_E_RX_DROPPED:\par
  552         atomic_long_inc(&vport->err_stats.rx_dropped);\par
  553         break;\par
  554 \par
  555     case VPORT_E_RX_ERROR:\par
  556         atomic_long_inc(&vport->err_stats.rx_errors);\par
  557         break;\par
  558 \par
  559     case VPORT_E_TX_DROPPED:\par
  560         atomic_long_inc(&vport->err_stats.tx_dropped);\par
  561         break;\par
  562 \par
  563     case VPORT_E_TX_ERROR:\par
  564         atomic_long_inc(&vport->err_stats.tx_errors);\par
  565         break;\par
  566     \}\par
  567 \par
  568 \}\par
}
}
{\xe \v ovs_vport_send\:vport.c}
{\xe \v vport.c\:ovs_vport_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_send - send a packet on a device\par
: vport on which to send the packet : skb to send\par
Sends the given packet and returns the length of data sent. Either ovs lock or rcu_read_lock must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   518 \{\par
  519     int sent = vport->ops->send(vport, skb);\par
  520 \par
  521     if (likely(sent > 0)) \{\par
  522         struct pcpu_sw_netstats *stats;\par
  523 \par
  524         stats = this_cpu_ptr(vport->percpu_stats);\par
  525 \par
  526         u64_stats_update_begin(&stats->syncp);\par
  527         stats->tx_packets++;\par
  528         stats->tx_bytes += sent;\par
  529         u64_stats_update_end(&stats->syncp);\par
  530     \} else if (sent < 0) \{\par
  531         ovs_vport_record_error(vport, VPORT_E_TX_ERROR);\par
  532     \} else \{\par
  533         ovs_vport_record_error(vport, VPORT_E_TX_DROPPED);\par
  534     \}\par
  535     return sent;\par
  536 \}\par
}
}
{\xe \v ovs_vport_set_options\:vport.c}
{\xe \v vport.c\:ovs_vport_set_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_options (struct {\b vport} *  {\i vport}, struct nlattr *  {\i options})}}
\par
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_options - modify existing vport device (for kernel callers)\par
: vport to modify. : New configuration.\par
Modifies an existing device with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     if (!vport->ops->set_options)\par
  260         return -EOPNOTSUPP;\par
  261     return vport->ops->set_options(vport, options);\par
  262 \}\par
}
}
{\xe \v ovs_vport_set_upcall_portids\:vport.c}
{\xe \v vport.c\:ovs_vport_set_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_upcall_portids (struct {\b vport} *  {\i vport}, const struct nlattr *  {\i ids})}}
\par
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_upcall_portids - set upcall portids of .\par
: vport to modify. : new configuration, an array of port ids.\par
Sets the vport's upcall_portids to .\par
Returns 0 if successful, -EINVAL if  is zero length or cannot be parsed as an array of U32.\par
Must be called with ovs_mutex. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   394 \{\par
  395     struct vport_portids *old, *vport_portids;\par
  396 \par
  397     if (!nla_len(ids) || nla_len(ids) % sizeof(u32))\par
  398         return -EINVAL;\par
  399 \par
  400     old = ovsl_dereference(vport->upcall_portids);\par
  401 \par
  402     vport_portids = kmalloc(sizeof *vport_portids + nla_len(ids),\par
  403                 GFP_KERNEL);\par
  404     if (!vport_portids)\par
  405         return -ENOMEM;\par
  406 \par
  407     vport_portids->n_ids = nla_len(ids) / sizeof(u32);\par
  408     vport_portids->rn_ids = reciprocal_value(vport_portids->n_ids);\par
  409     nla_memcpy(vport_portids->ids, ids, nla_len(ids));\par
  410 \par
  411     rcu_assign_pointer(vport->upcall_portids, vport_portids);\par
  412 \par
  413     if (old)\par
  414         call_rcu(&old->rcu, vport_portids_destroy_rcu_cb);\par
  415 \par
  416     return 0;\par
  417 \}\par
}
}
{\xe \v vport_portids_destroy_rcu_cb\:vport.c}
{\xe \v vport.c\:vport_portids_destroy_rcu_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vport_portids_destroy_rcu_cb (struct rcu_head *  {\i rcu}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   373 \{\par
  374     struct vport_portids *ids = container_of(rcu, struct vport_portids,\par
  375                          rcu);\par
  376 \par
  377     kfree(ids);\par
  378 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dev_table\:vport.c}
{\xe \v vport.c\:dev_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct hlist_head* dev_table{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/README.md}
{\xe \v /home/vladn/git/ovs/datapath/README.md}
{\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vlan.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vlan.h}
{\xe \v /home/vladn/git/ovs/datapath/vlan.h}
{\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_vlan.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/version.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vlan.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vlan_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vlan_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static u16 {\b vlan_get_tci} (struct sk_buff *skb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b vlan_set_tci} (struct sk_buff *skb, u16 vlan_tci)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vlan_get_tci\:vlan.h}
{\xe \v vlan.h\:vlan_get_tci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static u16 vlan_get_tci (struct sk_buff *  {\i skb}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DOC: VLAN tag manipulation.\par
&struct sk_buff handling of VLAN tags has evolved over time:\par
In 2.6.26 and earlier, VLAN tags did not have any generic representation in an skb, other than as a raw 802.1Q header inside the packet data.\par
In 2.6.27 &struct sk_buff added a  member. Between 2.6.27 and 2.6.32, its value was the raw contents of the 802.1Q TCI field, or zero if no 802.1Q header was present. This worked OK except for the corner case of an 802.1Q header with an all-0-bits TCI, which could not be represented.\par
In 2.6.33,  semantics changed. Now, if an 802.1Q header is present, then the VLAN_TAG_PRESENT bit is always set. This fixes the all-0-bits TCI corner case.\par
For compatibility we emulate the 2.6.33+ behavior on earlier kernel versions. The client must not access  directly. Instead, use {\b vlan_get_tci()} to read it or {\b vlan_set_tci()} to write it, with semantics equivalent to those on 2.6.33+. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)\par
   52     if (skb->vlan_tci)\par
   53         return skb->vlan_tci | VLAN_TAG_PRESENT;\par
   54 #endif\par
   55     return skb->vlan_tci;\par
   56 \}\par
}
}
{\xe \v vlan_set_tci\:vlan.h}
{\xe \v vlan.h\:vlan_set_tci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void vlan_set_tci (struct sk_buff *  {\i skb}, u16  {\i vlan_tci}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{\par
   60 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)\par
   61     vlan_tci &= ~VLAN_TAG_PRESENT;\par
   62 #endif\par
   63     skb->vlan_tci = vlan_tci;\par
   64 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-internal_dev.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-internal_dev.h}
{\xe \v /home/vladn/git/ovs/datapath/vport-internal_dev.h}
{\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "datapath.h"}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-internal_dev.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-internal__dev_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-internal__dev_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_is_internal_dev} (const struct net_device *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_internal_dev_get_vport} (struct net_device *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_internal_dev_rtnl_link_register} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_internal_dev_rtnl_link_unregister} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_internal_dev_get_vport\:vport-internal_dev.h}
{\xe \v vport-internal_dev.h\:ovs_internal_dev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_internal_dev_get_vport (struct net_device * )}}
\par
{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   304 \{\par
  305     if (!ovs_is_internal_dev(netdev))\par
  306         return NULL;\par
  307 \par
  308     return internal_dev_priv(netdev)->vport;\par
  309 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_register\:vport-internal_dev.h}
{\xe \v vport-internal_dev.h\:ovs_internal_dev_rtnl_link_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_internal_dev_rtnl_link_register (void )}}
\par
{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   312 \{\par
  313     int err;\par
  314 \par
  315     err = rtnl_link_register(&internal_dev_link_ops);\par
  316     if (err < 0)\par
  317         return err;\par
  318 \par
  319     err = ovs_vport_ops_register(&ovs_internal_vport_ops);\par
  320     if (err < 0)\par
  321         rtnl_link_unregister(&internal_dev_link_ops);\par
  322 \par
  323     return err;\par
  324 \}\par
}
}
{\xe \v ovs_internal_dev_rtnl_link_unregister\:vport-internal_dev.h}
{\xe \v vport-internal_dev.h\:ovs_internal_dev_rtnl_link_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_internal_dev_rtnl_link_unregister (void )}}
\par
{\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   327 \{\par
  328     ovs_vport_ops_unregister(&ovs_internal_vport_ops);\par
  329     rtnl_link_unregister(&internal_dev_link_ops);\par
  330 \}\par
}
}
{\xe \v ovs_is_internal_dev\:vport-internal_dev.h}
{\xe \v vport-internal_dev.h\:ovs_is_internal_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_is_internal_dev (const struct net_device * )}}
\par
{\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   299 \{\par
  300     return netdev->netdev_ops == &internal_dev_netdev_ops;\par
  301 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-netdev.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-netdev.h}
{\xe \v /home/vladn/git/ovs/datapath/vport-netdev.h}
{\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/netdevice.h>}\par
{\f2 #include <linux/rcupdate.h>}\par
{\f2 #include "vport.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-netdev.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-netdev_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-netdev_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b netdev_vport}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_netdev_get_vport} (struct net_device *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b netdev_vport} * {\b netdev_vport_priv} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ovs_netdev_get_name} (const struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_detach_dev} (struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int __init {\b ovs_netdev_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_netdev_exit} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v netdev_vport_priv\:vport-netdev.h}
{\xe \v vport-netdev.h\:netdev_vport_priv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b netdev_vport}* netdev_vport_priv (const struct {\b vport} *  {\i vport}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    37 \{\par
   38     return vport_priv(vport);\par
   39 \}\par
}
}
{\xe \v ovs_netdev_detach_dev\:vport-netdev.h}
{\xe \v vport-netdev.h\:ovs_netdev_detach_dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_detach_dev (struct {\b vport} * )}}
\par
{\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165 \{\par
  166     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  167 \par
  168     ASSERT_RTNL();\par
  169     netdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\par
  170     netdev_rx_handler_unregister(netdev_vport->dev);\par
  171     netdev_upper_dev_unlink(netdev_vport->dev,\par
  172                 netdev_master_upper_dev_get(netdev_vport->dev));\par
  173     dev_set_promiscuity(netdev_vport->dev, -1);\par
  174 \}\par
}
}
{\xe \v ovs_netdev_exit\:vport-netdev.h}
{\xe \v vport-netdev.h\:ovs_netdev_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_netdev_exit (void )}}
\par
{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     ovs_vport_ops_unregister(&ovs_netdev_vport_ops);\par
  294 \}\par
}
}
{\xe \v ovs_netdev_get_name\:vport-netdev.h}
{\xe \v vport-netdev.h\:ovs_netdev_get_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* ovs_netdev_get_name (const struct {\b vport} * )}}
\par
{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   189 \{\par
  190     const struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\par
  191     return netdev_vport->dev->name;\par
  192 \}\par
}
}
{\xe \v ovs_netdev_get_vport\:vport-netdev.h}
{\xe \v vport-netdev.h\:ovs_netdev_get_vport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_netdev_get_vport (struct net_device *  {\i dev})}}
\par
{\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36) || \\\par
  260     defined HAVE_RHEL_OVS_HOOK\par
  261 #ifdef HAVE_OVS_DATAPATH\par
  262     if (likely(dev->priv_flags & IFF_OVS_DATAPATH))\par
  263 #else\par
  264     if (likely(rcu_access_pointer(dev->rx_handler) == netdev_frame_hook))\par
  265 #endif\par
  266 #ifdef HAVE_RHEL_OVS_HOOK\par
  267         return (struct vport *)rcu_dereference_rtnl(dev->ax25_ptr);\par
  268 #else\par
  269         return (struct vport *)rcu_dereference_rtnl(dev->rx_handler_data);\par
  270 #endif\par
  271     else\par
  272         return NULL;\par
  273 #else\par
  274     return (struct vport *)rcu_dereference_rtnl(dev->br_port);\par
  275 #endif\par
  276 \}\par
}
}
{\xe \v ovs_netdev_init\:vport-netdev.h}
{\xe \v vport-netdev.h\:ovs_netdev_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __init ovs_netdev_init (void )}}
\par
{\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   287 \{\par
  288     return ovs_vport_ops_register(&ovs_netdev_vport_ops);\par
  289 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport-vxlan.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport-vxlan.h}
{\xe \v /home/vladn/git/ovs/datapath/vport-vxlan.h}
{\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/kernel.h>}\par
{\f2 #include <linux/types.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport-vxlan.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-vxlan_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport-vxlan_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ovs_vxlan_opts}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/vladn/git/ovs/datapath/vport.h File Reference\par \pard\plain 
{\tc\tcl2 \v /home/vladn/git/ovs/datapath/vport.h}
{\xe \v /home/vladn/git/ovs/datapath/vport.h}
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <linux/if_tunnel.h>}\par
{\f2 #include <linux/list.h>}\par
{\f2 #include <linux/netlink.h>}\par
{\f2 #include <linux/openvswitch.h>}\par
{\f2 #include <linux/reciprocal_div.h>}\par
{\f2 #include <linux/skbuff.h>}\par
{\f2 #include <linux/spinlock.h>}\par
{\f2 #include <linux/u64_stats_sync.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vport.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vport_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_net}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_err_stats}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_portids}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_parms}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport_ops}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_exit} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_add} (const struct {\b vport_parms} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_del} (struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_locate} (const struct net *net, const char *name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_get_stats} (struct {\b vport} *, struct {\b ovs_vport_stats} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_set_options} (struct {\b vport} *, struct nlattr *options)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_get_options} (const struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_set_upcall_portids} (struct {\b vport} *, const struct nlattr *pids)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_get_upcall_portids} (const struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32 {\b ovs_vport_find_upcall_portid} (const struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_send} (struct {\b vport} *, struct sk_buff *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_tunnel_get_egress_info} (struct {\b ovs_tunnel_info} *egress_tun_info, struct net *net, const struct {\b ovs_tunnel_info} *tun_info, u8 ipproto, u32 {\b skb_mark}, __be16 {\b tp_src}, __be16 {\b tp_dst})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_get_egress_tun_info} (struct {\b vport} *{\b vport}, struct sk_buff *skb, struct {\b ovs_tunnel_info} *info)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
: New vport's name.\par
\pard\plain 
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
struct {\b vport_parms} - parameters for creating a new vport\par
: New vport's type. : OVS_VPORT_ATTR_OPTIONS attribute from Netlink message, NULL if none was supplied. : New vport's datapath. : New vport's port number. \par
}}

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VPORT_ALIGN}\~ 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b vport_err_type} \{ {\b VPORT_E_RX_DROPPED}, 
{\b VPORT_E_RX_ERROR}, 
{\b VPORT_E_TX_DROPPED}, 
{\b VPORT_E_TX_ERROR}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vport} * {\b ovs_vport_alloc} (int priv_size, const struct {\b vport_ops} *, const struct {\b vport_parms} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_free} (struct {\b vport} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_deferred_free} (struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b vport_priv} (const struct {\b vport} *{\b vport})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct {\b vport} * {\b vport_from_priv} (void *priv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_receive} (struct {\b vport} *, struct sk_buff *, const struct {\b ovs_tunnel_info} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ovs_skb_postpush_rcsum} (struct sk_buff *skb, const void *start, unsigned int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ovs_vport_ops_register} (struct {\b vport_ops} *ops)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ovs_vport_ops_unregister} (struct {\b vport_ops} *ops)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v VPORT_ALIGN\:vport.h}
{\xe \v vport.h\:VPORT_ALIGN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VPORT_ALIGN\~ 8}}
\par
{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v vport_err_type\:vport.h}
{\xe \v vport.h\:vport_err_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b vport_err_type}}}
\par
{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v VPORT_E_RX_DROPPED\:vport.h}
{\xe \v vport.h\:VPORT_E_RX_DROPPED}
{\b {\i VPORT_E_RX_DROPPED{\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
}}  \par
{\xe \v VPORT_E_RX_ERROR\:vport.h}
{\xe \v vport.h\:VPORT_E_RX_ERROR}
{\b {\i VPORT_E_RX_ERROR{\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
}}  \par
{\xe \v VPORT_E_TX_DROPPED\:vport.h}
{\xe \v vport.h\:VPORT_E_TX_DROPPED}
{\b {\i VPORT_E_TX_DROPPED{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
}}  \par
{\xe \v VPORT_E_TX_ERROR\:vport.h}
{\xe \v vport.h\:VPORT_E_TX_ERROR}
{\b {\i VPORT_E_TX_ERROR{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
}}  \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   183                     \{\par
  184     VPORT_E_RX_DROPPED,\par
  185     VPORT_E_RX_ERROR,\par
  186     VPORT_E_TX_DROPPED,\par
  187     VPORT_E_TX_ERROR,\par
  188 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ovs_skb_postpush_rcsum\:vport.h}
{\xe \v vport.h\:ovs_skb_postpush_rcsum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ovs_skb_postpush_rcsum (struct sk_buff *  {\i skb}, const void *  {\i start}, unsigned int  {\i len}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{\par
  232     if (skb->ip_summed == CHECKSUM_COMPLETE)\par
  233         skb->csum = csum_add(skb->csum, csum_partial(start, len, 0));\par
  234 \}\par
}
}
{\xe \v ovs_tunnel_get_egress_info\:vport.h}
{\xe \v vport.h\:ovs_tunnel_get_egress_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_tunnel_get_egress_info (struct {\b ovs_tunnel_info} *  {\i egress_tun_info}, struct net *  {\i net}, const struct {\b ovs_tunnel_info} *  {\i tun_info}, u8  {\i ipproto}, u32  {\i skb_mark}, __be16  {\i tp_src}, __be16  {\i tp_dst})}}
\par
{\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   593 \{\par
  594     const struct ovs_key_ipv4_tunnel *tun_key;\par
  595     struct rtable *rt;\par
  596     __be32 saddr;\par
  597 \par
  598     if (unlikely(!tun_info))\par
  599         return -EINVAL;\par
  600 \par
  601     tun_key = &tun_info->tunnel;\par
  602     saddr = tun_key->ipv4_src;\par
  603     /* Route lookup to get srouce IP address: saddr.\par
  604      * The process may need to be changed if the corresponding process\par
  605      * in vports ops changed.\par
  606      */\par
  607     rt = find_route(net,\par
  608             &saddr,\par
  609             tun_key->ipv4_dst,\par
  610             ipproto,\par
  611             tun_key->ipv4_tos,\par
  612             skb_mark);\par
  613     if (IS_ERR(rt))\par
  614         return PTR_ERR(rt);\par
  615 \par
  616     ip_rt_put(rt);\par
  617 \par
  618     /* Generate egress_tun_info based on tun_info,\par
  619      * saddr, tp_src and tp_dst\par
  620      */\par
  621     __ovs_flow_tun_info_init(egress_tun_info,\par
  622                  saddr, tun_key->ipv4_dst,\par
  623                  tun_key->ipv4_tos,\par
  624                  tun_key->ipv4_ttl,\par
  625                  tp_src, tp_dst,\par
  626                  tun_key->tun_id,\par
  627                  tun_key->tun_flags,\par
  628                  tun_info->options,\par
  629                  tun_info->options_len);\par
  630 \par
  631     return 0;\par
  632 \}\par
}
}
{\xe \v ovs_vport_add\:vport.h}
{\xe \v vport.h\:ovs_vport_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_add (const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_add - add vport device (for kernel callers)\par
: Information about new vport.\par
Creates a new vport with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   211 \{\par
  212     struct vport_ops *ops;\par
  213     struct vport *vport;\par
  214 \par
  215     ops = ovs_vport_lookup(parms);\par
  216     if (ops) \{\par
  217         struct hlist_head *bucket;\par
  218 \par
  219         if (!try_module_get(ops->owner))\par
  220             return ERR_PTR(-EAFNOSUPPORT);\par
  221 \par
  222         vport = ops->create(parms);\par
  223         if (IS_ERR(vport)) \{\par
  224             module_put(ops->owner);\par
  225             return vport;\par
  226         \}\par
  227 \par
  228         bucket = hash_bucket(ovs_dp_get_net(vport->dp),\par
  229                      vport->ops->get_name(vport));\par
  230         hlist_add_head_rcu(&vport->hash_node, bucket);\par
  231         return vport;\par
  232     \}\par
  233 \par
  234     /* Unlock to attempt module load and return -EAGAIN if load\par
  235      * was successful as we need to restart the port addition\par
  236      * workflow.\par
  237      */\par
  238     ovs_unlock();\par
  239     request_module("vport-type-%d", parms->type);\par
  240     ovs_lock();\par
  241 \par
  242     if (!ovs_vport_lookup(parms))\par
  243         return ERR_PTR(-EAFNOSUPPORT);\par
  244     else\par
  245         return ERR_PTR(-EAGAIN);\par
  246 \}\par
}
}
{\xe \v ovs_vport_alloc\:vport.h}
{\xe \v vport.h\:ovs_vport_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_alloc (int  {\i priv_size}, const struct {\b vport_ops} *  {\i ops}, const struct {\b vport_parms} *  {\i parms})}}
\par
{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_alloc - allocate and initialize new vport\par
: Size of private data area to allocate. : vport device ops\par
Allocate and initialize a new vport defined by . The vport will contain a private data area of size  that can be accessed using {\b vport_priv()}. vports that are no longer needed should be released with {\b ovs_vport_free()}. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   139 \{\par
  140     struct vport *vport;\par
  141     size_t alloc_size;\par
  142 \par
  143     alloc_size = sizeof(struct vport);\par
  144     if (priv_size) \{\par
  145         alloc_size = ALIGN(alloc_size, VPORT_ALIGN);\par
  146         alloc_size += priv_size;\par
  147     \}\par
  148 \par
  149     vport = kzalloc(alloc_size, GFP_KERNEL);\par
  150     if (!vport)\par
  151         return ERR_PTR(-ENOMEM);\par
  152 \par
  153     vport->dp = parms->dp;\par
  154     vport->port_no = parms->port_no;\par
  155     vport->ops = ops;\par
  156     INIT_HLIST_NODE(&vport->dp_hash_node);\par
  157 \par
  158     if (ovs_vport_set_upcall_portids(vport, parms->upcall_portids)) \{\par
  159         kfree(vport);\par
  160         return ERR_PTR(-EINVAL);\par
  161     \}\par
  162 \par
  163     vport->percpu_stats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\par
  164     if (!vport->percpu_stats) \{\par
  165         kfree(vport);\par
  166         return ERR_PTR(-ENOMEM);\par
  167     \}\par
  168 \par
  169     return vport;\par
  170 \}\par
}
}
{\xe \v ovs_vport_deferred_free\:vport.h}
{\xe \v vport.h\:ovs_vport_deferred_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_deferred_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578 \{\par
  579     if (!vport)\par
  580         return;\par
  581 \par
  582     call_rcu(&vport->rcu, free_vport_rcu);\par
  583 \}\par
}
}
{\xe \v ovs_vport_del\:vport.h}
{\xe \v vport.h\:ovs_vport_del}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_del (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_del - delete existing vport device\par
: vport to delete.\par
Detaches  from its datapath and destroys it. It is possible to fail for reasons such as lack of memory. ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273 \{\par
  274     ASSERT_OVSL();\par
  275 \par
  276     hlist_del_rcu(&vport->hash_node);\par
  277     module_put(vport->ops->owner);\par
  278     vport->ops->destroy(vport);\par
  279 \}\par
}
}
{\xe \v ovs_vport_exit\:vport.h}
{\xe \v vport.h\:ovs_vport_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_exit (void )}}
\par
{\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_exit - shutdown vport subsystem\par
Called at module exit time to shutdown the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71     kfree(dev_table);\par
   72 \}\par
}
}
{\xe \v ovs_vport_find_upcall_portid\:vport.h}
{\xe \v vport.h\:ovs_vport_find_upcall_portid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32 ovs_vport_find_upcall_portid (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_find_upcall_portid - find the upcall portid to send upcall.\par
: vport from which the missed packet is received. : skb that the missed packet was received.\par
Uses the {\b skb_get_hash()} to select the upcall portid to send the upcall.\par
Returns the portid of the target socket. Must be called with rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   459 \{\par
  460     struct vport_portids *ids;\par
  461     u32 hash;\par
  462 \par
  463     ids = rcu_dereference(vport->upcall_portids);\par
  464 \par
  465     if (ids->n_ids == 1 && ids->ids[0] == 0)\par
  466         return 0;\par
  467 \par
  468     hash = skb_get_hash(skb);\par
  469     return ids->ids[hash - ids->n_ids * reciprocal_divide(hash, ids->rn_ids)];\par
  470 \}\par
}
}
{\xe \v ovs_vport_free\:vport.h}
{\xe \v vport.h\:ovs_vport_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_free (struct {\b vport} *  {\i vport})}}
\par
{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_free - uninitialize and free vport\par
: vport to free\par
Frees a vport allocated with {\b ovs_vport_alloc()} when it is no longer needed.\par
The caller must ensure that an RCU grace period has passed since the last time  was in a datapath. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195 \{\par
  196     kfree(rcu_dereference_raw(vport->upcall_portids));\par
  197     free_percpu(vport->percpu_stats);\par
  198     kfree(vport);\par
  199 \}\par
}
}
{\xe \v ovs_vport_get_egress_tun_info\:vport.h}
{\xe \v vport.h\:ovs_vport_get_egress_tun_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_egress_tun_info (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, struct {\b ovs_tunnel_info} *  {\i info})}}
\par
{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   637 \{\par
  638     /* get_egress_tun_info() is only implemented on tunnel ports. */\par
  639     if (unlikely(!vport->ops->get_egress_tun_info))\par
  640         return -EINVAL;\par
  641 \par
  642     return vport->ops->get_egress_tun_info(vport, skb, info);\par
  643 \}\par
}
}
{\xe \v ovs_vport_get_options\:vport.h}
{\xe \v vport.h\:ovs_vport_get_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_options (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_options - retrieve device options\par
: vport from which to retrieve the options. : sk_buff where options should be appended.\par
Retrieves the configuration of the given device, appending an OVS_VPORT_ATTR_OPTIONS attribute that in turn contains nested vport-specific attributes to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room, or another negative error code if a real error occurred. If an error occurs,  is left unmodified.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351 \{\par
  352     struct nlattr *nla;\par
  353     int err;\par
  354 \par
  355     if (!vport->ops->get_options)\par
  356         return 0;\par
  357 \par
  358     nla = nla_nest_start(skb, OVS_VPORT_ATTR_OPTIONS);\par
  359     if (!nla)\par
  360         return -EMSGSIZE;\par
  361 \par
  362     err = vport->ops->get_options(vport, skb);\par
  363     if (err) \{\par
  364         nla_nest_cancel(skb, nla);\par
  365         return err;\par
  366     \}\par
  367 \par
  368     nla_nest_end(skb, nla);\par
  369     return 0;\par
  370 \}\par
}
}
{\xe \v ovs_vport_get_stats\:vport.h}
{\xe \v vport.h\:ovs_vport_get_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_get_stats (struct {\b vport} *  {\i vport}, struct {\b ovs_vport_stats} *  {\i stats})}}
\par
{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_stats - retrieve device stats\par
: vport from which to retrieve the stats : location to store stats\par
Retrieves transmit, receive, and error stats for the given device.\par
Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int i;\par
  294 \par
  295     /* We potentially have two surces of stats that need to be\par
  296      * combined: those we have collected (split into err_stats and\par
  297      * percpu_stats), and device error stats from netdev->get_stats()\par
  298      * (for errors that happen downstream and therefore aren't\par
  299      * reported through our vport_record_error() function).\par
  300      * Stats from first source are reported by ovs over\par
  301      * OVS_VPORT_ATTR_STATS.\par
  302      * netdev-stats can be directly read over netlink-ioctl.\par
  303      */\par
  304 \par
  305     stats->rx_errors  = atomic_long_read(&vport->err_stats.rx_errors);\par
  306     stats->tx_errors  = atomic_long_read(&vport->err_stats.tx_errors);\par
  307     stats->tx_dropped = atomic_long_read(&vport->err_stats.tx_dropped);\par
  308     stats->rx_dropped = atomic_long_read(&vport->err_stats.rx_dropped);\par
  309 \par
  310     stats->rx_bytes     = 0;\par
  311     stats->rx_packets   = 0;\par
  312     stats->tx_bytes     = 0;\par
  313     stats->tx_packets   = 0;\par
  314 \par
  315     for_each_possible_cpu(i) \{\par
  316         const struct pcpu_sw_netstats *percpu_stats;\par
  317         struct pcpu_sw_netstats local_stats;\par
  318         unsigned int start;\par
  319 \par
  320         percpu_stats = per_cpu_ptr(vport->percpu_stats, i);\par
  321 \par
  322         do \{\par
  323             start = u64_stats_fetch_begin_irq(&percpu_stats->syncp);\par
  324             local_stats = *percpu_stats;\par
  325         \} while (u64_stats_fetch_retry_irq(&percpu_stats->syncp, start));\par
  326 \par
  327         stats->rx_bytes     += local_stats.rx_bytes;\par
  328         stats->rx_packets   += local_stats.rx_packets;\par
  329         stats->tx_bytes     += local_stats.tx_bytes;\par
  330         stats->tx_packets   += local_stats.tx_packets;\par
  331     \}\par
  332 \}\par
}
}
{\xe \v ovs_vport_get_upcall_portids\:vport.h}
{\xe \v vport.h\:ovs_vport_get_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_get_upcall_portids (const struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_get_upcall_portids - get the upcall_portids of .\par
: vport from which to retrieve the portids. : sk_buff where portids should be appended.\par
Retrieves the configuration of the given vport, appending the OVS_VPORT_ATTR_UPCALL_PID attribute which is the array of upcall portids to .\par
Returns 0 if successful, -EMSGSIZE if  has insufficient room. If an error occurs,  is left unmodified. Must be called with ovs_mutex or rcu_read_lock. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   435 \{\par
  436     struct vport_portids *ids;\par
  437 \par
  438     ids = rcu_dereference_ovsl(vport->upcall_portids);\par
  439 \par
  440     if (vport->dp->user_features & OVS_DP_F_VPORT_PIDS)\par
  441         return nla_put(skb, OVS_VPORT_ATTR_UPCALL_PID,\par
  442                    ids->n_ids * sizeof(u32), (void *) ids->ids);\par
  443     else\par
  444         return nla_put_u32(skb, OVS_VPORT_ATTR_UPCALL_PID, ids->ids[0]);\par
  445 \}\par
}
}
{\xe \v ovs_vport_init\:vport.h}
{\xe \v vport.h\:ovs_vport_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_init (void )}}
\par
{\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_init - initialize vport subsystem\par
Called at module load time to initialize the vport subsystem. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 \{\par
   56     dev_table = kzalloc(VPORT_HASH_BUCKETS * sizeof(struct hlist_head),\par
   57                 GFP_KERNEL);\par
   58     if (!dev_table)\par
   59         return -ENOMEM;\par
   60 \par
   61     return 0;\par
   62 \}\par
}
}
{\xe \v ovs_vport_locate\:vport.h}
{\xe \v vport.h\:ovs_vport_locate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vport}* ovs_vport_locate (const struct net *  {\i net}, const char *  {\i name})}}
\par
{\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114 \{\par
  115     struct hlist_head *bucket = hash_bucket(net, name);\par
  116     struct vport *vport;\par
  117 \par
  118     hlist_for_each_entry_rcu(vport, bucket, hash_node)\par
  119         if (!strcmp(name, vport->ops->get_name(vport)) &&\par
  120             net_eq(ovs_dp_get_net(vport->dp), net))\par
  121             return vport;\par
  122 \par
  123     return NULL;\par
  124 \}\par
}
}
{\xe \v ovs_vport_ops_register\:vport.h}
{\xe \v vport.h\:ovs_vport_ops_register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_ops_register (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    81 \{\par
   82     int err = -EEXIST;\par
   83     struct vport_ops *o;\par
   84 \par
   85     ovs_lock();\par
   86     list_for_each_entry(o, &vport_ops_list, list)\par
   87     if (ops->type == o->type)\par
   88         goto errout;\par
   89 \par
   90     list_add_tail(&ops->list, &vport_ops_list);\par
   91     err = 0;\par
   92 errout:\par
   93     ovs_unlock();\par
   94     return err;\par
   95 \}\par
}
}
{\xe \v ovs_vport_ops_unregister\:vport.h}
{\xe \v vport.h\:ovs_vport_ops_unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_ops_unregister (struct {\b vport_ops} *  {\i ops})}}
\par
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    99 \{\par
  100     ovs_lock();\par
  101     list_del(&ops->list);\par
  102     ovs_unlock();\par
  103 \}\par
}
}
{\xe \v ovs_vport_receive\:vport.h}
{\xe \v vport.h\:ovs_vport_receive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ovs_vport_receive (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb}, const struct {\b ovs_tunnel_info} *  {\i tun_info})}}
\par
{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_receive - pass up received packet to the datapath for processing\par
: vport that received the packet : skb that was received : tunnel (if any) that carried packet\par
Must be called with rcu_read_lock. The packet cannot be shared and skb->data should point to the Ethernet header. The caller must have already called compute_ip_summed() to initialize the checksumming fields. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   485 \{\par
  486     struct pcpu_sw_netstats *stats;\par
  487     struct sw_flow_key key;\par
  488     int error;\par
  489 \par
  490     stats = this_cpu_ptr(vport->percpu_stats);\par
  491     u64_stats_update_begin(&stats->syncp);\par
  492     stats->rx_packets++;\par
  493     stats->rx_bytes += skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);\par
  494     u64_stats_update_end(&stats->syncp);\par
  495 \par
  496     ovs_skb_init_inner_protocol(skb);\par
  497     OVS_CB(skb)->input_vport = vport;\par
  498     OVS_CB(skb)->egress_tun_info = NULL;\par
  499     error = ovs_flow_key_extract(tun_info, skb, &key);\par
  500     if (unlikely(error)) \{\par
  501         kfree_skb(skb);\par
  502         return;\par
  503     \}\par
  504     ovs_dp_process_packet(skb, &key);\par
  505 \}\par
}
}
{\xe \v ovs_vport_send\:vport.h}
{\xe \v vport.h\:ovs_vport_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_send (struct {\b vport} *  {\i vport}, struct sk_buff *  {\i skb})}}
\par
{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_send - send a packet on a device\par
: vport on which to send the packet : skb to send\par
Sends the given packet and returns the length of data sent. Either ovs lock or rcu_read_lock must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   518 \{\par
  519     int sent = vport->ops->send(vport, skb);\par
  520 \par
  521     if (likely(sent > 0)) \{\par
  522         struct pcpu_sw_netstats *stats;\par
  523 \par
  524         stats = this_cpu_ptr(vport->percpu_stats);\par
  525 \par
  526         u64_stats_update_begin(&stats->syncp);\par
  527         stats->tx_packets++;\par
  528         stats->tx_bytes += sent;\par
  529         u64_stats_update_end(&stats->syncp);\par
  530     \} else if (sent < 0) \{\par
  531         ovs_vport_record_error(vport, VPORT_E_TX_ERROR);\par
  532     \} else \{\par
  533         ovs_vport_record_error(vport, VPORT_E_TX_DROPPED);\par
  534     \}\par
  535     return sent;\par
  536 \}\par
}
}
{\xe \v ovs_vport_set_options\:vport.h}
{\xe \v vport.h\:ovs_vport_set_options}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_options (struct {\b vport} *  {\i vport}, struct nlattr *  {\i options})}}
\par
{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_options - modify existing vport device (for kernel callers)\par
: vport to modify. : New configuration.\par
Modifies an existing device with the specified configuration (which is dependent on device type). ovs_mutex must be held. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   258 \{\par
  259     if (!vport->ops->set_options)\par
  260         return -EOPNOTSUPP;\par
  261     return vport->ops->set_options(vport, options);\par
  262 \}\par
}
}
{\xe \v ovs_vport_set_upcall_portids\:vport.h}
{\xe \v vport.h\:ovs_vport_set_upcall_portids}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ovs_vport_set_upcall_portids (struct {\b vport} *  {\i vport}, const struct nlattr *  {\i ids})}}
\par
{\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ovs_vport_set_upcall_portids - set upcall portids of .\par
: vport to modify. : new configuration, an array of port ids.\par
Sets the vport's upcall_portids to .\par
Returns 0 if successful, -EINVAL if  is zero length or cannot be parsed as an array of U32.\par
Must be called with ovs_mutex. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   394 \{\par
  395     struct vport_portids *old, *vport_portids;\par
  396 \par
  397     if (!nla_len(ids) || nla_len(ids) % sizeof(u32))\par
  398         return -EINVAL;\par
  399 \par
  400     old = ovsl_dereference(vport->upcall_portids);\par
  401 \par
  402     vport_portids = kmalloc(sizeof *vport_portids + nla_len(ids),\par
  403                 GFP_KERNEL);\par
  404     if (!vport_portids)\par
  405         return -ENOMEM;\par
  406 \par
  407     vport_portids->n_ids = nla_len(ids) / sizeof(u32);\par
  408     vport_portids->rn_ids = reciprocal_value(vport_portids->n_ids);\par
  409     nla_memcpy(vport_portids->ids, ids, nla_len(ids));\par
  410 \par
  411     rcu_assign_pointer(vport->upcall_portids, vport_portids);\par
  412 \par
  413     if (old)\par
  414         call_rcu(&old->rcu, vport_portids_destroy_rcu_cb);\par
  415 \par
  416     return 0;\par
  417 \}\par
}
}
{\xe \v vport_from_priv\:vport.h}
{\xe \v vport.h\:vport_from_priv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static struct {\b vport}* vport_from_priv (void *  {\i priv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
vport_from_priv - lookup vport from private data pointer\par
: Start of private data area.\par
It is sometimes useful to translate from a pointer to the private data area to the vport, such as in the case where the private data pointer is the result of a hash table lookup.  must point to the start of the private data area. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   222 \{\par
  223     return (struct vport *)((u8 *)priv - ALIGN(sizeof(struct vport), VPORT_ALIGN));\par
  224 \}\par
}
}
{\xe \v vport_priv\:vport.h}
{\xe \v vport.h\:vport_priv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* vport_priv (const struct {\b vport} *  {\i vport}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
vport_priv - access private data area of vport\par
: vport to access\par
If a nonzero size was passed in priv_size of vport_alloc() a private data area was allocated on creation. This allows that area to be accessed and used for any purpose needed by the vport implementer. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   207 \{\par
  208     return (u8 *)(uintptr_t)vport + ALIGN(sizeof(struct vport), VPORT_ALIGN);\par
  209 \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}