\hypertarget{linux_2flow_8c}{}\section{/home/vladn/git/ovs/datapath/linux/flow.c File Reference}
\label{linux_2flow_8c}\index{/home/vladn/git/ovs/datapath/linux/flow.\+c@{/home/vladn/git/ovs/datapath/linux/flow.\+c}}
{\ttfamily \#include $<$linux/uaccess.\+h$>$}\\*
{\ttfamily \#include $<$linux/netdevice.\+h$>$}\\*
{\ttfamily \#include $<$linux/etherdevice.\+h$>$}\\*
{\ttfamily \#include $<$linux/if\+\_\+ether.\+h$>$}\\*
{\ttfamily \#include $<$linux/if\+\_\+vlan.\+h$>$}\\*
{\ttfamily \#include $<$net/llc\+\_\+pdu.\+h$>$}\\*
{\ttfamily \#include $<$linux/kernel.\+h$>$}\\*
{\ttfamily \#include $<$linux/jhash.\+h$>$}\\*
{\ttfamily \#include $<$linux/jiffies.\+h$>$}\\*
{\ttfamily \#include $<$linux/llc.\+h$>$}\\*
{\ttfamily \#include $<$linux/module.\+h$>$}\\*
{\ttfamily \#include $<$linux/in.\+h$>$}\\*
{\ttfamily \#include $<$linux/rcupdate.\+h$>$}\\*
{\ttfamily \#include $<$linux/if\+\_\+arp.\+h$>$}\\*
{\ttfamily \#include $<$linux/ip.\+h$>$}\\*
{\ttfamily \#include $<$linux/ipv6.\+h$>$}\\*
{\ttfamily \#include $<$linux/mpls.\+h$>$}\\*
{\ttfamily \#include $<$linux/sctp.\+h$>$}\\*
{\ttfamily \#include $<$linux/smp.\+h$>$}\\*
{\ttfamily \#include $<$linux/tcp.\+h$>$}\\*
{\ttfamily \#include $<$linux/udp.\+h$>$}\\*
{\ttfamily \#include $<$linux/icmp.\+h$>$}\\*
{\ttfamily \#include $<$linux/icmpv6.\+h$>$}\\*
{\ttfamily \#include $<$linux/rculist.\+h$>$}\\*
{\ttfamily \#include $<$net/ip.\+h$>$}\\*
{\ttfamily \#include $<$net/ipv6.\+h$>$}\\*
{\ttfamily \#include $<$net/mpls.\+h$>$}\\*
{\ttfamily \#include $<$net/ndisc.\+h$>$}\\*
{\ttfamily \#include \char`\"{}datapath.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}flow.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}flow\+\_\+netlink.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}vlan.\+h\char`\"{}}\\*
Include dependency graph for flow.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{linux_2flow_8c__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{linux_2flow_8c_a1244774ec23560204eceaae557eff6d1}{T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16}(\hyperlink{flow_8h_ad44c86ae49f219522bcd4fb2744b81b2}{tp})~($\ast$(\+\_\+\+\_\+be16 $\ast$)\&tcp\+\_\+flag\+\_\+word(\hyperlink{flow_8h_ad44c86ae49f219522bcd4fb2744b81b2}{tp}) \& htons(0x0\+F\+F\+F))
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
u64 \hyperlink{linux_2flow_8c_adfdcc779325fc169a793acda2e32a46b}{ovs\+\_\+flow\+\_\+used\+\_\+time} (unsigned long flow\+\_\+jiffies)
\item 
void \hyperlink{linux_2flow_8c_ad20885fb9e6da56eb9cb58d139281916}{ovs\+\_\+flow\+\_\+stats\+\_\+update} (struct \hyperlink{structsw__flow}{sw\+\_\+flow} $\ast$flow, \+\_\+\+\_\+be16 tcp\+\_\+flags, const struct sk\+\_\+buff $\ast$skb)
\item 
void \hyperlink{linux_2flow_8c_a03636247cfc74747632c000eec0919db}{ovs\+\_\+flow\+\_\+stats\+\_\+get} (const struct \hyperlink{structsw__flow}{sw\+\_\+flow} $\ast$flow, struct \hyperlink{structovs__flow__stats}{ovs\+\_\+flow\+\_\+stats} $\ast$ovs\+\_\+stats, unsigned long $\ast$used, \+\_\+\+\_\+be16 $\ast$tcp\+\_\+flags)
\item 
void \hyperlink{linux_2flow_8c_a8dfa7ecd72ff9237664d0c402ff3f543}{ovs\+\_\+flow\+\_\+stats\+\_\+clear} (struct \hyperlink{structsw__flow}{sw\+\_\+flow} $\ast$flow)
\item 
static int \hyperlink{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}{check\+\_\+header} (struct sk\+\_\+buff $\ast$skb, int len)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_ad6e91741b7e2a5ad174d0d9c899887b6}{arphdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static int \hyperlink{linux_2flow_8c_ac23e11b5fa6e9068412b23f6388ae2df}{check\+\_\+iphdr} (struct sk\+\_\+buff $\ast$skb)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_a71815483a340e9bab0bbcbc52537cfb5}{tcphdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_a354e4e351441e305c10a030f9d1dab7f}{udphdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_a235207174d62d682354a73e4b43a4ee2}{sctphdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_ac87d76f166f066dd4a2c9bc729702ab6}{icmphdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static int \hyperlink{linux_2flow_8c_aae5a88c529fa6e31de896e40c546ec90}{parse\+\_\+ipv6hdr} (struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key)
\item 
static \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} \hyperlink{linux_2flow_8c_a4191de70201a777f1ac4e71fc5c24d17}{icmp6hdr\+\_\+ok} (struct sk\+\_\+buff $\ast$skb)
\item 
static int \hyperlink{linux_2flow_8c_aab1dd840cacc7b21ee01cb885171d60d}{parse\+\_\+vlan} (struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key)
\item 
static \+\_\+\+\_\+be16 \hyperlink{linux_2flow_8c_a8f4a5415b9d6b2be7aef9e3749e65908}{parse\+\_\+ethertype} (struct sk\+\_\+buff $\ast$skb)
\item 
static int \hyperlink{linux_2flow_8c_a0b01cb308f20bbfe4348b6ef1b27a65d}{parse\+\_\+icmpv6} (struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key, int nh\+\_\+len)
\item 
static int \hyperlink{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}{key\+\_\+extract} (struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key)
\item 
int \hyperlink{linux_2flow_8c_a7d27b3745046ced4859b9fa615e27543}{ovs\+\_\+flow\+\_\+key\+\_\+update} (struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key)
\item 
int \hyperlink{linux_2flow_8c_a88b5c281d297950115033a17dbce5208}{ovs\+\_\+flow\+\_\+key\+\_\+extract} (const struct \hyperlink{structovs__tunnel__info}{ovs\+\_\+tunnel\+\_\+info} $\ast$tun\+\_\+info, struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key)
\item 
int \hyperlink{linux_2flow_8c_a5e042238993a5a8a8a8b3472cb274ead}{ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace} (const struct nlattr $\ast$attr, struct sk\+\_\+buff $\ast$skb, struct \hyperlink{structsw__flow__key}{sw\+\_\+flow\+\_\+key} $\ast$key, \hyperlink{types_8h_afaa87723b8417d40fcf45b7330261ef9}{bool} log)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{linux_2flow_8c_a1244774ec23560204eceaae557eff6d1}{}\index{linux/flow.\+c@{linux/flow.\+c}!T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16@{T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16}}
\index{T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16@{T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16}]{\setlength{\rightskip}{0pt plus 5cm}\#define T\+C\+P\+\_\+\+F\+L\+A\+G\+S\+\_\+\+B\+E16(
\begin{DoxyParamCaption}
\item[{}]{{\bf tp}}
\end{DoxyParamCaption}
)~($\ast$(\+\_\+\+\_\+be16 $\ast$)\&tcp\+\_\+flag\+\_\+word({\bf tp}) \& htons(0x0\+F\+F\+F))}\label{linux_2flow_8c_a1244774ec23560204eceaae557eff6d1}


\subsection{Function Documentation}
\hypertarget{linux_2flow_8c_ad6e91741b7e2a5ad174d0d9c899887b6}{}\index{linux/flow.\+c@{linux/flow.\+c}!arphdr\+\_\+ok@{arphdr\+\_\+ok}}
\index{arphdr\+\_\+ok@{arphdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{arphdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} arphdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_ad6e91741b7e2a5ad174d0d9c899887b6}

\begin{DoxyCode}
189 \{
190     \textcolor{keywordflow}{return} pskb\_may\_pull(skb, \hyperlink{skbuff_8h_aabe75b44039b11c1b7c6e2f246e7146e}{skb\_network\_offset}(skb) +
191                   \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structarp__eth__header}{arp\_eth\_header}));
192 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}{}\index{linux/flow.\+c@{linux/flow.\+c}!check\+\_\+header@{check\+\_\+header}}
\index{check\+\_\+header@{check\+\_\+header}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{check\+\_\+header}]{\setlength{\rightskip}{0pt plus 5cm}static int check\+\_\+header (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{int}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}

\begin{DoxyCode}
180 \{
181     \textcolor{keywordflow}{if} (unlikely(skb->len < len))
182         \textcolor{keywordflow}{return} -EINVAL;
183     \textcolor{keywordflow}{if} (unlikely(!pskb\_may\_pull(skb, len)))
184         \textcolor{keywordflow}{return} -ENOMEM;
185     \textcolor{keywordflow}{return} 0;
186 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_ac23e11b5fa6e9068412b23f6388ae2df}{}\index{linux/flow.\+c@{linux/flow.\+c}!check\+\_\+iphdr@{check\+\_\+iphdr}}
\index{check\+\_\+iphdr@{check\+\_\+iphdr}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{check\+\_\+iphdr}]{\setlength{\rightskip}{0pt plus 5cm}static int check\+\_\+iphdr (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_ac23e11b5fa6e9068412b23f6388ae2df}

\begin{DoxyCode}
195 \{
196     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nh\_ofs = \hyperlink{skbuff_8h_aabe75b44039b11c1b7c6e2f246e7146e}{skb\_network\_offset}(skb);
197     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ip\_len;
198     \textcolor{keywordtype}{int} err;
199 
200     err = \hyperlink{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}{check\_header}(skb, nh\_ofs + \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} iphdr));
201     \textcolor{keywordflow}{if} (unlikely(err))
202         \textcolor{keywordflow}{return} err;
203 
204     ip\_len = \hyperlink{linux_2ip_8h_a769819999a936046f6b97cca3ec3ef74}{ip\_hdrlen}(skb);
205     \textcolor{keywordflow}{if} (unlikely(ip\_len < \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} iphdr) ||
206              skb->len < nh\_ofs + ip\_len))
207         \textcolor{keywordflow}{return} -EINVAL;
208 
209     \hyperlink{skbuff_8h_a35af79b1b630fc75fbd7347549b6affe}{skb\_set\_transport\_header}(skb, nh\_ofs + ip\_len);
210     \textcolor{keywordflow}{return} 0;
211 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a4191de70201a777f1ac4e71fc5c24d17}{}\index{linux/flow.\+c@{linux/flow.\+c}!icmp6hdr\+\_\+ok@{icmp6hdr\+\_\+ok}}
\index{icmp6hdr\+\_\+ok@{icmp6hdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{icmp6hdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} icmp6hdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a4191de70201a777f1ac4e71fc5c24d17}

\begin{DoxyCode}
292 \{
293     \textcolor{keywordflow}{return} pskb\_may\_pull(skb, \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb) +
294                   \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} icmp6hdr));
295 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_ac87d76f166f066dd4a2c9bc729702ab6}{}\index{linux/flow.\+c@{linux/flow.\+c}!icmphdr\+\_\+ok@{icmphdr\+\_\+ok}}
\index{icmphdr\+\_\+ok@{icmphdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{icmphdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} icmphdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_ac87d76f166f066dd4a2c9bc729702ab6}

\begin{DoxyCode}
242 \{
243     \textcolor{keywordflow}{return} pskb\_may\_pull(skb, \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb) +
244                   \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} icmphdr));
245 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}{}\index{linux/flow.\+c@{linux/flow.\+c}!key\+\_\+extract@{key\+\_\+extract}}
\index{key\+\_\+extract@{key\+\_\+extract}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{key\+\_\+extract}]{\setlength{\rightskip}{0pt plus 5cm}static int key\+\_\+extract (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}
key\+\_\+extract -\/ extracts a flow key from an Ethernet frame. \+: sk\+\_\+buff that contains the frame, with skb-\/$>$data pointing to the Ethernet header \+: output flow key

The caller must ensure that skb-\/$>$len $>$= E\+T\+H\+\_\+\+H\+L\+E\+N.

Returns 0 if successful, otherwise a negative errno value.

Initializes  header pointers as follows\+:


\begin{DoxyItemize}
\item skb-\/$>$mac\+\_\+header\+: the Ethernet header.
\item skb-\/$>$network\+\_\+header\+: just past the Ethernet header, or just past the V\+L\+A\+N header, to the first byte of the Ethernet payload.
\item skb-\/$>$transport\+\_\+header\+: If key-\/$>$eth.\+type is E\+T\+H\+\_\+\+P\+\_\+\+I\+P or E\+T\+H\+\_\+\+P\+\_\+\+I\+P\+V6 on output, then just past the I\+P header, if one is present and of a correct length, otherwise the same as skb-\/$>$network\+\_\+header. For other key-\/$>$eth.\+type values it is left untouched. 
\end{DoxyItemize}
\begin{DoxyCode}
454 \{
455     \textcolor{keywordtype}{int} error;
456     \textcolor{keyword}{struct }ethhdr *\hyperlink{flow_8h_a1679a3c93391059deba58179f52c86a6}{eth};
457 
458     \textcolor{comment}{/* Flags are always used as part of stats */}
459     key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a910f5e4408d113dbc9211190b44e0880}{flags} = 0;
460 
461     \hyperlink{skbuff_8h_aaf81c26756757ac1e1d7e6933f61bdaf}{skb\_reset\_mac\_header}(skb);
462 
463     \textcolor{comment}{/* Link layer.  We are guaranteed to have at least the 14 byte Ethernet}
464 \textcolor{comment}{     * header in the linear data area.}
465 \textcolor{comment}{     */}
466     eth = eth\_hdr(skb);
467     \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src}, eth->h\_source);
468     \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst}, eth->h\_dest);
469 
470     \_\_skb\_pull(skb, 2 * ETH\_ALEN);
471     \textcolor{comment}{/* We are going to push all headers that we pull, so no need to}
472 \textcolor{comment}{     * update skb->csum here.}
473 \textcolor{comment}{     */}
474 
475     key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_a56b27b9b9eafa8f79acd544eba98c7b0}{tci} = 0;
476     \textcolor{keywordflow}{if} (\hyperlink{if__vlan_8h_a0bdf3e26944669a4265c7e717e846215}{skb\_vlan\_tag\_present}(skb))
477         key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_a56b27b9b9eafa8f79acd544eba98c7b0}{tci} = htons(\hyperlink{vlan_8h_a7d6820c8064af28c10f40f519605c2db}{vlan\_get\_tci}(skb));
478     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (eth->h\_proto == htons(ETH\_P\_8021Q))
479         \textcolor{keywordflow}{if} (unlikely(\hyperlink{linux_2flow_8c_aab1dd840cacc7b21ee01cb885171d60d}{parse\_vlan}(skb, key)))
480             \textcolor{keywordflow}{return} -ENOMEM;
481 
482     key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} = \hyperlink{linux_2flow_8c_a8f4a5415b9d6b2be7aef9e3749e65908}{parse\_ethertype}(skb);
483     \textcolor{keywordflow}{if} (unlikely(key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} == htons(0)))
484         \textcolor{keywordflow}{return} -ENOMEM;
485 
486     \hyperlink{skbuff_8h_a2ea5d9050fe3927247bb55820cfcb02c}{skb\_reset\_network\_header}(skb);
487     \hyperlink{skbuff_8h_ae4be7dfedacf0e75fd904f0f54c9c731}{skb\_reset\_mac\_len}(skb);
488     \_\_skb\_push(skb, skb->data - \hyperlink{skbuff_8h_a292027671dfcf3aa23f9551f48713e24}{skb\_mac\_header}(skb));
489 
490     \textcolor{comment}{/* Network layer. */}
491     \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} == htons(ETH\_P\_IP)) \{
492         \textcolor{keyword}{struct }iphdr *nh;
493         \_\_be16 offset;
494 
495         error = \hyperlink{linux_2flow_8c_ac23e11b5fa6e9068412b23f6388ae2df}{check\_iphdr}(skb);
496         \textcolor{keywordflow}{if} (unlikely(error)) \{
497             memset(&key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}));
498             memset(&key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}));
499             \textcolor{keywordflow}{if} (error == -EINVAL) \{
500                 skb->transport\_header = skb->network\_header;
501                 error = 0;
502             \}
503             \textcolor{keywordflow}{return} error;
504         \}
505 
506         nh = \hyperlink{linux_2ip_8h_a06ad68dbeebbe718758ba2d5ebb6335c}{ip\_hdr}(skb);
507         key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.src = nh->saddr;
508         key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.dst = nh->daddr;
509 
510         key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto = nh->protocol;
511         key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.tos = nh->tos;
512         key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.ttl = nh->ttl;
513 
514         offset = nh->frag\_off & htons(IP\_OFFSET);
515         \textcolor{keywordflow}{if} (offset) \{
516             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a1d1c9f89ced33419ec870391d8954c10}{OVS\_FRAG\_TYPE\_LATER};
517             \textcolor{keywordflow}{return} 0;
518         \}
519         \textcolor{keywordflow}{if} (nh->frag\_off & htons(IP\_MF) ||
520             skb\_shinfo(skb)->gso\_type & SKB\_GSO\_UDP)
521             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a7302a2ecd7ef2e817fadcd3e943af200}{OVS\_FRAG\_TYPE\_FIRST};
522         \textcolor{keywordflow}{else}
523             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a8551f9db6addee11579a10fe4b1e9d62}{OVS\_FRAG\_TYPE\_NONE};
524 
525         \textcolor{comment}{/* Transport layer. */}
526         \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == IPPROTO\_TCP) \{
527             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a71815483a340e9bab0bbcbc52537cfb5}{tcphdr\_ok}(skb)) \{
528                 \textcolor{keyword}{struct }tcphdr *tcp = \hyperlink{tcp_8h_a9ac4e94949ea9142c45cf46683be5ef7}{tcp\_hdr}(skb);
529                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = tcp->source;
530                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = tcp->dest;
531                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a910f5e4408d113dbc9211190b44e0880}{flags} = \hyperlink{linux_2flow_8c_a1244774ec23560204eceaae557eff6d1}{TCP\_FLAGS\_BE16}(tcp);
532             \} \textcolor{keywordflow}{else} \{
533                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
534             \}
535 
536         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == IPPROTO\_UDP) \{
537             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a354e4e351441e305c10a030f9d1dab7f}{udphdr\_ok}(skb)) \{
538                 \textcolor{keyword}{struct }udphdr *udp = \hyperlink{linux_2udp_8h_a7b8908e197538768cf4ff9ec577bd86b}{udp\_hdr}(skb);
539                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = udp->source;
540                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = udp->dest;
541             \} \textcolor{keywordflow}{else} \{
542                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
543             \}
544         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == IPPROTO\_SCTP) \{
545             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a235207174d62d682354a73e4b43a4ee2}{sctphdr\_ok}(skb)) \{
546                 \textcolor{keyword}{struct }sctphdr *sctp = \hyperlink{sctp_8h_a6f9abfbe98294e40a3f32db7ad723998}{sctp\_hdr}(skb);
547                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = sctp->source;
548                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = sctp->dest;
549             \} \textcolor{keywordflow}{else} \{
550                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
551             \}
552         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == IPPROTO\_ICMP) \{
553             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_ac87d76f166f066dd4a2c9bc729702ab6}{icmphdr\_ok}(skb)) \{
554                 \textcolor{keyword}{struct }icmphdr *icmp = \hyperlink{icmp_8h_a2226121e608b10a1dde33ed552361bba}{icmp\_hdr}(skb);
555                 \textcolor{comment}{/* The ICMP type and code fields use the 16-bit}
556 \textcolor{comment}{                 * transport port fields, so we need to store}
557 \textcolor{comment}{                 * them in 16-bit network byte order.}
558 \textcolor{comment}{                 */}
559                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = htons(icmp->type);
560                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = htons(icmp->code);
561             \} \textcolor{keywordflow}{else} \{
562                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
563             \}
564         \}
565 
566     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} == htons(ETH\_P\_ARP) ||
567            key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} == htons(ETH\_P\_RARP)) \{
568         \textcolor{keyword}{struct }\hyperlink{structarp__eth__header}{arp\_eth\_header} *\hyperlink{flow_8h_aa05c06f4d8f8b791f607aa53db449356}{arp};
569         \textcolor{keywordtype}{bool} arp\_available = \hyperlink{linux_2flow_8c_ad6e91741b7e2a5ad174d0d9c899887b6}{arphdr\_ok}(skb);
570 
571         arp = (\textcolor{keyword}{struct }\hyperlink{structarp__eth__header}{arp\_eth\_header} *)\hyperlink{skbuff_8h_aa9e0f2aeb3abecde73023d35145bc4a0}{skb\_network\_header}(skb);
572 
573         \textcolor{keywordflow}{if} (arp\_available &&
574             arp->\hyperlink{structarp__eth__header_afe4c385a8760054d1d9da4e06b72dc3a}{ar\_hrd} == htons(ARPHRD\_ETHER) &&
575             arp->\hyperlink{structarp__eth__header_aa0a6c956f6f9001377528f86f94d91b4}{ar\_pro} == htons(ETH\_P\_IP) &&
576             arp->\hyperlink{structarp__eth__header_a8feceb41fdd95e4a0f1e17e56b957bf4}{ar\_hln} == ETH\_ALEN &&
577             arp->\hyperlink{structarp__eth__header_abc215d845eb12176276c8cee0501ecd8}{ar\_pln} == 4) \{
578 
579             \textcolor{comment}{/* We only match on the lower 8 bits of the opcode. */}
580             \textcolor{keywordflow}{if} (ntohs(arp->\hyperlink{structarp__eth__header_a0cad73c318ab7ea788fa836f6b5a011d}{ar\_op}) <= 0xff)
581                 key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto = ntohs(arp->\hyperlink{structarp__eth__header_a0cad73c318ab7ea788fa836f6b5a011d}{ar\_op});
582             \textcolor{keywordflow}{else}
583                 key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto = 0;
584 
585             memcpy(&key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.src, arp->\hyperlink{structarp__eth__header_ae584842ae04804b2f5cf3c26fb135961}{ar\_sip}, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.src));
586             memcpy(&key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.dst, arp->\hyperlink{structarp__eth__header_a9ed88031c0dd2f554f1dc455e878945d}{ar\_tip}, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.addr.dst));
587             \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.arp.sha, arp->\hyperlink{structarp__eth__header_a569cddaf9ed4aa40b04b60958783e908}{ar\_sha});
588             \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}.arp.tha, arp->\hyperlink{structarp__eth__header_a490c51d5f01a32e78c57d020ca2662f6}{ar\_tha});
589         \} \textcolor{keywordflow}{else} \{
590             memset(&key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}));
591             memset(&key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_aeb4295bcb2fb4efea5c30337b871a423}{ipv4}));
592         \}
593     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{net_2mpls_8h_aab48ab242fbafafc869b3e98df4ace8f}{eth\_p\_mpls}(key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type})) \{
594         \textcolor{keywordtype}{size\_t} stack\_len = \hyperlink{net_2mpls_8h_a9a0b8d7adb48a79ca82a00b2663823ee}{MPLS\_HLEN};
595 
596         \textcolor{comment}{/* In the presence of an MPLS label stack the end of the L2}
597 \textcolor{comment}{         * header and the beginning of the L3 header differ.}
598 \textcolor{comment}{         *}
599 \textcolor{comment}{         * Advance network\_header to the beginning of the L3}
600 \textcolor{comment}{         * header. mac\_len corresponds to the end of the L2 header.}
601 \textcolor{comment}{         */}
602         \textcolor{keywordflow}{while} (1) \{
603             \_\_be32 lse;
604 
605             error = \hyperlink{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}{check\_header}(skb, skb->mac\_len + stack\_len);
606             \textcolor{keywordflow}{if} (unlikely(error))
607                 \textcolor{keywordflow}{return} 0;
608 
609             memcpy(&lse, \hyperlink{skbuff_8h_aa9e0f2aeb3abecde73023d35145bc4a0}{skb\_network\_header}(skb), \hyperlink{net_2mpls_8h_a9a0b8d7adb48a79ca82a00b2663823ee}{MPLS\_HLEN});
610 
611             \textcolor{keywordflow}{if} (stack\_len == \hyperlink{net_2mpls_8h_a9a0b8d7adb48a79ca82a00b2663823ee}{MPLS\_HLEN})
612                 memcpy(&key->\hyperlink{structsw__flow__key_a005840d04ee5b462be3c8e21809dc9aa}{mpls}.top\_lse, &lse, \hyperlink{net_2mpls_8h_a9a0b8d7adb48a79ca82a00b2663823ee}{MPLS\_HLEN});
613 
614             \hyperlink{skbuff_8h_a2aa771daf8e324a50f60e4934839dc2c}{skb\_set\_network\_header}(skb, skb->mac\_len + stack\_len);
615             \textcolor{keywordflow}{if} (lse & htonl(MPLS\_LS\_S\_MASK))
616                 \textcolor{keywordflow}{break};
617 
618             stack\_len += \hyperlink{net_2mpls_8h_a9a0b8d7adb48a79ca82a00b2663823ee}{MPLS\_HLEN};
619         \}
620     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_af30defbb2a81c997e8747594e1d937a0}{type} == htons(ETH\_P\_IPV6)) \{
621         \textcolor{keywordtype}{int} nh\_len;             \textcolor{comment}{/* IPv6 Header + Extensions */}
622 
623         nh\_len = \hyperlink{linux_2flow_8c_aae5a88c529fa6e31de896e40c546ec90}{parse\_ipv6hdr}(skb, key);
624         \textcolor{keywordflow}{if} (unlikely(nh\_len < 0)) \{
625             memset(&key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}));
626             memset(&key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.addr, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.addr));
627             \textcolor{keywordflow}{if} (nh\_len == -EINVAL) \{
628                 skb->transport\_header = skb->network\_header;
629                 error = 0;
630             \} \textcolor{keywordflow}{else} \{
631                 error = nh\_len;
632             \}
633             \textcolor{keywordflow}{return} error;
634         \}
635 
636         \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag == \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a1d1c9f89ced33419ec870391d8954c10}{OVS\_FRAG\_TYPE\_LATER})
637             \textcolor{keywordflow}{return} 0;
638         \textcolor{keywordflow}{if} (skb\_shinfo(skb)->gso\_type & SKB\_GSO\_UDP)
639             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a7302a2ecd7ef2e817fadcd3e943af200}{OVS\_FRAG\_TYPE\_FIRST};
640 
641         \textcolor{comment}{/* Transport layer. */}
642         \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == NEXTHDR\_TCP) \{
643             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a71815483a340e9bab0bbcbc52537cfb5}{tcphdr\_ok}(skb)) \{
644                 \textcolor{keyword}{struct }tcphdr *tcp = \hyperlink{tcp_8h_a9ac4e94949ea9142c45cf46683be5ef7}{tcp\_hdr}(skb);
645                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = tcp->source;
646                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = tcp->dest;
647                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a910f5e4408d113dbc9211190b44e0880}{flags} = \hyperlink{linux_2flow_8c_a1244774ec23560204eceaae557eff6d1}{TCP\_FLAGS\_BE16}(tcp);
648             \} \textcolor{keywordflow}{else} \{
649                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
650             \}
651         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == NEXTHDR\_UDP) \{
652             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a354e4e351441e305c10a030f9d1dab7f}{udphdr\_ok}(skb)) \{
653                 \textcolor{keyword}{struct }udphdr *udp = \hyperlink{linux_2udp_8h_a7b8908e197538768cf4ff9ec577bd86b}{udp\_hdr}(skb);
654                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = udp->source;
655                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = udp->dest;
656             \} \textcolor{keywordflow}{else} \{
657                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
658             \}
659         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == \hyperlink{net_2ipv6_8h_a1135c535edd95af9465ce2921dd31c28}{NEXTHDR\_SCTP}) \{
660             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a235207174d62d682354a73e4b43a4ee2}{sctphdr\_ok}(skb)) \{
661                 \textcolor{keyword}{struct }sctphdr *sctp = \hyperlink{sctp_8h_a6f9abfbe98294e40a3f32db7ad723998}{sctp\_hdr}(skb);
662                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = sctp->source;
663                 key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = sctp->dest;
664             \} \textcolor{keywordflow}{else} \{
665                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
666             \}
667         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto == NEXTHDR\_ICMP) \{
668             \textcolor{keywordflow}{if} (\hyperlink{linux_2flow_8c_a4191de70201a777f1ac4e71fc5c24d17}{icmp6hdr\_ok}(skb)) \{
669                 error = \hyperlink{linux_2flow_8c_a0b01cb308f20bbfe4348b6ef1b27a65d}{parse\_icmpv6}(skb, key, nh\_len);
670                 \textcolor{keywordflow}{if} (error)
671                     \textcolor{keywordflow}{return} error;
672             \} \textcolor{keywordflow}{else} \{
673                 memset(&key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}));
674             \}
675         \}
676     \}
677     \textcolor{keywordflow}{return} 0;
678 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a88b5c281d297950115033a17dbce5208}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+key\+\_\+extract@{ovs\+\_\+flow\+\_\+key\+\_\+extract}}
\index{ovs\+\_\+flow\+\_\+key\+\_\+extract@{ovs\+\_\+flow\+\_\+key\+\_\+extract}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+key\+\_\+extract}]{\setlength{\rightskip}{0pt plus 5cm}int ovs\+\_\+flow\+\_\+key\+\_\+extract (
\begin{DoxyParamCaption}
\item[{const struct {\bf ovs\+\_\+tunnel\+\_\+info} $\ast$}]{tun\+\_\+info, }
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_a88b5c281d297950115033a17dbce5208}

\begin{DoxyCode}
687 \{
688     \textcolor{comment}{/* Extract metadata from packet. */}
689     \textcolor{keywordflow}{if} (tun\_info) \{
690         memcpy(&key->\hyperlink{structsw__flow__key_a2f87b7690c0cc2797f1f4347589472c3}{tun\_key}, &tun\_info->\hyperlink{structovs__tunnel__info_a007f0c7a9938884e6e8663cb4ab20d10}{tunnel}, \textcolor{keyword}{sizeof}(key->
      \hyperlink{structsw__flow__key_a2f87b7690c0cc2797f1f4347589472c3}{tun\_key}));
691 
692         BUILD\_BUG\_ON(((1 << (\textcolor{keyword}{sizeof}(tun\_info->\hyperlink{structovs__tunnel__info_ab50d289f61727b922831739affb28b18}{options\_len}) * 8)) - 1) >
693                  \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a54b30752817dccb02665a7eecde52a72}{tun\_opts}));
694 
695         \textcolor{keywordflow}{if} (tun\_info->\hyperlink{structovs__tunnel__info_ae4fd786894f579a38a5955e7a0e68fd4}{options}) \{
696             memcpy(\hyperlink{flow_8h_a5d74524a15e17551a8d8235f4375c296}{TUN\_METADATA\_OPTS}(key, tun\_info->\hyperlink{structovs__tunnel__info_ab50d289f61727b922831739affb28b18}{options\_len}),
697                    tun\_info->\hyperlink{structovs__tunnel__info_ae4fd786894f579a38a5955e7a0e68fd4}{options}, tun\_info->\hyperlink{structovs__tunnel__info_ab50d289f61727b922831739affb28b18}{options\_len});
698             key->\hyperlink{structsw__flow__key_aef0ea317d3bd0125e0d6390261ba3e2d}{tun\_opts\_len} = tun\_info->\hyperlink{structovs__tunnel__info_ab50d289f61727b922831739affb28b18}{options\_len};
699         \} \textcolor{keywordflow}{else} \{
700             key->\hyperlink{structsw__flow__key_aef0ea317d3bd0125e0d6390261ba3e2d}{tun\_opts\_len} = 0;
701         \}
702     \} \textcolor{keywordflow}{else} \{
703         key->\hyperlink{structsw__flow__key_aef0ea317d3bd0125e0d6390261ba3e2d}{tun\_opts\_len} = 0;
704         memset(&key->\hyperlink{structsw__flow__key_a2f87b7690c0cc2797f1f4347589472c3}{tun\_key}, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a2f87b7690c0cc2797f1f4347589472c3}{tun\_key}));
705     \}
706 
707     key->\hyperlink{structsw__flow__key_a57cbddb75a8d4fd859300bd34d98e84a}{phy}.\hyperlink{structsw__flow__key_a9dd898913d9faaec1ec970029e7fbb71}{priority} = skb->priority;
708     key->\hyperlink{structsw__flow__key_a57cbddb75a8d4fd859300bd34d98e84a}{phy}.\hyperlink{structsw__flow__key_a5848de18caa80d36d9bc60cc686a2c6e}{in\_port} = \hyperlink{datapath_8h_ac337c4d4ddca29916ce8e900038ddd78}{OVS\_CB}(skb)->input\_vport->port\_no;
709     key->\hyperlink{structsw__flow__key_a57cbddb75a8d4fd859300bd34d98e84a}{phy}.\hyperlink{structsw__flow__key_ae02571657f29397dcc45de8528f4ed05}{skb\_mark} = skb->mark;
710     key->\hyperlink{structsw__flow__key_a73dd9402f1f54c321f6d704d9b018d15}{ovs\_flow\_hash} = 0;
711     key->\hyperlink{structsw__flow__key_a7e51857c88ad6b0bf90551d0b6e2607b}{recirc\_id} = 0;
712 
713     \textcolor{keywordflow}{return} \hyperlink{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}{key\_extract}(skb, key);
714 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a5e042238993a5a8a8a8b3472cb274ead}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace@{ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace}}
\index{ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace@{ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace}]{\setlength{\rightskip}{0pt plus 5cm}int ovs\+\_\+flow\+\_\+key\+\_\+extract\+\_\+userspace (
\begin{DoxyParamCaption}
\item[{const struct nlattr $\ast$}]{attr, }
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key, }
\item[{{\bf bool}}]{log}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_a5e042238993a5a8a8a8b3472cb274ead}

\begin{DoxyCode}
719 \{
720     \textcolor{keywordtype}{int} err;
721 
722     \textcolor{comment}{/* Extract metadata from netlink attributes. */}
723     err = \hyperlink{flow__netlink_8c_a90428a389e4ba65133d2cf837d5a8dc3}{ovs\_nla\_get\_flow\_metadata}(attr, key, log);
724     \textcolor{keywordflow}{if} (err)
725         \textcolor{keywordflow}{return} err;
726 
727     \textcolor{keywordflow}{return} \hyperlink{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}{key\_extract}(skb, key);
728 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a7d27b3745046ced4859b9fa615e27543}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+key\+\_\+update@{ovs\+\_\+flow\+\_\+key\+\_\+update}}
\index{ovs\+\_\+flow\+\_\+key\+\_\+update@{ovs\+\_\+flow\+\_\+key\+\_\+update}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+key\+\_\+update}]{\setlength{\rightskip}{0pt plus 5cm}int ovs\+\_\+flow\+\_\+key\+\_\+update (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_a7d27b3745046ced4859b9fa615e27543}

\begin{DoxyCode}
681 \{
682     \textcolor{keywordflow}{return} \hyperlink{linux_2flow_8c_af69403050accb2489f73d37b528aa9c4}{key\_extract}(skb, key);
683 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a8dfa7ecd72ff9237664d0c402ff3f543}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+stats\+\_\+clear@{ovs\+\_\+flow\+\_\+stats\+\_\+clear}}
\index{ovs\+\_\+flow\+\_\+stats\+\_\+clear@{ovs\+\_\+flow\+\_\+stats\+\_\+clear}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+stats\+\_\+clear}]{\setlength{\rightskip}{0pt plus 5cm}void ovs\+\_\+flow\+\_\+stats\+\_\+clear (
\begin{DoxyParamCaption}
\item[{struct {\bf sw\+\_\+flow} $\ast$}]{flow}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_a8dfa7ecd72ff9237664d0c402ff3f543}

\begin{DoxyCode}
162 \{
163     \textcolor{keywordtype}{int} node;
164 
165     for\_each\_node(node) \{
166         \textcolor{keyword}{struct }\hyperlink{structflow__stats}{flow\_stats} *stats = \hyperlink{datapath_8h_a06ef69170d345fd3996a467dcacf3ff3}{ovsl\_dereference}(flow->
      \hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[node]);
167 
168         \textcolor{keywordflow}{if} (stats) \{
169             spin\_lock\_bh(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
170             stats->\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} = 0;
171             stats->\hyperlink{structflow__stats_a9399b2cdc3d48c11357fbc2aaff33226}{packet\_count} = 0;
172             stats->\hyperlink{structflow__stats_a97844fc570ddb0d4b80f4cfe36bfee29}{byte\_count} = 0;
173             stats->\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags} = 0;
174             spin\_unlock\_bh(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
175         \}
176     \}
177 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a03636247cfc74747632c000eec0919db}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+stats\+\_\+get@{ovs\+\_\+flow\+\_\+stats\+\_\+get}}
\index{ovs\+\_\+flow\+\_\+stats\+\_\+get@{ovs\+\_\+flow\+\_\+stats\+\_\+get}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+stats\+\_\+get}]{\setlength{\rightskip}{0pt plus 5cm}void ovs\+\_\+flow\+\_\+stats\+\_\+get (
\begin{DoxyParamCaption}
\item[{const struct {\bf sw\+\_\+flow} $\ast$}]{flow, }
\item[{struct {\bf ovs\+\_\+flow\+\_\+stats} $\ast$}]{ovs\+\_\+stats, }
\item[{unsigned long $\ast$}]{used, }
\item[{\+\_\+\+\_\+be16 $\ast$}]{tcp\+\_\+flags}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_a03636247cfc74747632c000eec0919db}

\begin{DoxyCode}
135 \{
136     \textcolor{keywordtype}{int} node;
137 
138     *\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} = 0;
139     *\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags} = 0;
140     memset(ovs\_stats, 0, \textcolor{keyword}{sizeof}(*ovs\_stats));
141 
142     for\_each\_node(node) \{
143         \textcolor{keyword}{struct }\hyperlink{structflow__stats}{flow\_stats} *stats = \hyperlink{datapath_8h_a5f2a2c1026f970f0052e77f5ebba33d1}{rcu\_dereference\_ovsl}(flow->
      \hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[node]);
144 
145         \textcolor{keywordflow}{if} (stats) \{
146             \textcolor{comment}{/* Local CPU may write on non-local stats, so we must}
147 \textcolor{comment}{             * block bottom-halves here.}
148 \textcolor{comment}{             */}
149             spin\_lock\_bh(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
150             \textcolor{keywordflow}{if} (!*\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} || time\_after(stats->\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used}, *\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used}))
151                 *\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} = stats->\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used};
152             *\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags} |= stats->\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags};
153             ovs\_stats->\hyperlink{structovs__flow__stats_ab82070e9f656011c1a5b988082c7bfcc}{n\_packets} += stats->\hyperlink{structflow__stats_a9399b2cdc3d48c11357fbc2aaff33226}{packet\_count};
154             ovs\_stats->\hyperlink{structovs__flow__stats_a4dea1785485d954f41121a561701ddf2}{n\_bytes} += stats->\hyperlink{structflow__stats_a97844fc570ddb0d4b80f4cfe36bfee29}{byte\_count};
155             spin\_unlock\_bh(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
156         \}
157     \}
158 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_ad20885fb9e6da56eb9cb58d139281916}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+stats\+\_\+update@{ovs\+\_\+flow\+\_\+stats\+\_\+update}}
\index{ovs\+\_\+flow\+\_\+stats\+\_\+update@{ovs\+\_\+flow\+\_\+stats\+\_\+update}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+stats\+\_\+update}]{\setlength{\rightskip}{0pt plus 5cm}void ovs\+\_\+flow\+\_\+stats\+\_\+update (
\begin{DoxyParamCaption}
\item[{struct {\bf sw\+\_\+flow} $\ast$}]{flow, }
\item[{\+\_\+\+\_\+be16}]{tcp\+\_\+flags, }
\item[{const struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_ad20885fb9e6da56eb9cb58d139281916}

\begin{DoxyCode}
71 \{
72     \textcolor{keyword}{struct }\hyperlink{structflow__stats}{flow\_stats} *stats;
73     \textcolor{keywordtype}{int} node = numa\_node\_id();
74     \textcolor{keywordtype}{int} len = skb->len + (\hyperlink{if__vlan_8h_a0bdf3e26944669a4265c7e717e846215}{skb\_vlan\_tag\_present}(skb) ? VLAN\_HLEN : 0);
75 
76     stats = rcu\_dereference(flow->\hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[node]);
77 
78     \textcolor{comment}{/* Check if already have node-specific stats. */}
79     \textcolor{keywordflow}{if} (likely(stats)) \{
80         spin\_lock(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
81         \textcolor{comment}{/* Mark if we write on the pre-allocated stats. */}
82         \textcolor{keywordflow}{if} (node == 0 && unlikely(flow->\hyperlink{structsw__flow_a7b4a10d23b2824b421527bc2600ef4ba}{stats\_last\_writer} != node))
83             flow->\hyperlink{structsw__flow_a7b4a10d23b2824b421527bc2600ef4ba}{stats\_last\_writer} = node;
84     \} \textcolor{keywordflow}{else} \{
85         stats = rcu\_dereference(flow->\hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[0]); \textcolor{comment}{/* Pre-allocated. */}
86         spin\_lock(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
87 
88         \textcolor{comment}{/* If the current NUMA-node is the only writer on the}
89 \textcolor{comment}{         * pre-allocated stats keep using them.}
90 \textcolor{comment}{         */}
91         \textcolor{keywordflow}{if} (unlikely(flow->\hyperlink{structsw__flow_a7b4a10d23b2824b421527bc2600ef4ba}{stats\_last\_writer} != node)) \{
92             \textcolor{comment}{/* A previous locker may have already allocated the}
93 \textcolor{comment}{             * stats, so we need to check again.  If node-specific}
94 \textcolor{comment}{             * stats were already allocated, we update the pre-}
95 \textcolor{comment}{             * allocated stats as we have already locked them.}
96 \textcolor{comment}{             */}
97             \textcolor{keywordflow}{if} (likely(flow->\hyperlink{structsw__flow_a7b4a10d23b2824b421527bc2600ef4ba}{stats\_last\_writer} != NUMA\_NO\_NODE)
98                 && likely(!\hyperlink{rcupdate_8h_a2c3aebbd11b184d9cab3049e4743882e}{rcu\_access\_pointer}(flow->\hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[node]))) \{
99                 \textcolor{comment}{/* Try to allocate node-specific stats. */}
100                 \textcolor{keyword}{struct }\hyperlink{structflow__stats}{flow\_stats} *new\_stats;
101 
102                 new\_stats =
103                     kmem\_cache\_alloc\_node(\hyperlink{flow__table_8h_ab305bee215adea2618069cc592f6ee6b}{flow\_stats\_cache},
104                                   GFP\_THISNODE |
105                                   \_\_GFP\_NOMEMALLOC,
106                                   node);
107                 \textcolor{keywordflow}{if} (likely(new\_stats)) \{
108                     new\_stats->\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} = jiffies;
109                     new\_stats->\hyperlink{structflow__stats_a9399b2cdc3d48c11357fbc2aaff33226}{packet\_count} = 1;
110                     new\_stats->\hyperlink{structflow__stats_a97844fc570ddb0d4b80f4cfe36bfee29}{byte\_count} = len;
111                     new\_stats->\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags} = \hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags};
112                     spin\_lock\_init(&new\_stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
113 
114                     rcu\_assign\_pointer(flow->\hyperlink{structsw__flow_a5ccc743bcf16038ab0cf5dda88565f33}{stats}[node],
115                                new\_stats);
116                     \textcolor{keywordflow}{goto} unlock;
117                 \}
118             \}
119             flow->\hyperlink{structsw__flow_a7b4a10d23b2824b421527bc2600ef4ba}{stats\_last\_writer} = node;
120         \}
121     \}
122 
123     stats->\hyperlink{structflow__stats_a3eefc54cf53ad3e24bb070bd6f251f50}{used} = jiffies;
124     stats->\hyperlink{structflow__stats_a9399b2cdc3d48c11357fbc2aaff33226}{packet\_count}++;
125     stats->\hyperlink{structflow__stats_a97844fc570ddb0d4b80f4cfe36bfee29}{byte\_count} += len;
126     stats->\hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags} |= \hyperlink{structflow__stats_a2b2812adf4fd5f4f188324fdf503deba}{tcp\_flags};
127 unlock:
128     spin\_unlock(&stats->\hyperlink{structflow__stats_a1930f864d7fc52f4afeb86714e3e5c07}{lock});
129 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_adfdcc779325fc169a793acda2e32a46b}{}\index{linux/flow.\+c@{linux/flow.\+c}!ovs\+\_\+flow\+\_\+used\+\_\+time@{ovs\+\_\+flow\+\_\+used\+\_\+time}}
\index{ovs\+\_\+flow\+\_\+used\+\_\+time@{ovs\+\_\+flow\+\_\+used\+\_\+time}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{ovs\+\_\+flow\+\_\+used\+\_\+time}]{\setlength{\rightskip}{0pt plus 5cm}u64 ovs\+\_\+flow\+\_\+used\+\_\+time (
\begin{DoxyParamCaption}
\item[{unsigned long}]{flow\+\_\+jiffies}
\end{DoxyParamCaption}
)}\label{linux_2flow_8c_adfdcc779325fc169a793acda2e32a46b}

\begin{DoxyCode}
55 \{
56     \textcolor{keyword}{struct }timespec cur\_ts;
57     u64 cur\_ms, idle\_ms;
58 
59     ktime\_get\_ts(&cur\_ts);
60     idle\_ms = jiffies\_to\_msecs(jiffies - flow\_jiffies);
61     cur\_ms = (u64)cur\_ts.tv\_sec * MSEC\_PER\_SEC +
62          cur\_ts.tv\_nsec / NSEC\_PER\_MSEC;
63 
64     \textcolor{keywordflow}{return} cur\_ms - idle\_ms;
65 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a8f4a5415b9d6b2be7aef9e3749e65908}{}\index{linux/flow.\+c@{linux/flow.\+c}!parse\+\_\+ethertype@{parse\+\_\+ethertype}}
\index{parse\+\_\+ethertype@{parse\+\_\+ethertype}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{parse\+\_\+ethertype}]{\setlength{\rightskip}{0pt plus 5cm}static \+\_\+\+\_\+be16 parse\+\_\+ethertype (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a8f4a5415b9d6b2be7aef9e3749e65908}

\begin{DoxyCode}
320 \{
321     \textcolor{keyword}{struct }llc\_snap\_hdr \{
322         u8  dsap;  \textcolor{comment}{/* Always 0xAA */}
323         u8  ssap;  \textcolor{comment}{/* Always 0xAA */}
324         u8  ctrl;
325         u8  oui[3];
326         \_\_be16 ethertype;
327     \};
328     \textcolor{keyword}{struct }llc\_snap\_hdr *llc;
329     \_\_be16 \hyperlink{flow_8h_af1698a0033f39eb7a745097761b717d2}{proto};
330 
331     proto = *(\_\_be16 *) skb->data;
332     \_\_skb\_pull(skb, \textcolor{keyword}{sizeof}(\_\_be16));
333 
334     \textcolor{keywordflow}{if} (eth\_proto\_is\_802\_3(proto))
335         \textcolor{keywordflow}{return} proto;
336 
337     \textcolor{keywordflow}{if} (skb->len < \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} llc\_snap\_hdr))
338         \textcolor{keywordflow}{return} htons(ETH\_P\_802\_2);
339 
340     \textcolor{keywordflow}{if} (unlikely(!pskb\_may\_pull(skb, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} llc\_snap\_hdr))))
341         \textcolor{keywordflow}{return} htons(0);
342 
343     llc = (\textcolor{keyword}{struct }llc\_snap\_hdr *) skb->data;
344     if (llc->dsap != LLC\_SAP\_SNAP ||
345         llc->ssap != LLC\_SAP\_SNAP ||
346         (llc->oui[0] | llc->oui[1] | llc->oui[2]) != 0)
347         \textcolor{keywordflow}{return} htons(ETH\_P\_802\_2);
348 
349     \_\_skb\_pull(skb, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} llc\_snap\_hdr));
350 
351     \textcolor{keywordflow}{if} (eth\_proto\_is\_802\_3(llc->ethertype))
352         \textcolor{keywordflow}{return} llc->ethertype;
353 
354     \textcolor{keywordflow}{return} htons(ETH\_P\_802\_2);
355 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a0b01cb308f20bbfe4348b6ef1b27a65d}{}\index{linux/flow.\+c@{linux/flow.\+c}!parse\+\_\+icmpv6@{parse\+\_\+icmpv6}}
\index{parse\+\_\+icmpv6@{parse\+\_\+icmpv6}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{parse\+\_\+icmpv6}]{\setlength{\rightskip}{0pt plus 5cm}static int parse\+\_\+icmpv6 (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key, }
\item[{int}]{nh\+\_\+len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a0b01cb308f20bbfe4348b6ef1b27a65d}

\begin{DoxyCode}
359 \{
360     \textcolor{keyword}{struct }icmp6hdr *icmp = \hyperlink{icmpv6_8h_a82bcc0d06b83b4deb3670393075dee13}{icmp6\_hdr}(skb);
361 
362     \textcolor{comment}{/* The ICMPv6 type and code fields use the 16-bit transport port}
363 \textcolor{comment}{     * fields, so we need to store them in 16-bit network byte order.}
364 \textcolor{comment}{     */}
365     key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a2fbd4aa7a500630627eff0630f864117}{src} = htons(icmp->icmp6\_type);
366     key->\hyperlink{structsw__flow__key_a9c1944a39db1bf91141048df6d85ce8b}{tp}.\hyperlink{structsw__flow__key_a44a0cdfe7471df8bb73762085da4cda9}{dst} = htons(icmp->icmp6\_code);
367     memset(&key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd));
368 
369     \textcolor{keywordflow}{if} (icmp->icmp6\_code == 0 &&
370         (icmp->icmp6\_type == NDISC\_NEIGHBOUR\_SOLICITATION ||
371          icmp->icmp6\_type == NDISC\_NEIGHBOUR\_ADVERTISEMENT)) \{
372         \textcolor{keywordtype}{int} icmp\_len = skb->len - \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb);
373         \textcolor{keyword}{struct }nd\_msg *\hyperlink{flow_8h_a3043c4ac00ac70f331a1dd225c03daa2}{nd};
374         \textcolor{keywordtype}{int} offset;
375 
376         \textcolor{comment}{/* In order to process neighbor discovery options, we need the}
377 \textcolor{comment}{         * entire packet.}
378 \textcolor{comment}{         */}
379         \textcolor{keywordflow}{if} (unlikely(icmp\_len < \textcolor{keyword}{sizeof}(*nd)))
380             \textcolor{keywordflow}{return} 0;
381 
382         \textcolor{keywordflow}{if} (unlikely(skb\_linearize(skb)))
383             \textcolor{keywordflow}{return} -ENOMEM;
384 
385         nd = (\textcolor{keyword}{struct }nd\_msg *)\hyperlink{skbuff_8h_ad4a95a26793695e82fca60888688450f}{skb\_transport\_header}(skb);
386         key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.target = nd->target;
387 
388         icmp\_len -= \textcolor{keyword}{sizeof}(*nd);
389         offset = 0;
390         \textcolor{keywordflow}{while} (icmp\_len >= 8) \{
391             \textcolor{keyword}{struct }nd\_opt\_hdr *nd\_opt =
392                  (\textcolor{keyword}{struct }nd\_opt\_hdr *)(nd->opt + offset);
393             \textcolor{keywordtype}{int} opt\_len = nd\_opt->nd\_opt\_len * 8;
394 
395             \textcolor{keywordflow}{if} (unlikely(!opt\_len || opt\_len > icmp\_len))
396                 \textcolor{keywordflow}{return} 0;
397 
398             \textcolor{comment}{/* Store the link layer address if the appropriate}
399 \textcolor{comment}{             * option is provided.  It is considered an error if}
400 \textcolor{comment}{             * the same link layer option is specified twice.}
401 \textcolor{comment}{             */}
402             \textcolor{keywordflow}{if} (nd\_opt->nd\_opt\_type == ND\_OPT\_SOURCE\_LL\_ADDR
403                 && opt\_len == 8) \{
404                 \textcolor{keywordflow}{if} (unlikely(!is\_zero\_ether\_addr(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.sll)))
405                     \textcolor{keywordflow}{goto} invalid;
406                 \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.sll,
407                         &nd->opt[offset+\textcolor{keyword}{sizeof}(*nd\_opt)]);
408             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nd\_opt->nd\_opt\_type == ND\_OPT\_TARGET\_LL\_ADDR
409                    && opt\_len == 8) \{
410                 \textcolor{keywordflow}{if} (unlikely(!is\_zero\_ether\_addr(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.tll)))
411                     \textcolor{keywordflow}{goto} invalid;
412                 \hyperlink{etherdevice_8h_a564a2ea461aa6add2fa94a6864ee494d}{ether\_addr\_copy}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.tll,
413                         &nd->opt[offset+\textcolor{keyword}{sizeof}(*nd\_opt)]);
414             \}
415 
416             icmp\_len -= opt\_len;
417             offset += opt\_len;
418         \}
419     \}
420 
421     \textcolor{keywordflow}{return} 0;
422 
423 invalid:
424     memset(&key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.target, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.target));
425     memset(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.sll, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.sll));
426     memset(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.tll, 0, \textcolor{keyword}{sizeof}(key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.nd.tll));
427 
428     \textcolor{keywordflow}{return} 0;
429 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_aae5a88c529fa6e31de896e40c546ec90}{}\index{linux/flow.\+c@{linux/flow.\+c}!parse\+\_\+ipv6hdr@{parse\+\_\+ipv6hdr}}
\index{parse\+\_\+ipv6hdr@{parse\+\_\+ipv6hdr}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{parse\+\_\+ipv6hdr}]{\setlength{\rightskip}{0pt plus 5cm}static int parse\+\_\+ipv6hdr (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_aae5a88c529fa6e31de896e40c546ec90}

\begin{DoxyCode}
248 \{
249     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nh\_ofs = \hyperlink{skbuff_8h_aabe75b44039b11c1b7c6e2f246e7146e}{skb\_network\_offset}(skb);
250     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nh\_len;
251     \textcolor{keywordtype}{int} payload\_ofs;
252     \textcolor{keyword}{struct }ipv6hdr *nh;
253     uint8\_t nexthdr;
254     \_\_be16 frag\_off;
255     \textcolor{keywordtype}{int} err;
256 
257     err = \hyperlink{linux_2flow_8c_a51976bbff11a171b00faaffd004ba963}{check\_header}(skb, nh\_ofs + \textcolor{keyword}{sizeof}(*nh));
258     \textcolor{keywordflow}{if} (unlikely(err))
259         \textcolor{keywordflow}{return} err;
260 
261     nh = \hyperlink{linux_2ipv6_8h_ab31aa2f5ade9dadb3cede168a0761bb3}{ipv6\_hdr}(skb);
262     nexthdr = nh->nexthdr;
263     payload\_ofs = (u8 *)(nh + 1) - skb->data;
264 
265     key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto = NEXTHDR\_NONE;
266     key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.tos = ipv6\_get\_dsfield(nh);
267     key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.ttl = nh->hop\_limit;
268     key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.label = *(\_\_be32 *)nh & htonl(IPV6\_FLOWINFO\_FLOWLABEL);
269     key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.addr.src = nh->saddr;
270     key->\hyperlink{structsw__flow__key_a6b13e14d62eb632b05378784a2d61f87}{ipv6}.addr.dst = nh->daddr;
271 
272     payload\_ofs = ipv6\_skip\_exthdr(skb, payload\_ofs, &nexthdr, &frag\_off);
273     \textcolor{keywordflow}{if} (unlikely(payload\_ofs < 0))
274         \textcolor{keywordflow}{return} -EINVAL;
275 
276     \textcolor{keywordflow}{if} (frag\_off) \{
277         \textcolor{keywordflow}{if} (frag\_off & htons(~0x7))
278             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a1d1c9f89ced33419ec870391d8954c10}{OVS\_FRAG\_TYPE\_LATER};
279         \textcolor{keywordflow}{else}
280             key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a7302a2ecd7ef2e817fadcd3e943af200}{OVS\_FRAG\_TYPE\_FIRST};
281     \} \textcolor{keywordflow}{else} \{
282         key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.frag = \hyperlink{openvswitch_8h_ad843f713a855bfcacd0adfe3e98eb447a8551f9db6addee11579a10fe4b1e9d62}{OVS\_FRAG\_TYPE\_NONE};
283     \}
284 
285     nh\_len = payload\_ofs - nh\_ofs;
286     \hyperlink{skbuff_8h_a35af79b1b630fc75fbd7347549b6affe}{skb\_set\_transport\_header}(skb, nh\_ofs + nh\_len);
287     key->\hyperlink{structsw__flow__key_ae8d48c419eaff6a9fda97c7446bdec0e}{ip}.proto = nexthdr;
288     \textcolor{keywordflow}{return} nh\_len;
289 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_aab1dd840cacc7b21ee01cb885171d60d}{}\index{linux/flow.\+c@{linux/flow.\+c}!parse\+\_\+vlan@{parse\+\_\+vlan}}
\index{parse\+\_\+vlan@{parse\+\_\+vlan}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{parse\+\_\+vlan}]{\setlength{\rightskip}{0pt plus 5cm}static int parse\+\_\+vlan (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb, }
\item[{struct {\bf sw\+\_\+flow\+\_\+key} $\ast$}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_aab1dd840cacc7b21ee01cb885171d60d}

\begin{DoxyCode}
298 \{
299     \textcolor{keyword}{struct }qtag\_prefix \{
300         \_\_be16 eth\_type; \textcolor{comment}{/* ETH\_P\_8021Q */}
301         \_\_be16 \hyperlink{flow_8h_a4528fe4db43b403cd959b50285d71b0c}{tci};
302     \};
303     \textcolor{keyword}{struct }qtag\_prefix *qp;
304 
305     \textcolor{keywordflow}{if} (unlikely(skb->len < \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} qtag\_prefix) + \textcolor{keyword}{sizeof}(\_\_be16)))
306         \textcolor{keywordflow}{return} 0;
307 
308     \textcolor{keywordflow}{if} (unlikely(!pskb\_may\_pull(skb, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} qtag\_prefix) +
309                      \textcolor{keyword}{sizeof}(\_\_be16))))
310         \textcolor{keywordflow}{return} -ENOMEM;
311 
312     qp = (\textcolor{keyword}{struct }qtag\_prefix *) skb->data;
313     key->\hyperlink{structsw__flow__key_af3e10c978a3a2bf303b7d953ac6ff361}{eth}.\hyperlink{structsw__flow__key_a56b27b9b9eafa8f79acd544eba98c7b0}{tci} = qp->tci | htons(\hyperlink{if__vlan_8h_ac8bf15be3fd1a3a63a2452fa05a83217}{VLAN\_TAG\_PRESENT});
314     \_\_skb\_pull(skb, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} qtag\_prefix));
315 
316     \textcolor{keywordflow}{return} 0;
317 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a235207174d62d682354a73e4b43a4ee2}{}\index{linux/flow.\+c@{linux/flow.\+c}!sctphdr\+\_\+ok@{sctphdr\+\_\+ok}}
\index{sctphdr\+\_\+ok@{sctphdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{sctphdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} sctphdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a235207174d62d682354a73e4b43a4ee2}

\begin{DoxyCode}
236 \{
237     \textcolor{keywordflow}{return} pskb\_may\_pull(skb, \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb) +
238                   \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sctphdr));
239 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a71815483a340e9bab0bbcbc52537cfb5}{}\index{linux/flow.\+c@{linux/flow.\+c}!tcphdr\+\_\+ok@{tcphdr\+\_\+ok}}
\index{tcphdr\+\_\+ok@{tcphdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{tcphdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} tcphdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a71815483a340e9bab0bbcbc52537cfb5}

\begin{DoxyCode}
214 \{
215     \textcolor{keywordtype}{int} th\_ofs = \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb);
216     \textcolor{keywordtype}{int} tcp\_len;
217 
218     \textcolor{keywordflow}{if} (unlikely(!pskb\_may\_pull(skb, th\_ofs + \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} tcphdr))))
219         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
220 
221     tcp\_len = \hyperlink{tcp_8h_ab799f4173faf8a6cdcdbb11d72f526d0}{tcp\_hdrlen}(skb);
222     \textcolor{keywordflow}{if} (unlikely(tcp\_len < \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} tcphdr) ||
223              skb->len < th\_ofs + tcp\_len))
224         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
225 
226     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
227 \}
\end{DoxyCode}
\hypertarget{linux_2flow_8c_a354e4e351441e305c10a030f9d1dab7f}{}\index{linux/flow.\+c@{linux/flow.\+c}!udphdr\+\_\+ok@{udphdr\+\_\+ok}}
\index{udphdr\+\_\+ok@{udphdr\+\_\+ok}!linux/flow.\+c@{linux/flow.\+c}}
\subsubsection[{udphdr\+\_\+ok}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf bool} udphdr\+\_\+ok (
\begin{DoxyParamCaption}
\item[{struct sk\+\_\+buff $\ast$}]{skb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{linux_2flow_8c_a354e4e351441e305c10a030f9d1dab7f}

\begin{DoxyCode}
230 \{
231     \textcolor{keywordflow}{return} pskb\_may\_pull(skb, \hyperlink{skbuff_8h_ac8d86ecdcd808a5839009d4a8f85f6c8}{skb\_transport\_offset}(skb) +
232                   \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} udphdr));
233 \}
\end{DoxyCode}
