.TH "/home/vladn/git/ovs/datapath/flow.h" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/flow.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/cache\&.h>\fP
.br
\fC#include <linux/kernel\&.h>\fP
.br
\fC#include <linux/netlink\&.h>\fP
.br
\fC#include <linux/openvswitch\&.h>\fP
.br
\fC#include <linux/spinlock\&.h>\fP
.br
\fC#include <linux/types\&.h>\fP
.br
\fC#include <linux/rcupdate\&.h>\fP
.br
\fC#include <linux/if_ether\&.h>\fP
.br
\fC#include <linux/in6\&.h>\fP
.br
\fC#include <linux/jiffies\&.h>\fP
.br
\fC#include <linux/time\&.h>\fP
.br
\fC#include <linux/flex_array\&.h>\fP
.br
\fC#include <net/inet_ecn\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBovs_key_ipv4_tunnel\fP"
.br
.ti -1c
.RI "struct \fBovs_tunnel_info\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_key\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_key_range\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_mask\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_match\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_id\fP"
.br
.ti -1c
.RI "struct \fBsw_flow_actions\fP"
.br
.ti -1c
.RI "struct \fBflow_stats\fP"
.br
.ti -1c
.RI "struct \fBsw_flow\fP"
.br
.ti -1c
.RI "struct \fBarp_eth_header\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBOVS_TUNNEL_KEY_SIZE\fP"
.br
.ti -1c
.RI "#define \fBTUN_METADATA_OFFSET\fP(opt_len)   (FIELD_SIZEOF(struct \fBsw_flow_key\fP, \fBtun_opts\fP) - opt_len)"
.br
.ti -1c
.RI "#define \fBTUN_METADATA_OPTS\fP(flow_key,  opt_len)   ((void *)((flow_key)->\fBtun_opts\fP + \fBTUN_METADATA_OFFSET\fP(opt_len)))"
.br
.ti -1c
.RI "#define \fBOVS_SW_FLOW_KEY_METADATA_SIZE\fP"
.br
.ti -1c
.RI "#define \fBMAX_UFID_LENGTH\fP   16 /* 128 bits */"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBovs_key_ipv4_tunnel\fP \fB__aligned\fP (4)"
.br
.ti -1c
.RI "static void \fB__ovs_flow_tun_info_init\fP (struct \fBovs_tunnel_info\fP *tun_info, __be32 saddr, __be32 daddr, u8 \fBtos\fP, u8 \fBttl\fP, __be16 \fBtp_src\fP, __be16 \fBtp_dst\fP, __be64 \fBtun_id\fP, __be16 \fBtun_flags\fP, const void *opts, u8 opts_len)"
.br
.ti -1c
.RI "static void \fBovs_flow_tun_info_init\fP (struct \fBovs_tunnel_info\fP *tun_info, const struct iphdr *iph, __be16 \fBtp_src\fP, __be16 \fBtp_dst\fP, __be64 \fBtun_id\fP, __be16 \fBtun_flags\fP, const void *opts, u8 opts_len)"
.br
.ti -1c
.RI "struct \fBsw_flow_key\fP \fB__aligned\fP (BITS_PER_LONG/8)"
.br
.ti -1c
.RI "static \fBbool\fP \fBovs_identifier_is_ufid\fP (const struct \fBsw_flow_id\fP *sfid)"
.br
.ti -1c
.RI "static \fBbool\fP \fBovs_identifier_is_key\fP (const struct \fBsw_flow_id\fP *sfid)"
.br
.ti -1c
.RI "void \fBovs_flow_stats_update\fP (struct \fBsw_flow\fP *, __be16 tcp_flags, const struct sk_buff *)"
.br
.ti -1c
.RI "void \fBovs_flow_stats_get\fP (const struct \fBsw_flow\fP *, struct \fBovs_flow_stats\fP *, unsigned long *used, __be16 *tcp_flags)"
.br
.ti -1c
.RI "void \fBovs_flow_stats_clear\fP (struct \fBsw_flow\fP *)"
.br
.ti -1c
.RI "u64 \fBovs_flow_used_time\fP (unsigned long flow_jiffies)"
.br
.ti -1c
.RI "int \fBovs_flow_key_update\fP (struct sk_buff *skb, struct \fBsw_flow_key\fP *key)"
.br
.ti -1c
.RI "int \fBovs_flow_key_extract\fP (const struct \fBovs_tunnel_info\fP *tun_info, struct sk_buff *skb, struct \fBsw_flow_key\fP *key)"
.br
.ti -1c
.RI "int \fBovs_flow_key_extract_userspace\fP (const struct nlattr *attr, struct sk_buff *skb, struct \fBsw_flow_key\fP *key, \fBbool\fP log)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "__be64 \fBtun_id\fP"
.br
.ti -1c
.RI "__be32 \fBipv4_src\fP"
.br
.ti -1c
.RI "__be32 \fBipv4_dst\fP"
.br
.ti -1c
.RI "__be16 \fBtun_flags\fP"
.br
.ti -1c
.RI "u8 \fBipv4_tos\fP"
.br
.ti -1c
.RI "u8 \fBipv4_ttl\fP"
.br
.ti -1c
.RI "__be16 \fBtp_src\fP"
.br
.ti -1c
.RI "__be16 \fBtp_dst\fP"
.br
.ti -1c
.RI "struct \fBovs_tunnel_info\fP \fB__aligned\fP"
.br
.ti -1c
.RI "u8 \fBtun_opts\fP [255]"
.br
.ti -1c
.RI "u8 \fBtun_opts_len\fP"
.br
.ti -1c
.RI "struct \fBovs_key_ipv4_tunnel\fP \fBtun_key\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   u32 \fBpriority\fP"
.br
.ti -1c
.RI "   u32 \fBskb_mark\fP"
.br
.ti -1c
.RI "   u16 \fBin_port\fP"
.br
.ti -1c
.RI "} \fBphy\fP"
.br
.ti -1c
.RI "u32 \fBovs_flow_hash\fP"
.br
.ti -1c
.RI "u32 \fBrecirc_id\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   u8 \fBsrc\fP [ETH_ALEN]"
.br
.ti -1c
.RI "   u8 \fBdst\fP [ETH_ALEN]"
.br
.ti -1c
.RI "   __be16 \fBtci\fP"
.br
.ti -1c
.RI "   __be16 \fBtype\fP"
.br
.ti -1c
.RI "} \fBeth\fP"
.br
.ti -1c
.RI "union {"
.br
.ti -1c
.RI "   struct {"
.br
.ti -1c
.RI "      __be32 \fBtop_lse\fP"
.br
.ti -1c
.RI "   } \fBmpls\fP"
.br
.ti -1c
.RI "   struct {"
.br
.ti -1c
.RI "      u8 \fBproto\fP"
.br
.ti -1c
.RI "      u8 \fBtos\fP"
.br
.ti -1c
.RI "      u8 \fBttl\fP"
.br
.ti -1c
.RI "      u8 \fBfrag\fP"
.br
.ti -1c
.RI "   } \fBip\fP"
.br
.ti -1c
.RI "}; "
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   __be16 \fBsrc\fP"
.br
.ti -1c
.RI "   __be16 \fBdst\fP"
.br
.ti -1c
.RI "   __be16 \fBflags\fP"
.br
.ti -1c
.RI "} \fBtp\fP"
.br
.ti -1c
.RI "union {"
.br
.ti -1c
.RI "   struct {"
.br
.ti -1c
.RI "      struct {"
.br
.ti -1c
.RI "         __be32 \fBsrc\fP"
.br
.ti -1c
.RI "         __be32 \fBdst\fP"
.br
.ti -1c
.RI "      } \fBaddr\fP"
.br
.ti -1c
.RI "      struct {"
.br
.ti -1c
.RI "         u8 \fBsha\fP [ETH_ALEN]"
.br
.ti -1c
.RI "         u8 \fBtha\fP [ETH_ALEN]"
.br
.ti -1c
.RI "      } \fBarp\fP"
.br
.ti -1c
.RI "   } \fBipv4\fP"
.br
.ti -1c
.RI "   struct {"
.br
.ti -1c
.RI "      struct {"
.br
.ti -1c
.RI "         struct in6_addr \fBsrc\fP"
.br
.ti -1c
.RI "         struct in6_addr \fBdst\fP"
.br
.ti -1c
.RI "      } \fBaddr\fP"
.br
.ti -1c
.RI "      __be32 \fBlabel\fP"
.br
.ti -1c
.RI "      struct {"
.br
.ti -1c
.RI "         struct in6_addr \fBtarget\fP"
.br
.ti -1c
.RI "         u8 \fBsll\fP [ETH_ALEN]"
.br
.ti -1c
.RI "         u8 \fBtll\fP [ETH_ALEN]"
.br
.ti -1c
.RI "      } \fBnd\fP"
.br
.ti -1c
.RI "   } \fBipv6\fP"
.br
.ti -1c
.RI "}; "
.br
.ti -1c
.RI "struct \fBarp_eth_header\fP \fB__packed\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAX_UFID_LENGTH   16 /* 128 bits */"

.SS "#define OVS_SW_FLOW_KEY_METADATA_SIZE"
\fBValue:\fP
.PP
.nf
(offsetof(struct sw_flow_key, recirc_id) +    \
    FIELD_SIZEOF(struct sw_flow_key, recirc_id))
.fi
.SS "#define OVS_TUNNEL_KEY_SIZE"
\fBValue:\fP
.PP
.nf
(offsetof(struct ovs_key_ipv4_tunnel, tp_dst) +      \
     FIELD_SIZEOF(struct ovs_key_ipv4_tunnel, tp_dst))
.fi
.SS "#define TUN_METADATA_OFFSET(opt_len)   (FIELD_SIZEOF(struct \fBsw_flow_key\fP, \fBtun_opts\fP) - opt_len)"

.SS "#define TUN_METADATA_OPTS(flow_key, opt_len)   ((void *)((flow_key)->\fBtun_opts\fP + \fBTUN_METADATA_OFFSET\fP(opt_len)))"

.SH "Function Documentation"
.PP 
.SS "struct \fBsw_flow_key\fP __aligned (BITS_PER_LONG/ 8)"

.SS "struct \fBovs_key_ipv4_tunnel\fP __aligned (4)"

.SS "static void __ovs_flow_tun_info_init (struct \fBovs_tunnel_info\fP * tun_info, __be32 saddr, __be32 daddr, u8 tos, u8 ttl, __be16 tp_src, __be16 tp_dst, __be64 tun_id, __be16 tun_flags, const void * opts, u8 opts_len)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
78 {
79     tun_info->tunnel\&.tun_id = tun_id;
80     tun_info->tunnel\&.ipv4_src = saddr;
81     tun_info->tunnel\&.ipv4_dst = daddr;
82     tun_info->tunnel\&.ipv4_tos = tos;
83     tun_info->tunnel\&.ipv4_ttl = ttl;
84     tun_info->tunnel\&.tun_flags = tun_flags;
85 
86     /* For the tunnel types on the top of IPsec, the tp_src and tp_dst of
87      * the upper tunnel are used\&.
88      * E\&.g: GRE over IPSEC, the tp_src and tp_port are zero\&.
89      */
90     tun_info->tunnel\&.tp_src = tp_src;
91     tun_info->tunnel\&.tp_dst = tp_dst;
92 
93     /* Clear struct padding\&. */
94     if (sizeof(tun_info->tunnel) != OVS_TUNNEL_KEY_SIZE)
95         memset((unsigned char *)&tun_info->tunnel + OVS_TUNNEL_KEY_SIZE,
96                0, sizeof(tun_info->tunnel) - OVS_TUNNEL_KEY_SIZE);
97 
98     tun_info->options = opts;
99     tun_info->options_len = opts_len;
100 }
.fi
.SS "int ovs_flow_key_extract (const struct \fBovs_tunnel_info\fP * tun_info, struct sk_buff * skb, struct \fBsw_flow_key\fP * key)"

.PP
.nf
687 {
688     /* Extract metadata from packet\&. */
689     if (tun_info) {
690         memcpy(&key->tun_key, &tun_info->tunnel, sizeof(key->tun_key));
691 
692         BUILD_BUG_ON(((1 << (sizeof(tun_info->options_len) * 8)) - 1) >
693                  sizeof(key->tun_opts));
694 
695         if (tun_info->options) {
696             memcpy(TUN_METADATA_OPTS(key, tun_info->options_len),
697                    tun_info->options, tun_info->options_len);
698             key->tun_opts_len = tun_info->options_len;
699         } else {
700             key->tun_opts_len = 0;
701         }
702     } else {
703         key->tun_opts_len = 0;
704         memset(&key->tun_key, 0, sizeof(key->tun_key));
705     }
706 
707     key->phy\&.priority = skb->priority;
708     key->phy\&.in_port = OVS_CB(skb)->input_vport->port_no;
709     key->phy\&.skb_mark = skb->mark;
710     key->ovs_flow_hash = 0;
711     key->recirc_id = 0;
712 
713     return key_extract(skb, key);
714 }
.fi
.SS "int ovs_flow_key_extract_userspace (const struct nlattr * attr, struct sk_buff * skb, struct \fBsw_flow_key\fP * key, \fBbool\fP log)"

.PP
.nf
719 {
720     int err;
721 
722     /* Extract metadata from netlink attributes\&. */
723     err = ovs_nla_get_flow_metadata(attr, key, log);
724     if (err)
725         return err;
726 
727     return key_extract(skb, key);
728 }
.fi
.SS "int ovs_flow_key_update (struct sk_buff * skb, struct \fBsw_flow_key\fP * key)"

.PP
.nf
681 {
682     return key_extract(skb, key);
683 }
.fi
.SS "void ovs_flow_stats_clear (struct \fBsw_flow\fP *)"

.PP
.nf
162 {
163     int node;
164 
165     for_each_node(node) {
166         struct flow_stats *stats = ovsl_dereference(flow->stats[node]);
167 
168         if (stats) {
169             spin_lock_bh(&stats->lock);
170             stats->used = 0;
171             stats->packet_count = 0;
172             stats->byte_count = 0;
173             stats->tcp_flags = 0;
174             spin_unlock_bh(&stats->lock);
175         }
176     }
177 }
.fi
.SS "void ovs_flow_stats_get (const struct \fBsw_flow\fP *, struct \fBovs_flow_stats\fP *, unsigned long * used, __be16 * tcp_flags)"

.PP
.nf
135 {
136     int node;
137 
138     *used = 0;
139     *tcp_flags = 0;
140     memset(ovs_stats, 0, sizeof(*ovs_stats));
141 
142     for_each_node(node) {
143         struct flow_stats *stats = rcu_dereference_ovsl(flow->stats[node]);
144 
145         if (stats) {
146             /* Local CPU may write on non-local stats, so we must
147              * block bottom-halves here\&.
148              */
149             spin_lock_bh(&stats->lock);
150             if (!*used || time_after(stats->used, *used))
151                 *used = stats->used;
152             *tcp_flags |= stats->tcp_flags;
153             ovs_stats->n_packets += stats->packet_count;
154             ovs_stats->n_bytes += stats->byte_count;
155             spin_unlock_bh(&stats->lock);
156         }
157     }
158 }
.fi
.SS "void ovs_flow_stats_update (struct \fBsw_flow\fP *, __be16 tcp_flags, const struct sk_buff *)"

.PP
.nf
71 {
72     struct flow_stats *stats;
73     int node = numa_node_id();
74     int len = skb->len + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);
75 
76     stats = rcu_dereference(flow->stats[node]);
77 
78     /* Check if already have node-specific stats\&. */
79     if (likely(stats)) {
80         spin_lock(&stats->lock);
81         /* Mark if we write on the pre-allocated stats\&. */
82         if (node == 0 && unlikely(flow->stats_last_writer != node))
83             flow->stats_last_writer = node;
84     } else {
85         stats = rcu_dereference(flow->stats[0]); /* Pre-allocated\&. */
86         spin_lock(&stats->lock);
87 
88         /* If the current NUMA-node is the only writer on the
89          * pre-allocated stats keep using them\&.
90          */
91         if (unlikely(flow->stats_last_writer != node)) {
92             /* A previous locker may have already allocated the
93              * stats, so we need to check again\&.  If node-specific
94              * stats were already allocated, we update the pre-
95              * allocated stats as we have already locked them\&.
96              */
97             if (likely(flow->stats_last_writer != NUMA_NO_NODE)
98                 && likely(!rcu_access_pointer(flow->stats[node]))) {
99                 /* Try to allocate node-specific stats\&. */
100                 struct flow_stats *new_stats;
101 
102                 new_stats =
103                     kmem_cache_alloc_node(flow_stats_cache,
104                                   GFP_THISNODE |
105                                   __GFP_NOMEMALLOC,
106                                   node);
107                 if (likely(new_stats)) {
108                     new_stats->used = jiffies;
109                     new_stats->packet_count = 1;
110                     new_stats->byte_count = len;
111                     new_stats->tcp_flags = tcp_flags;
112                     spin_lock_init(&new_stats->lock);
113 
114                     rcu_assign_pointer(flow->stats[node],
115                                new_stats);
116                     goto unlock;
117                 }
118             }
119             flow->stats_last_writer = node;
120         }
121     }
122 
123     stats->used = jiffies;
124     stats->packet_count++;
125     stats->byte_count += len;
126     stats->tcp_flags |= tcp_flags;
127 unlock:
128     spin_unlock(&stats->lock);
129 }
.fi
.SS "static void ovs_flow_tun_info_init (struct \fBovs_tunnel_info\fP * tun_info, const struct iphdr * iph, __be16 tp_src, __be16 tp_dst, __be64 tun_id, __be16 tun_flags, const void * opts, u8 opts_len)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
110 {
111     __ovs_flow_tun_info_init(tun_info, iph->saddr, iph->daddr,
112                  iph->tos, iph->ttl,
113                  tp_src, tp_dst,
114                  tun_id, tun_flags,
115                  opts, opts_len);
116 }
.fi
.SS "u64 ovs_flow_used_time (unsigned long flow_jiffies)"

.PP
.nf
55 {
56     struct timespec cur_ts;
57     u64 cur_ms, idle_ms;
58 
59     ktime_get_ts(&cur_ts);
60     idle_ms = jiffies_to_msecs(jiffies - flow_jiffies);
61     cur_ms = (u64)cur_ts\&.tv_sec * MSEC_PER_SEC +
62          cur_ts\&.tv_nsec / NSEC_PER_MSEC;
63 
64     return cur_ms - idle_ms;
65 }
.fi
.SS "static \fBbool\fP ovs_identifier_is_key (const struct \fBsw_flow_id\fP * sfid)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
263 {
264     return !ovs_identifier_is_ufid(sfid);
265 }
.fi
.SS "static \fBbool\fP ovs_identifier_is_ufid (const struct \fBsw_flow_id\fP * sfid)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
258 {
259     return sfid->ufid_len;
260 }
.fi
.SH "Variable Documentation"
.PP 
.SS "union { \&.\&.\&. } "

.SS "union { \&.\&.\&. } "

.SS "struct \fBsw_flow_key_range\fP __aligned"

.SS "struct \fBarp_eth_header\fP  __packed"

.SS "struct { \&.\&.\&. }   addr"

.SS "struct { \&.\&.\&. }   arp"

.SS "struct in6_addr dst"

.SS "struct { \&.\&.\&. }   eth"

.SS "__be16 flags"

.SS "u8 frag"

.SS "u16 in_port"

.SS "struct { \&.\&.\&. }   ip"

.SS "struct { \&.\&.\&. }   ipv4"

.SS "__be32 ipv4_dst"

.SS "__be32 ipv4_src"

.SS "u8 ipv4_tos"

.SS "u8 ipv4_ttl"

.SS "struct { \&.\&.\&. }   ipv6"

.SS "__be32 label"

.SS "struct { \&.\&.\&. }   mpls"

.SS "struct { \&.\&.\&. }   nd"

.SS "u32 ovs_flow_hash"

.SS "struct { \&.\&.\&. }  phy"

.SS "u32 priority"

.SS "u8 proto"

.SS "u32 recirc_id"

.SS "u8 sha[ETH_ALEN]"

.SS "u32 skb_mark"

.SS "u8 sll[ETH_ALEN]"

.SS "struct in6_addr src"

.SS "struct in6_addr target"

.SS "__be16 tci"

.SS "u8 tha[ETH_ALEN]"

.SS "u8 tll[ETH_ALEN]"

.SS "__be32 top_lse"

.SS "u8 tos"

.SS "struct { \&.\&.\&. }   tp"

.SS "__be16 tp_dst"

.SS "__be16 tp_src"

.SS "u8 ttl"

.SS "__be16 tun_flags"

.SS "__be64 tun_id"

.SS "struct \fBovs_key_ipv4_tunnel\fP tun_key"

.SS "u8 tun_opts[255]"

.SS "u8 tun_opts_len"

.SS "__be16 type"

.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
