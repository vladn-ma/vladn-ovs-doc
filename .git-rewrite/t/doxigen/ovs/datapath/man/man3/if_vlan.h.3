.TH "/home/vladn/git/ovs/datapath/linux/compat/include/linux/if_vlan.h" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/linux/compat/include/linux/if_vlan.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/skbuff\&.h>\fP
.br
\fC#include <linux/version\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBvlan_insert_tag_set_proto\fP(skb,  \fBproto\fP,  vlan_tci)   \fBrpl_vlan_insert_tag_set_proto\fP(skb, vlan_tci)"
.br
.ti -1c
.RI "#define \fBVLAN_PRIO_MASK\fP   0xe000 /* Priority Code Point */"
.br
.ti -1c
.RI "#define \fBVLAN_PRIO_SHIFT\fP   13"
.br
.ti -1c
.RI "#define \fBVLAN_CFI_MASK\fP   0x1000 /* Canonical Format Indicator */"
.br
.ti -1c
.RI "#define \fBVLAN_TAG_PRESENT\fP   \fBVLAN_CFI_MASK\fP"
.br
.ti -1c
.RI "#define \fB__vlan_insert_tag\fP(skb,  \fBproto\fP,  \fBtci\fP)   \fBrpl_vlan_insert_tag\fP(skb, \fBtci\fP)"
.br
.ti -1c
.RI "#define \fBskb_vlan_tag_present\fP(skb)   vlan_tx_tag_present(skb)"
.br
.ti -1c
.RI "#define \fBskb_vlan_tag_get\fP(skb)   vlan_tx_tag_get(skb)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static struct sk_buff * \fBrpl_vlan_insert_tag_set_proto\fP (struct sk_buff *skb, u16 vlan_tci)"
.br
.ti -1c
.RI "static void \fBvlan_set_encap_proto\fP (struct sk_buff *skb, struct vlan_hdr *vhdr)"
.br
.ti -1c
.RI "static int \fBrpl_vlan_insert_tag\fP (struct sk_buff *skb, u16 vlan_tci)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __vlan_insert_tag(skb, \fBproto\fP, \fBtci\fP)   \fBrpl_vlan_insert_tag\fP(skb, \fBtci\fP)"

.SS "#define skb_vlan_tag_get(skb)   vlan_tx_tag_get(skb)"

.SS "#define skb_vlan_tag_present(skb)   vlan_tx_tag_present(skb)"

.SS "#define VLAN_CFI_MASK   0x1000 /* Canonical Format Indicator */"

.SS "#define vlan_insert_tag_set_proto(skb, \fBproto\fP, vlan_tci)   \fBrpl_vlan_insert_tag_set_proto\fP(skb, vlan_tci)"

.SS "#define VLAN_PRIO_MASK   0xe000 /* Priority Code Point */"

.SS "#define VLAN_PRIO_SHIFT   13"

.SS "#define VLAN_TAG_PRESENT   \fBVLAN_CFI_MASK\fP"

.SH "Function Documentation"
.PP 
.SS "static int rpl_vlan_insert_tag (struct sk_buff * skb, u16 vlan_tci)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
152 {
153     struct vlan_ethhdr *veth;
154 
155     if (skb_cow_head(skb, VLAN_HLEN) < 0)
156         return -ENOMEM;
157 
158     veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
159 
160     /* Move the mac addresses to the beginning of the new header\&. */
161     memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);
162     skb->mac_header -= VLAN_HLEN;
163 
164     /* first, the ethernet type */
165     veth->h_vlan_proto = htons(ETH_P_8021Q);
166 
167     /* now, the TCI */
168     veth->h_vlan_TCI = htons(vlan_tci);
169 
170     return 0;
171 }
.fi
.SS "static struct sk_buff* rpl_vlan_insert_tag_set_proto (struct sk_buff * skb, u16 vlan_tci)\fC [static]\fP"

.PP
.nf
30 {
31     struct vlan_ethhdr *veth;
32 
33     if (skb_cow_head(skb, VLAN_HLEN) < 0) {
34         kfree_skb(skb);
35         return NULL;
36     }
37     veth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);
38 
39     /* Move the mac addresses to the beginning of the new header\&. */
40     memmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);
41     skb->mac_header -= VLAN_HLEN;
42 
43     /* first, the ethernet type */
44     veth->h_vlan_proto = htons(ETH_P_8021Q);
45 
46     /* now, the TCI */
47     veth->h_vlan_TCI = htons(vlan_tci);
48 
49     skb->protocol = htons(ETH_P_8021Q);
50 
51     return skb;
52 }
.fi
.SS "static void vlan_set_encap_proto (struct sk_buff * skb, struct vlan_hdr * vhdr)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
113 {
114     __be16 proto;
115     unsigned char *rawp;
116 
117     /*
118      * Was a VLAN packet, grab the encapsulated protocol, which the layer
119      * three protocols care about\&.
120      */
121 
122     proto = vhdr->h_vlan_encapsulated_proto;
123     if (ntohs(proto) >= 1536) {
124         skb->protocol = proto;
125         return;
126     }
127 
128     rawp = skb->data;
129     if (*(unsigned short *) rawp == 0xFFFF)
130         /*
131          * This is a magic hack to spot IPX packets\&. Older Novell
132          * breaks the protocol design and runs IPX over 802\&.3 without
133          * an 802\&.2 LLC layer\&. We look for FFFF which isn't a used
134          * 802\&.2 SSAP/DSAP\&. This won't work for fault tolerant netware
135          * but does for the rest\&.
136          */
137         skb->protocol = htons(ETH_P_802_3);
138     else
139         /*
140          * Real 802\&.2 LLC
141          */
142         skb->protocol = htons(ETH_P_802_2);
143 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
