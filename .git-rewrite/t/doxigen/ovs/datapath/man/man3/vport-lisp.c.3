.TH "/home/vladn/git/ovs/datapath/vport-lisp.c" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/vport-lisp.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/version\&.h>\fP
.br
\fC#include <linux/in\&.h>\fP
.br
\fC#include <linux/ip\&.h>\fP
.br
\fC#include <linux/net\&.h>\fP
.br
\fC#include <linux/module\&.h>\fP
.br
\fC#include <linux/rculist\&.h>\fP
.br
\fC#include <linux/udp\&.h>\fP
.br
\fC#include <net/icmp\&.h>\fP
.br
\fC#include <net/ip\&.h>\fP
.br
\fC#include <net/route\&.h>\fP
.br
\fC#include <net/udp\&.h>\fP
.br
\fC#include <net/udp_tunnel\&.h>\fP
.br
\fC#include <net/xfrm\&.h>\fP
.br
\fC#include 'datapath\&.h'\fP
.br
\fC#include 'gso\&.h'\fP
.br
\fC#include 'vport\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlisphdr\fP"
.br
.ti -1c
.RI "struct \fBlisp_port\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBpr_fmt\fP(fmt)   KBUILD_MODNAME ': ' fmt"
.br
.ti -1c
.RI "#define \fBLISP_HLEN\fP   (sizeof(struct udphdr) + sizeof(struct \fBlisphdr\fP))"
.br
.in -1c
.SS ": vport name\&."
struct \fBlisp_port\fP - Keeps track of open UDP ports : lisp UDP port no\&. : list element in \&. : The socket created for this port number\&. 
.in +1c
.ti -1c
.RI "static struct \fBvport_ops\fP \fBovs_lisp_vport_ops\fP"
.br
.ti -1c
.RI "static \fBLIST_HEAD\fP (lisp_ports)"
.br
.ti -1c
.RI "static struct \fBlisp_port\fP * \fBlisp_vport\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static struct \fBlisp_port\fP * \fBlisp_find_port\fP (struct net *net, __be16 port)"
.br
.ti -1c
.RI "static struct \fBlisphdr\fP * \fBlisp_hdr\fP (const struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBtunnel_id_to_instance_id\fP (__be64 \fBtun_id\fP, __u8 *iid)"
.br
.ti -1c
.RI "static __be64 \fBinstance_id_to_tunnel_id\fP (__u8 *iid)"
.br
.ti -1c
.RI "static u16 \fBget_src_port\fP (struct net *net, struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBlisp_build_header\fP (struct sk_buff *skb)"
.br
.ti -1c
.RI "static int \fBlisp_rcv\fP (struct sock *sk, struct sk_buff *skb)"
.br
.ti -1c
.RI "static int \fBlisp_socket_init\fP (struct \fBlisp_port\fP *\fBlisp_port\fP, struct net *net)"
.br
.ti -1c
.RI "static int \fBlisp_get_options\fP (const struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBlisp_tnl_destroy\fP (struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static struct \fBvport\fP * \fBlisp_tnl_create\fP (const struct \fBvport_parms\fP *parms)"
.br
.ti -1c
.RI "static int \fBlisp_send\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static const char * \fBlisp_get_name\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static int \fBlisp_get_egress_tun_info\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb, struct \fBovs_tunnel_info\fP *egress_tun_info)"
.br
.ti -1c
.RI "static int __init \fBovs_lisp_tnl_init\fP (void)"
.br
.ti -1c
.RI "static void __exit \fBovs_lisp_tnl_exit\fP (void)"
.br
.ti -1c
.RI "\fBmodule_init\fP (\fBovs_lisp_tnl_init\fP)"
.br
.ti -1c
.RI "\fBmodule_exit\fP (\fBovs_lisp_tnl_exit\fP)"
.br
.ti -1c
.RI "\fBMODULE_DESCRIPTION\fP ('OVS: LISP switching port')"
.br
.ti -1c
.RI "\fBMODULE_LICENSE\fP ('GPL')"
.br
.ti -1c
.RI "\fBMODULE_ALIAS\fP ('vport-\fBtype\fP-105')"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define LISP_HLEN   (sizeof(struct udphdr) + sizeof(struct \fBlisphdr\fP))"

.SS "#define pr_fmt(fmt)   KBUILD_MODNAME ': ' fmt"

.SH "Function Documentation"
.PP 
.SS "static u16 get_src_port (struct net * net, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
170 {
171     u32 hash = skb_get_hash(skb);
172     unsigned int range;
173     int high;
174     int low;
175 
176     if (!hash) {
177         if (skb->protocol == htons(ETH_P_IP)) {
178             struct iphdr *iph;
179             int size = (sizeof(iph->saddr) * 2) / sizeof(u32);
180 
181             iph = (struct iphdr *) skb_network_header(skb);
182             hash = jhash2((const u32 *)&iph->saddr, size, 0);
183         } else if (skb->protocol == htons(ETH_P_IPV6)) {
184             struct ipv6hdr *ipv6hdr;
185 
186             ipv6hdr = (struct ipv6hdr *) skb_network_header(skb);
187             hash = jhash2((const u32 *)&ipv6hdr->saddr,
188                       (sizeof(struct in6_addr) * 2) / sizeof(u32), 0);
189         } else {
190             pr_warn_once("LISP inner protocol is not IP when "
191                      "calculating hash\&.\n");
192         }
193     }
194 
195     inet_get_local_port_range(net, &low, &high);
196     range = (high - low) + 1;
197     return (((u64) hash * range) >> 32) + low;
198 }
.fi
.SS "static __be64 instance_id_to_tunnel_id (__u8 * iid)\fC [static]\fP"

.PP
.nf
156 {
157 #ifdef __BIG_ENDIAN
158     return (iid[0] << 16) | (iid[1] << 8) | iid[2];
159 #else
160     return (__force __be64)(((__force u64)iid[0] << 40) |
161                 ((__force u64)iid[1] << 48) |
162                 ((__force u64)iid[2] << 56));
163 #endif
164 }
.fi
.SS "static void lisp_build_header (struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
201 {
202     struct lisphdr *lisph;
203     const struct ovs_key_ipv4_tunnel *tun_key;
204 
205     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;
206 
207     lisph = (struct lisphdr *)__skb_push(skb, sizeof(struct lisphdr));
208     lisph->nonce_present = 0;   /* We don't support echo nonce algorithm */
209     lisph->locator_status_bits_present = 1; /* Set LSB */
210     lisph->solicit_echo_nonce = 0;  /* No echo noncing */
211     lisph->map_version_present = 0; /* No mapping versioning, nonce instead */
212     lisph->instance_id_present = 1; /* Store the tun_id as Instance ID  */
213     lisph->reserved_flags = 0;  /* Reserved flags, set to 0  */
214 
215     lisph->u1\&.nonce[0] = 0;
216     lisph->u1\&.nonce[1] = 0;
217     lisph->u1\&.nonce[2] = 0;
218 
219     tunnel_id_to_instance_id(tun_key->tun_id, &lisph->u2\&.word2\&.instance_id[0]);
220     lisph->u2\&.word2\&.locator_status_bits = 1;
221 }
.fi
.SS "static struct \fBlisp_port\fP* lisp_find_port (struct net * net, __be16 port)\fC [static]\fP"

.PP
.nf
122 {
123     struct lisp_port *lisp_port;
124 
125     list_for_each_entry_rcu(lisp_port, &lisp_ports, list) {
126         if (lisp_port->dst_port == port &&
127             net_eq(sock_net(lisp_port->lisp_rcv_socket->sk), net))
128             return lisp_port;
129     }
130 
131     return NULL;
132 }
.fi
.SS "static int lisp_get_egress_tun_info (struct \fBvport\fP * vport, struct sk_buff * skb, struct \fBovs_tunnel_info\fP * egress_tun_info)\fC [static]\fP"

.PP
.nf
479 {
480     struct net *net = ovs_dp_get_net(vport->dp);
481     struct lisp_port *lisp_port = lisp_vport(vport);
482 
483     if (skb->protocol != htons(ETH_P_IP) &&
484         skb->protocol != htons(ETH_P_IPV6)) {
485         return -EINVAL;
486     }
487 
488     /*
489      * Get tp_src and tp_dst, refert to lisp_build_header()\&.
490      */
491     return ovs_tunnel_get_egress_info(egress_tun_info, net,
492                       OVS_CB(skb)->egress_tun_info,
493                       IPPROTO_UDP, skb->mark,
494                       htons(get_src_port(net, skb)),
495                       lisp_port->dst_port);
496 }
.fi
.SS "static const char* lisp_get_name (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
472 {
473     struct lisp_port *lisp_port = lisp_vport(vport);
474     return lisp_port->name;
475 }
.fi
.SS "static int lisp_get_options (const struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
315 {
316     struct lisp_port *lisp_port = lisp_vport(vport);
317 
318     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(lisp_port->dst_port)))
319         return -EMSGSIZE;
320     return 0;
321 }
.fi
.SS "static struct \fBlisphdr\fP* lisp_hdr (const struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
135 {
136     return (struct lisphdr *)(udp_hdr(skb) + 1);
137 }
.fi
.SS "static int lisp_rcv (struct sock * sk, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
225 {
226     struct lisp_port *lisp_port;
227     struct lisphdr *lisph;
228     struct iphdr *iph, *inner_iph;
229     struct ovs_tunnel_info tun_info;
230     __be64 key;
231     struct ethhdr *ethh;
232     __be16 protocol;
233 
234     lisp_port = rcu_dereference_sk_user_data(sk);
235     if (unlikely(!lisp_port))
236         goto error;
237 
238     if (iptunnel_pull_header(skb, LISP_HLEN, 0))
239         goto error;
240 
241     lisph = lisp_hdr(skb);
242 
243     if (lisph->instance_id_present != 1)
244         key = 0;
245     else
246         key = instance_id_to_tunnel_id(&lisph->u2\&.word2\&.instance_id[0]);
247 
248     /* Save outer tunnel values */
249     iph = ip_hdr(skb);
250     ovs_flow_tun_info_init(&tun_info, iph,
251                    udp_hdr(skb)->source, udp_hdr(skb)->dest,
252                    key, TUNNEL_KEY, NULL, 0);
253 
254     /* Drop non-IP inner packets */
255     inner_iph = (struct iphdr *)(lisph + 1);
256     switch (inner_iph->version) {
257     case 4:
258         protocol = htons(ETH_P_IP);
259         break;
260     case 6:
261         protocol = htons(ETH_P_IPV6);
262         break;
263     default:
264         goto error;
265     }
266     skb->protocol = protocol;
267 
268     /* Add Ethernet header */
269     ethh = (struct ethhdr *)skb_push(skb, ETH_HLEN);
270     memset(ethh, 0, ETH_HLEN);
271     ethh->h_dest[0] = 0x02;
272     ethh->h_source[0] = 0x02;
273     ethh->h_proto = protocol;
274 
275     ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);
276 
277     ovs_vport_receive(vport_from_priv(lisp_port), skb, &tun_info);
278     goto out;
279 
280 error:
281     kfree_skb(skb);
282 out:
283     return 0;
284 }
.fi
.SS "static int lisp_send (struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
385 {
386     struct ovs_key_ipv4_tunnel *tun_key;
387     struct lisp_port *lisp_port = lisp_vport(vport);
388     struct net *net = ovs_dp_get_net(vport->dp);
389     int network_offset = skb_network_offset(skb);
390     struct rtable *rt;
391     int min_headroom;
392     __be32 saddr;
393     __be16 src_port, dst_port;
394     __be16 df;
395     int sent_len;
396     int err;
397 
398     if (unlikely(!OVS_CB(skb)->egress_tun_info)) {
399         err = -EINVAL;
400         goto error;
401     }
402 
403     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;
404 
405     if (skb->protocol != htons(ETH_P_IP) &&
406         skb->protocol != htons(ETH_P_IPV6)) {
407         err = 0;
408         goto error;
409     }
410 
411     /* Route lookup */
412     saddr = tun_key->ipv4_src;
413     rt = find_route(ovs_dp_get_net(vport->dp),
414             &saddr, tun_key->ipv4_dst,
415             IPPROTO_UDP, tun_key->ipv4_tos,
416             skb->mark);
417     if (IS_ERR(rt)) {
418         err = PTR_ERR(rt);
419         goto error;
420     }
421 
422     min_headroom = LL_RESERVED_SPACE(rt_dst(rt)\&.dev) + rt_dst(rt)\&.header_len
423             + sizeof(struct iphdr) + LISP_HLEN;
424 
425     if (skb_headroom(skb) < min_headroom || skb_header_cloned(skb)) {
426         int head_delta = SKB_DATA_ALIGN(min_headroom -
427                         skb_headroom(skb) +
428                         16);
429 
430         err = pskb_expand_head(skb, max_t(int, head_delta, 0),
431                     0, GFP_ATOMIC);
432         if (unlikely(err))
433             goto err_free_rt;
434     }
435 
436     /* Reset l2 headers\&. */
437     skb_pull(skb, network_offset);
438     skb_reset_mac_header(skb);
439     vlan_set_tci(skb, 0);
440 
441     skb = udp_tunnel_handle_offloads(skb, false, false);
442     if (IS_ERR(skb)) {
443         err = PTR_ERR(skb);
444         skb = NULL;
445         goto err_free_rt;
446     }
447 
448     src_port = htons(get_src_port(net, skb));
449     dst_port = lisp_port->dst_port;
450 
451     lisp_build_header(skb);
452 
453     skb->ignore_df = 1;
454 
455     ovs_skb_set_inner_protocol(skb, skb->protocol);
456 
457     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
458     sent_len = udp_tunnel_xmit_skb(rt, skb, saddr, tun_key->ipv4_dst,
459                        tun_key->ipv4_tos, tun_key->ipv4_ttl,
460                        df, src_port, dst_port, false, true);
461 
462     return sent_len > 0 ? sent_len + network_offset : sent_len;
463 
464 err_free_rt:
465     ip_rt_put(rt);
466 error:
467     kfree_skb(skb);
468     return err;
469 }
.fi
.SS "static int lisp_socket_init (struct \fBlisp_port\fP * lisp_port, struct net * net)\fC [static]\fP"

.PP
.nf
287 {
288     struct udp_port_cfg udp_conf;
289     struct udp_tunnel_sock_cfg tunnel_cfg;
290     int err;
291 
292     memset(&udp_conf, 0, sizeof(udp_conf));
293 
294     udp_conf\&.family = AF_INET;
295     udp_conf\&.local_ip\&.s_addr = htonl(INADDR_ANY);
296     udp_conf\&.local_udp_port = lisp_port->dst_port;
297 
298         err = udp_sock_create(net, &udp_conf, &lisp_port->lisp_rcv_socket);
299         if (err < 0) {
300         pr_warn("cannot register lisp protocol handler: %d\n", err);
301                 return err;
302     }
303 
304     tunnel_cfg\&.sk_user_data = lisp_port;
305     tunnel_cfg\&.encap_type = 1;
306     tunnel_cfg\&.encap_rcv = lisp_rcv;
307     tunnel_cfg\&.encap_destroy = NULL;
308 
309     setup_udp_tunnel_sock(net, lisp_port->lisp_rcv_socket, &tunnel_cfg);
310 
311     return 0;
312 }
.fi
.SS "static struct \fBvport\fP* lisp_tnl_create (const struct \fBvport_parms\fP * parms)\fC [static]\fP"

.PP
.nf
333 {
334     struct net *net = ovs_dp_get_net(parms->dp);
335     struct nlattr *options = parms->options;
336     struct lisp_port *lisp_port;
337     struct vport *vport;
338     struct nlattr *a;
339     int err;
340     u16 dst_port;
341 
342     if (!options) {
343         err = -EINVAL;
344         goto error;
345     }
346 
347     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);
348     if (a && nla_len(a) == sizeof(u16)) {
349         dst_port = nla_get_u16(a);
350     } else {
351         /* Require destination port from userspace\&. */
352         err = -EINVAL;
353         goto error;
354     }
355 
356     /* Verify if we already have a socket created for this port */
357     if (lisp_find_port(net, htons(dst_port))) {
358         err = -EEXIST;
359         goto error;
360     }
361 
362     vport = ovs_vport_alloc(sizeof(struct lisp_port),
363                 &ovs_lisp_vport_ops, parms);
364     if (IS_ERR(vport))
365         return vport;
366 
367     lisp_port = lisp_vport(vport);
368     lisp_port->dst_port = htons(dst_port);
369     strncpy(lisp_port->name, parms->name, IFNAMSIZ);
370 
371     err = lisp_socket_init(lisp_port, net);
372     if (err)
373         goto error_free;
374 
375     list_add_tail_rcu(&lisp_port->list, &lisp_ports);
376     return vport;
377 
378 error_free:
379     ovs_vport_free(vport);
380 error:
381     return ERR_PTR(err);
382 }
.fi
.SS "static void lisp_tnl_destroy (struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
324 {
325     struct lisp_port *lisp_port = lisp_vport(vport);
326 
327     list_del_rcu(&lisp_port->list);
328     udp_tunnel_sock_release(lisp_port->lisp_rcv_socket);
329     ovs_vport_deferred_free(vport);
330 }
.fi
.SS "static struct \fBlisp_port\fP* lisp_vport (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
117 {
118     return vport_priv(vport);
119 }
.fi
.SS "static LIST_HEAD (lisp_ports)\fC [static]\fP"

.SS "MODULE_ALIAS ('vport-\fBtype\fP-105')"

.SS "MODULE_DESCRIPTION ('OVS: LISP switching port')"

.SS "module_exit (\fBovs_lisp_tnl_exit\fP)"

.SS "module_init (\fBovs_lisp_tnl_init\fP)"

.SS "MODULE_LICENSE ('GPL')"

.SS "static void __exit ovs_lisp_tnl_exit (void)\fC [static]\fP"

.PP
.nf
515 {
516     ovs_vport_ops_unregister(&ovs_lisp_vport_ops);
517 }
.fi
.SS "static int __init ovs_lisp_tnl_init (void)\fC [static]\fP"

.PP
.nf
510 {
511     return ovs_vport_ops_register(&ovs_lisp_vport_ops);
512 }
.fi
.SS "static void tunnel_id_to_instance_id (__be64 tun_id, __u8 * iid)\fC [static]\fP"

.PP
.nf
141 {
142 
143 #ifdef __BIG_ENDIAN
144     iid[0] = (__force __u8)(tun_id >> 16);
145     iid[1] = (__force __u8)(tun_id >> 8);
146     iid[2] = (__force __u8)tun_id;
147 #else
148     iid[0] = (__force __u8)((__force u64)tun_id >> 40);
149     iid[1] = (__force __u8)((__force u64)tun_id >> 48);
150     iid[2] = (__force __u8)((__force u64)tun_id >> 56);
151 #endif
152 }
.fi
.SH "Variable Documentation"
.PP 
.SS "static struct \fBvport_ops\fP ovs_lisp_vport_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.type            = OVS_VPORT_TYPE_LISP,
    \&.create          = lisp_tnl_create,
    \&.destroy     = lisp_tnl_destroy,
    \&.get_name        = lisp_get_name,
    \&.get_options     = lisp_get_options,
    \&.send            = lisp_send,
    \&.get_egress_tun_info = lisp_get_egress_tun_info,
    \&.owner           = THIS_MODULE,
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
