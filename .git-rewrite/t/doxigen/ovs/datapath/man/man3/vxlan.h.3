.TH "/home/vladn/git/ovs/datapath/linux/compat/include/net/vxlan.h" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/linux/compat/include/net/vxlan.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/skbuff\&.h>\fP
.br
\fC#include <linux/netdevice\&.h>\fP
.br
\fC#include <linux/udp\&.h>\fP
.br
\fC#include <net/gre\&.h>\fP
.br
\fC#include <linux/version\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBvxlanhdr_gbp\fP"
.br
.ti -1c
.RI "struct \fBvxlan_metadata\fP"
.br
.ti -1c
.RI "struct \fBvxlan_sock\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBVXLAN_HF_VNI\fP   0x08000000"
.br
.ti -1c
.RI "#define \fBVXLAN_HF_GBP\fP   0x80000000"
.br
.ti -1c
.RI "#define \fBVXLAN_N_VID\fP   (1u << 24)"
.br
.ti -1c
.RI "#define \fBVXLAN_VID_MASK\fP   (\fBVXLAN_N_VID\fP - 1)"
.br
.ti -1c
.RI "#define \fBVXLAN_HLEN\fP   (sizeof(struct udphdr) + sizeof(struct \fBvxlanhdr\fP))"
.br
.ti -1c
.RI "#define \fBVXLAN_GBP_USED_BITS\fP   (\fBVXLAN_HF_GBP\fP | 0xFFFFFF)"
.br
.ti -1c
.RI "#define \fBVXLAN_GBP_DONT_LEARN\fP   (BIT(6) << 16)"
.br
.ti -1c
.RI "#define \fBVXLAN_GBP_POLICY_APPLIED\fP   (BIT(3) << 16)"
.br
.ti -1c
.RI "#define \fBVXLAN_GBP_ID_MASK\fP   (0xFFFF)"
.br
.ti -1c
.RI "#define \fBVXLAN_F_GBP\fP   0x800"
.br
.ti -1c
.RI "#define \fBVXLAN_F_UDP_CSUM\fP   0x40"
.br
.ti -1c
.RI "#define \fBVXLAN_F_RCV_FLAGS\fP   \fBVXLAN_F_GBP\fP"
.br
.ti -1c
.RI "#define \fBvxlan_sock\fP   rpl_vxlan_sock"
.br
.ti -1c
.RI "#define \fBvxlan_rcv_t\fP   rpl_vxlan_rcv_t"
.br
.ti -1c
.RI "#define \fBvxlan_sock_add\fP   \fBrpl_vxlan_sock_add\fP"
.br
.ti -1c
.RI "#define \fBvxlan_sock_release\fP   \fBrpl_vxlan_sock_release\fP"
.br
.ti -1c
.RI "#define \fBvxlan_xmit_skb\fP   \fBrpl_vxlan_xmit_skb\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void( \fBvxlan_rcv_t\fP) (struct \fBvxlan_sock\fP *vh, struct sk_buff *skb, struct \fBvxlan_metadata\fP *md)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBvxlan_sock\fP * \fBrpl_vxlan_sock_add\fP (struct net *net, __be16 port, \fBvxlan_rcv_t\fP *rcv, void *data, \fBbool\fP no_share, u32 \fBflags\fP)"
.br
.ti -1c
.RI "void \fBrpl_vxlan_sock_release\fP (struct \fBvxlan_sock\fP *vs)"
.br
.ti -1c
.RI "int \fBrpl_vxlan_xmit_skb\fP (struct \fBvxlan_sock\fP *vs, struct rtable *rt, struct sk_buff *skb, __be32 \fBsrc\fP, __be32 \fBdst\fP, __u8 \fBtos\fP, __u8 \fBttl\fP, __be16 df, __be16 src_port, __be16 dst_port, struct \fBvxlan_metadata\fP *md, \fBbool\fP xnet, u32 vxflags)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define VXLAN_F_GBP   0x800"

.SS "#define VXLAN_F_RCV_FLAGS   \fBVXLAN_F_GBP\fP"

.SS "#define VXLAN_F_UDP_CSUM   0x40"

.SS "#define VXLAN_GBP_DONT_LEARN   (BIT(6) << 16)"

.SS "#define VXLAN_GBP_ID_MASK   (0xFFFF)"

.SS "#define VXLAN_GBP_POLICY_APPLIED   (BIT(3) << 16)"

.SS "#define VXLAN_GBP_USED_BITS   (\fBVXLAN_HF_GBP\fP | 0xFFFFFF)"

.SS "#define VXLAN_HF_GBP   0x80000000"

.SS "#define VXLAN_HF_VNI   0x08000000"

.SS "#define VXLAN_HLEN   (sizeof(struct udphdr) + sizeof(struct \fBvxlanhdr\fP))"

.SS "#define VXLAN_N_VID   (1u << 24)"

.SS "#define vxlan_rcv_t   rpl_vxlan_rcv_t"

.SS "#define \fBvxlan_sock\fP   rpl_vxlan_sock"

.SS "#define vxlan_sock_add   \fBrpl_vxlan_sock_add\fP"

.SS "#define vxlan_sock_release   \fBrpl_vxlan_sock_release\fP"

.SS "#define VXLAN_VID_MASK   (\fBVXLAN_N_VID\fP - 1)"

.SS "#define vxlan_xmit_skb   \fBrpl_vxlan_xmit_skb\fP"

.SH "Typedef Documentation"
.PP 
.SS "typedef void( vxlan_rcv_t) (struct \fBvxlan_sock\fP *vh, struct sk_buff *skb, struct \fBvxlan_metadata\fP *md)"

.SH "Function Documentation"
.PP 
.SS "struct \fBvxlan_sock\fP* rpl_vxlan_sock_add (struct net * net, __be16 port, \fBvxlan_rcv_t\fP * rcv, void * data, \fBbool\fP no_share, u32 flags)"

.PP
.nf
314 {
315     return vxlan_socket_create(net, port, rcv, data, flags);
316 }
.fi
.SS "void rpl_vxlan_sock_release (struct \fBvxlan_sock\fP * vs)"

.PP
.nf
320 {
321     ASSERT_OVSL();
322 
323     queue_work(system_wq, &vs->del_work);
324 }
.fi
.SS "int rpl_vxlan_xmit_skb (struct \fBvxlan_sock\fP * vs, struct rtable * rt, struct sk_buff * skb, __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df, __be16 src_port, __be16 dst_port, struct \fBvxlan_metadata\fP * md, \fBbool\fP xnet, u32 vxflags)"

.PP
.nf
188 {
189     struct vxlanhdr *vxh;
190     int min_headroom;
191     int err;
192     bool udp_sum = !!(vxflags & VXLAN_F_UDP_CSUM);
193 
194     min_headroom = LL_RESERVED_SPACE(rt_dst(rt)\&.dev) + rt_dst(rt)\&.header_len
195             + VXLAN_HLEN + sizeof(struct iphdr)
196             + (skb_vlan_tag_present(skb) ? VLAN_HLEN : 0);
197 
198     /* Need space for new headers (invalidates iph ptr) */
199     err = skb_cow_head(skb, min_headroom);
200     if (unlikely(err)) {
201         kfree_skb(skb);
202         return err;
203     }
204 
205     skb = vlan_hwaccel_push_inside(skb);
206     if (WARN_ON(!skb))
207         return -ENOMEM;
208 
209     skb = udp_tunnel_handle_offloads(skb, udp_sum, true);
210     if (IS_ERR(skb))
211         return PTR_ERR(skb);
212 
213     vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(*vxh));
214     vxh->vx_flags = htonl(VXLAN_HF_VNI);
215     vxh->vx_vni = md->vni;
216 
217     if (vxflags & VXLAN_F_GBP)
218         vxlan_build_gbp_hdr(vxh, vxflags, md);
219 
220     vxlan_set_owner(vs->sock->sk, skb);
221 
222     ovs_skb_set_inner_protocol(skb, htons(ETH_P_TEB));
223 
224     return udp_tunnel_xmit_skb(rt, skb, src, dst, tos,
225                    ttl, df, src_port, dst_port, xnet,
226                    !udp_sum);
227 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
