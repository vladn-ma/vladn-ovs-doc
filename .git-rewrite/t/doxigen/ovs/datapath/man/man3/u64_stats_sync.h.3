.TH "/home/vladn/git/ovs/datapath/linux/compat/include/linux/u64_stats_sync.h" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/linux/compat/include/linux/u64_stats_sync.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/version\&.h>\fP
.br
\fC#include <linux/seqlock\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBu64_stats_sync\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBu64_stats_init\fP(syncp)   do { } while (0)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBu64_stats_update_begin\fP (struct \fBu64_stats_sync\fP *syncp)"
.br
.ti -1c
.RI "static void \fBu64_stats_update_end\fP (struct \fBu64_stats_sync\fP *syncp)"
.br
.ti -1c
.RI "static unsigned int \fBu64_stats_fetch_begin\fP (const struct \fBu64_stats_sync\fP *syncp)"
.br
.ti -1c
.RI "static \fBbool\fP \fBu64_stats_fetch_retry\fP (const struct \fBu64_stats_sync\fP *syncp, unsigned int start)"
.br
.ti -1c
.RI "static unsigned int \fBu64_stats_fetch_begin_irq\fP (const struct \fBu64_stats_sync\fP *syncp)"
.br
.ti -1c
.RI "static \fBbool\fP \fBu64_stats_fetch_retry_irq\fP (const struct \fBu64_stats_sync\fP *syncp, unsigned int start)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define u64_stats_init(syncp)   do { } while (0)"

.SH "Function Documentation"
.PP 
.SS "static unsigned int u64_stats_fetch_begin (const struct \fBu64_stats_sync\fP * syncp)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
98 {
99 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
100     return read_seqcount_begin(&syncp->seq);
101 #else
102 #if BITS_PER_LONG==32
103     preempt_disable();
104 #endif
105     return 0;
106 #endif
107 }
.fi
.SS "static unsigned int u64_stats_fetch_begin_irq (const struct \fBu64_stats_sync\fP * syncp)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
129 {
130 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
131     return read_seqcount_begin(&syncp->seq);
132 #else
133 #if BITS_PER_LONG==32
134     local_irq_disable();
135 #endif
136     return 0;
137 #endif
138 }
.fi
.SS "static \fBbool\fP u64_stats_fetch_retry (const struct \fBu64_stats_sync\fP * syncp, unsigned int start)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
111 {
112 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
113     return read_seqcount_retry(&syncp->seq, start);
114 #else
115 #if BITS_PER_LONG==32
116     preempt_enable();
117 #endif
118     return false;
119 #endif
120 }
.fi
.SS "static \fBbool\fP u64_stats_fetch_retry_irq (const struct \fBu64_stats_sync\fP * syncp, unsigned int start)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
142 {
143 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
144     return read_seqcount_retry(&syncp->seq, start);
145 #else
146 #if BITS_PER_LONG==32
147     local_irq_enable();
148 #endif
149     return false;
150 #endif
151 }
.fi
.SS "static void u64_stats_update_begin (struct \fBu64_stats_sync\fP * syncp)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
84 {
85 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
86     write_seqcount_begin(&syncp->seq);
87 #endif
88 }
.fi
.SS "static void u64_stats_update_end (struct \fBu64_stats_sync\fP * syncp)\fC [inline]\fP, \fC [static]\fP"

.PP
.nf
91 {
92 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
93     write_seqcount_end(&syncp->seq);
94 #endif
95 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
