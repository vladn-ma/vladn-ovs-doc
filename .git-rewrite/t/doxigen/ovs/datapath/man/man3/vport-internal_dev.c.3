.TH "/home/vladn/git/ovs/datapath/vport-internal_dev.c" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/vport-internal_dev.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/hardirq\&.h>\fP
.br
\fC#include <linux/if_vlan\&.h>\fP
.br
\fC#include <linux/kernel\&.h>\fP
.br
\fC#include <linux/netdevice\&.h>\fP
.br
\fC#include <linux/etherdevice\&.h>\fP
.br
\fC#include <linux/ethtool\&.h>\fP
.br
\fC#include <linux/netdev_features\&.h>\fP
.br
\fC#include <linux/skbuff\&.h>\fP
.br
\fC#include <linux/version\&.h>\fP
.br
\fC#include <net/dst\&.h>\fP
.br
\fC#include <net/xfrm\&.h>\fP
.br
\fC#include 'datapath\&.h'\fP
.br
\fC#include 'vlan\&.h'\fP
.br
\fC#include 'vport-internal_dev\&.h'\fP
.br
\fC#include 'vport-netdev\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBinternal_dev\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static struct \fBinternal_dev\fP * \fBinternal_dev_priv\fP (struct net_device *netdev)"
.br
.ti -1c
.RI "static struct rtnl_link_stats64 * \fBinternal_dev_get_stats\fP (struct net_device *netdev, struct rtnl_link_stats64 *stats)"
.br
.ti -1c
.RI "static int \fBinternal_dev_xmit\fP (struct sk_buff *skb, struct net_device *netdev)"
.br
.ti -1c
.RI "static int \fBinternal_dev_open\fP (struct net_device *netdev)"
.br
.ti -1c
.RI "static int \fBinternal_dev_stop\fP (struct net_device *netdev)"
.br
.ti -1c
.RI "static void \fBinternal_dev_getinfo\fP (struct net_device *netdev, struct ethtool_drvinfo *info)"
.br
.ti -1c
.RI "static int \fBinternal_dev_change_mtu\fP (struct net_device *netdev, int new_mtu)"
.br
.ti -1c
.RI "static void \fBinternal_dev_destructor\fP (struct net_device *dev)"
.br
.ti -1c
.RI "static void \fBdo_setup\fP (struct net_device *netdev)"
.br
.ti -1c
.RI "static struct \fBvport\fP * \fBinternal_dev_create\fP (const struct \fBvport_parms\fP *parms)"
.br
.ti -1c
.RI "static void \fBinternal_dev_destroy\fP (struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static int \fBinternal_dev_recv\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "int \fBovs_is_internal_dev\fP (const struct net_device *netdev)"
.br
.ti -1c
.RI "struct \fBvport\fP * \fBovs_internal_dev_get_vport\fP (struct net_device *netdev)"
.br
.ti -1c
.RI "int \fBovs_internal_dev_rtnl_link_register\fP (void)"
.br
.ti -1c
.RI "void \fBovs_internal_dev_rtnl_link_unregister\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static struct \fBvport_ops\fP \fBovs_internal_vport_ops\fP"
.br
.ti -1c
.RI "static const struct ethtool_ops \fBinternal_dev_ethtool_ops\fP"
.br
.ti -1c
.RI "static const struct net_device_ops \fBinternal_dev_netdev_ops\fP"
.br
.ti -1c
.RI "static struct rtnl_link_ops internal_dev_link_ops \fB__read_mostly\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void do_setup (struct net_device * netdev)\fC [static]\fP"

.PP
.nf
153 {
154     ether_setup(netdev);
155 
156     netdev->netdev_ops = &internal_dev_netdev_ops;
157 
158     netdev->priv_flags &= ~IFF_TX_SKB_SHARING;
159     netdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
160     netdev->destructor = internal_dev_destructor;
161     netdev->ethtool_ops = &internal_dev_ethtool_ops;
162     netdev->rtnl_link_ops = &internal_dev_link_ops;
163     netdev->tx_queue_len = 0;
164 
165     netdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |
166                NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |
167                NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL;
168 
169     netdev->vlan_features = netdev->features;
170     netdev->features |= NETIF_F_HW_VLAN_CTAG_TX;
171 
172 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
173     netdev->hw_features = netdev->features & ~NETIF_F_LLTX;
174 #endif
175 
176 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
177     netdev->hw_enc_features = netdev->features;
178 #endif
179 
180     eth_hw_addr_random(netdev);
181 }
.fi
.SS "static int internal_dev_change_mtu (struct net_device * netdev, int new_mtu)\fC [static]\fP"

.PP
.nf
119 {
120     if (new_mtu < 68)
121         return -EINVAL;
122 
123     netdev->mtu = new_mtu;
124     return 0;
125 }
.fi
.SS "static struct \fBvport\fP* internal_dev_create (const struct \fBvport_parms\fP * parms)\fC [static]\fP"

.PP
.nf
184 {
185     struct vport *vport;
186     struct netdev_vport *netdev_vport;
187     struct internal_dev *internal_dev;
188     int err;
189 
190     vport = ovs_vport_alloc(sizeof(struct netdev_vport),
191                 &ovs_internal_vport_ops, parms);
192     if (IS_ERR(vport)) {
193         err = PTR_ERR(vport);
194         goto error;
195     }
196 
197     netdev_vport = netdev_vport_priv(vport);
198 
199     netdev_vport->dev = alloc_netdev(sizeof(struct internal_dev),
200                      parms->name, NET_NAME_UNKNOWN, do_setup);
201     if (!netdev_vport->dev) {
202         err = -ENOMEM;
203         goto error_free_vport;
204     }
205 
206     dev_net_set(netdev_vport->dev, ovs_dp_get_net(vport->dp));
207     internal_dev = internal_dev_priv(netdev_vport->dev);
208     internal_dev->vport = vport;
209 
210     /* Restrict bridge port to current netns\&. */
211     if (vport->port_no == OVSP_LOCAL)
212         netdev_vport->dev->features |= NETIF_F_NETNS_LOCAL;
213 
214     rtnl_lock();
215     err = register_netdevice(netdev_vport->dev);
216     if (err)
217         goto error_free_netdev;
218 
219     dev_set_promiscuity(netdev_vport->dev, 1);
220     rtnl_unlock();
221     netif_start_queue(netdev_vport->dev);
222 
223     return vport;
224 
225 error_free_netdev:
226     rtnl_unlock();
227     free_netdev(netdev_vport->dev);
228 error_free_vport:
229     ovs_vport_free(vport);
230 error:
231     return ERR_PTR(err);
232 }
.fi
.SS "static void internal_dev_destroy (struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
235 {
236     struct netdev_vport *netdev_vport = netdev_vport_priv(vport);
237 
238     netif_stop_queue(netdev_vport->dev);
239     rtnl_lock();
240     dev_set_promiscuity(netdev_vport->dev, -1);
241 
242     /* unregister_netdevice() waits for an RCU grace period\&. */
243     unregister_netdevice(netdev_vport->dev);
244 
245     rtnl_unlock();
246 }
.fi
.SS "static void internal_dev_destructor (struct net_device * dev)\fC [static]\fP"

.PP
.nf
128 {
129     struct vport *vport = ovs_internal_dev_get_vport(dev);
130 
131     ovs_vport_free(vport);
132     free_netdev(dev);
133 }
.fi
.SS "static struct rtnl_link_stats64* internal_dev_get_stats (struct net_device * netdev, struct rtnl_link_stats64 * stats)\fC [static]\fP"

.PP
.nf
52 {
53 #else
54 static struct net_device_stats *internal_dev_sys_stats(struct net_device *netdev)
55 {
56     struct net_device_stats *stats = &netdev->stats;
57 #endif
58     struct vport *vport = ovs_internal_dev_get_vport(netdev);
59     struct ovs_vport_stats vport_stats;
60 
61     ovs_vport_get_stats(vport, &vport_stats);
62 
63     /* The tx and rx stats need to be swapped because the
64      * switch and host OS have opposite perspectives\&.
65      */
66     stats->rx_packets   = vport_stats\&.tx_packets;
67     stats->tx_packets   = vport_stats\&.rx_packets;
68     stats->rx_bytes     = vport_stats\&.tx_bytes;
69     stats->tx_bytes     = vport_stats\&.rx_bytes;
70     stats->rx_errors    = vport_stats\&.tx_errors;
71     stats->tx_errors    = vport_stats\&.rx_errors;
72     stats->rx_dropped   = vport_stats\&.tx_dropped;
73     stats->tx_dropped   = vport_stats\&.rx_dropped;
74 
75     return stats;
76 }
.fi
.SS "static void internal_dev_getinfo (struct net_device * netdev, struct ethtool_drvinfo * info)\fC [static]\fP"

.PP
.nf
101 {
102     strlcpy(info->driver, "openvswitch", sizeof(info->driver));
103 }
.fi
.SS "static int internal_dev_open (struct net_device * netdev)\fC [static]\fP"

.PP
.nf
88 {
89     netif_start_queue(netdev);
90     return 0;
91 }
.fi
.SS "static struct \fBinternal_dev\fP* internal_dev_priv (struct net_device * netdev)\fC [static]\fP"

.PP
.nf
44 {
45     return netdev_priv(netdev);
46 }
.fi
.SS "static int internal_dev_recv (struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
249 {
250     struct net_device *netdev = netdev_vport_priv(vport)->dev;
251     int len;
252 
253     if (unlikely(!(netdev->flags & IFF_UP))) {
254         kfree_skb(skb);
255         return 0;
256     }
257 
258 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
259     if (skb_vlan_tag_present(skb)) {
260         if (unlikely(!vlan_insert_tag_set_proto(skb,
261                             skb->vlan_proto,
262                             skb_vlan_tag_get(skb))))
263             return 0;
264 
265         if (skb->ip_summed == CHECKSUM_COMPLETE)
266             skb->csum = csum_add(skb->csum,
267                          csum_partial(skb->data + (2 * ETH_ALEN),
268                               VLAN_HLEN, 0));
269 
270         vlan_set_tci(skb, 0);
271     }
272 #endif
273 
274     len = skb->len;
275 
276     skb_dst_drop(skb);
277     nf_reset(skb);
278     secpath_reset(skb);
279 
280     skb->dev = netdev;
281     skb->pkt_type = PACKET_HOST;
282     skb->protocol = eth_type_trans(skb, netdev);
283     skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
284 
285     netif_rx(skb);
286 
287     return len;
288 }
.fi
.SS "static int internal_dev_stop (struct net_device * netdev)\fC [static]\fP"

.PP
.nf
94 {
95     netif_stop_queue(netdev);
96     return 0;
97 }
.fi
.SS "static int internal_dev_xmit (struct sk_buff * skb, struct net_device * netdev)\fC [static]\fP"

.PP
.nf
80 {
81     rcu_read_lock();
82     ovs_vport_receive(internal_dev_priv(netdev)->vport, skb, NULL);
83     rcu_read_unlock();
84     return 0;
85 }
.fi
.SS "struct \fBvport\fP* ovs_internal_dev_get_vport (struct net_device * netdev)"

.PP
.nf
304 {
305     if (!ovs_is_internal_dev(netdev))
306         return NULL;
307 
308     return internal_dev_priv(netdev)->vport;
309 }
.fi
.SS "int ovs_internal_dev_rtnl_link_register (void)"

.PP
.nf
312 {
313     int err;
314 
315     err = rtnl_link_register(&internal_dev_link_ops);
316     if (err < 0)
317         return err;
318 
319     err = ovs_vport_ops_register(&ovs_internal_vport_ops);
320     if (err < 0)
321         rtnl_link_unregister(&internal_dev_link_ops);
322 
323     return err;
324 }
.fi
.SS "void ovs_internal_dev_rtnl_link_unregister (void)"

.PP
.nf
327 {
328     ovs_vport_ops_unregister(&ovs_internal_vport_ops);
329     rtnl_link_unregister(&internal_dev_link_ops);
330 }
.fi
.SS "int ovs_is_internal_dev (const struct net_device * netdev)"

.PP
.nf
299 {
300     return netdev->netdev_ops == &internal_dev_netdev_ops;
301 }
.fi
.SH "Variable Documentation"
.PP 
.SS "struct rtnl_link_ops internal_dev_link_ops __read_mostly\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.kind = "openvswitch",
}
.fi
.SS "const struct ethtool_ops internal_dev_ethtool_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.get_drvinfo = internal_dev_getinfo,
    \&.get_link    = ethtool_op_get_link,








}
.fi
.SS "const struct net_device_ops internal_dev_netdev_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.ndo_open = internal_dev_open,
    \&.ndo_stop = internal_dev_stop,
    \&.ndo_start_xmit = internal_dev_xmit,
    \&.ndo_set_mac_address = eth_mac_addr,
    \&.ndo_change_mtu = internal_dev_change_mtu,

    \&.ndo_get_stats64 = internal_dev_get_stats,



}
.fi
.SS "static struct \fBvport_ops\fP ovs_internal_vport_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.type        = OVS_VPORT_TYPE_INTERNAL,
    \&.create      = internal_dev_create,
    \&.destroy = internal_dev_destroy,
    \&.get_name    = ovs_netdev_get_name,
    \&.send        = internal_dev_recv,
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
