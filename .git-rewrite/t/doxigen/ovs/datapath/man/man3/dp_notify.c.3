.TH "/home/vladn/git/ovs/datapath/linux/dp_notify.c" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/linux/dp_notify.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/netdevice\&.h>\fP
.br
\fC#include <net/genetlink\&.h>\fP
.br
\fC#include <net/net_namespace\&.h>\fP
.br
\fC#include <net/netns/generic\&.h>\fP
.br
\fC#include 'datapath\&.h'\fP
.br
\fC#include 'vport-internal_dev\&.h'\fP
.br
\fC#include 'vport-netdev\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBdp_detach_port_notify\fP (struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "void \fBovs_dp_notify_wq\fP (struct work_struct *work)"
.br
.ti -1c
.RI "static int \fBdp_device_event\fP (struct notifier_block *unused, unsigned long event, void *ptr)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct notifier_block \fBovs_dp_device_notifier\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void dp_detach_port_notify (struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
29 {
30     struct sk_buff *notify;
31     struct datapath *dp;
32 
33     dp = vport->dp;
34     notify = ovs_vport_cmd_build_info(vport, 0, 0, OVS_VPORT_CMD_DEL);
35     ovs_dp_detach_port(vport);
36     if (IS_ERR(notify)) {
37         genl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,
38                  GROUP_ID(&ovs_dp_vport_multicast_group),
39                  PTR_ERR(notify));
40         return;
41     }
42 
43     genlmsg_multicast_netns(&dp_vport_genl_family,
44                 ovs_dp_get_net(dp), notify, 0,
45                 GROUP_ID(&ovs_dp_vport_multicast_group),
46                 GFP_KERNEL);
47 }
.fi
.SS "static int dp_device_event (struct notifier_block * unused, unsigned long event, void * ptr)\fC [static]\fP"

.PP
.nf
79 {
80     struct ovs_net *ovs_net;
81     struct net_device *dev = netdev_notifier_info_to_dev(ptr);
82     struct vport *vport = NULL;
83 
84     if (!ovs_is_internal_dev(dev))
85         vport = ovs_netdev_get_vport(dev);
86 
87     if (!vport)
88         return NOTIFY_DONE;
89 
90     if (event == NETDEV_UNREGISTER) {
91         /* upper_dev_unlink and decrement promisc immediately */
92         ovs_netdev_detach_dev(vport);
93 
94         /* schedule vport destroy, dev_put and genl notification */
95         ovs_net = net_generic(dev_net(dev), ovs_net_id);
96         queue_work(system_wq, &ovs_net->dp_notify_work);
97     }
98 
99     return NOTIFY_DONE;
100 }
.fi
.SS "void ovs_dp_notify_wq (struct work_struct * work)"

.PP
.nf
50 {
51     struct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);
52     struct datapath *dp;
53 
54     ovs_lock();
55     list_for_each_entry(dp, &ovs_net->dps, list_node) {
56         int i;
57 
58         for (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {
59             struct vport *vport;
60             struct hlist_node *n;
61 
62             hlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) {
63                 struct netdev_vport *netdev_vport;
64 
65                 if (vport->ops->type != OVS_VPORT_TYPE_NETDEV)
66                     continue;
67 
68                 netdev_vport = netdev_vport_priv(vport);
69                 if (!(ovs_netdev_get_vport(netdev_vport->dev)))
70                     dp_detach_port_notify(vport);
71             }
72         }
73     }
74     ovs_unlock();
75 }
.fi
.SH "Variable Documentation"
.PP 
.SS "struct notifier_block ovs_dp_device_notifier"
\fBInitial value:\fP
.PP
.nf
= {
    \&.notifier_call = dp_device_event
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
