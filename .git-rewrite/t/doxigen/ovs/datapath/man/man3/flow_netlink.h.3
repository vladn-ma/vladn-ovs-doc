.TH "/home/vladn/git/ovs/datapath/flow_netlink.h" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/flow_netlink.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/kernel\&.h>\fP
.br
\fC#include <linux/netlink\&.h>\fP
.br
\fC#include <linux/openvswitch\&.h>\fP
.br
\fC#include <linux/spinlock\&.h>\fP
.br
\fC#include <linux/types\&.h>\fP
.br
\fC#include <linux/rcupdate\&.h>\fP
.br
\fC#include <linux/if_ether\&.h>\fP
.br
\fC#include <linux/in6\&.h>\fP
.br
\fC#include <linux/jiffies\&.h>\fP
.br
\fC#include <linux/time\&.h>\fP
.br
\fC#include <linux/flex_array\&.h>\fP
.br
\fC#include <net/inet_ecn\&.h>\fP
.br
\fC#include <net/ip_tunnels\&.h>\fP
.br
\fC#include 'flow\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "size_t \fBovs_tun_key_attr_size\fP (void)"
.br
.ti -1c
.RI "size_t \fBovs_key_attr_size\fP (void)"
.br
.ti -1c
.RI "void \fBovs_match_init\fP (struct \fBsw_flow_match\fP *match, struct \fBsw_flow_key\fP *key, struct \fBsw_flow_mask\fP *mask)"
.br
.ti -1c
.RI "int \fBovs_nla_put_key\fP (const struct \fBsw_flow_key\fP *, const struct \fBsw_flow_key\fP *, int attr, \fBbool\fP is_mask, struct sk_buff *)"
.br
.ti -1c
.RI "int \fBovs_nla_get_flow_metadata\fP (const struct nlattr *, struct \fBsw_flow_key\fP *, \fBbool\fP log)"
.br
.ti -1c
.RI "int \fBovs_nla_put_identifier\fP (const struct \fBsw_flow\fP *flow, struct sk_buff *skb)"
.br
.ti -1c
.RI "int \fBovs_nla_put_masked_key\fP (const struct \fBsw_flow\fP *flow, struct sk_buff *skb)"
.br
.ti -1c
.RI "int \fBovs_nla_put_mask\fP (const struct \fBsw_flow\fP *flow, struct sk_buff *skb)"
.br
.ti -1c
.RI "int \fBovs_nla_get_match\fP (struct \fBsw_flow_match\fP *, const struct nlattr *key, const struct nlattr *mask, \fBbool\fP log)"
.br
.ti -1c
.RI "int \fBovs_nla_put_egress_tunnel_key\fP (struct sk_buff *, const struct \fBovs_tunnel_info\fP *)"
.br
.ti -1c
.RI "\fBbool\fP \fBovs_nla_get_ufid\fP (struct \fBsw_flow_id\fP *, const struct nlattr *, \fBbool\fP log)"
.br
.ti -1c
.RI "int \fBovs_nla_get_identifier\fP (struct \fBsw_flow_id\fP *sfid, const struct nlattr *ufid, const struct \fBsw_flow_key\fP *key, \fBbool\fP log)"
.br
.ti -1c
.RI "u32 \fBovs_nla_get_ufid_flags\fP (const struct nlattr *attr)"
.br
.ti -1c
.RI "int \fBovs_nla_copy_actions\fP (const struct nlattr *attr, const struct \fBsw_flow_key\fP *key, struct \fBsw_flow_actions\fP **sfa, \fBbool\fP log)"
.br
.ti -1c
.RI "int \fBovs_nla_put_actions\fP (const struct nlattr *attr, int len, struct sk_buff *skb)"
.br
.ti -1c
.RI "void \fBovs_nla_free_flow_actions\fP (struct \fBsw_flow_actions\fP *)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "size_t ovs_key_attr_size (void)"

.PP
.nf
280 {
281     /* Whenever adding new OVS_KEY_ FIELDS, we should consider
282      * updating this function\&.
283      */
284     BUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 22);
285 
286     return    nla_total_size(4)   /* OVS_KEY_ATTR_PRIORITY */
287         + nla_total_size(0)   /* OVS_KEY_ATTR_TUNNEL */
288           + ovs_tun_key_attr_size()
289         + nla_total_size(4)   /* OVS_KEY_ATTR_IN_PORT */
290         + nla_total_size(4)   /* OVS_KEY_ATTR_SKB_MARK */
291         + nla_total_size(4)   /* OVS_KEY_ATTR_DP_HASH */
292         + nla_total_size(4)   /* OVS_KEY_ATTR_RECIRC_ID */
293         + nla_total_size(12)  /* OVS_KEY_ATTR_ETHERNET */
294         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */
295         + nla_total_size(4)   /* OVS_KEY_ATTR_VLAN */
296         + nla_total_size(0)   /* OVS_KEY_ATTR_ENCAP */
297         + nla_total_size(2)   /* OVS_KEY_ATTR_ETHERTYPE */
298         + nla_total_size(40)  /* OVS_KEY_ATTR_IPV6 */
299         + nla_total_size(2)   /* OVS_KEY_ATTR_ICMPV6 */
300         + nla_total_size(28); /* OVS_KEY_ATTR_ND */
301 }
.fi
.SS "void ovs_match_init (struct \fBsw_flow_match\fP * match, struct \fBsw_flow_key\fP * key, struct \fBsw_flow_mask\fP * mask)"

.PP
.nf
1714 {
1715     memset(match, 0, sizeof(*match));
1716     match->key = key;
1717     match->mask = mask;
1718 
1719     memset(key, 0, sizeof(*key));
1720 
1721     if (mask) {
1722         memset(&mask->key, 0, sizeof(mask->key));
1723         mask->range\&.start = mask->range\&.end = 0;
1724     }
1725 }
.fi
.SS "int ovs_nla_copy_actions (const struct nlattr * attr, const struct \fBsw_flow_key\fP * key, struct \fBsw_flow_actions\fP ** sfa, \fBbool\fP log)"

.PP
.nf
2182 {
2183     int err;
2184 
2185     *sfa = nla_alloc_flow_actions(nla_len(attr), log);
2186     if (IS_ERR(*sfa))
2187         return PTR_ERR(*sfa);
2188 
2189     err = __ovs_nla_copy_actions(attr, key, 0, sfa, key->eth\&.type,
2190                      key->eth\&.tci, log);
2191     if (err)
2192         kfree(*sfa);
2193 
2194     return err;
2195 }
.fi
.SS "void ovs_nla_free_flow_actions (struct \fBsw_flow_actions\fP *)"

.PP
.nf
1563 {
1564     call_rcu(&sf_acts->rcu, rcu_free_acts_callback);
1565 }
.fi
.SS "int ovs_nla_get_flow_metadata (const struct nlattr * attr, struct \fBsw_flow_key\fP * key, \fBbool\fP log)"
ovs_nla_get_flow_metadata - parses Netlink attributes into a flow key\&. : Receives extracted in_port, priority, tun_key and skb_mark\&. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence\&. : Boolean to allow kernel error logging\&. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging\&.
.PP
This parses a series of Netlink attributes that form a flow key, which must take the same form accepted by flow_from_nlattrs(), but only enough of it to get the metadata, that is, the parts of the flow key that cannot be extracted from the packet itself\&. 
.PP
.nf
1255 {
1256     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];
1257     struct sw_flow_match match;
1258     u64 attrs = 0;
1259     int err;
1260 
1261     err = parse_flow_nlattrs(attr, a, &attrs, log);
1262     if (err)
1263         return -EINVAL;
1264 
1265     memset(&match, 0, sizeof(match));
1266     match\&.key = key;
1267 
1268     memset(key, 0, OVS_SW_FLOW_KEY_METADATA_SIZE);
1269     key->phy\&.in_port = DP_MAX_PORTS;
1270 
1271     return metadata_from_nlattrs(&match, &attrs, a, false, log);
1272 }
.fi
.SS "int ovs_nla_get_identifier (struct \fBsw_flow_id\fP * sfid, const struct nlattr * ufid, const struct \fBsw_flow_key\fP * key, \fBbool\fP log)"

.PP
.nf
1216 {
1217     struct sw_flow_key *new_key;
1218 
1219     if (ovs_nla_get_ufid(sfid, ufid, log))
1220         return 0;
1221 
1222     /* If UFID was not provided, use unmasked key\&. */
1223     new_key = kmalloc(sizeof(*new_key), GFP_KERNEL);
1224     if (!new_key)
1225         return -ENOMEM;
1226     memcpy(new_key, key, sizeof(*key));
1227     sfid->unmasked_key = new_key;
1228 
1229     return 0;
1230 }
.fi
.SS "int ovs_nla_get_match (struct \fBsw_flow_match\fP * match, const struct nlattr * nla_key, const struct nlattr * nla_mask, \fBbool\fP log)"
ovs_nla_get_match - parses Netlink attributes into a flow key and mask\&. In case the 'mask' is NULL, the flow is treated as exact match flow\&. Otherwise, it is treated as a wildcarded flow, except the mask does not include any don't care bit\&. : receives the extracted flow match information\&. : Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute sequence\&. The fields should of the packet that triggered the creation of this flow\&. : Optional\&. Netlink attribute holding nested OVS_KEY_ATTR_* Netlink attribute specifies the mask field of the wildcarded flow\&. : Boolean to allow kernel error logging\&. Normally true, but when probing for feature compatibility this should be passed in as false to suppress unnecessary error logging\&. 
.PP
.nf
1045 {
1046     const struct nlattr *a[OVS_KEY_ATTR_MAX + 1];
1047     const struct nlattr *encap;
1048     struct nlattr *newmask = NULL;
1049     u64 key_attrs = 0;
1050     u64 mask_attrs = 0;
1051     bool encap_valid = false;
1052     int err;
1053 
1054     err = parse_flow_nlattrs(nla_key, a, &key_attrs, log);
1055     if (err)
1056         return err;
1057 
1058     if ((key_attrs & (1ULL << OVS_KEY_ATTR_ETHERNET)) &&
1059         (key_attrs & (1ULL << OVS_KEY_ATTR_ETHERTYPE)) &&
1060         (nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) {
1061         __be16 tci;
1062 
1063         if (!((key_attrs & (1ULL << OVS_KEY_ATTR_VLAN)) &&
1064               (key_attrs & (1ULL << OVS_KEY_ATTR_ENCAP)))) {
1065             OVS_NLERR(log, "Invalid Vlan frame\&.");
1066             return -EINVAL;
1067         }
1068 
1069         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);
1070         tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);
1071         encap = a[OVS_KEY_ATTR_ENCAP];
1072         key_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);
1073         encap_valid = true;
1074 
1075         if (tci & htons(VLAN_TAG_PRESENT)) {
1076             err = parse_flow_nlattrs(encap, a, &key_attrs, log);
1077             if (err)
1078                 return err;
1079         } else if (!tci) {
1080             /* Corner case for truncated 802\&.1Q header\&. */
1081             if (nla_len(encap)) {
1082                 OVS_NLERR(log, "Truncated 802\&.1Q header has non-zero encap attribute\&.");
1083                 return -EINVAL;
1084             }
1085         } else {
1086             OVS_NLERR(log, "Encap attr is set for non-VLAN frame");
1087             return  -EINVAL;
1088         }
1089     }
1090 
1091     err = ovs_key_from_nlattrs(match, key_attrs, a, false, log);
1092     if (err)
1093         return err;
1094 
1095     if (match->mask) {
1096         if (!nla_mask) {
1097             /* Create an exact match mask\&. We need to set to 0xff
1098              * all the 'match->mask' fields that have been touched
1099              * in 'match->key'\&. We cannot simply memset
1100              * 'match->mask', because padding bytes and fields not
1101              * specified in 'match->key' should be left to 0\&.
1102              * Instead, we use a stream of netlink attributes,
1103              * copied from 'key' and set to 0xff\&.
1104              * ovs_key_from_nlattrs() will take care of filling
1105              * 'match->mask' appropriately\&.
1106              */
1107             newmask = kmemdup(nla_key,
1108                       nla_total_size(nla_len(nla_key)),
1109                       GFP_KERNEL);
1110             if (!newmask)
1111                 return -ENOMEM;
1112 
1113             mask_set_nlattr(newmask, 0xff);
1114 
1115             /* The userspace does not send tunnel attributes that
1116              * are 0, but we should not wildcard them nonetheless\&.
1117              */
1118             if (match->key->tun_key\&.ipv4_dst)
1119                 SW_FLOW_KEY_MEMSET_FIELD(match, tun_key,
1120                              0xff, true);
1121 
1122             nla_mask = newmask;
1123         }
1124 
1125         err = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);
1126         if (err)
1127             goto free_newmask;
1128 
1129         /* Always match on tci\&. */
1130         SW_FLOW_KEY_PUT(match, eth\&.tci, htons(0xffff), true);
1131 
1132         if (mask_attrs & 1ULL << OVS_KEY_ATTR_ENCAP) {
1133             __be16 eth_type = 0;
1134             __be16 tci = 0;
1135 
1136             if (!encap_valid) {
1137                 OVS_NLERR(log, "Encap mask attribute is set for non-VLAN frame\&.");
1138                 err = -EINVAL;
1139                 goto free_newmask;
1140             }
1141 
1142             mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ENCAP);
1143             if (a[OVS_KEY_ATTR_ETHERTYPE])
1144                 eth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);
1145 
1146             if (eth_type == htons(0xffff)) {
1147                 mask_attrs &= ~(1ULL << OVS_KEY_ATTR_ETHERTYPE);
1148                 encap = a[OVS_KEY_ATTR_ENCAP];
1149                 err = parse_flow_mask_nlattrs(encap, a,
1150                                   &mask_attrs, log);
1151                 if (err)
1152                     goto free_newmask;
1153             } else {
1154                 OVS_NLERR(log, "VLAN frames must have an exact match on the TPID (mask=%x)\&.",
1155                       ntohs(eth_type));
1156                 err = -EINVAL;
1157                 goto free_newmask;
1158             }
1159 
1160             if (a[OVS_KEY_ATTR_VLAN])
1161                 tci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);
1162 
1163             if (!(tci & htons(VLAN_TAG_PRESENT))) {
1164                 OVS_NLERR(log, "VLAN tag present bit must have an exact match (tci_mask=%x)\&.",
1165                       ntohs(tci));
1166                 err = -EINVAL;
1167                 goto free_newmask;
1168             }
1169         }
1170 
1171         err = ovs_key_from_nlattrs(match, mask_attrs, a, true, log);
1172         if (err)
1173             goto free_newmask;
1174     }
1175 
1176     if (!match_validate(match, key_attrs, mask_attrs, log))
1177         err = -EINVAL;
1178 
1179 free_newmask:
1180     kfree(newmask);
1181     return err;
1182 }
.fi
.SS "\fBbool\fP ovs_nla_get_ufid (struct \fBsw_flow_id\fP *, const struct nlattr *, \fBbool\fP log)"

.PP
.nf
1206 {
1207     sfid->ufid_len = get_ufid_len(attr, log);
1208     if (sfid->ufid_len)
1209         memcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);
1210 
1211     return sfid->ufid_len;
1212 }
.fi
.SS "u32 ovs_nla_get_ufid_flags (const struct nlattr * attr)"

.PP
.nf
1233 {
1234     return attr ? nla_get_u32(attr) : 0;
1235 }
.fi
.SS "int ovs_nla_put_actions (const struct nlattr * attr, int len, struct sk_buff * skb)"

.PP
.nf
2282 {
2283     const struct nlattr *a;
2284     int rem, err;
2285 
2286     nla_for_each_attr(a, attr, len, rem) {
2287         int type = nla_type(a);
2288 
2289         switch (type) {
2290         case OVS_ACTION_ATTR_SET:
2291             err = set_action_to_attr(a, skb);
2292             if (err)
2293                 return err;
2294             break;
2295 
2296         case OVS_ACTION_ATTR_SET_TO_MASKED:
2297             err = masked_set_action_to_set_action_attr(a, skb);
2298             if (err)
2299                 return err;
2300             break;
2301 
2302         case OVS_ACTION_ATTR_SAMPLE:
2303             err = sample_action_to_attr(a, skb);
2304             if (err)
2305                 return err;
2306             break;
2307         default:
2308             if (nla_put(skb, type, nla_len(a), nla_data(a)))
2309                 return -EMSGSIZE;
2310             break;
2311         }
2312     }
2313 
2314     return 0;
2315 }
.fi
.SS "int ovs_nla_put_egress_tunnel_key (struct sk_buff *, const struct \fBovs_tunnel_info\fP *)"

.PP
.nf
710 {
711     return __ipv4_tun_to_nlattr(skb, &egress_tun_info->tunnel,
712                     egress_tun_info->options,
713                     egress_tun_info->options_len);
714 }
.fi
.SS "int ovs_nla_put_identifier (const struct \fBsw_flow\fP * flow, struct sk_buff * skb)"

.PP
.nf
1509 {
1510     if (ovs_identifier_is_ufid(&flow->id))
1511         return nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id\&.ufid_len,
1512                    flow->id\&.ufid);
1513 
1514     return ovs_nla_put_key(flow->id\&.unmasked_key, flow->id\&.unmasked_key,
1515                    OVS_FLOW_ATTR_KEY, false, skb);
1516 }
.fi
.SS "int ovs_nla_put_key (const struct \fBsw_flow_key\fP *, const struct \fBsw_flow_key\fP *, int attr, \fBbool\fP is_mask, struct sk_buff *)"

.PP
.nf
1492 {
1493     int err;
1494     struct nlattr *nla;
1495 
1496     nla = nla_nest_start(skb, attr);
1497     if (!nla)
1498         return -EMSGSIZE;
1499     err = __ovs_nla_put_key(swkey, output, is_mask, skb);
1500     if (err)
1501         return err;
1502     nla_nest_end(skb, nla);
1503 
1504     return 0;
1505 }
.fi
.SS "int ovs_nla_put_mask (const struct \fBsw_flow\fP * flow, struct sk_buff * skb)"

.PP
.nf
1527 {
1528     return ovs_nla_put_key(&flow->key, &flow->mask->key,
1529                 OVS_FLOW_ATTR_MASK, true, skb);
1530 }
.fi
.SS "int ovs_nla_put_masked_key (const struct \fBsw_flow\fP * flow, struct sk_buff * skb)"

.PP
.nf
1520 {
1521     return ovs_nla_put_key(&flow->key, &flow->key,
1522                 OVS_FLOW_ATTR_KEY, false, skb);
1523 }
.fi
.SS "size_t ovs_tun_key_attr_size (void)"

.PP
.nf
259 {
260     /* Whenever adding new OVS_TUNNEL_KEY_ FIELDS, we should consider
261      * updating this function\&.
262      */
263     return    nla_total_size(8)    /* OVS_TUNNEL_KEY_ATTR_ID */
264         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_SRC */
265         + nla_total_size(4)    /* OVS_TUNNEL_KEY_ATTR_IPV4_DST */
266         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TOS */
267         + nla_total_size(1)    /* OVS_TUNNEL_KEY_ATTR_TTL */
268         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT */
269         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_CSUM */
270         + nla_total_size(0)    /* OVS_TUNNEL_KEY_ATTR_OAM */
271         + nla_total_size(256)  /* OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS */
272         /* OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS is mutually exclusive with
273          * OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS and covered by it\&.
274          */
275         + nla_total_size(2)    /* OVS_TUNNEL_KEY_ATTR_TP_SRC */
276         + nla_total_size(2);   /* OVS_TUNNEL_KEY_ATTR_TP_DST */
277 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
