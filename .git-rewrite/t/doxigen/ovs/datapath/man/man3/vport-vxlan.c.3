.TH "/home/vladn/git/ovs/datapath/vport-vxlan.c" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/vport-vxlan.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/version\&.h>\fP
.br
\fC#include <linux/in\&.h>\fP
.br
\fC#include <linux/ip\&.h>\fP
.br
\fC#include <linux/net\&.h>\fP
.br
\fC#include <linux/rculist\&.h>\fP
.br
\fC#include <linux/udp\&.h>\fP
.br
\fC#include <linux/module\&.h>\fP
.br
\fC#include <net/icmp\&.h>\fP
.br
\fC#include <net/ip\&.h>\fP
.br
\fC#include <net/udp\&.h>\fP
.br
\fC#include <net/ip_tunnels\&.h>\fP
.br
\fC#include <net/rtnetlink\&.h>\fP
.br
\fC#include <net/route\&.h>\fP
.br
\fC#include <net/dsfield\&.h>\fP
.br
\fC#include <net/inet_ecn\&.h>\fP
.br
\fC#include <net/net_namespace\&.h>\fP
.br
\fC#include <net/netns/generic\&.h>\fP
.br
\fC#include <net/vxlan\&.h>\fP
.br
\fC#include 'datapath\&.h'\fP
.br
\fC#include 'vport\&.h'\fP
.br
\fC#include 'vport-vxlan\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBvxlan_port\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBpr_fmt\fP(fmt)   KBUILD_MODNAME ': ' fmt"
.br
.in -1c
.SS ": vport name\&."
struct \fBvxlan_port\fP - Keeps track of open UDP ports : \fBvxlan_sock\fP created for the port\&. 
.in +1c
.ti -1c
.RI "static struct \fBvport_ops\fP \fBovs_vxlan_vport_ops\fP"
.br
.ti -1c
.RI "static const struct nla_policy \fBexts_policy\fP [\fBOVS_VXLAN_EXT_MAX\fP+1]"
.br
.ti -1c
.RI "static struct \fBvxlan_port\fP * \fBvxlan_vport\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static void \fBvxlan_rcv\fP (struct \fBvxlan_sock\fP *vs, struct sk_buff *skb, struct \fBvxlan_metadata\fP *md)"
.br
.ti -1c
.RI "static int \fBvxlan_get_options\fP (const struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBvxlan_tnl_destroy\fP (struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static int \fBvxlan_configure_exts\fP (struct \fBvport\fP *\fBvport\fP, struct nlattr *attr)"
.br
.ti -1c
.RI "static struct \fBvport\fP * \fBvxlan_tnl_create\fP (const struct \fBvport_parms\fP *parms)"
.br
.ti -1c
.RI "static int \fBvxlan_ext_gbp\fP (struct sk_buff *skb)"
.br
.ti -1c
.RI "static int \fBvxlan_tnl_send\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static int \fBvxlan_get_egress_tun_info\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb, struct \fBovs_tunnel_info\fP *egress_tun_info)"
.br
.ti -1c
.RI "static const char * \fBvxlan_get_name\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static int __init \fBovs_vxlan_tnl_init\fP (void)"
.br
.ti -1c
.RI "static void __exit \fBovs_vxlan_tnl_exit\fP (void)"
.br
.ti -1c
.RI "\fBmodule_init\fP (\fBovs_vxlan_tnl_init\fP)"
.br
.ti -1c
.RI "\fBmodule_exit\fP (\fBovs_vxlan_tnl_exit\fP)"
.br
.ti -1c
.RI "\fBMODULE_DESCRIPTION\fP ('OVS: VXLAN switching port')"
.br
.ti -1c
.RI "\fBMODULE_LICENSE\fP ('GPL')"
.br
.ti -1c
.RI "\fBMODULE_ALIAS\fP ('vport-\fBtype\fP-4')"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define pr_fmt(fmt)   KBUILD_MODNAME ': ' fmt"

.SH "Function Documentation"
.PP 
.SS "MODULE_ALIAS ('vport-\fBtype\fP-4')"

.SS "MODULE_DESCRIPTION ('OVS: VXLAN switching port')"

.SS "module_exit (\fBovs_vxlan_tnl_exit\fP)"

.SS "module_init (\fBovs_vxlan_tnl_init\fP)"

.SS "MODULE_LICENSE ('GPL')"

.SS "static void __exit ovs_vxlan_tnl_exit (void)\fC [static]\fP"

.PP
.nf
316 {
317     ovs_vport_ops_unregister(&ovs_vxlan_vport_ops);
318 }
.fi
.SS "static int __init ovs_vxlan_tnl_init (void)\fC [static]\fP"

.PP
.nf
311 {
312     return ovs_vport_ops_register(&ovs_vxlan_vport_ops);
313 }
.fi
.SS "static int vxlan_configure_exts (struct \fBvport\fP * vport, struct nlattr * attr)\fC [static]\fP"

.PP
.nf
132 {
133     struct nlattr *exts[OVS_VXLAN_EXT_MAX+1];
134     struct vxlan_port *vxlan_port;
135     int err;
136 
137     if (nla_len(attr) < sizeof(struct nlattr))
138         return -EINVAL;
139 
140     err = nla_parse_nested(exts, OVS_VXLAN_EXT_MAX, attr, exts_policy);
141     if (err < 0)
142         return err;
143 
144     vxlan_port = vxlan_vport(vport);
145 
146     if (exts[OVS_VXLAN_EXT_GBP])
147         vxlan_port->exts |= VXLAN_F_GBP;
148 
149     return 0;
150 }
.fi
.SS "static int vxlan_ext_gbp (struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
208 {
209     const struct ovs_tunnel_info *tun_info;
210     const struct ovs_vxlan_opts *opts;
211 
212     tun_info = OVS_CB(skb)->egress_tun_info;
213     opts = tun_info->options;
214 
215     if (tun_info->tunnel\&.tun_flags & TUNNEL_VXLAN_OPT &&
216         tun_info->options_len >= sizeof(*opts))
217         return opts->gbp;
218     else
219         return 0;
220 }
.fi
.SS "static int vxlan_get_egress_tun_info (struct \fBvport\fP * vport, struct sk_buff * skb, struct \fBovs_tunnel_info\fP * egress_tun_info)\fC [static]\fP"

.PP
.nf
279 {
280     struct net *net = ovs_dp_get_net(vport->dp);
281     struct vxlan_port *vxlan_port = vxlan_vport(vport);
282     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);
283     __be16 src_port;
284 
285     src_port = udp_flow_src_port(net, skb, 0, 0, true);
286 
287     return ovs_tunnel_get_egress_info(egress_tun_info, net,
288                       OVS_CB(skb)->egress_tun_info,
289                       IPPROTO_UDP, skb->mark,
290                       src_port, dst_port);
291 }
.fi
.SS "static const char* vxlan_get_name (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
294 {
295     struct vxlan_port *vxlan_port = vxlan_vport(vport);
296     return vxlan_port->name;
297 }
.fi
.SS "static int vxlan_get_options (const struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
94 {
95     struct vxlan_port *vxlan_port = vxlan_vport(vport);
96     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);
97 
98     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))
99         return -EMSGSIZE;
100 
101     if (vxlan_port->exts) {
102         struct nlattr *exts;
103 
104         exts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);
105         if (!exts)
106             return -EMSGSIZE;
107 
108         if (vxlan_port->exts & VXLAN_F_GBP &&
109             nla_put_flag(skb, OVS_VXLAN_EXT_GBP))
110             return -EMSGSIZE;
111 
112         nla_nest_end(skb, exts);
113     }
114 
115     return 0;
116 }
.fi
.SS "static void vxlan_rcv (struct \fBvxlan_sock\fP * vs, struct sk_buff * skb, struct \fBvxlan_metadata\fP * md)\fC [static]\fP"

.PP
.nf
67 {
68     struct ovs_tunnel_info tun_info;
69     struct vxlan_port *vxlan_port;
70     struct vport *vport = vs->data;
71     struct iphdr *iph;
72     struct ovs_vxlan_opts opts = {
73         \&.gbp = md->gbp,
74     };
75     __be64 key;
76     __be16 flags;
77 
78     flags = TUNNEL_KEY | (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0);
79     vxlan_port = vxlan_vport(vport);
80     if (vxlan_port->exts & VXLAN_F_GBP && md->gbp)
81         flags |= TUNNEL_VXLAN_OPT;
82 
83     /* Save outer tunnel values */
84     iph = ip_hdr(skb);
85     key = cpu_to_be64(ntohl(md->vni) >> 8);
86     ovs_flow_tun_info_init(&tun_info, iph,
87                    udp_hdr(skb)->source, udp_hdr(skb)->dest,
88                    key, flags, &opts, sizeof(opts));
89 
90     ovs_vport_receive(vport, skb, &tun_info);
91 }
.fi
.SS "static struct \fBvport\fP* vxlan_tnl_create (const struct \fBvport_parms\fP * parms)\fC [static]\fP"

.PP
.nf
153 {
154     struct net *net = ovs_dp_get_net(parms->dp);
155     struct nlattr *options = parms->options;
156     struct vxlan_port *vxlan_port;
157     struct vxlan_sock *vs;
158     struct vport *vport;
159     struct nlattr *a;
160     u16 dst_port;
161     int err;
162 
163     if (!options) {
164         err = -EINVAL;
165         goto error;
166     }
167     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);
168     if (a && nla_len(a) == sizeof(u16)) {
169         dst_port = nla_get_u16(a);
170     } else {
171         /* Require destination port from userspace\&. */
172         err = -EINVAL;
173         goto error;
174     }
175 
176     vport = ovs_vport_alloc(sizeof(struct vxlan_port),
177                 &ovs_vxlan_vport_ops, parms);
178     if (IS_ERR(vport))
179         return vport;
180 
181     vxlan_port = vxlan_vport(vport);
182     strncpy(vxlan_port->name, parms->name, IFNAMSIZ);
183 
184     a = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);
185     if (a) {
186         err = vxlan_configure_exts(vport, a);
187         if (err) {
188             ovs_vport_free(vport);
189             goto error;
190         }
191     }
192 
193     vs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, true,
194                 vxlan_port->exts);
195     if (IS_ERR(vs)) {
196         ovs_vport_free(vport);
197         return (void *)vs;
198     }
199     vxlan_port->vs = vs;
200 
201     return vport;
202 
203 error:
204     return ERR_PTR(err);
205 }
.fi
.SS "static void vxlan_tnl_destroy (struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
119 {
120     struct vxlan_port *vxlan_port = vxlan_vport(vport);
121 
122     vxlan_sock_release(vxlan_port->vs);
123 
124     ovs_vport_deferred_free(vport);
125 }
.fi
.SS "static int vxlan_tnl_send (struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
223 {
224     struct ovs_key_ipv4_tunnel *tun_key;
225     struct net *net = ovs_dp_get_net(vport->dp);
226     struct vxlan_port *vxlan_port = vxlan_vport(vport);
227     __be16 dst_port = inet_sport(vxlan_port->vs->sock->sk);
228     struct vxlan_metadata md = {0};
229     struct rtable *rt;
230     __be16 src_port;
231     __be32 saddr;
232     __be16 df;
233     int err;
234     u32 vxflags;
235 
236     if (unlikely(!OVS_CB(skb)->egress_tun_info)) {
237         err = -EINVAL;
238         goto error;
239     }
240 
241     tun_key = &OVS_CB(skb)->egress_tun_info->tunnel;
242 
243     /* Route lookup */
244     saddr = tun_key->ipv4_src;
245     rt = find_route(ovs_dp_get_net(vport->dp),
246             &saddr, tun_key->ipv4_dst,
247             IPPROTO_UDP, tun_key->ipv4_tos,
248             skb->mark);
249     if (IS_ERR(rt)) {
250         err = PTR_ERR(rt);
251         goto error;
252     }
253 
254     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
255     skb->ignore_df = 1;
256 
257     src_port = udp_flow_src_port(net, skb, 0, 0, true);
258     md\&.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);
259     md\&.gbp = vxlan_ext_gbp(skb);
260     vxflags = vxlan_port->exts |
261               (tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);
262 
263     err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,
264                  saddr, tun_key->ipv4_dst,
265                  tun_key->ipv4_tos,
266                  tun_key->ipv4_ttl, df,
267                  src_port, dst_port,
268                  &md, false, vxflags);
269     if (err < 0)
270         ip_rt_put(rt);
271     return err;
272 error:
273     kfree_skb(skb);
274     return err;
275 }
.fi
.SS "static struct \fBvxlan_port\fP* vxlan_vport (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
61 {
62     return vport_priv(vport);
63 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const struct nla_policy exts_policy[\fBOVS_VXLAN_EXT_MAX\fP+1]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    [OVS_VXLAN_EXT_GBP] = { \&.type = NLA_FLAG, },
}
.fi
.SS "static struct \fBvport_ops\fP ovs_vxlan_vport_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.type            = OVS_VPORT_TYPE_VXLAN,
    \&.create          = vxlan_tnl_create,
    \&.destroy     = vxlan_tnl_destroy,
    \&.get_name        = vxlan_get_name,
    \&.get_options     = vxlan_get_options,
    \&.send            = vxlan_tnl_send,
    \&.get_egress_tun_info = vxlan_get_egress_tun_info,
    \&.owner           = THIS_MODULE,
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
