.TH "/home/vladn/git/ovs/datapath/vport-geneve.c" 3 "Mon Aug 17 2015" "ovs datapath" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/vladn/git/ovs/datapath/vport-geneve.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <linux/in\&.h>\fP
.br
\fC#include <linux/ip\&.h>\fP
.br
\fC#include <linux/net\&.h>\fP
.br
\fC#include <linux/rculist\&.h>\fP
.br
\fC#include <linux/udp\&.h>\fP
.br
\fC#include <linux/if_vlan\&.h>\fP
.br
\fC#include <linux/module\&.h>\fP
.br
\fC#include <net/geneve\&.h>\fP
.br
\fC#include <net/icmp\&.h>\fP
.br
\fC#include <net/ip\&.h>\fP
.br
\fC#include <net/route\&.h>\fP
.br
\fC#include <net/udp\&.h>\fP
.br
\fC#include <net/xfrm\&.h>\fP
.br
\fC#include 'datapath\&.h'\fP
.br
\fC#include 'vport\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBgeneve_port\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBpr_fmt\fP(fmt)   KBUILD_MODNAME ': ' fmt"
.br
.in -1c
.SS ": vport name\&."
struct \fBgeneve_port\fP - Keeps track of open UDP ports : The socket created for this port number\&. 
.in +1c
.ti -1c
.RI "static struct \fBvport_ops\fP \fBovs_geneve_vport_ops\fP"
.br
.ti -1c
.RI "static \fBLIST_HEAD\fP (geneve_ports)"
.br
.ti -1c
.RI "static struct \fBgeneve_port\fP * \fBgeneve_vport\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static struct genevehdr * \fBgeneve_hdr\fP (const struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBtunnel_id_to_vni\fP (__be64 \fBtun_id\fP, __u8 *vni)"
.br
.ti -1c
.RI "static __be64 \fBvni_to_tunnel_id\fP (const __u8 *vni)"
.br
.ti -1c
.RI "static void \fBgeneve_rcv\fP (struct geneve_sock *gs, struct sk_buff *skb)"
.br
.ti -1c
.RI "static int \fBgeneve_get_options\fP (const struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static void \fBgeneve_tnl_destroy\fP (struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static struct \fBvport\fP * \fBgeneve_tnl_create\fP (const struct \fBvport_parms\fP *parms)"
.br
.ti -1c
.RI "static int \fBgeneve_tnl_send\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb)"
.br
.ti -1c
.RI "static const char * \fBgeneve_get_name\fP (const struct \fBvport\fP *\fBvport\fP)"
.br
.ti -1c
.RI "static int \fBgeneve_get_egress_tun_info\fP (struct \fBvport\fP *\fBvport\fP, struct sk_buff *skb, struct \fBovs_tunnel_info\fP *egress_tun_info)"
.br
.ti -1c
.RI "static int __init \fBovs_geneve_tnl_init\fP (void)"
.br
.ti -1c
.RI "static void __exit \fBovs_geneve_tnl_exit\fP (void)"
.br
.ti -1c
.RI "\fBmodule_init\fP (\fBovs_geneve_tnl_init\fP)"
.br
.ti -1c
.RI "\fBmodule_exit\fP (\fBovs_geneve_tnl_exit\fP)"
.br
.ti -1c
.RI "\fBMODULE_DESCRIPTION\fP ('OVS: Geneve swiching port')"
.br
.ti -1c
.RI "\fBMODULE_LICENSE\fP ('GPL')"
.br
.ti -1c
.RI "\fBMODULE_ALIAS\fP ('vport-\fBtype\fP-5')"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define pr_fmt(fmt)   KBUILD_MODNAME ': ' fmt"

.SH "Function Documentation"
.PP 
.SS "static int geneve_get_egress_tun_info (struct \fBvport\fP * vport, struct sk_buff * skb, struct \fBovs_tunnel_info\fP * egress_tun_info)\fC [static]\fP"

.PP
.nf
239 {
240     struct geneve_port *geneve_port = geneve_vport(vport);
241     struct net *net = ovs_dp_get_net(vport->dp);
242     __be16 dport = inet_sport(geneve_port->gs->sock->sk);
243     __be16 sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);
244 
245     /* Get tp_src and tp_dst, refert to geneve_build_header()\&.
246      */
247     return ovs_tunnel_get_egress_info(egress_tun_info,
248                       ovs_dp_get_net(vport->dp),
249                       OVS_CB(skb)->egress_tun_info,
250                       IPPROTO_UDP, skb->mark, sport, dport);
251 }
.fi
.SS "static const char* geneve_get_name (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
231 {
232     struct geneve_port *geneve_port = geneve_vport(vport);
233 
234     return geneve_port->name;
235 }
.fi
.SS "static int geneve_get_options (const struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
108 {
109     struct geneve_port *geneve_port = geneve_vport(vport);
110     __be16 dst_port = inet_sport(geneve_port->gs->sock->sk);
111 
112     if (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))
113         return -EMSGSIZE;
114     return 0;
115 }
.fi
.SS "static struct genevehdr* geneve_hdr (const struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
50 {
51     return (struct genevehdr *)(udp_hdr(skb) + 1);
52 }
.fi
.SS "static void geneve_rcv (struct geneve_sock * gs, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
81 {
82     struct vport *vport = gs->rcv_data;
83     struct genevehdr *geneveh = geneve_hdr(skb);
84     int opts_len;
85     struct ovs_tunnel_info tun_info;
86     __be64 key;
87     __be16 flags;
88 
89     opts_len = geneveh->opt_len * 4;
90 
91     flags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |
92         (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0) |
93         (geneveh->oam ? TUNNEL_OAM : 0) |
94         (geneveh->critical ? TUNNEL_CRIT_OPT : 0);
95 
96     key = vni_to_tunnel_id(geneveh->vni);
97 
98     ovs_flow_tun_info_init(&tun_info, ip_hdr(skb),
99                    udp_hdr(skb)->source, udp_hdr(skb)->dest,
100                    key, flags,
101                    geneveh->options, opts_len);
102 
103     ovs_vport_receive(vport, skb, &tun_info);
104 }
.fi
.SS "static struct \fBvport\fP* geneve_tnl_create (const struct \fBvport_parms\fP * parms)\fC [static]\fP"

.PP
.nf
127 {
128     struct net *net = ovs_dp_get_net(parms->dp);
129     struct nlattr *options = parms->options;
130     struct geneve_port *geneve_port;
131     struct geneve_sock *gs;
132     struct vport *vport;
133     struct nlattr *a;
134     int err;
135     u16 dst_port;
136 
137     if (!options) {
138         err = -EINVAL;
139         goto error;
140     }
141 
142     a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);
143     if (a && nla_len(a) == sizeof(u16)) {
144         dst_port = nla_get_u16(a);
145     } else {
146         /* Require destination port from userspace\&. */
147         err = -EINVAL;
148         goto error;
149     }
150 
151     vport = ovs_vport_alloc(sizeof(struct geneve_port),
152                 &ovs_geneve_vport_ops, parms);
153     if (IS_ERR(vport))
154         return vport;
155 
156     geneve_port = geneve_vport(vport);
157     strncpy(geneve_port->name, parms->name, IFNAMSIZ);
158 
159     gs = geneve_sock_add(net, htons(dst_port), geneve_rcv, vport, true, 0);
160     if (IS_ERR(gs)) {
161         ovs_vport_free(vport);
162         return (void *)gs;
163     }
164     geneve_port->gs = gs;
165 
166     return vport;
167 error:
168     return ERR_PTR(err);
169 }
.fi
.SS "static void geneve_tnl_destroy (struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
118 {
119     struct geneve_port *geneve_port = geneve_vport(vport);
120 
121     geneve_sock_release(geneve_port->gs);
122 
123     ovs_vport_deferred_free(vport);
124 }
.fi
.SS "static int geneve_tnl_send (struct \fBvport\fP * vport, struct sk_buff * skb)\fC [static]\fP"

.PP
.nf
172 {
173     const struct ovs_key_ipv4_tunnel *tun_key;
174     struct ovs_tunnel_info *tun_info;
175     struct net *net = ovs_dp_get_net(vport->dp);
176     struct geneve_port *geneve_port = geneve_vport(vport);
177     __be16 dport = inet_sport(geneve_port->gs->sock->sk);
178     __be16 sport;
179     __be32 saddr;
180     struct rtable *rt;
181     u8 vni[3], opts_len, *opts;
182     __be16 df;
183     int err;
184 
185     tun_info = OVS_CB(skb)->egress_tun_info;
186     if (unlikely(!tun_info)) {
187         err = -EINVAL;
188         goto error;
189     }
190 
191     tun_key = &tun_info->tunnel;
192 
193     saddr = tun_key->ipv4_src;
194     rt = find_route(ovs_dp_get_net(vport->dp),
195             &saddr, tun_key->ipv4_dst,
196             IPPROTO_UDP, tun_key->ipv4_tos,
197             skb->mark);
198     if (IS_ERR(rt)) {
199         err = PTR_ERR(rt);
200         goto error;
201     }
202 
203     df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
204     sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);
205     tunnel_id_to_vni(tun_key->tun_id, vni);
206     skb->ignore_df = 1;
207 
208     if (tun_key->tun_flags & TUNNEL_GENEVE_OPT) {
209         opts = (u8 *)tun_info->options;
210         opts_len = tun_info->options_len;
211     } else {
212         opts = NULL;
213         opts_len = 0;
214     }
215 
216     err = geneve_xmit_skb(geneve_port->gs, rt, skb, saddr,
217                   tun_key->ipv4_dst, tun_key->ipv4_tos,
218                   tun_key->ipv4_ttl, df, sport, dport,
219                   tun_key->tun_flags, vni, opts_len, opts,
220                   !!(tun_key->tun_flags & TUNNEL_CSUM), false);
221     if (err < 0)
222         ip_rt_put(rt);
223     return err;
224 
225 error:
226     kfree_skb(skb);
227     return err;
228 }
.fi
.SS "static struct \fBgeneve_port\fP* geneve_vport (const struct \fBvport\fP * vport)\fC [static]\fP"

.PP
.nf
45 {
46     return vport_priv(vport);
47 }
.fi
.SS "static LIST_HEAD (geneve_ports)\fC [static]\fP"

.SS "MODULE_ALIAS ('vport-\fBtype\fP-5')"

.SS "MODULE_DESCRIPTION ('OVS: Geneve swiching port')"

.SS "module_exit (\fBovs_geneve_tnl_exit\fP)"

.SS "module_init (\fBovs_geneve_tnl_init\fP)"

.SS "MODULE_LICENSE ('GPL')"

.SS "static void __exit ovs_geneve_tnl_exit (void)\fC [static]\fP"

.PP
.nf
270 {
271     ovs_vport_ops_unregister(&ovs_geneve_vport_ops);
272 }
.fi
.SS "static int __init ovs_geneve_tnl_init (void)\fC [static]\fP"

.PP
.nf
265 {
266     return ovs_vport_ops_register(&ovs_geneve_vport_ops);
267 }
.fi
.SS "static void tunnel_id_to_vni (__be64 tun_id, __u8 * vni)\fC [static]\fP"

.PP
.nf
56 {
57 #ifdef __BIG_ENDIAN
58     vni[0] = (__force __u8)(tun_id >> 16);
59     vni[1] = (__force __u8)(tun_id >> 8);
60     vni[2] = (__force __u8)tun_id;
61 #else
62     vni[0] = (__force __u8)((__force u64)tun_id >> 40);
63     vni[1] = (__force __u8)((__force u64)tun_id >> 48);
64     vni[2] = (__force __u8)((__force u64)tun_id >> 56);
65 #endif
66 }
.fi
.SS "static __be64 vni_to_tunnel_id (const __u8 * vni)\fC [static]\fP"

.PP
.nf
70 {
71 #ifdef __BIG_ENDIAN
72     return (vni[0] << 16) | (vni[1] << 8) | vni[2];
73 #else
74     return (__force __be64)(((__force u64)vni[0] << 40) |
75                 ((__force u64)vni[1] << 48) |
76                 ((__force u64)vni[2] << 56));
77 #endif
78 }
.fi
.SH "Variable Documentation"
.PP 
.SS "static struct \fBvport_ops\fP ovs_geneve_vport_ops\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    \&.type            = OVS_VPORT_TYPE_GENEVE,
    \&.create          = geneve_tnl_create,
    \&.destroy     = geneve_tnl_destroy,
    \&.get_name        = geneve_get_name,
    \&.get_options     = geneve_get_options,
    \&.send            = geneve_tnl_send,
    \&.get_egress_tun_info = geneve_get_egress_tun_info,
    \&.owner           = THIS_MODULE,
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ovs datapath from the source code\&.
